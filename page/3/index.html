<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Re：从零开始的写博客生活">
<meta property="og:type" content="website">
<meta property="og:title" content="JySama">
<meta property="og:url" content="https://jysama.cn/page/3/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="Re：从零开始的写博客生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 21:38:06 / 修改时间：23:49:03" itemprop="dateCreated datePublished" datetime="2022-08-08T21:38:06+08:00">2022-08-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>lambda 表达式是 C++11 最重要也最常用的一个特性之一，C#3.5 和 Java8 中就引入了 lambda 表达式。</p>
<p>lambda 来源于函数式编程的概念，也是现代编程语言的一个特点。C++11 这次终于把 lambda 加进来了。</p>
<p>lambda表达式有如下优点：</p>
<ul>
<li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<h1 id="lambda-表达式的概念和基本用法"><a href="#lambda-表达式的概念和基本用法" class="headerlink" title="lambda 表达式的概念和基本用法"></a>lambda 表达式的概念和基本用法</h1><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。</span></span><br><span class="line">[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure>

<p>因此，一个完整的 lambda 表达式看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。</p>
<p>在 C++11 中，lambda 表达式的返回值是通过前面介绍的《C++返回值类型后置》语法来定义的。其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>这样编译器就会根据 return 语句自动推导出返回值类型。</p>
<p>需要注意的是，初始化列表不能用于返回值的自动推导：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i; &#125;;  <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []()&#123; <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure>

<p>这时我们需要显式给出具体的返回值类型。</p>
<p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;  <span class="comment">// 省略空参数表</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-lambda-表达式捕获列表"><a href="#使用-lambda-表达式捕获列表" class="headerlink" title="使用 lambda 表达式捕获列表"></a>使用 lambda 表达式捕获列表</h1><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[] 不捕获任何变量。</li>
<li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获，无法修改）。</li>
<li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li>
<li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li>
<li>[this] 捕获当前类中的 this <a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li>
</ul>
<p>下面看一下它的具体用法，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                    <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                <span class="comment">// OK，捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">// error，没有捕获x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;  <span class="comment">// OK，捕获this指针、x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;              <span class="comment">// OK，捕获this指针，并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          <span class="comment">// error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure>

<p>从上例中可以看到，lambda 表达式的捕获列表精细地控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。</p>
<p>需要注意的是，默认状态下 lambda 表达式<strong>无法修改通过复制方式捕获的外部变量</strong>。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。</p>
<hr>
<p>一个容易出错的细节是关于 lambda 表达式的<strong>延迟调用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">// 按值捕获外部变量</span></span><br><span class="line">a += <span class="number">1</span>;                         <span class="comment">// a被修改了</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;  <span class="comment">// 输出？</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p>
<p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。</p>
<p>从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被<strong>复制了一份</strong>存储在 lambda 表达式变量中。虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却<strong>仍然无法修改它们</strong>。</p>
<p>那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]&#123; <span class="keyword">return</span> a++; &#125;;             <span class="comment">// error，修改按值捕获的外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，mutable</span></span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，被 mutable 修饰的 lambda 表达式<strong>就算没有参数也要写明参数列表</strong>。</p>
<h1 id="lambda-表达式的类型"><a href="#lambda-表达式的类型" class="headerlink" title="lambda 表达式的类型"></a>lambda 表达式的类型</h1><p>最后，介绍一下 lambda 表达式的类型。</p>
<p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p>
<p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 <strong>std::function</strong> 和 <strong>std::bind</strong> 来存储和操作 lambda 表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;  f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>关于std::function和std::bind，在后面章节介绍。</p>
<p>另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p>
<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() <strong>默认是 const 的</strong>。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p>
<p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而<strong>捕获变量的 lambda 表达式则不能转换为函数指针</strong>。看看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Ptr)</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line">Ptr p = [](<span class="type">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针</span></span><br><span class="line">Ptr p1 = [&amp;](<span class="type">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 错误，有状态的lambda不能直接转换为函数指针</span></span><br></pre></td></tr></table></figure>

<p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>
<h1 id="声明式的编程风格，简洁的代码"><a href="#声明式的编程风格，简洁的代码" class="headerlink" title="声明式的编程风格，简洁的代码"></a>声明式的编程风格，简洁的代码</h1><p>就地定义匿名函数，不再需要定义函数对象，大大简化了标准库算法的调用。比如，在 C++11 之前，我们要调用 for_each 函数将 vector 中的偶数打印出来，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountEven</span> <span class="comment">//一个仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>&amp; count_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CountEven</span>(<span class="type">int</span>&amp; count) : <span class="built_in">count_</span>(count) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))       <span class="comment">// val % 2 == 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++ count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">CountEven</span>(even_count));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这样写既烦琐又容易出错。有了 lambda 表达式以后，我们可以使用真正的闭包概念来替换掉这里的仿函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;even_count](<span class="type">int</span> val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))  <span class="comment">// val % 2 == 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++ even_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。</p>
<h1 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::function，其中Rp是返回类型，ArgTypes是参数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span> __function::__maybe_derive_from_unary_function&lt;_Rp(_ArgTypes...)&gt;,</span><br><span class="line">      <span class="keyword">public</span> __function::__maybe_derive_from_binary_function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.std::function对象实例包装函数指针</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; callback;<span class="comment">//定义一个std::function&lt;int(int)&gt;对象实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*fun_ptr)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    fun_ptr = fun1; <span class="comment">//函数指针fun_ptr指向fun1函数</span></span><br><span class="line">    callback = fun_ptr; <span class="comment">//std::function对象包装函数指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.std::function包装函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = fun1; <span class="comment">//std::function包装函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">42</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.std::function包装模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fun2</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = fun2&lt;<span class="type">int</span>&gt;; <span class="comment">//std::function包装模板函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.std::function包装函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">add</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = <span class="built_in">add</span>(); <span class="comment">//std::function包装对象函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.std::function包装lamda表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun3 = [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a * <span class="number">2</span>;&#125;; <span class="comment">//lamda表达式</span></span><br><span class="line">    callback = fun3; <span class="comment">//std::function包装lamda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">9</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h1><p>C++11中提供了<code>std::bind</code>。bind()函数的意义就像它的函数名一样，是用来绑定函数调用的某些参数的。</p>
<p>bind的思想实际上是一种延迟计算的思想，将可调用对象保存起来，然后在需要的时候再调用。而且这种绑定是非常灵活的，不论是普通函数、函数对象、还是成员函数都可以绑定，而且其参数可以支持占位符，比如你可以这样绑定一个二元函数<code>auto f = bind(&amp;func, _1, _2);</code>，调用的时候通过f(1,2)实现调用。</p>
<p>简单的认为就是<code>std::bind</code>就是<code>std::bind1st</code>和<code>std::bind2nd</code>的加强版。</p>
<hr>
<p>使用（与this指针相关）：</p>
<p><code>std::function</code>可以绑定全局函数，静态函数，但是绑定类的成员函数时，需要借助<code>std::bind</code>的帮忙。但是话又说回来，不借助<code>std::bind</code>也是可以完成的，只需要传一个*this变量进去就好了，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onClick</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;X : &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, Y : &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义function类型, 三个参数</span></span><br><span class="line">function&lt;<span class="type">void</span>(View, <span class="type">int</span>, <span class="type">int</span>)&gt; clickCallback;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    View button;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向成员函数</span></span><br><span class="line">    clickCallback = &amp;View::onClick;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 进行调用方法1</span></span><br><span class="line">    <span class="built_in">clickCallback</span>(button, <span class="number">10</span>, <span class="number">123</span>);<span class="comment">//成员函数第一个参数是this指针，这里把this指针传进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行调用方法2.使用bind，第一个参数绑定成员函数，第二个参数为this指针</span></span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(&amp;View::onClick,<span class="keyword">this</span>,std::placeholders::_1,std::placeholders::_2);</span><br><span class="line">    <span class="built_in">bindFunc</span>(<span class="number">10</span>,<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他使用std::bind代码的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> c, <span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_1, <span class="string">&#x27;A&#x27;</span>, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc1</span>(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> bindFunc2 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_2, std::placeholders::_1, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc2</span>(<span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> bindFunc3 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码主要说的是bind中std::placeholders的使用。 std::placeholders是一个占位符。当使用bind生成一个新的可调用对象时，std::placeholders表示新的可调用<strong>对象的第几个参数和原函数的第几个参数进行匹配</strong>。</p>
<p>以下是使用std::bind的一些需要注意的地方：</p>
<ul>
<li>bind预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是pass-by-value的；</li>
<li>对于不事先绑定的参数，需要传std::placeholders进去，从_1开始，依次递增。placeholder是pass-by-reference的；</li>
<li>bind的返回值是可调用实体，可以直接赋给std::function对象；</li>
<li>对于绑定的指针、引用类型的参数，使用者需要保证在可调用实体调用之前，这些参数是可用的；</li>
<li>类的this可以通过对象或者指针来绑定。</li>
</ul>
<p>当我们厌倦了使用<code>std::bind1st</code>和<code>std::bind2nd</code>的时候，现在有了<code>std::bind</code>，你完全可以放弃使用<code>std::bind1st</code>和<code>std::bind2nd</code>了。<code>std::bind</code>绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind才是真正意义上的绑定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/08/c++stringTOint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/c++stringTOint/" class="post-title-link" itemprop="url">将string类型转换为int类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 19:36:18 / 修改时间：20:04:43" itemprop="dateCreated datePublished" datetime="2022-08-08T19:36:18+08:00">2022-08-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先提出解决方案：</p>
<ul>
<li>atoi（头文件<code>&lt;stdlib.h&gt;</code>）：<ul>
<li><code>int atoi(const char *str)</code>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</li>
</ul>
</li>
<li>strtol（头文件<code>&lt;stdlib.h&gt;</code>）：<ul>
<li><code>long int strtol(const char *str, char **endptr, int base)</code>该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。</li>
<li><strong>str</strong> – 要转换为长整数的字符串。</li>
<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中数值后的下一个字符。（即把整数部分后面的字符串返回）</li>
<li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li>
</ul>
</li>
<li>stoi（头文件<code>&lt;string&gt;</code>）：<ul>
<li><code>int stoi (const string&amp; str, size_t* idx = 0, int base = 10);</code></li>
</ul>
</li>
</ul>
<p>这几个有什么不同呢？下面测试对比。</p>
<blockquote>
<p>C语言风格函数</p>
</blockquote>
<p>atoi与strtol对比：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;16s&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atoi的结果为:<span class="number">16</span></span><br><span class="line">strtol的结果为:<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>这两个函数都是从字符串开始寻找数字或者正负号或者小数点，遇到非法字符终止（<strong>即匹配第一个出现的连续的数字</strong>）。</p>
<p>所以到上述s字符就不输出了，提前结束，也就是说<strong>当你的字符串不是数字的时候，或者小数点等非数字，不会报异常！直接输出0</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;asdsa&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>strtol相比与atoi来说，支持多种进制转换,例如8进制等</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++风格</p>
</blockquote>
<p>在C++中可以使用stoi来转int，这个函数相比于前两个一个最大特点是：<strong>异常</strong>！</p>
<p>我们知道C++相比于C语言多了异常，这也是这个函数在C++中具有的最显著功能。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;asq,&quot;</span>;</span><br><span class="line"><span class="comment">//    int c = stoi(str1);    // 报异常</span></span><br><span class="line">string str2 = <span class="string">&quot;12312&quot;</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">stoi</span>(str2);     <span class="comment">// ok</span></span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>异常如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::invalid_argument&#x27;</span></span><br><span class="line"><span class="built_in">what</span>():  stoi</span><br></pre></td></tr></table></figure>

<ul>
<li>stoi()会检查输入是否越界，默认范围也是在int的范围内，越界后则会报错runtime error！</li>
<li>atoi()没有安全性检查<br>如果我们输入的这个字符串转换成int超出了int范围[-2147483648, 2147483647],则会输出错误<br>如果结果超出了int的上界，则输出为上界的值2147483647<br>如果结果超出了下界，则输出为下界的值-2147483647<br>如果字符串无法转换为一个int或这个字符串为空，则会返回0。</li>
</ul>
<blockquote>
<p>自定义，更推荐这种方法</p>
</blockquote>
<p>也就是自己写，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    ss &gt;&gt; v;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">stringToInt</span>(<span class="string">&quot;2.3&quot;</span>);</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里介绍一下stringstream</p>
<p><code>&lt;sstream&gt; </code>定义了三个<strong>类</strong>：<strong>istringstream</strong>、<strong>ostringstream</strong> 和 <strong>stringstream</strong>，分别用来进行流的输入、输出和输入输出操作。</p>
<p><code>&lt;sstream&gt;</code> 主要用来进行数据类型转换，由于 <code>&lt;sstream&gt; </code>使用 string 对象来代替字符数组（snprintf 方式），避免了缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符号的问题。简单说，相比 C 编程语言库的数据类型转换，<code>&lt;sstream&gt;</code> 更加安全、自动和直接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 string</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    <span class="type">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[cout]strResult is: &quot;</span> &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[printf]strResult is: %s\n&quot;</span>, strResult.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> out_type, <span class="keyword">typename</span> in_value&gt;</span></span><br><span class="line"><span class="function">out_type <span class="title">convert</span><span class="params">(<span class="type">const</span> in_value &amp; t)</span></span>&#123;</span><br><span class="line">	stringstream stream;</span><br><span class="line">　　 stream&lt;&lt;t;<span class="comment">//向流中传值</span></span><br><span class="line">　　 out_type result;<span class="comment">//这里存储转换结果</span></span><br><span class="line">　　 stream&gt;&gt;result;<span class="comment">//向result中写入值</span></span><br><span class="line">　　 <span class="keyword">return</span> result;</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">c++智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:12:13" itemprop="dateCreated datePublished" datetime="2022-08-07T21:12:13+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 12:12:27" itemprop="dateModified" datetime="2022-08-10T12:12:27+08:00">2022-08-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>先看一组类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">shape_type</span> &#123;<span class="comment">//枚举类</span></span><br><span class="line">    circle,</span><br><span class="line">    triangle,</span><br><span class="line">    rectangle,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;shape&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am shape&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">triangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;triangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am triangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rectangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;rectangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am rectangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态 上转 如果返回值为shape,会存在对象切片问题（强制转换，损失数据）。</span></span><br><span class="line"><span class="comment">// 使用基类指针指向派生类</span></span><br><span class="line"><span class="function">shape *<span class="title">create_shape</span><span class="params">(shape_type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> shape_type::circle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">triangle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">shape_wrapper</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shape* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shape_wrapper这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ul>
<li>这个类只适用于 shape 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为</li>
</ul>
<h1 id="手写auto-ptr与scope-ptr"><a href="#手写auto-ptr与scope-ptr" class="headerlink" title="手写auto_ptr与scope_ptr"></a>手写auto_ptr与scope_ptr</h1><p>针对”这个类只适用于 shape 类”，我们想到了模板，于是改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smater_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">smater_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”该类对象的行为不够像指针”，我们想到了指针的基本操作有<code>*</code>，<code>-&gt;</code>，布尔表达式。</p>
<p>于是添加三个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	...</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;<span class="comment">//返回引用，作为左值</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;<span class="comment">//返回目的类型的指针</span></span><br><span class="line">    				<span class="comment">//语句 sp-&gt;m 被解释为 (sp.operator-&gt;())-&gt;m，即ptr_-&gt;m，通过对sp类操作就可以调用ptr_类的成员</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”拷贝该类对象会引发程序行为”，我们想到了拷贝构造和赋值。</p>
<p>现考虑如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr1</span><span class="params">(create_shape(shape_type::circle))</span></span>;<span class="comment">//create...表示new一个对象</span></span><br><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查 一下各种可能性。</p>
<p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以设为private。</p>
<p>禁用这两个函数非常简单，但却解决了一种可能出错的情况：<code>smart_ptr&lt;shape&gt; ptr2(ptr1);</code> 在编译时不会出错，但在运行时却会有未定义行为——<strong>由于会对同一内存释放两次，通常情况下会导致程序崩溃。</strong></p>
<blockquote>
<p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。在 C++ 里没有像 Java 的clone 方法这样的约定；<strong>一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</strong></p>
</blockquote>
<p>那关键点就来了，<strong>所有权！</strong>，我们可以拷贝时转移指针的所有权！下面实现便是<code>auto_ptr</code>的核心实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回值为T&amp;，允许*ptr=10操作</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造,被复制放释放原来指针的所有权,交给复制方</span></span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr &amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap</span></span><br><span class="line">    auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr &amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="comment">//        auto_ptr tmp(rhs.release());拷贝构造copy</span></span><br><span class="line"><span class="comment">//        tmp.swap(*this);交换swap</span></span><br><span class="line">        <span class="comment">// s上述两行等价于下面一行</span></span><br><span class="line">        <span class="built_in">auto_ptr</span>(rhs.<span class="built_in">release</span>()).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr&lt;T&gt; &amp;lhs, auto_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr2.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造：ptr1释放了所有权,ptr2获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr1 = ptr1;</span><br><span class="line"></span><br><span class="line">    auto_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr3.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述通过copy-swap技术完成了避免自我赋值与保证了强异常安全！</p>
<p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 auto_ptr 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<strong>auto_ptr 在 C++17 时已经被正式从C++ 标准里删除了</strong>。</p>
<p>上面会导致什么问题呢？</p>
<p>看一下输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">拷贝构造：ptr1释放了所有权,ptr2获得了所有权</span><br><span class="line">shape</span><br><span class="line">rectangle</span><br><span class="line">赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权</span><br></pre></td></tr></table></figure>

<p>shape与circle是在create_shape时候输出的，我们重点关注最后一句话，发现了一个很大的问题：<strong>它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 auto_ptr，你就不再拥有这个对象了。</strong></p>
<p>针对这个问题，在C++11标准出来之前，C++98标准中都一直只有一个智能指针auto_ptr，我们知道，这是一个失败的设计。它的本质是<strong>管理权的转移</strong>，这有许多问题。而这时就有一群人开始扩展C++标准库的关于智能指针的部分，他们组成了boost社区，他们负责boost库的开发和维护。其目的是为C++程序员提供免费的、同行审查的、可移植的程序库。boost库可以和C++标准库完美的共同工作，并且为其提供扩展功能。现在的<strong>C++11标准库</strong>的智能指针很大程度上“借鉴”了boost库。</p>
<p>boost::scoped_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt; </code>可以使用。scoped_ptr 跟 auto_ptr 一样，可以方便的管理单个堆内存对象，特别的是，scoped_ptr <strong>独享所有权</strong>，避免了auto_ptr恼人的几个问题。</p>
<p>scope_ptr是一种简单粗暴的设计，它本质就是<strong>防拷贝</strong>，避免出现管理权的转移。这是它的最大特点，所以他的拷贝构造函数和赋值运算符重载函数都只是声明而不定义，而且为了<strong>防止有的人在类外定义</strong>，所以<strong>将函数声明为private</strong>。但这也是它最大的问题所在，就是<strong>不能赋值拷贝，也就是说功能不全</strong>。但是这种设计比较高效、简洁。没有 release() 函数，不会导致先前的内存泄露问题。下面我也将模拟实现scoped_ptr的管理机制(实际上就是前面提到的禁止拷贝)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_ptr</span> <span class="comment">// noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">(T *ptr = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : ptr_(ptr) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scoped_ptr</span>(p).<span class="built_in">swap</span>(*<span class="keyword">this</span>);<span class="comment">//使用构造函数构造一个临时对象，然后交换指针，让临时对象把原来的空间析构掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    <span class="comment">//在private里禁用，也可以delete</span></span><br><span class="line">    <span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;);<span class="comment">//只需声明，然后不提供实现即可</span></span><br><span class="line">    scoped_ptr &amp;<span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&lt;T&gt; &amp;lhs, scoped_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scoped_ptr特点总结：</p>
<ul>
<li><p>与auto_ptr类似，采用<strong>栈上的指针去管理堆上的内容</strong>，从而<strong>使得堆上的对象随着栈上对象销毁时自动删除（栈自动删除-&gt;析构函数-&gt;释放堆空间）</strong>；</p>
</li>
<li><p>scoped_ptr有着更严格的使用限制——<strong>不能拷贝</strong>，这也意味着scoped_ptr<strong>不能转换其所有权</strong>，所以它管理的对象不能作为<strong>函数的返回值</strong>，对象生命周期仅仅局限于一定区间（该指针所在的{}区间，因为不允许拷贝和赋值，对象<strong>与scoped_ptr紧紧地绑定在了一起</strong>，受限于{}的栈，而std::auto_ptr管理的对象可以在不同的区间存活）；</p>
</li>
<li><p>由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>，这与std::auto_ptr类似（一个是独享，一个是转移，都不是共享），这一特点使该指针简单易用，但也<strong>造成了功能的薄弱</strong>。</p>
</li>
</ul>
<h1 id="手写unique-ptr之子类向基类转换"><a href="#手写unique-ptr之子类向基类转换" class="headerlink" title="手写unique_ptr之子类向基类转换"></a>手写unique_ptr之子类向基类转换</h1><p>在上述auto_ptr基础上，我们把拷贝构造与拷贝赋值，改为移动构造与移动赋值（参考语法记录内的相关内容）。</p>
<ul>
<li>noexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&lt;T&gt; &amp;lhs, unique_ptr&lt;T&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，没有拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok，使用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，此时赋值构造函数通过拷贝构造函数实现（ptr3是左值），但没有</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok，使用赋值构造函数通过移动构造函数实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::move将对象转化为右值</span></span><br></pre></td></tr></table></figure>

<p>把拷贝构造函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr&amp;&amp;；现在它成了移动构造函数。 把赋值函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象（<strong>相当于传入参数时，就构造了临时对象</strong>）。现在赋值函数的行为是移动还是拷贝，<strong>完全依赖于构造参数时走的是移动构造还是拷贝构造</strong>。</p>
<p>最后，一个<code> circle*</code> 是可以隐式转换成 <code>shape*</code>的，但上面的 <code>unique_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>unique_ptr&lt;shape&gt;</code>（基类转子类，即<code>unique_ptr&lt;circle&gt; = shape*</code>是非法的，不能自动转换）。</p>
<hr>
<p>现在我们考虑两种情况：</p>
<p><strong>（1）第一种：当我们只是在原先的移动构造上面添加<code>template &lt;typename U&gt;</code>，此时情况是移动构造变为带模板的移动构造，可以进行子类向基类转换，但是与移动构造相关的，则调用的是默认移动构造，除非是子类向基类转换，才调用带模板的移动构造。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;U&gt; &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>六个特殊的成员函数其生成规则如下：</strong></p>
<ul>
<li><strong>默认构造函数，生成规则和C++98一样，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成。</strong></li>
<li><strong>析构函数，生成规则和C++98一样，在C++11中有点不同的是，析构函数默认是noexcept。</strong></li>
<li><strong>拷贝构造函数，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其它和C++98的行为一致。</strong></li>
<li><strong>拷贝赋值操作符，用户自定义了移动操作会导致不生成默认的拷贝赋值操作，其它和C++98的行为一致。</strong></li>
<li><strong>移动构造函数和移动赋值操作符，仅仅在没有用户自定义的拷贝操作、析构操作，移动操作的时候才会生成。因为默认移动构造函数出现应该在是在你需要它且能保证内存不被泄露的前提下才会出现。析构函数被显示定义的一个隐含说明就是说需要回收内存。</strong></li>
</ul>
<p>根据《Effective Modern C++》Item17 P115页提到，当类中含有特殊成员函数变为模板特殊成员函数的时候，此时不满足上述生成规则，也就是针对当前例子来说，编译器<strong>会默认生成拷贝构造</strong>，因为移动构造是模板函数（且没有非模板函数版本），所以此时上述main调用里面为error的都可以正常运行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; <span class="comment">// 由于带模板的移动构造函数引发编译器会默认生成拷贝构造</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)      <span class="comment">// bitwise copy 此时ptr1不为NULL</span></span><br><span class="line">        ptr2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// 调用的是默认的移动构造,而不是带模板的移动构造 bitwise move</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)   <span class="comment">// ptr1 不为空</span></span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;    <span class="comment">// ok  根据形参先调用默认拷贝（ptr3是左值）,再调用拷贝赋值</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok 根据形参先调用默认移动构造（使用move后是右值），而不是带参数的移动构造,再调用移动赋值</span></span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr4</span><span class="params">(std::move(<span class="keyword">new</span> circle))</span></span>;  <span class="comment">// ok 调用带模板的移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）第二种：移动构造与带模板的移动构造同时存在，可以完成子类向基类的转换，此时满足上述生成规则，但此时不会生成拷贝函数！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，无拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，无拷贝构造函数，无法使用赋值构造函数（左值）</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//    unique_ptr&lt;circle&gt; cl&#123;create_shape(shape_type::circle)&#125;;  // error 因为create_shape返回的是shape 不能基类转子类</span></span><br><span class="line">    unique_ptr&lt;circle&gt; cl&#123;<span class="keyword">new</span> <span class="built_in">circle</span>()&#125;;</span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr5</span><span class="params">(std::move(cl))</span></span>;  <span class="comment">// ok unique&lt;circle&gt;转unique&lt;circle&gt;（即不用转换）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<ul>
<li><p>我们需要了解子类向基类的隐式转换，通过将移动构造函数变为带模板的移动构造函数，要明白两者共存情况与只有带模板的移动或者其他构造函数<strong>对编译器生成规则的影响</strong>！上述代码，此时还不能完成基类向子类的转换！例如:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<ul>
<li>如果只有带模板的拷贝&#x2F;移动构造函数，则还是会生成默认的拷贝&#x2F;移动构造函数，优先供<strong>同类型</strong>的对象使用，而带模板的供不同类型的对象使用。</li>
</ul>
</li>
<li><p>auto_ptr与unique_ptr都是独占所有权，每次只能被单个对象所拥有，unique_ptr与auto_ptr不同的是<strong>使用移动语义来显式的编写</strong>。</p>
</li>
<li><p>auto_ptr是可以说你随便赋值，但赋值完了之后原来的对象就不知不觉的报废，搞得你莫名其妙。而unique_ptr就干脆不让你可以随便去复制，赋值。如果实在想传个值就哪里显式的说明内存转移<strong>std:move</strong>一下。然后这样传值完了之后，之前的对象也同样报废了。只不过整个move你让<strong>明显的知道这样操作后会导致之前的unique_ptr对象失效</strong>。</p>
</li>
<li><p>scope_ptr则是直接<strong>不允许拷贝</strong>。由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>。</p>
</li>
</ul>
<h1 id="shared-ptr之引用计数"><a href="#shared-ptr之引用计数" class="headerlink" title="shared_ptr之引用计数"></a>shared_ptr之引用计数</h1><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 shared_ptr 了。</p>
<p>两者区别如下：</p>
<p>多个shared_ptr不仅<strong>共享一个对象，同时还得共享同一个计数</strong>。<strong>当最后一个指向对象(和共享计数)的shared_ptr析构时，它需要删除对象和共享计数。</strong></p>
<p>首先需要一个共享计数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>() : <span class="built_in">count_</span>(<span class="number">1</span>) &#123;<span class="comment">//一旦初始化，赋1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来实现引用计数智能指针：</p>
<p>构造与析构、swap实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();<span class="comment">//初始化一个计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个shared_ptr再去删除对象与共享计数</span></span><br><span class="line">        <span class="comment">// ptr_不为空且此时共享计数减为0的时候,再去删除</span></span><br><span class="line">        <span class="keyword">if</span>(ptr_&amp;&amp;!shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);   </span><br><span class="line">        <span class="built_in">swap</span>(shared_count_,rhs.shared_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&lt;T&gt; &amp;lhs, shared_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的赋值函数，编译器可以根据调用来决定是调拷贝构造还是移动构造函数，所以不变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">shared_ptr &amp;<span class="keyword">operator</span>=(shared_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造与移动构造需要改变：</p>
<p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把<strong>引用数加一</strong>，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 other.ptr_ 置为空，<strong>认为 other 不再指向该共享对象即可</strong></p>
<p>实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">    ptr_ = other.ptr_; <span class="comment">//1.数据指针共享</span></span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();<span class="comment">//3.计数+1</span></span><br><span class="line">        shared_count_ = other.shared_count_;<span class="comment">//2.计数指针共享</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;U&gt; &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//移动构造</span></span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;<span class="comment">//移除数据指针</span></span><br><span class="line">        other.shared_count_ = <span class="literal">nullptr</span>;<span class="comment">//移除计数指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行的时候，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘circle* shared_ptr&lt;circle&gt;::ptr_’ is private</span><br></pre></td></tr></table></figure>

<p>错误原因是<strong>模板的各个实例间并不天然就有 friend 关系</strong>，因而不能互访私有成员 <code>ptr_ </code>和<code>shared_count_</code>。我们需要在 shared_ptr 的定义中显式声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;<span class="comment">//使得可以直接在不同模板实例间互相访问，不需要指定shared_ptr&lt;U&gt;。</span></span><br><span class="line">	<span class="comment">//声明一个模板函数作为友元也是，不需要加&lt;U&gt;</span></span><br><span class="line">	<span class="comment">//若是声明一种特例，直接friend class A&lt;int&gt;; 函数则 friend void fun&lt;int&gt;();</span></span><br></pre></td></tr></table></figure>

<p>对于这个问题，需要进一步解释：</p>
<p>类的private成员，只能由这个类所访问（不论是这个类的哪个实例，在类的作用域就行）。而对于模板类，实际上不同模板的实例并不属于一个类，比如说<code>A&lt;int&gt;</code>和<code>A&lt;double&gt;</code>就不能互相访问，一个私有成员 x 是属于<code>A&lt;int&gt;</code>这个类的，那么就不属于<code>A&lt;double&gt;</code>这个类，但是<code>A&lt;int&gt;</code>这个类的不同实例是可以互相访问 x 的。</p>
<p>因此在shared_ptr这个类中声明友元，也就声明了所有这个类的模板，都是友元。</p>
<hr>
<p>此外，在当前引用计数实现中，我们应该删除release释放所有权函数，编写一个返回引用计数值的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> circle())</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 was &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">ptr2 = ptr1;        <span class="comment">// shared_ptr&lt;circle&gt;隐式转换shared_ptr&lt;shape&gt; 调用带模板的拷贝构造</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    ptr3 = ptr2;        // 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 ptr3=ptr2</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line">ptr3 = ptr1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时3个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (ptr1)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 会先调用赋值函数,由编译器决定调用的是拷贝构造还是移动构造,造出一个新的临时对象出来,临时对象会在跳出作用域后被析构掉。</span></span><br><span class="line"><span class="comment">// 在析构函数中,会先判断该临时对象的是否指向资源,如果没有,析构结束。否则,对引用计数减1,判断引用计数是否为0,如果为0,删除共享引用计数指针,否则不操作。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时2个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line"><span class="keyword">if</span> (!ptr1 &amp;&amp; ptr2) &#123;      <span class="comment">// 调用的是bool重载操作符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 move to ptr2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">use count of ptr1 is <span class="number">1</span></span><br><span class="line">use count of ptr2 was <span class="number">0</span></span><br><span class="line">此时<span class="number">3</span>个shared_ptr指向同一个资源</span><br><span class="line">use count of ptr1 is now <span class="number">3</span></span><br><span class="line">use count of ptr2 is now <span class="number">3</span></span><br><span class="line">use count of ptr3 is now <span class="number">3</span></span><br><span class="line">ptr1 is <span class="keyword">not</span> empty</span><br><span class="line">此时<span class="number">2</span>个shared_ptr指向同一个资源</span><br><span class="line">ptr1 move to ptr2</span><br><span class="line">use count of ptr1 is now <span class="number">0</span></span><br><span class="line">use count of ptr2 is now <span class="number">2</span></span><br><span class="line">use count of ptr3 is now <span class="number">2</span></span><br><span class="line">~circle</span><br><span class="line">~shape</span><br></pre></td></tr></table></figure>

<p>有几点注意事项：</p>
<ul>
<li>上述代码没有考虑线程安全性，这里只是简化版</li>
<li>&#x3D;赋值重载函数不加<code>&amp;</code>，编译器决定调用拷贝构造还是移动构造，来造出一个临时对象出来。</li>
<li>根据前面提到的，当类中特殊函数变为带模板的函数，编译器仍然会生成默认拷贝构造与默认移动构造。</li>
</ul>
<p>针对第一点：例如：<code>ptr2 = std::move(ptr1);</code></p>
<p>会先调用赋值函数，由编译器决定调用的是拷贝构造还是移动构造，造出一个新的临时对象出来，临时对象会在跳出作用域后被析构掉。在析构函数中，会先判断该临时对象的是否指向资源，如果没有，析构结束。否则，对引用计数减1，判断引用计数是否为0，如果为0，删除共享引用计数指针，否则不操作。</p>
<p>针对第二点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;<span class="comment">//两个引用计数</span></span><br><span class="line">ptr3 = ptr2;        <span class="comment">// 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 </span></span><br></pre></td></tr></table></figure>

<p>两者都是<strong>一种类型</strong>，所以在调用赋值操作后，不会调用带模板的拷贝构造来创建临时变量，而是调用编译器生成的<strong>默认拷贝构造</strong>，所以此时引用计数不会增加。</p>
<h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>对应于 C++ 里的不同的类型强制转：</p>
<ul>
<li>dynamic_cast</li>
<li>static_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>在上述<code>unique_ptr</code>处实现了子类向基类的转换，但是却没有实现基类向子类的转换，例如：:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<p>实现这种，需要使用<code>dynamic_cast</code>，实现如下：</p>
<p>首先为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现强制类型转换需要的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other, T *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，就是实现转换函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">dynamic_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());<span class="comment">//强制转换为T*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);<span class="comment">//使用上述的构造函数，返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用dynamic_cast转换后，指针为空。此时资源还是被dptr2拥有，dptr1为0</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; dptr1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; dptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; dptr1_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1_1 is now &quot;</span> &lt;&lt; dptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3 is now &quot;</span> &lt;&lt; dptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">dptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; dptr2_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;shape&gt;(dptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2_1 is now &quot;</span> &lt;&lt; dptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3_1 is now &quot;</span> &lt;&lt; dptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。</p>
<ul>
<li>下行转换，基类转换为子类（派生类指针指向基类对象），例如：智能指针转换类似于<code>shape*</code> 转换为<code>circle*</code> 使用dynamic_cast转换后,，<strong>指针为空</strong>。此时资源还是被<strong>dptr2拥有，dptr1为0</strong>。比static_cast安全。</li>
<li>平行转换，指向一致的相互转换，例如：智能指针转换类似于<code>circle*</code>转换为<code>circle*</code>。此时引用计数为<strong>两者共享</strong>。</li>
<li>上行转换，子类转基类，例如：智能指针转换类似于<code>circle*</code>转换为<code>shape*</code>，此时引用技术为<strong>两者共享</strong>。等价于static_cast。</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>同样，编写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">static_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">static_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用static_cast转换后,指针为空  与dynamic_cast相比,不安全</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; sptr1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; sptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; sptr1_1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1_1 is now &quot;</span> &lt;&lt; sptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3 is now &quot;</span> &lt;&lt; sptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用static_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2 等价于dynamic_cast</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">sptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; sptr2_1 = <span class="built_in">static_pointer_cast</span>&lt;shape&gt;(sptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2_1 is now &quot;</span> &lt;&lt; sptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3_1 is now &quot;</span> &lt;&lt; sptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>输出结果同上dynamic_cast，不同之处，在下行转换的时候(基类转子类)，是不安全的！</p>
<p>还可以将non-const对象强制转换为const：<code>static_cast&lt;const A&amp;&gt;(*this)</code>：将本身（A&amp;）转换为const A&amp;。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去掉const属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">const_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">const_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;circle&gt; s = <span class="built_in">const_pointer_cast</span>&lt;circle&gt;(<span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> circle&gt;(<span class="keyword">new</span> circle));</span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>例如：想把一个指针转为整数，就可以用reinterpret_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">reinterpret_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">reinterpret_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">reinterpret_pointer_cast</span>&lt;<span class="type">int</span>&gt;(s);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/06/c++%E6%83%AF%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/c++%E6%83%AF%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">c++编程风格惯用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-06 23:31:21" itemprop="dateCreated datePublished" datetime="2022-08-06T23:31:21+08:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 17:11:51" itemprop="dateModified" datetime="2022-08-08T17:11:51+08:00">2022-08-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在基本的语法学习差不多学习完之后，来学一下编程风格惯用法。因为c++的语法支持我们以多种形式编写代码，但有些语法内容还需要进一步探讨，应该有一个明确的规范，这就是惯用法的作用。实际上有些部分在语法内容也有提到，这里再总结一下。当我们在编写这类代码时，应当遵循惯用法。</p>
<p>参考自GitHub项目：CPlusPlusThings</p>
<h1 id="初始化列表与赋值"><a href="#初始化列表与赋值" class="headerlink" title="初始化列表与赋值"></a>初始化列表与赋值</h1><p>本章学习编程过程中，何时用初始化列表，何时直接赋值。</p>
<p>总结：</p>
<ul>
<li><strong>const成员</strong>的初始化只能在构造函数初始化列表中进行。</li>
<li><strong>引用成员</strong>的初始化也只能在构造函数初始化列表中进行。</li>
<li><strong>对象成员</strong>（对象成员所对应的类<strong>没有默认构造函数</strong>）的初始化，也只能在构造函数初始化列表中进行（调用拷贝构造函数）。</li>
</ul>
<p>下面具体学习一下：</p>
<h2 id="类之间嵌套"><a href="#类之间嵌套" class="headerlink" title="类之间嵌套"></a>类之间嵌套</h2><p>这个比较重要，后面介绍的继承关系一律用初始化列表构造。</p>
<h3 id="第一种：-使用初始化列表"><a href="#第一种：-使用初始化列表" class="headerlink" title="第一种： 使用初始化列表"></a>第一种： 使用初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(animal) &#123;<span class="comment">//第一种方式，调用拷贝构造</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal __animal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(animal)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="built_in">Animal</span>() is called</span><br><span class="line"><span class="comment">//构造，先构造成员对象（如果有多，按照声明的顺序），再调用类自己的构造函数</span></span><br><span class="line"><span class="built_in">Animal</span> (<span class="type">const</span> Animal &amp;) <span class="function">is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//析构，后定义的先析构；调用析构函数后再析构成员变量</span></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>

<p>依次分析从上到下：</p>
<p>main函数中<code>Animal animal;</code>调用默认构造。</p>
<p><code>Dog d(animal);</code>且初始化对象是一个类成员对象，等价于定义同时初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal __animal = animal;</span><br></pre></td></tr></table></figure>

<p>实际上就是调用了拷贝构造，因此输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal (const Animal &amp;) is called</span><br></pre></td></tr></table></figure>

<p>再然后打印Dog的构造函数里面的输出。</p>
<p>最后调用析构，程序结束。</p>
<p><strong>在初始化列表中不一定要调用拷贝构造，也可以调用默认构造函数或者有参构造函数。</strong>比如这里调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal()<span class="comment">//第二种方式，默认构造函数</span></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(<span class="number">5</span>)<span class="comment">//第二种方式，有参构造函数（如果有）</span></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> x) : __animal(x)<span class="comment">//第二种方式，有参构造函数，进一步指定变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal() is called</span><br><span class="line"></span><br><span class="line">Animal() is called</span><br><span class="line">Dog(const Animal &amp;animal) is called</span><br><span class="line"></span><br><span class="line">~Dog() is called</span><br><span class="line">~Animal() is called</span><br><span class="line">~Animal() is called</span><br></pre></td></tr></table></figure>

<p>也就是说，在初始化列表中初始化，等同于定义同时初始化（因此既能够使用构造函数（传入其他类型）、也能使用拷贝构造函数（传入类自己的类型）），而不是先声明。</p>
<h3 id="第二种：构造函数赋值来初始化对象"><a href="#第二种：构造函数赋值来初始化对象" class="headerlink" title="第二种：构造函数赋值来初始化对象"></a>第二种：构造函数赋值来初始化对象</h3><p>构造函数修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) &#123;</span><br><span class="line">    __animal = animal;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal() is called</span><br><span class="line"></span><br><span class="line">Animal() is called</span><br><span class="line">Animal &amp; operator=(const Animal &amp;) is called</span><br><span class="line">Dog(const Animal &amp;animal) is called</span><br><span class="line"></span><br><span class="line">~Dog() is called</span><br><span class="line">~Animal() is called</span><br><span class="line">~Animal() is called</span><br></pre></td></tr></table></figure>

<p>于是得出：</p>
<p>当调用<code>Dog d(animal);</code>时，等价于：</p>
<p>先定义对象，再进行赋值，因此先调用了默认构造（<strong>因此如果没有默认构造函数会出错</strong>），再调用&#x3D;操作符重载函数（如果没重载赋值构造函数，使用默认的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 假设之前已经有了animal对象</span><br><span class="line">Animal __animal;</span><br><span class="line">__animal = animal;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上述我们得出如下结论：</p>
<ul>
<li><strong>类中包含其他自定义的class或者struct，采用初始化列表，实际上就是创建对象同时并初始化（可用构造和拷贝构造，取决于参数类型）</strong></li>
<li><strong>而采用类中赋值方式，等价于先定义对象，再进行赋值，一般会先调用默认构造，在调用&#x3D;操作符重载函数。</strong></li>
</ul>
<h2 id="无默认构造函数的继承关系"><a href="#无默认构造函数的继承关系" class="headerlink" title="无默认构造函数的继承关系"></a>无默认构造函数的继承关系</h2><p>现考虑把上述嵌套的关系改为继承，并修改Animal与Dog的构造函数，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age) &#123;<span class="comment">//有参，非默认构造函数，且编译器不提供默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp; animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp; amimal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">int</span> age) : <span class="built_in">Animal</span>(age) &#123;<span class="comment">//继承构造的标准形式，如果无参或默认构造，使用Animal()</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述是通过初始化列表给<strong>基类带参构造传递参数</strong>，如果不通过初始化列表传递，会发生什么影响？</p>
<p>去掉初始化列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dog(int age)  &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Dog(int age) is called&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function for call to ‘Animal::Animal()’</span><br></pre></td></tr></table></figure>

<p>由于在Animal中没有默认构造函数，所以报错，遇到这种问题属于灾难性的，我们应该尽量避免，可以通过初始化列表给基类的构造初始化。</p>
<h2 id="类中const数据成员、引用数据成员"><a href="#类中const数据成员、引用数据成员" class="headerlink" title="类中const数据成员、引用数据成员"></a>类中const数据成员、引用数据成员</h2><p>特别是引用数据成员，必须用初始化列表初始化，而不能通过赋值初始化！</p>
<p>例如：在上述的Animal中添加私有成员，并修改构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age,std::string name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;age_;<span class="comment">//引用，定义同时必须初始化</span></span><br><span class="line">    <span class="type">const</span> std::string name_;<span class="comment">//const类型，定义同时必须初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>报下面错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: uninitialized reference member in ‘int&amp;’</span><br></pre></td></tr></table></figure>

<p>应该改为下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Animal</span>(<span class="type">int</span> age, std::string name) : <span class="built_in">age_</span>(age), <span class="built_in">name_</span>(name) &#123;<span class="comment">//使用初始化列表，相当于定义同时初始化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="枚举类与命名空间"><a href="#枚举类与命名空间" class="headerlink" title="枚举类与命名空间"></a>枚举类与命名空间</h1><p>在Effective modern C++中Item 10: Prefer scoped enums to unscoped enum，<strong>要用有范围的enum class代替无范围的enum</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;circle,retangle&#125;;</span><br><span class="line"><span class="keyword">auto</span> circle = <span class="number">10</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>上述错误是因为两个circle在同一范围。 对于enum等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> circle 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> retangle 1</span></span><br></pre></td></tr></table></figure>

<p>因此后面再去定义circle就会出错。</p>
<p>所以不管枚举名是否一样，里面的成员只要有一致的,就会出问题。 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> &#123;a,b&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">B</span> &#123;c,a&#125;;</span><br></pre></td></tr></table></figure>

<p>a出现两次，在enum B的a处报错。</p>
<p>根据前面我们知道，enum名在范围方面没有什么作用，因此我们想到了namespace，如下例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建枚举时，将它们放在名称空间中，以便可以使用有意义的名称访问它们:</span></span><br><span class="line"><span class="keyword">namespace</span> EntityType &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">        Ground = <span class="number">0</span>,</span><br><span class="line">        Human,</span><br><span class="line">        Aerial,</span><br><span class="line">        Total</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(EntityType::Enum entityType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entityType == EntityType::Ground) &#123;<span class="comment">//使得Ground在EntityType空间才是全局的</span></span><br><span class="line">        <span class="comment">/*code*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将命名空间起的有意思点，就可以达到想要的效果。</p>
<p>但是不断的使用命名空间，势必太繁琐，而且如果我不想使用namespace，要达到这样的效果，便会变得不安全，也没有约束。</p>
<p>因此在c++11后，引入<strong>enum class</strong>。</p>
<p>enum class 解决了为enum成员定义类型、类型安全、约束等问题。 回到上述例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum class</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EntityType</span> &#123;</span><br><span class="line">    Ground = <span class="number">0</span>,</span><br><span class="line">    Human,</span><br><span class="line">    Aerial,</span><br><span class="line">    Total</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(EntityType entityType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entityType == EntityType::Ground) &#123;<span class="comment">//Ground已非全局，属于枚举类的成员</span></span><br><span class="line">        <span class="comment">/*code*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这便是这一节要阐述的惯用法：enum class。</p>
<h1 id="资源获取即初始化方法-RAII"><a href="#资源获取即初始化方法-RAII" class="headerlink" title="资源获取即初始化方法(RAII)"></a>资源获取即初始化方法(RAII)</h1><blockquote>
<p>RAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父 Bjarne Stroustrup 提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。</p>
</blockquote>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在C语言中，有三种类型的内存分配:静态、自动和动态。静态变量是嵌入在源文件中的常数，因为它们有已知的大小并且从不改变，所以它们并不那么有趣。自动分配可以被认为是堆栈分配——当一个词法块进入时分配空间，当该块退出时释放空间。它最重要的特征与此直接相关。在C99之前，自动分配的变量需要在编译时知道它们的大小。这意味着任何字符串、列表、映射以及从这些派生的任何结构都必须存在于堆中的动态内存中。</p>
<p>程序员使用四个基本操作明确地分配和释放动态内存:malloc、realloc、calloc和free。前两个不执行任何初始化，内存可能包含碎片。除了自由，他们都可能失败。在这种情况下，它们返回一个空指针，其访问是未定义的行为。</p>
<p>例如：	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">7</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>(str, <span class="string">&quot;toptal&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char array = \&quot;%s\&quot; @ %u\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">   str = (<span class="type">char</span> *) <span class="built_in">realloc</span>(str, <span class="number">11</span>);</span><br><span class="line">   <span class="built_in">strcat</span>(str, <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char array = \&quot;%s\&quot; @ %u\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(str);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> array = <span class="string">&quot;toptal&quot;</span> @ <span class="number">2762894960</span></span><br><span class="line"><span class="type">char</span> array = <span class="string">&quot;toptal.com&quot;</span> @ <span class="number">2762894960</span></span><br></pre></td></tr></table></figure>

<p>尽管代码很简单，但它已经包含了一个反模式和一个有问题的决定。在现实生活中，你不应该直接写字节数，而应该使用sizeof函数。类似地，我们将char *数组精确地分配给我们需要的字符串大小的两倍(比字符串长度多一倍，以说明空终止)，这是一个相当昂贵的操作。一个更复杂的程序可能会构建一个更大的字符串缓冲区，允许字符串大小增长。</p>
<h2 id="RAII的发明：新希望"><a href="#RAII的发明：新希望" class="headerlink" title="RAII的发明：新希望"></a>RAII的发明：新希望</h2><p>至少可以说，所有手动管理都是令人不快的。 在80年代中期，Bjarne Stroustrup为他的全新语言C ++发明了一种新的范例。 他将其称为“资源获取即初始化”，其基本见解如下：<strong>可以指定对象具有构造函数和析构函数，这些构造函数和析构函数在适当的时候由编译器自动调用，这为管理给定对象的内存提供了更为方便的方法。</strong> 并且该技术对于不是内存的资源也很有用。</p>
<p>意味着上面的例子在c++中更简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::string str = std::<span class="built_in">string</span> (<span class="string">&quot;toptal&quot;</span>);</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;string object: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   str += <span class="string">&quot;.com&quot;</span>;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;string object: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string object: toptal @ <span class="number">0x7fffa67b9400</span></span><br><span class="line">string object: toptal.com @ <span class="number">0x7fffa67b9400</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们没有手动内存管理！构造string对象，调用重载方法，并在函数退出时自动销毁。不幸的是，同样的简单也会导致其他问题。让我们详细地看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; lines;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines.<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">size</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File makefile contains <span class="number">37</span> lines.</span><br></pre></td></tr></table></figure>

<p>这看起来很简单。<code>vector</code>被填满、返回和调用。然而，作为关心性能的高效程序员，这方面的一些问题困扰着我们:在return语句中，由于使用了值语义，<code>vector</code>在销毁之前不久就被复制到一个新<code>vector</code>中（伴随main函数一直存在）。</p>
<blockquote>
<p>在现代C ++中，这不再是严格的要求了。 C ++ 11引入了移动语义的概念，其中将原点保留在有效状态（以便仍然可以正确销毁）但未指定状态。 对于编译器而言，返回调用是最容易优化以优化语义移动的情况，因为它知道在进行任何进一步访问之前不久将销毁源。 但是，该示例的目的是说明为什么人们在80年代末和90年代初发明了一大堆垃圾收集的语言，而在那个时候C ++ move语义不可用。</p>
</blockquote>
<p>对于数据量比较大的文件，这可能会变得昂贵。 让我们对其进行优化，只返回一个指针。 语法进行了一些更改，但其他代码相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; * <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; * lines;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">size</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>程序崩溃！我们只需要将上述的<code>lines</code>进行内存分配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; * lines = <span class="keyword">new</span> vector&lt;string&gt;;</span><br></pre></td></tr></table></figure>

<p>这样就可以运行了！</p>
<p>不幸的是，尽管这看起来很完美，但它仍然有一个缺陷：它会泄露内存。在C++中，指向堆的指针在不再需要后必须手动删除（此时类对象的析构函数无法帮忙）；否则，一旦最后一个指针超出范围，该内存将变得不可用，并且直到进程结束时操作系统对其进行管理后才会恢复。惯用的现代C++将在这里使用<code>unique_ptr</code>，它实现了期望的行为。它删除指针超出范围时指向的对象。然而，这种行为直到C++11才成为语言的一部分。</p>
<p>在这里，可以直接使用C++11之前的语法，只是把main中改一下即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; * <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; * lines = <span class="keyword">new</span> vector&lt;string&gt;;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	vector&lt;string&gt; * file_lines = <span class="built_in">read_lines_from_file</span>(file_name);</span><br><span class="line">	<span class="type">int</span> count = file_lines-&gt;<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">delete</span> file_lines;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动去分配内存与释放内存。</p>
<p><strong>不幸的是，随着程序扩展到上述范围之外，很快就变得更加难以推理指针应该在何时何地被删除。当一个函数返回指针时，你现在拥有它吗？您应该在完成后自己删除它，还是它属于某个稍后将被一次性释放的数据结构？一方面出错，内存泄漏，另一方面出错，你已经破坏了正在讨论的数据结构和其他可能的数据结构，因为它们试图取消引用现在不再有效的指针。</strong></p>
<h2 id="“使用垃圾收集器，flyboy！”"><a href="#“使用垃圾收集器，flyboy！”" class="headerlink" title="“使用垃圾收集器，flyboy！”"></a>“使用垃圾收集器，flyboy！”</h2><p>垃圾收集器不是一项新技术。 它们由John McCarthy在1959年为Lisp发明。 1980年，随着Smalltalk-80的出现，垃圾收集开始成为主流。 但是，1990年代代表了该技术的真正发芽：在1990年至2000年之间，发布了多种语言，所有语言都使用一种或另一种垃圾回收：Haskell，Python，Lua，Java，JavaScript，Ruby，OCaml 和C＃是最著名的。</p>
<p>什么是垃圾收集？ 简而言之，这是一组用于<strong>自动执行手动内存管理的技术</strong>。 它通常作为具有手动内存管理的语言（例如C和C ++）的库提供，但在需要它的语言中更常用。 最大的优点是程序员根本不需要考虑内存。 都被抽象了。 例如，相当于我们上面的文件读取代码的Python就是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_lines_from_file</span>(<span class="params">file_name</span>):</span><br><span class="line">	lines = []</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> fp: </span><br><span class="line">		<span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">			lines.append(line)</span><br><span class="line">	<span class="keyword">return</span> lines</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="keyword">import</span> sys</span><br><span class="line">	file_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">	count = <span class="built_in">len</span>(read_lines_from_file(file_name))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;File &#123;&#125; contains &#123;&#125; lines.&quot;</span>.<span class="built_in">format</span>(file_name, count))</span><br></pre></td></tr></table></figure>

<p>行数组是在第一次分配给它时出现的，并且不复制到调用范围就返回。 由于时间不确定，它会在超出该范围后的某个时间被垃圾收集器清理。 有趣的是，在Python中，用于非内存资源的RAII不是惯用语言。 允许我们可以简单地编写<code>fp = open（file_name）</code>而不是使用with块，然后让GC（Garbage Collection，垃圾回收）清理。 但是建议的模式是在可能的情况下使用上下文管理器，以便可以在确定的时间释放它们。</p>
<p>尽管简化了内存管理，但要付出很大的代价。 在引用计数垃圾回收中，所有变量赋值和作用域出口都会获得少量成本来更新引用。在标记清除系统中，在GC清除内存的同时，所有程序的执行都<strong>以不可预测的时间间隔暂停</strong>。 这通常称为<strong>世界停止事件（stop the world）</strong>。「具体来说，<strong>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行</strong>。」 同时使用这两种系统的Python之类的实现都会受到两种惩罚。 这些问题降低了垃圾收集语言在性能至关重要或需要实时应用程序的情况下的适用性。 即使在以下玩具程序上，也可以看到实际的性能下降：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ make cpp &amp;&amp; time ./c++ makefile</span><br><span class="line">g++ -o c++ c++.cpp</span><br><span class="line">File makefile contains <span class="number">38</span> lines.</span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.016</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.015</span>s</span><br><span class="line"></span><br><span class="line">$ time python3 python3.py makefile</span><br><span class="line">File makefile contains <span class="number">38</span> lines.</span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.041</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.015</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.015</span>s</span><br></pre></td></tr></table></figure>

<p>Python版本的实时时间几乎是C ++版本的三倍。 尽管并非所有这些差异都可以归因于垃圾收集，但它仍然是可观的。</p>
<p>GC算法和特点参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/piwenjun/p/5482855.html">GC算法 - 寐语者 - 博客园 (cnblogs.com)</a></p>
<h2 id="所有权：RAII觉醒"><a href="#所有权：RAII觉醒" class="headerlink" title="所有权：RAII觉醒"></a>所有权：RAII觉醒</h2><p>我们知道对象的生存期由其范围决定。 但是，有时我们需要创建一个对象，该对象与创建对象的作用域无关，这是有用的，或者很有用。 在C ++中，运算符new用于创建这样的对象。 为了销毁对象，可以使用运算符delete。 由new操作员创建的对象是动态分配的，即在动态内存（也称为堆或空闲存储）中分配。 因此，由new创建的对象将继续存在，直到使用delete将其明确销毁为止。</p>
<p>使用new和delete时可能发生的一些错误是：</p>
<ul>
<li><p>对象（或内存）泄漏：使用new分配对象，而忘记删除该对象。</p>
</li>
<li><p>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，然而还有其他指针在引用它。</p>
</li>
<li><p>双重删除：尝试两次删除一个对象。</p>
</li>
</ul>
<p>通常，范围变量是首选。 但是，RAII可以用作new和delete的替代方法，以使对象独立于其范围而存在。 这种技术包括将指针分配到在堆上分配的对象，并将其（堆空间&#x2F;对象）放在<strong>句柄&#x2F;管理器对象</strong>中。 后者具有一个<strong>析构函数</strong>，将负责销毁该对象。 这将确保该对象可用于任何想要访问它的函数，并且该对象<strong>在句柄对象的生存期结束时将被销毁</strong>，而无需进行显式清理。</p>
<p>来自C ++标准库的使用RAII的示例为std :: string和std :: vector。</p>
<p>考虑这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(c);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建<code>vector</code>,并将元素推入<code>vector</code>时，您不必担心分配和取消分配此类元素内存。 <code>vector</code>使用new为其堆上的元素分配空间，并使用delete释放该空间。 作为vector的用户，您无需关心实现细节，并且会相信vector不会泄漏。 在这种情况下，vector是其元素的句柄对象。</p>
<p>标准库中使用RAII的其他示例是std :: shared_ptr，std :: unique_ptr和std :: lock_guard。</p>
<p>该技术的另一个名称是SBRM，是范围绑定资源管理的缩写。</p>
<p>现在，我们将上述读取文件例子，进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/unique_ptr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unique_ptr&lt;vector&lt;string&gt;&gt; <span class="built_in">read_lines_from_file</span>(string &amp;file_name) &#123;</span><br><span class="line">    unique_ptr&lt;vector&lt;string&gt;&gt; <span class="built_in">lines</span>(<span class="keyword">new</span> vector&lt;string&gt;);</span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">        lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file_handle.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">get</span>()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只有在最后，你才意识到RAII的真正力量。"><a href="#只有在最后，你才意识到RAII的真正力量。" class="headerlink" title="只有在最后，你才意识到RAII的真正力量。"></a>只有在最后，你才意识到RAII的真正力量。</h2><p>自从编译器发明以来，手动内存管理是程序员一直在想办法避免的噩梦。 RAII是一种很有前途的模式，但由于没有一些奇怪的解决方法，它根本无法用于堆分配的对象，因此在C ++中会受到影响。 因此，在90年代出现了垃圾收集语言的爆炸式增长，旨在使程序员生活更加愉快，即使以性能为代价。</p>
<p>最后，RAII总结如下：</p>
<ul>
<li><p>资源<strong>在析构函数中被释放</strong></p>
</li>
<li><p>该类的实例是<strong>堆栈分配的</strong></p>
</li>
<li><p>资源是<strong>在构造函数中获取的</strong>。</p>
</li>
</ul>
<p>RAII代表“资源获取是初始化”。</p>
<p>常见的例子有：</p>
<ul>
<li><p>文件操作</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>互斥量</p>
</li>
</ul>
<h1 id="拷贝交换copy-swap"><a href="#拷贝交换copy-swap" class="headerlink" title="拷贝交换copy-swap"></a>拷贝交换copy-swap</h1><p>这部分内容比较难懂，但特别巧妙。我花了挺长时间（起码比前面部分要多得多）理解，期间收集了多方的资料，并根据自己的理解整合（缝合）了一下，形成了一个比较完好、比较易懂的逻辑块，最后进行了一下总结。</p>
<p>首先介绍一下异常安全的概念（主要是针对析构函数，也可以直接跳到copy and swap惯用法章节）</p>
<h2 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h2><p>当异常发生时，会进行栈展开stack unwinding，具体步骤为：</p>
<blockquote>
<p>将暂停当前函数的执行，开始查找匹配的 catch 子句。首先检查 throw 本身是否在 try 块内部，如果是，检查与该 try 相关的 catch 子句，看是否有匹配的catch。如果不能处理，就退出当前函数，并且释放当前函数的局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 catch 。这个过程称为栈展开(stack unwinding)。当处理该异常的 catch 结束之后，紧接着该 catch 之后的点继续执行。</p>
</blockquote>
<p>显然栈展开跟对象离开函数作用域，自动析构的功能一样，是为了避免内存泄漏。而stack unwinding只能对栈上的变量析构，堆上动态分配的new不会自动析构。<strong>所以当发生异常时，要特别当心内存泄漏的发生</strong>。</p>
<p>异常处理威力很大，是处理错误的不二之选，但有时我们并不希望在有些函数中抛出异常，如：</p>
<ul>
<li><p><strong>析构函数不可以抛出异常，详见下文</strong>；</p>
</li>
<li><p><strong>构造函数可以抛出异常；</strong></p>
<ul>
<li>如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，根据栈展开的原理，会把已经构造好的对象自动析构；</li>
</ul>
</li>
<li><p><strong>移动赋值函数不应该抛出异常；</strong></p>
<ul>
<li>在STL标准库中很多容器在resize时都会通过<code>std::move_if_noexcept</code>模板来判断元素是否提供了noexcept（无异常）的移动赋值，如果提供那么move，否则调用拷贝赋值函数。所以不抛出异常的移动赋值函数效率会更高。</li>
</ul>
</li>
<li><p><strong>拷贝赋值函数可以抛出异常</strong>；</p>
</li>
<li><p><strong>swap不应该抛出异常</strong>；</p>
<ul>
<li>根据copy and swap惯用法，swap是移动赋值函数的基石。swap不抛出异常，移动赋值才不会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>note：未捕获的异常将会终止程序。</strong>如果找不到匹配的catch，程序就会调用库函数std::terminate。</p>
<h3 id="析构中的异常安全"><a href="#析构中的异常安全" class="headerlink" title="析构中的异常安全"></a>析构中的异常安全</h3><p>提问：析构函数可以抛出异常吗？答案是：不应该也不能。</p>
<p>理由有二，假设某类能抛出异常：</p>
<ol>
<li>vector析构所有元素时，<strong>那么当有一个元素抛出异常，此时catch之后的处理显然是继续销毁剩下的元素，但是假设运气很不好，又有一个元素抛出异常</strong>，c++此时无能为力，要么结束执行，要么发生不预期的行为。</li>
<li>析构函数往往不仅仅释放一个资源，<strong>当前一个资源释放时抛出异常，此时跳过异常点后面的代码，使得后一块资源没有释放，造成内存泄漏</strong>。</li>
</ol>
<p>因此得出结论，即便析构函数抛出了异常，程序猿catch后也无法处理这烫手山芋。不抛出异常是一种及时止损，如果抛会引起其他不可以预期的行为。<strong>c++资源释放不许失败。如果失败了，也不去管它，不抛异常让他去，let it go。</strong>（因为其他不可预期行为比资源释放失败更难以接受）</p>
<p>那么当析构函数发生错误时，该怎么办呢：</p>
<ul>
<li>只好忍气吞声（吞下异常）；</li>
<li>直接终止程序；</li>
<li>其他释放会失败的资源，建议释放不要放析构，放第三方函数，让程序员手工操作；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DBConn::~<span class="built_in">DBConn</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 直接终止</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        记录日志;</span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吞下异常</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        记录日志;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管吞下异常是个坏主意，但是没有办法的办法。</p>
<p>其他释放会失败的资源，建议释放不要放析构，放第三方函数，让程序锁手工操作</p>
<p>比如数据库连接断开操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">                记录日志;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBconnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把数据库连接释放这样可能出错的操作交给程序员自行释放，如果程序猿没有自行释放，但由析构函释放。那么此时析构函数出错，程序员也无话可说。</p>
<p>此外c++11之后，默认会把析构函数看成<code>noexcept(true)</code>，这意味着**如果析构函数抛出异常，直接<code>std::terminal</code>**。</p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>本节是copy and swap的铺垫。</p>
<p>交换函数是一种不抛异常函数，它交换一个类的两个对象或者成员。我们可能很想使用std :: swap而不是提供我们自己的方法，但这是不可能的。 std :: swap在实现中使用了copy-constructor和copy-assignment运算符，我们最终将尝试根据自身定义赋值运算符。</p>
<p>（不仅如此，对swap的无条件调用将使用我们的自定义swap运算符，从而跳过了std :: swap会导致的不必要的类构造和破坏。）</p>
<p>std中的swap是这么写的，应尽可能地<strong>对类的成员变量使用std::swap，而不是对整个类使用std::swap</strong>（如注释所写，若对整个类使用，在内部会调用拷贝构造和赋值构造，会导致的不必要的类构造和破坏）。实际上若使用copy-swap，赋值构造函数会需要调用swap函数，也就是说<strong>在使用swap函数时，赋值构造函数并没有完成。</strong></p>
<p><strong>swap必须注重安全，不允许抛出异常。（std::swap是安全的）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>; <span class="comment">//拷贝构造，如果对象是类</span></span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;<span class="comment">//赋值构造，如果对象是类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="copy-and-swap惯用法"><a href="#copy-and-swap惯用法" class="headerlink" title="copy and swap惯用法"></a>copy and swap惯用法</h2><blockquote>
<p>为什么我们需要复制和交换习惯？</p>
</blockquote>
<p>任何管理资源的类（包装程序，如智能指针）都需要实现big three。尽管拷贝构造函数和析构函数的目标和实现很简单。</p>
<p>big three（亦即下列三个成员函数缺一不可）：</p>
<ul>
<li>析构函数（Destructor）</li>
<li>拷贝构造函数（copy constructor）</li>
<li>赋值构造函数（copy assignment operator）</li>
</ul>
<p>但是赋值构造函数无疑是最细微和最困难的。</p>
<blockquote>
<p>应该怎么做？需要避免什么陷阱？</p>
</blockquote>
<p>copy-swap是解决方案，可以很好地协助赋值运算符实现两件事：<strong>避免代码重复</strong>，并提供强大的<strong>异常保证</strong>。</p>
<blockquote>
<p>它是如何工作的？</p>
</blockquote>
<p><strong>从概念上讲，它通过使用拷贝构造函数的功能来创建数据的本地副本，然后使用交换功能获取复制的数据，将旧数据与新数据交换来工作。然后，临时副本将销毁，并随身携带旧数据。我们剩下的是新数据的副本。</strong></p>
<p>为了使用copy-swap，我们需要三件事：</p>
<ul>
<li>一个有效的拷贝构造函数</li>
<li>一个有效的析构函数（两者都是任何包装程序的基础，因此无论如何都应完整）以及交换功能（swap）。</li>
</ul>
<hr>
<p><strong>实现方式对比</strong></p>
<p>我们先不考虑存在继承关系的类的赋值运算符重写，只考虑最简单的情况。我们知道，按照C++ primer的理解，赋值运算符应该实现两个方面的工作：</p>
<ul>
<li>拷贝构造函数</li>
<li>析构函数。</li>
</ul>
<p>只有完整实现了上述两步工作，赋值运算才能够正确进行。</p>
<p>首先介绍自赋值安全和异常安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当是自赋值的时候，pb已经先被删除了，那么后面的new就会为空，这是未知的计算。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异常安全是指当异常发生时：</span></span><br><span class="line"><span class="comment">	1) 不会泄漏资源，</span></span><br><span class="line"><span class="comment">	2) 也不会使系统处于不一致的状态。</span></span><br><span class="line"><span class="comment"> 通常有三个异常安全级别：基本保证、强烈保证、不抛异常（nothrow）保证。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个自赋值安全，但是没有异常安全，如果new处出现了异常，那么pb仍旧指向空。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出类A的定义，注意到类A中数据成员的数据类型，分别是内置整型以及整型指针。据此给出了构造以及析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;rhs):<span class="built_in">a</span>(rhs.a),<span class="built_in">b</span>(rhs.b==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:<span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b))&#123;&#125;;<span class="comment">//拷贝</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;<span class="comment">//析构</span></span><br><span class="line">        <span class="keyword">delete</span> b;</span><br><span class="line">        b = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值运算符包括拷贝构造以及析构两方面，因此给出第一种定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b);<span class="comment">// 可能失败</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回this对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们的代码几乎是对拷贝构造函数和析构函数的完全复制，此外，上述代码虽然完成了自赋值的验证，但并未保障异常安全。一旦new失败，原this对象的b已经被删除，因此会<strong>引发异常</strong>（若再使用b取值）。</p>
<p>effective C++ 关于本节的条款提到，无须在意自赋值，更多地考虑异常安全，异常安全得到保证，则自赋值自然得到处理。回到当前的例子，异常不安全主要在于，<strong>b对应的对象可能在异常到来之前被删除</strong>。因此我们首先保存该对象的副本，从而保证了异常安全特性，无论new是否成功，this对象中的b指针都会指向已知对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">auto</span> orign = <span class="keyword">this</span>-&gt;b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b);</span><br><span class="line">    <span class="keyword">delete</span> orign;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = rhs.a;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该写法<strong>不仅是异常安全</strong>的，同时也<strong>能够处理自赋值</strong>，但<strong>冗余代码</strong>的问题仍未得到解决，在effective C++中提到，可以写一个private函数进行调用，可是，这种写法并未解决根本问题：我们在赋值运算中<strong>重复实现了拷贝构造函数和析构函数</strong>。</p>
<p>上述方法事实上是致命的。在不考虑继承关系的复杂情况下，如果更改类A，添加数据成员，我们<strong>在修改其它构造&#x2F;析构函数的同时，也必须修改赋值运算符</strong>。copy and swap技术则可以做到完全规避这一点，此外，所有调用工作由编译器自动完成，无需再做任何额外操作。</p>
<p>该技术的核心就是不再使用引用作为赋值运算符参数，<strong>形参将直接是对象</strong>，这样的写法将会使编译器<strong>自动调用拷贝构造函数</strong>，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生，因为所有的swap是安全、不抛出异常的）。<strong>经过swap后的对象在离开函数体后会自动销毁</strong>，因此也就自动调用了析构函数，具体写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种写法，copy-swap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;a,rhs.a);<span class="comment">//赋值或调用赋值构造函数（如果a是一个类对象），这导致rhs被销毁后，类本身的数据仍然存在</span></span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;b,rhs.b);<span class="comment">//浅拷贝，把指针内容（地址）交换，</span></span><br><span class="line">    			<span class="comment">//使得rhs调用析构函数时，释放的空间是原来的this-&gt;b的，而新的数据空间仍可以使用，一举两得</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(A rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的代码有着显而易见的优势：所有需要考虑的问题会由编译器处理，我们无需考虑任何事项，关键是，它的正确性是显而易见而且符合逻辑的。对于类的扩展，我们除了构造函数&#x2F;析构函数外，只需要修改swap函数即可。</p>
<hr>
<p><strong>考虑存在继承的复杂情形</strong></p>
<p>本节对应的内容是<em>effective C++ 条款12，<strong>复制对象时勿忘记复制其每一成分。</strong></em> 假设有如下类B继承自上述类A：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ab;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">ab</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp;rhs):<span class="built_in">ab</span>(rhs.ab)&#123;&#125; <span class="comment">// copy constructor</span></span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp;rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ab = rhs.ab;      <span class="comment">// assignment operator</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述写法有两个错误，首先，B的拷贝构造函数只复制了B的数据成员，对于父类A中的私有成员，并没有进行复制，因此没有做到<strong>复制所有成员</strong>，对此拷贝构造函数需要修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp;rhs):<span class="built_in">A</span>(rhs),<span class="built_in">ab</span>(rhs.ab)&#123;&#125; <span class="comment">// copy constructor</span></span><br></pre></td></tr></table></figure>

<p>同理：赋值运算符也应修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp;rhs)&#123;</span><br><span class="line">        A::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ab = rhs.ab;      <span class="comment">// assignment operator</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于采用拷贝交换技术的类，我们则调用其父类的swap函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(B&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    A::<span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;ab,rhs.ab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>=(B rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>copy-swap惯用法实际上是利用编译器调用拷贝构造函数和析构函数来实现赋值构造函数（大前提是赋值构造函数的动作基本与拷贝构造函数（数据复制）和析构函数（原数据清除）相似）。</p>
<ul>
<li>基本的操作是通过传入函数的形参<strong>不是引用</strong>完成的（不是引用的话，则传入的参数会调用拷贝构造，当离开作用域时又会调用析构函数，使得赋值构造函数本身不用重复写这些代码）。<ul>
<li>这同时使得赋值构造函数<strong>避免了自赋值</strong>（因为传入的形参是一个临时对象）；</li>
<li>同时保证<strong>异常安全</strong>，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生，因为所有的swap是安全、不抛出异常的）。</li>
</ul>
</li>
<li>然后把拷贝构造函数产生的对象拿来swap，为什么是swap而非继续直接赋值呢？<ul>
<li>这主要是考虑对象中有指针与堆空间的释放，如果将指针直接赋值，则在临时对象析构后，赋值后指向的空间立马就释放了，做了无用功；同时又不保证异常安全了（空指针）。</li>
<li>更重要的是，对象自身的指针也指向堆空间，直接赋值就导致内存空间未释放就丢失，明显是不行的。</li>
<li>使用<strong>swap即可一举两得</strong>，swap一方面把自身指针的地址交换给临时对象的指针地址，当对方调用析构函数时释放掉这块空间；同时使原来拷贝构造出来的数据空间不会丢失。</li>
</ul>
</li>
</ul>
<h1 id="指向实现的指针"><a href="#指向实现的指针" class="headerlink" title="指向实现的指针"></a>指向实现的指针</h1><p>“指向实现的指针”或“pImpl”是一种 C++ 编程技巧，它将类的实现细节从对象表示中移除，<strong>放到一个分离的类中</strong>，并以一个不透明的指针进行访问。</p>
<p>使用pImpl惯用法的原因如下：</p>
<p>考虑如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  C c;</span><br><span class="line">  D d;  </span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>变成pImpl就是下面这样子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">XImpl</span>;</span><br><span class="line">  XImpl* pImpl;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CPP定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>::XImpl</span><br><span class="line">&#123;</span><br><span class="line">  C c;</span><br><span class="line">  D d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>二进制兼容性</li>
</ul>
<p>开发库时，可以在不破坏与客户端的二进制兼容性的情况下向XImpl添加&#x2F;修改字段（这将导致崩溃！）。 由于在向Ximpl类添加新字段时X类的二进制布局不会更改，因此可以安全地在次要版本更新中向库添加新功能。</p>
<p>当然，也可以在不破坏二进制兼容性的情况下向X &#x2F; XImpl添加新的公共&#x2F;私有非虚拟方法，但这与标准的标头&#x2F;实现技术相当。</p>
<ul>
<li>数据隐藏</li>
</ul>
<p>如果您正在开发一个库，尤其是专有库，则可能不希望公开用于实现库公共接口的其他库&#x2F;实现技术。 要么是由于知识产权问题，要么是因为认为用户可能会被诱使对实现进行危险的假设，或者只是通过使用可怕的转换技巧来破坏封装。 PIMPL解决&#x2F;缓解了这一难题。</p>
<ul>
<li>编译时间</li>
</ul>
<p>编译时间减少了，因为当向XImpl类添加&#x2F;删除字段和&#x2F;或方法时（仅映射到标准技术中添加私有字段&#x2F;方法的情况），仅需要重建X的源（实现）文件。 实际上，这是一种常见的操作。</p>
<p>使用标准的标头&#x2F;实现技术（没有PIMPL），当向X添加新字段时，曾经重新分配X（在堆栈或堆上）的每个客户端都需要重新编译，因为它必须调整分配的大小 。 好吧，每个从未分配X的客户端也都需要重新编译，但这只是开销（客户端上的结果代码是相同的）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/03/c++%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/03/c++%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">c++语法记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-03 10:10:09" itemprop="dateCreated datePublished" datetime="2022-08-03T10:10:09+08:00">2022-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-19 13:56:05" itemprop="dateModified" datetime="2023-02-19T13:56:05+08:00">2023-02-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h1><p>在 C++ 中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就<strong>只能调用</strong>类的 <strong>const 成员（包括 const 成员变量和 const 成员函数）</strong>了。</p>
<p>定义常对象的语法和定义常量的语法类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span>  <span class="keyword">class</span>  <span class="title">object</span><span class="params">(params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="type">const</span> <span class="title">object</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当然你也可以定义 const 指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> *p = <span class="keyword">new</span> <span class="built_in">class</span>(params);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const</span> *p = <span class="keyword">new</span> <span class="built_in">class</span>(params);</span><br></pre></td></tr></table></figure>

<p><code>class</code>为类名，<code>object</code>为对象名，<code>params</code>为实参列表，<code>p</code>为指针名。两种方式定义出来的对象都是常对象。</p>
<p>一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p>
<p>虽然常对象中的数据成员不能被修改，但是如果想要修改可以通过修改数据成员声明为<strong>mutable</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> x) :<span class="built_in">n</span>(x) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTest::display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n++;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">const</span> CTest <span class="title">test</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	test.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用于区分重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span></span><br><span class="line">&#123;    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">R</span>(<span class="type">int</span> r1, <span class="type">int</span> r2)&#123;R1=r1;R2=r2;&#125;</span><br><span class="line">         <span class="comment">//const区分成员重载函数</span></span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">int</span> R1,R2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常成员函数说明格式：类型说明符  函数名（参数表）const;</span></span><br><span class="line"><span class="comment">这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字。</span></span><br><span class="line"><span class="comment">const关键字可以被用于参与对重载函数的区分</span></span><br><span class="line"><span class="comment">通过常对象只能调用它的常成员函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;普通调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;R1&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;R2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化也需要带上const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;常对象调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;R1&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;R2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();  <span class="comment">//调用void print()</span></span><br><span class="line">    <span class="comment">//通过常对象只能调用它的常成员函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">52</span>)</span></span>;  </span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">//调用void print() const</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const成员函数的总结：</p>
<ul>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员（但不对任何数据作修改，除非是mutable的）；</li>
<li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li>
<li>作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。</li>
<li>如果只有const成员函数，非const对象是可以调用const成员函数的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数。</li>
</ul>
<h1 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testClass</span>();                    <span class="comment">/* 默认构造函数 */</span></span><br><span class="line">    <span class="built_in">testClass</span>(<span class="type">int</span> a, <span class="type">char</span> b);        <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="built_in">testClass</span>(<span class="type">int</span> a=<span class="number">10</span>,<span class="type">char</span> b=<span class="string">&#x27;c&#x27;</span>);    <span class="comment">/* 默认构造函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  m_a;</span><br><span class="line">    <span class="type">char</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认构造函数主要是用来完成如下形式的初始化的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 testClass classA;</span><br><span class="line">2 // 或者  testClass *classA = new testClass;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果没有提供默认构造函数，编译器会报错；</p>
<p>非默认构造函数在调用时接受参数，如以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 testClass classA(12,&#x27;H&#x27;);</span><br><span class="line">2 //或者  testClass *classA = new testClass(12,&#x27;H&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有定义<strong>任何构造函数</strong>，则编译器会自动定义默认构造函数，其形式如 testClass() {};  (比如定义了拷贝构造函数，也就不会自动生成默认构造函数)</li>
<li>定义默认构造函数有两种方式，如上述代码展示的，一是定义一个<strong>无参的构造函数</strong>，二是定义<strong>所有参数都有默认值的构造函数</strong> ；</li>
<li>注意：一个类<strong>只能有一个默认构造函数</strong>！也就是说上述两种方式不能同时出现，一般选择 testClass(); 这种形式的默认构造函数 ；</li>
<li><strong>只要定义了构造函数</strong>，编译器就不会再提供默认构造函数了，所以，最好再<strong>手动定义一个默认构造函数</strong>，以防出现 testClass a; 这样的错误。</li>
</ul>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，参数类型是本类的引用。</p>
<p>复制构造函数的参数可以是 <strong>const 引用</strong>，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。</p>
<p>如果类的设计者不写复制构造函数，编译器就会<strong>自动生成复制构造函数</strong>。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。</p>
<p>注意，<strong>默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在</strong>。</p>
<p>复制构造函数在以下三种情况下会被调用。</p>
<ul>
<li><p>1.当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，<strong>赋值语句不会引发复制构造函数的调用</strong>。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c1, c2; c1 = c2 ;</span><br><span class="line">c1=c2;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2.如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(A &amp; a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copy constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(A a)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">Func</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这样，如果形参是一个对象，那么形参的值<strong>是否等于</strong>实参，取决于该对象所属的类的复制构造函数是如何实现的。</p>
</li>
<li><p>以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。</p>
</li>
<li><p>如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> Complex &amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种情况下，只能调用c的const成员函数和const成员。</p>
</li>
</ul>
</li>
<li><p>3.如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123; v = n; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Func</span>().v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="构造函数的default和delete"><a href="#构造函数的default和delete" class="headerlink" title="构造函数的default和delete"></a>构造函数的default和delete</h1><p>C++11中，当类中含有不能默认初始化的成员变量时，可以禁止默认构造函数的生成，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>()=<span class="keyword">delete</span>;<span class="comment">//表示删除默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myClass</span>()=<span class="keyword">default</span>;<span class="comment">//表示默认存在构造函数</span></span><br></pre></td></tr></table></figure>

<p>当类中含有不能默认拷贝成员变量时，可以禁止默认构造函数的生成，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>(<span class="type">const</span> myClass&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示删除默认拷贝构造函数，即不能进行默认拷贝</span></span><br><span class="line"></span><br><span class="line">myClass &amp; <span class="keyword">operator</span>=(<span class="type">const</span> myClass&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示删除默认赋值构造函数，即不能进行默认赋值</span></span><br></pre></td></tr></table></figure>

<p>同时C++规定，一旦程序员实现了这些函数的自定义版本，则编译器不会再自动生产默认版本。注意只是不自动生成默认版本，当然还是可手动生成默认版本的。当我们自己定义了待参数的构造函数时，我们最好是声明不带参数的版本以完成无参的变量初始化，此时编译是不会再自动提供默认的无参版本了。我们可以通过使用关键字default来控制默认构造函数的生成，显式地指示编译器生成该函数的默认版本。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;  <span class="comment">//同时提供默认版本和带参版本，类型是POD的</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i):<span class="built_in">data</span>(i)&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有些时候我们希望限制默认函数的生成。典型的是禁止使用拷贝构造函数，<strong>以往的做法是将拷贝构造函数声明为private的，并不提供实现</strong>，这样当拷贝构造对象时编译不能通过，C++11则使用delete关键字显式指示编译器不生成函数的默认版本。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">     <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; )=<span class="keyword">delete</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，一旦函数被delete过了，<strong>那么重载该函数也是非法的</strong>，该函数我们习惯上称为<strong>删除函数</strong>。</p>
<hr>
<p><strong>default和delete的其他用途</strong></p>
<p> 上面我们已经看到在类中我们可用default和delete修饰成员函数，使之成为缺省函数或者删除函数，在类的外面，也可以在类定义之外修饰成员函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyClass</span>() &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; );</span><br><span class="line">);</span><br><span class="line"><span class="comment">//在类的定义外用default来指明缺省函数版本</span></span><br><span class="line"><span class="keyword">inline</span> MyClass&amp; MyClass::<span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; )=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>而关于<em><strong>delete</strong></em>的显式删除，<em><strong>并非局限于成员函数</strong></em>，由此我们也知<strong>default是只局限作用于类的部分成员函数的</strong>。于是我们还可用delete来<strong>避免不必要的隐式数据类型转换</strong>。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="built_in">MyClsss</span>(<span class="type">char</span> c)=<span class="keyword">delete</span>;  <span class="comment">//删除char版本的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(MyClass m)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//编译不能通过，否则会自动把&#x27;a&#x27;转换成int</span></span><br><span class="line">  <span class="function">MyClass <span class="title">m1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">MyClass <span class="title">m2</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">//编译不能通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为char版本的构造函数被删除后，试图从char构造MyClass对象的方式是不允许的了。但去掉这句的函数删除后，编译器会<strong>隐式的将a转换为整型</strong>使得编译通过，调用的是整型构造函数，这可能并不是你所想要的。但是如果这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClsss</span><span class="params">(<span class="type">char</span> c)</span></span>=<span class="keyword">delete</span>;  <span class="comment">//删除explicit的char版本的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(MyClass m)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//编译可通过</span></span><br><span class="line">  <span class="function">MyClass <span class="title">m1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">MyClass <span class="title">m2</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">//编译不能通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将构造函数explicit后，<strong>构造函数一样的还是不能发生char的构造</strong>，因为char构造版本被删除了，但在Func的调用用，<strong>编译器会尝试将c转换为int</strong>，即Func(‘a’)会调用一次MyClass(int )构造，顺利通过编译。于是我们<strong>不提倡explicit和delete混用</strong>。</p>
<p><strong>对与普通函数delete也有类型的效果</strong>。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> c)</span></span>=<span class="keyword">delete</span>;  <span class="comment">//显式删除char版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;c);  //无法编译通过</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里因为Func的char版本已经被删除，故Func(‘c’)会编译失败。</p>
<p><strong>delete的有趣的用法还有删除operator new操作符</strong>，编码在堆上分配该类的对象如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>另外析构函数也是可以delete的</strong></p>
<p>这样做的目的是我们在指定内存位置进行内存分配时并不需要析构函数来完成对象级别的清理，这时我们可显式删除析构函数来限制自定义类型在栈上或者静态的构造。</p>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><blockquote>
<p>C++11中引入了移动构造函数，对象发生拷贝时不需要重新分配空间而是使用被拷贝对象的内存，从而<strong>提高代码运行效率</strong></p>
</blockquote>
<ul>
<li>C++中对象发生拷贝的场景可以分为两种，一种是被拷贝的对象还要继续使用，另一种是被拷贝的对象不再使用；第二种一般可以认为是对右值的拷贝<ul>
<li>&amp;&amp;是右值引用（即将消亡的值就是右值，函数返回的临时变量也是右值），右值可以匹配const &amp;</li>
<li>&amp;可以绑定左值（左值是指表达式结束后依然存在的持久对象，可被赋值）</li>
</ul>
</li>
<li>移动构造函数的第一个参数必须是自身类型的右值引用（不需要const，右值使用const没有意义），若存在额外的参数，任何额外的参数都必须有默认实参</li>
<li>移动构造函数<strong>构造对象时</strong>不再分配新内存，而是接管源对象的内存，移动后源对象进入<strong>可被销毁的状态</strong>，所以源对象中如果有<strong>指针数据成员</strong>，那么它们应该在移动构造函数中应该<strong>赋值为NULL</strong></li>
<li>因为移动操作不分配内存，所以不会抛出任何异常，因此可以用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Joezzz/p/9706769.html">noexcept</a>指定（如果定义在类的外面，那么定义也要用noexcept指定）</li>
</ul>
<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象初始化当前类的对象</strong>，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会<strong>退而求其次，调用拷贝构造函数</strong>。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 <strong>std::move()</strong> 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;<span class="comment">//修改源对象内部指针，指向NULL，使得析构后目标数据空间不会被释放</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct!</span></span><br><span class="line"><span class="comment">move construct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">move construct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<h1 id="移动赋值函数"><a href="#移动赋值函数" class="headerlink" title="移动赋值函数"></a>移动赋值函数</h1><p>与移动构造函数类似，移动构造函数是拷贝函数的替代，移动赋值函数则是赋值构造函数的替代。</p>
<p>也是将原对象的东西赋值给新对象，然后原对象指向空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span> = (A &amp;&amp; x)&#123;<span class="comment">//正常情况下，返回值为A&amp;</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;num = x.num;</span><br><span class="line">    x.num = <span class="literal">NULL</span>;<span class="comment">//修改指针指向NULL</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动赋值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> = (A &amp; x)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = <span class="keyword">new</span> <span class="built_in">int</span>(*x.num);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><p>初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。</p>
<p>使用初始化列表的原因：</p>
<ul>
<li><p>推荐使用初始化列表，它会比在函数体内初始化派生类成员更快，这是因为在分配内存后，在函数体内又多进行了一次赋值操作。</p>
</li>
<li><p>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</p>
</li>
<li><p>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</p>
</li>
<li><p>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接<strong>调用拷贝构造函数初始化</strong></p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test1</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;<span class="comment">//定义了构造函数，没有默认的</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test1 test1 ;<span class="comment">//因为在类Test2中，会根据Test2的构造函数来决定这句话到底只是声明，还是要用构造函数</span></span><br><span class="line"><span class="built_in">Test2</span>(Test1 &amp;t1)</span><br><span class="line">&#123;test1 = t1 ;&#125;<span class="comment">//这里表明test1已经构造好了，所以前面会执行默认构造函数，然后再执行赋值构造函数，会报错（注意这不是在声明时赋值，不是拷贝构造）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以上代码无法通过编译，因为Test2的构造函数中test1 = t1这一行实际上分成两步执行：</span></span><br><span class="line"><span class="comment">1. 调用Test1的默认构造函数来初始化test1，2.执行赋值构造函数</span></span><br><span class="line"><span class="comment">由于Test1没有默认的构造函数，所以1 无法执行，故而编译错误。正确的代码如下，使用初始化列表代替赋值操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test1 test1 ;<span class="comment">//在类Test2中，会根据Test2的构造函数来决定这句话到底只是声明，还是要用构造函数</span></span><br><span class="line"><span class="built_in">Test2</span>(Test1 &amp;t1):<span class="built_in">test1</span>(t1)&#123;&#125;<span class="comment">//这里对编译器强调了“初始化”，即前面只是声明，真正的初始化在这里，所以在这里调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line"><span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">i</span>(x), <span class="built_in">j</span>(i)&#123;&#125;; <span class="comment">// ok, 先初始化i，后初始化j</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line"><span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">j</span>(x), <span class="built_in">i</span>(j)&#123;&#125; <span class="comment">// i值未定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="派生类对象赋值给基类对象"><a href="#派生类对象赋值给基类对象" class="headerlink" title="派生类对象赋值给基类对象"></a>派生类对象赋值给基类对象</h1><p>c++中经常会发生数据类型的转换，例如将 int 类型的数据赋值给 float 类型的变量时，编译器会先把 int 类型的数据转换为 float 类型再赋值；反过来，float 类型的数据在经过类型转换后也可以赋值给 int 类型的变量。</p>
<p>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为<strong>向上转型</strong>（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。</p>
<p><strong>向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class A: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">A</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class B: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">66</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">//赋值前</span></span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//赋值后</span></span><br><span class="line">    a = b;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">10</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br><span class="line">----------------------------</span><br><span class="line">Class A: m_a=<span class="number">66</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。</p>
<p><strong>赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。</strong></p>
<p>实际上，为了执行赋值，派生类必须初始化好基类的成员变量。</p>
<h1 id="派生类指针（引用）赋值给基类指针（引用）"><a href="#派生类指针（引用）赋值给基类指针（引用）" class="headerlink" title="派生类指针（引用）赋值给基类指针（引用）"></a>派生类指针（引用）赋值给基类指针（引用）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class A: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间派生类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">A</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class B: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基类C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> c): <span class="built_in">m_c</span>(c)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class C: m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终派生类D</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::<span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d): <span class="built_in">B</span>(a, b), <span class="built_in">C</span>(c), <span class="built_in">m_d</span>(d)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class D: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;<span class="string">&quot;, m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;<span class="string">&quot;, m_d=&quot;</span>&lt;&lt;m_d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">3</span>);</span><br><span class="line">    D *pd = <span class="keyword">new</span> <span class="built_in">D</span>(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>);</span><br><span class="line">    pa = pd;</span><br><span class="line">    pa -&gt; <span class="built_in">display</span>();</span><br><span class="line">    pb = pd;</span><br><span class="line">    pb -&gt; <span class="built_in">display</span>();</span><br><span class="line">    pc = pd;</span><br><span class="line">    pc -&gt; <span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pa=&quot;</span>&lt;&lt;pa&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pb=&quot;</span>&lt;&lt;pb&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pc=&quot;</span>&lt;&lt;pc&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd=&quot;</span>&lt;&lt;pd&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br><span class="line">-----------------------</span><br><span class="line">pa=<span class="number">0x9b17f8</span></span><br><span class="line">pb=<span class="number">0x9b17f8</span></span><br><span class="line">pc=<span class="number">0x9b1800</span></span><br><span class="line">pd=<span class="number">0x9b17f8</span></span><br></pre></td></tr></table></figure>

<p>本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。</p>
<p>将派生类指针 pd 赋值给了基类指针 pa，从运行结果可以看出，调用 display() 函数时虽然使用了派生类的成员变量，但是 display() 函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数。</p>
<p>概括起来说就是：<strong>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。</strong>（注意一个是指针，一个是指针类型）</p>
<p>执行<code>pc = pd;</code>语句后，pc 和 pd 的值并不相等。这是因为D类先继承了B再继承了C，在内存模型中，<strong>D类实例的空间先存储了B类、再存储了C类</strong>，因此pa、pb直接指向内存空间的起始，而pc要指向C类的那一块空间， 因此在稍后一些的位置（B的结束、C的开始）。</p>
<p>引用在本质上是通过指针的方式实现的，基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    A &amp;ra = d;</span><br><span class="line">    B &amp;rb = d;</span><br><span class="line">    C &amp;rc = d;</span><br><span class="line">   </span><br><span class="line">    ra.<span class="built_in">display</span>();</span><br><span class="line">    rb.<span class="built_in">display</span>();</span><br><span class="line">    rc.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。</p>
<p>最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。</p>
<h1 id="类、派生类的构造"><a href="#类、派生类的构造" class="headerlink" title="类、派生类的构造"></a>类、派生类的构造</h1><ul>
<li><p>类对象成员的构造：<strong>先构造成员变量中的对象，再构造自身对象（调用构造函数）</strong> </p>
</li>
<li><p>派生类构造函数：派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要<strong>调用基类和成员对象的构造函数</strong>，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。</p>
<ul>
<li><p><strong>派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数</strong>，形式如下：</p>
<p><code>派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…&#123; //…… &#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子类的拷贝构造函数和拷贝赋值函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> Age,string Name):<span class="built_in">m_nAge</span>(Age),<span class="built_in">m_strName</span>(Name)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Person:基类的代参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nAge;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> Age,string Name,<span class="type">int</span> Num):<span class="built_in">Person</span>(Age,Name),<span class="built_in">m_nNum</span>(Num)&#123;<span class="comment">//初始化列表传入参数，调用构造</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Student:子类的代参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp;stu):<span class="built_in">Person</span>(stu),<span class="built_in">m_nNum</span>(stu.m_nNum)&#123;<span class="comment">//初始化列表传入stu，调用拷贝构造</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Student:子类的拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Student&amp;stu)&#123; <span class="comment">// 子类的拷贝赋值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;stu)</span><br><span class="line">        &#123;   </span><br><span class="line">            Person::<span class="keyword">operator</span>= (stu);<span class="comment">//显式调用基类的operator</span></span><br><span class="line">            m_nNum = stu.m_nNum;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nNum;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/whh_1218/article/details/8442734</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造函数和析构函数调用次序：</p>
<ul>
<li>先构造基类</li>
<li>再构造成员</li>
<li>最后构造自身（调用构造函数）</li>
</ul>
</li>
<li><p>基类构造顺序由派生层次决定：<strong>最远的基类最先构造</strong> 成员构造顺序和定义顺序符合 析构函数的析构顺序与构造相反</p>
</li>
</ul>
<h1 id="继承访问权限"><a href="#继承访问权限" class="headerlink" title="继承访问权限"></a>继承访问权限</h1><p>基类中protected的成员：</p>
<ul>
<li>类内部：可以访问； 类的使用者：不能访问； 类的派生类成员：可以访问（protected相比private就是能给派生类访问）</li>
<li>派生类不可访问基类的private成员，可访问基类的protected成员，可访问基类的public成员</li>
</ul>
<h2 id="公有（public）继承"><a href="#公有（public）继承" class="headerlink" title="公有（public）继承"></a>公有（public）继承</h2><p>在派生类中，基类成员在派生类的权限为：</p>
<ul>
<li>public -&gt; public</li>
<li>protected -&gt; protected</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="私有（private）继承"><a href="#私有（private）继承" class="headerlink" title="私有（private）继承"></a>私有（private）继承</h2><p>在派生类中，基类成员在派生类的权限为：</p>
<ul>
<li>public -&gt; private</li>
<li>protected -&gt; private</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="保护（protected）继承"><a href="#保护（protected）继承" class="headerlink" title="保护（protected）继承"></a>保护（protected）继承</h2><p>派生方式为protected的继承称为保护继承，在这种继承方式下， 基类的public成员在派生类中会变成protected成员， 基类的protected和private成员在派生类中保持原来的访问权限。注意点：当采用保护继承的时候，由于public成员变为protected成员，因此类的使用者不可访问，而派生类可访问。</p>
<p>在派生类中，基类成员在派生类的权限为</p>
<ul>
<li>public -&gt; protected</li>
<li>protected -&gt; protected</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="派生类对基类成员的访问形式"><a href="#派生类对基类成员的访问形式" class="headerlink" title="派生类对基类成员的访问形式"></a>派生类对基类成员的访问形式</h2><ul>
<li>通过派生类对象直接访问基类成员</li>
<li>在派生类成员函数中直接访问基类成员</li>
<li>通过基类名字限定访问被重载的基类成员名</li>
</ul>
<h1 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h1><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为<strong>虚拟继承</strong>，而A就成了<strong>虚拟基类</strong>。实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B1,<span class="keyword">public</span> B2;</span><br></pre></td></tr></table></figure>

<p>虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p>
<h2 id="为什么需要虚继承？"><a href="#为什么需要虚继承？" class="headerlink" title="为什么需要虚继承？"></a>为什么需要虚继承？</h2><p>由于C++支持多重继承，那么在这种情况下会出现重复的基类这种情况，也就是说可能出现将一个类两次作为基类的可能性。比如这里D继承B1和B2，B1继承A，B2也继承A，实际上有两条继承路径：D-&gt;B1-&gt;A，以及D-&gt;B2-&gt;A，D是一样的，但这<strong>两个A在直接继承的情况下是不一样的</strong>。当存在歧义的时候就会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>:<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DerivedA</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in DerivedA&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span>: <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DerivedB</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in DerivedB&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:DerivedA,DerivedB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in MyClass&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下会造成在MyClass中访问value时出现路径不明确的编译错误，要访问数据，就需要显示地加以限定。变成DerivedA::value或 者DerivedB::value，以消除歧义性。并且，通常情况下，像Base这样的公共基类不应该表示为两个分离的对象，而要解决这种问题就可以用虚 基类加以处理。如果使用虚继承，编译便正常了。</p>
<p><strong>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示。</strong></p>
<h2 id="引入虚继承和直接继承的区别"><a href="#引入虚继承和直接继承的区别" class="headerlink" title="引入虚继承和直接继承的区别"></a>引入虚继承和直接继承的区别</h2><p>由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同：</p>
<ul>
<li><strong>时间：</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。</li>
<li><strong>空间：</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承会节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个<strong>指向基类子对象的指针</strong>。</li>
</ul>
<h2 id="内存考虑"><a href="#内存考虑" class="headerlink" title="内存考虑"></a>内存考虑</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一种情况：　　　　　　　　   第二种情况：　　　　　　　　　　  第三种情况　　　　　　　　　　　　 第四种情况：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　 <span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　　  <span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　　　　<span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;　　　　　　　　　　　　　   &#123;　　　　　　　　　　　　　　　   &#123;　　　　　　　　　　　　　　　　　 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　　　	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　　　　　　<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　　  <span class="type">char</span> x;　　　　　　　　　　　　　　 <span class="type">char</span> x;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> a　 <span class="keyword">class</span> <span class="title class_">b</span> :<span class="keyword">public</span> a　　　　　　　 &#125;;　　　　　　　　　　　　　　　　  &#125;;</span><br><span class="line">&#123;　　　　　　　　　　　　　　 &#123;　　　　　　　　　　　　　　 　  <span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> a　　　　　 <span class="keyword">class</span> <span class="title class_">b</span>:<span class="function"><span class="keyword">public</span> a</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　 	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　　　 &#123;　　　　　　　　　　　　　　　　   &#123;</span><br><span class="line">&#125;;　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　	  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　　　　　　　<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　  &#125;;</span><br></pre></td></tr></table></figure>

<p>对这四种情况分别求sizeof(a）, sizeof(b)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：4，12</span><br><span class="line">第二种：4，4</span><br><span class="line">第三种：8，16</span><br><span class="line">第四种：8，8</span><br></pre></td></tr></table></figure>

<p><strong>每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表</strong>，所以每种情况的类a所占的字节数应该是没有什么问题的，那么类b的字节数怎么算呢？“第一种”和“第三种”情况采用的是虚继承，那么这时候就要有这样的一个指针vptr_b_a，这个指针叫<strong>虚类指针</strong>，指向虚拟基类，也是四个字节；还要包括类a的字节数，所以类b的字节数就求出来了。而“第二种”和“第四种”情况则不包括vptr_b_a这个指针。</p>
<p>注：关于虚函数表的内容，需要结合图片理解，推荐参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaokang01/p/12394420.html">虚函数和虚函数表 - Lucky&amp; - 博客园 (cnblogs.com)</a>。</p>
<h1 id="构造函数和析构函数的构造规则"><a href="#构造函数和析构函数的构造规则" class="headerlink" title="构造函数和析构函数的构造规则"></a>构造函数和析构函数的构造规则</h1><p>构造函数中有默认参数的情况：<strong>既可以在类的声明中，也可以在函数定义中声明缺省参数，但不能既在类声明中又在函数定义中同时声明缺省参数。</strong></p>
<ul>
<li><p>当具有下述情况之一时，派生类可以不定义构造函数：</p>
<ul>
<li><p>基类没有定义任何构造函数</p>
</li>
<li><p>基类具有缺省参数的构造函数</p>
</li>
<li><p>基类具有无参构造函数。</p>
</li>
</ul>
</li>
<li><p>派生类必须定义构造函数的情况：</p>
<ul>
<li>当基类或成员对象所属类只含有带参数的构造函数时，即使派生类本身没有数据成员要初始化，它也必须定义构造函数，并以构造函数<strong>初始化列表</strong>的方式向基类和成员对象的构造函数传递参数，以实现基类子对象和成员对象的初始化。</li>
</ul>
</li>
<li><p>派生类的构造函数只负责直接基类的初始化</p>
</li>
</ul>
<p>C++语言标准有一条规则：如果派生类的基类同时也是另外一个类的派生类，则<strong>每个派生类只负责它的直接基类的构造函数调用</strong>。 这条规则表明当派生类的直接基类只有带参数的构造函数，但没有默认构造函数时（包括缺省参数和无参构造函数），它必须在构造函数的初始化列表中调用其直接基类的构造函数，并向基类的构造函数传递参数，以实现派生类对象中的基类子对象的初始化。 这条规则有一个例外情况，<strong>当派生类存在虚基类时，所有虚基类都由最后的派生类负责初始化。</strong></p>
<p>总结： </p>
<ul>
<li>当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先调用基类B的构造函数，再调用基类A的构造函数。</li>
<li>当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。</li>
<li>当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码。</li>
</ul>
<h1 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h1><blockquote>
<p><strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p>
<p>类的虚表会被这个类的所有对象所共享。类的对象可以有很多，但是他们的虚表指针都指向同一个虚表</p>
</blockquote>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态就是在同一个类或继承体系结构的基类与派生类中，用<strong>同名函数</strong>来实现各种不同的功能。</p>
<ul>
<li><strong>静态绑定又称静态联编</strong>：是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。</li>
<li><strong>动态绑定又称动态联编</strong>：是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</li>
<li><strong>编译时多态性</strong>（静态联编(连接)）：系统在编译时就决定如何实现某一动作,即对某一消息如何处理。静态联编具有执行<strong>速度快</strong>的优点。在C++中的编译时多态性是通过<strong>函数重载和运算符重载</strong>实现的。</li>
<li><strong>运行时多态性</strong>（动态联编(连接)）：系统在运行时动态实现某一动作,即对某一消息在运行过程实现其如何响应。动态联编为系统提供了<strong>灵活和高度问题抽象</strong>的优点,在C++中的运行时多态性是通过<strong>继承和虚函数</strong>实现的。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的意义：</p>
<ul>
<li>首先派生类对象可以赋值给基类对象。 派生类对象的地址可以赋值给指向基类对象的指针。 派生类对象可以作为基类对象的引用。 赋值相容的问题： 不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中<strong>继承到的成员</strong>， <strong>不能借此访问派生类定义的成员</strong>。</li>
<li>虚函数使得可以通过基类对象的指针或引用<strong>访问派生类定义的成员</strong>。</li>
<li>virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。</li>
<li>虚函数的虚特征：基类指针指向派生类的对象时，通过该指针访问其虚函数将<strong>调用派生类的版本</strong>。</li>
</ul>
<p>要点：</p>
<ul>
<li>一旦将某个成员函数声明为虚函数后，它在继承体系中就<strong>永远</strong>为虚函数了。（派生类在定义时可以不加virtual关键字）</li>
<li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们<strong>实际所指对象中的虚函数版本</strong>。</li>
<li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，<strong>才能体现虚函数的特性</strong>。</li>
<li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的<strong>函数原型完全相同</strong>，<strong>否则就是普通的重载函数</strong>，与基类的虚函数无关。</li>
<li>派生类通过<strong>从基类继承的成员函数调用虚函数</strong>时，将<strong>访问到派生类中的版本</strong>。</li>
<li>只有类的<strong>非静态成员函数</strong>才能被定义为虚函数，类的<strong>构造函数和静态成员函数不能定义为虚函数</strong>。原因是虚函数在继承层次结构中才能够发生作用，而<strong>构造函数、静态成员是不能够被继承的</strong>。</li>
<li><strong>内联函数也不能是虚函数</strong>（多态时）。因为<strong>内联函数采用的是静态联编</strong>的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使<strong>虚函数在类体内被定义，C++编译器也将它视为非内联函数</strong>。 <ul>
<li>类中定义的函数是内联函数，类中声明、类外定义且都没用inline关键字的是普通函数（注：inline要起作用，inline要与<strong>函数定义</strong>放在一起。inline是一种“用于实现的关键字，而不是用于声明的关键字）</li>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
</li>
<li>基类<strong>析构函数几乎总是为虚析构函数</strong>。假定使用delete和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚，就如一个普通成员函数，delete函数调用的就是基类析构函数（<strong>而不是调用该派生类的析构函数</strong>）。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底。（如果是虚析构函数，则会先调用派生类的析构函数再调用基类的析构函数）</li>
</ul>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>纯虚函数：仅定义函数原型而不定义其实现的虚函数。</p>
<p>实用角度：占位手段place-holder。</p>
<p>方法学：接口定义手段，抽象表达手段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ret_type <span class="title">func_name</span> <span class="params">(param)</span> </span>= <span class="number">0</span>; <span class="comment">//virtual与‘=0’就构成纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类：包含一个或多个纯虚函数的类。</p>
<p><strong>不能实例化抽象类</strong>，但可以定义抽象类的<strong>指针和引用</strong>。定义一个抽象类的派生类，必须定义<strong>所有纯虚函数</strong>，否则该派生类仍然是一个抽象类。</p>
<p>总结：</p>
<ul>
<li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li>
<li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li>
<li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载是C++的一项强大功能。通过重载，可以扩展C++运算符的功能，使它们能够操作用户自定义的数据类型，增加程序代码的直观性和可读性。</p>
<h2 id="重载二元运算符"><a href="#重载二元运算符" class="headerlink" title="重载二元运算符"></a>重载二元运算符</h2><p>二元运算符的调用形式与解析：a@b 可解释成 <code>a.operator@(b)</code> 或解释成 <code>operator@(a,b)</code>(@表示运算符)</p>
<p>如果两者都有定义,就按照重载解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>+(<span class="type">int</span>);<span class="comment">//实际上是X+int</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(X,X);<span class="comment">//X+x</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(X,<span class="type">double</span>);<span class="comment">//X+double</span></span><br></pre></td></tr></table></figure>

<h2 id="类运算符重载形式"><a href="#类运算符重载形式" class="headerlink" title="类运算符重载形式"></a>类运算符重载形式</h2><ul>
<li><p>非静态成员运算符重载：以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以this指针隐式传递的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">		<span class="type">double</span> real,image;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		Complex <span class="keyword">operator</span>+(Complex b)&#123;……&#125;<span class="comment">//实际上是Complex+Complex，*this+b</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元运算符重载：如果将运算符函数作为类的友元重载，它需要的参数个数就与运算符实际需要的参数个数相同。</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">……</span><br><span class="line">		<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b);<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际上就是Complex+Complex，a+b</span></span><br><span class="line">Complex  <span class="keyword">operator</span>+(Complex a,Complex b)&#123;……&#125;<span class="comment">//定义，注意定义必须在类声明完成后实现，否则编译器不知道Complex是一个类的类型</span></span><br></pre></td></tr></table></figure>

<h2 id="重载一元运算符"><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h2><ul>
<li><p>一元运算符：只需要一个运算参数，如取地址运算符（&amp;）、负数（?）、自增加（++）等。</p>
</li>
<li><p>一元运算符常见调用形式如下，其中的@代表一元运算符，a代表操作数。</p>
<ul>
<li>隐式调用形式：@a 或 a@ ，@a代表前缀一元运算，如“++a”；a@表示后缀运算，如“a++”。</li>
<li>显式调用一元运算符@：a.operator@()</li>
</ul>
</li>
<li><p>一元运算符作为类成员函数重载时不需要参数，其形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		T <span class="keyword">operator</span>@()&#123;……&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//T是运算符@的返回类型。从形式上看，作为类成员函数重载的一元运算符没有参数</span></span><br><span class="line"><span class="comment">//但实际上它包含了一个隐含参数，即调用对象的this指针。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>前自增(减)与后自增(减)：C++编译器可以通过在运算符函数参数表中是否插入关键字int 来区分这两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀</span></span><br><span class="line"><span class="keyword">operator</span> ++ ();</span><br><span class="line"><span class="keyword">operator</span> ++ (X &amp; x);<span class="comment">//这里的X代表其他的类型，可能有其他操作</span></span><br><span class="line"><span class="comment">//后缀</span></span><br><span class="line"><span class="keyword">operator</span> ++ (<span class="type">int</span>);</span><br><span class="line"><span class="keyword">operator</span> ++ (X &amp; x, <span class="type">int</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重载赋值运算符-x3D"><a href="#重载赋值运算符-x3D" class="headerlink" title="重载赋值运算符&#x3D;"></a>重载赋值运算符&#x3D;</h2><p>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</p>
<p><strong>即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</strong></p>
<p>对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> len);</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_len;</span><br><span class="line">    <span class="type">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="type">int</span> len): <span class="built_in">m_len</span>(len)&#123;</span><br><span class="line">    m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="type">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line">Array::~<span class="built_in">Array</span>()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="type">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>operator&#x3D;() 的返回值类型为<code>Array &amp;</code>，这样不但能够<strong>避免在返回数据时调用拷贝构造函数</strong>，还能够达到<strong>连续赋值</strong>的目的。下面的语句就是连续赋值：arr4 &#x3D; arr3 &#x3D; arr2 &#x3D; arr1;</li>
<li><code>if( this != &amp;arr)</code>语句的作用是<strong>「判断是否是给同一个对象赋值」</strong>：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。</li>
<li><code>return *this</code>表示返回当前对象（新对象）。</li>
<li>operator&#x3D;() 的形参类型为<code>const Array &amp;</code>，这样不但<strong>能够避免在传参时调用拷贝构造函数</strong>，还能够<strong>同时接收 const 类型和非 const 类型的实参</strong>。</li>
<li>赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是<strong>其它参数必须给出默认值</strong>，例如：<code>Array &amp; operator=(const Array &amp;arr, int a = 100);</code></li>
</ul>
<h2 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符[]"></a>重载赋值运算符[]</h2><ul>
<li><p>[ ]是一个二元运算符，其重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		X&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//调用：X[n]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载[]需要注意的问题</p>
<ul>
<li>[]是一个二元运算符，其第1个参数是通过对象的this指针传递的，第2个参数代表数组的下标</li>
<li>由于[]既可以出现在赋值符“&#x3D;”的左边，也可以出现在赋值符“&#x3D;”的右边，所以重载运算符[]时常<strong>返回引用</strong>。（既能作为左值赋值也能作为右值读取，如果不是引用，作为左值时函数只是返回了一个临时对象，赋值写入没用意义）</li>
<li><strong>[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数</strong>。</li>
</ul>
</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载( )"></a>重载( )</h2><ul>
<li><p>运算符( )是函数调用运算符，也能被重载。且<strong>只能被重载为类的成员函数</strong>。</p>
</li>
<li><p>运算符( )的重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		<span class="function">X&amp; <span class="title">operator</span><span class="params">( )</span><span class="params">(参数表)</span></span>;<span class="comment">//其中的参数表可以包括任意多个参数。</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符( )的调用形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X Obj; <span class="comment">//对象定义</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Obj</span>()(参数表); <span class="comment">//调用形式1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Obj</span>(参数表); <span class="comment">//调用形式2，普遍用这种形式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类强制转换的重载"><a href="#类强制转换的重载" class="headerlink" title="类强制转换的重载"></a>类强制转换的重载</h2><ul>
<li>类型转换函数<strong>没有参数</strong>。</li>
<li>类型转换函数<strong>没有返回类型</strong>。</li>
<li>类型转换函数<strong>必须返回将要转换成的type类型数据</strong>。</li>
</ul>
<p>看一下实例便知：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有一个类Circle，设计该类的类型转换函数，当将Circle对象转换成int型时，返回圆的半径；当将它转换成double型时，就返回圆的周长；当将它转换成float型时，就返回圆的面积。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x,y,r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> r1)&#123;x=x1;y=y1;r=r1;	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">int</span>(r);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*<span class="number">3.14</span>*r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">float</span>)<span class="number">3.14</span>*r*r;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> r=c;        <span class="comment">//因为r是int类型，会导致c主动调用operator int()，将Circle类型转换成int，然后给r赋值。</span></span><br><span class="line">    <span class="type">double</span> length=c;   <span class="comment">//调用operator double()，转换成double</span></span><br><span class="line">    <span class="type">float</span> area=c;   <span class="comment">//调用operator float()，将Circle类型转换成float</span></span><br><span class="line">    <span class="type">double</span> len=(<span class="type">double</span>) c;	<span class="comment">//将Cirlce类型对象强制转换成double</span></span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;length&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;area&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">15.7</span></span><br><span class="line"><span class="comment">15.7</span></span><br><span class="line"><span class="comment">19.625</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板（template）是C++实现代码重用机制的重要工具，是泛型技术（即与数据类型无关的通用程序设计技术）的基础。 模板是C++中相对较新的语言机制，它实现了与具体数据类型无关的通用算法程序设计，能够提高软件开发的效率，是程序代码复用的强有力工具。</p>
<p>模板概念：模板是对具有相同特性的函数或类的再抽象，模板是一种参数多态性的工具，可以为逻辑功能相同而类型不同的程序提供一种代码共享的机制。 一个模板并非一个实实在在的函数或类，仅仅是一个函数或类的<strong>描述</strong>，是参数化的函数和类。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板提供了一种通用的函数行为，该函数行为可以用多种不同的数据类型进行调用，编译器会据调用类型自动将它实例化为具体数据类型的函数代码，也就是说函数模板代表了一个<strong>函数家族</strong>。 与普通函数相比，函数模板中某些函数元素的数据类型是未确定的，这些元素的类型将在使用时被参数化；与重载函数相比，函数模板<strong>不需要程序员重复编写函数代码</strong>，它可以自动生成许多功能相同但参数和返回值类型不同的函数。当实例化一个函数模板时，编译器自动生成一份具有相应类型的代码。</p>
<p>函数模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>,…&gt;</span><br><span class="line">返回类型 函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">   	…… <span class="comment">//函数模板定义体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>template是定义模板的关键字；写在一对&lt;&gt;中的T1，T2，…是模板参数，其中的class表示其后的参数可以是任意类型。</p>
<p>注意事项 :</p>
<ul>
<li><p>在定义模板时，不允许template语句与函数模板定义之间有任何其他语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> x;                 <span class="comment">//错误，不允许在此位置有任何语句</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板可以有多个类型参数，但每个类型参数都必须用关键字class或typename限定。此外，模板参数中还可以出现确定类型参数，称为非类型参数（<em><strong>浮点数和类对象是不允许作为非类型模板参数的</strong></em>）。例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="type">int</span> T4&gt;<span class="comment">//在传递实参时，非类型参数T4只能使用常量</span></span><br><span class="line"><span class="function">T1 <span class="title">fx</span><span class="params">(T1 a, T <span class="number">2</span> b, T3 c)</span></span>&#123;…&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> Val, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用，这种情况必须像类一样显式实例化</span></span><br><span class="line"><span class="built_in">addValue</span>&lt;<span class="number">5</span>,<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要把这里的class与类的声明关键字class混淆在一起，虽然它们由相同的字母组成，但含义是不同的。这里的class表示T是一个类型参数，可以是任何数据类型，如int、float、char等，或者用户定义的struct、enum或class等自定义数据类型。</p>
</li>
<li><p>为了区别类与模板参数中的类型关键字class，标准C++用typename作为模板参数的类型关键字，同时也支持使用class。比如，把min定义的template 写成下面的形式是完全等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数模板的实例化：</p>
<ul>
<li><p>实例化发生的时机 模板实例化发生在调用模板函数时。当编译器遇到程序中对函数模板的调用时，它才会根据调用语句中实参的具体类型，确定模板参数的数据类型，并<strong>用此类型替换函数模板中的模板参数，生成能够处理该类型的函数代码</strong>，即<strong>模板函数</strong>。</p>
</li>
<li><p>当多次发生类型相同的参数调用时，只在第1次进行实例化。假设有下面的函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="built_in">min</span>(<span class="number">2</span>,<span class="number">3</span>);     </span><br><span class="line"><span class="type">int</span> y=<span class="built_in">min</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> z=<span class="built_in">min</span>(<span class="number">8.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器只在第1次调用时生成模板函数，当之后遇到相同类型的参数调用时，不再生成其他模板函数，</span></span><br><span class="line"><span class="comment">//它将调用第1次实例化生成的模板函数。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>实例化方式：</p>
<ul>
<li><p><strong>隐式实例化</strong>：编译器能够判断模板参数类型时，自动实例化函数模板为模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式实例化，表面上是在调用模板，实际上是调用其实例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T, T)</span></span>;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span> (<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line"><span class="type">float</span> f = <span class="built_in">max</span> (<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">max</span> (‘a’, ‘A’);</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示实例化explicit instantiation</strong> ：编译器不能判断模板参数类型或常量值，需要使用特定数据类型实例化 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法形式：模板名称&lt;数据类型,…,常量值,…&gt; (参数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T, T)</span></span>;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span> (<span class="number">1</span>, ‘<span class="number">2</span>’); <span class="comment">// error: data type can’t be deduced</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span>&lt;<span class="type">int</span>&gt; (<span class="number">1</span>, ‘<span class="number">2</span>’);<span class="comment">//将&#x27;2‘强制转化为int类型</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数模板的特化(<strong>函数模板的特化，只能全特化</strong>）：</p>
<ul>
<li><p>特化的原因：在某些情况下，模板描述的通用算法<strong>不适合特定的场合</strong>（数据类型等） 比如：如max函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * cp = <span class="built_in">max</span> (“abcd”, “<span class="number">1234</span>”);</span><br><span class="line">实例化为：</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">max</span> <span class="params">(<span class="type">char</span> * a, <span class="type">char</span> * b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br></pre></td></tr></table></figure>

<p>这肯定是有问题的，因为字符串的比较为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">max</span> <span class="params">(<span class="type">char</span> * a, <span class="type">char</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b)&gt;<span class="number">0</span> ? a : b;   &#125;</span><br></pre></td></tr></table></figure>

<p>因此需要写出一份特化版本的max函数，在遇到字符串时使用特化版本而不使用泛型版本。</p>
</li>
<li><p>所谓特化，就是针对模板不能处理的特殊数据类型，编写与模板同名的特殊函数专门处理这些数据类型。 </p>
<p><strong>模板特化的定义形式</strong>：<code>template &lt;&gt; 返回类型 函数名&lt;特化的数据类型&gt;(参数表) &#123; …… &#125;</code></p>
<p>说明： ① template &lt; &gt;是模板特化的关键字，&lt; &gt;中不需要任何内容； ② 函数名后的&lt; &gt;中是需要特化处理的数据类型，实际上，这是对泛型版本说明该函数要特化的形式（即显式告知泛型中的T）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于该函数模板，当实参为两个char指针时，比较的是指针的大小，而不是指针指向内容的大小，</span></span><br><span class="line"><span class="comment">//此时就需要为该函数模板定义一个特化版本，即特殊处理的版本：</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//为实参类型 const char * 提供特化版本</span></span><br><span class="line"><span class="comment">//template &lt;&gt; int compare(const char * const &amp;v1, const char * const &amp;v2) </span></span><br><span class="line"><span class="comment">//省略了函数名后边的显示模板实参，因为可以从函数形参表推断出来，本定义与下边的定义都是正确的；</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">int</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v1, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;template &lt;&gt; int compare&lt;const char *&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//为实参类型 char * 提供特化版本</span></span><br><span class="line"><span class="comment">//template &lt;&gt; int compare(char * const &amp;v1, char * const &amp;v2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">int</span> <span class="built_in">compare</span>&lt;<span class="type">char</span> *&gt;(<span class="type">char</span> * <span class="type">const</span> &amp;v1, <span class="type">char</span> * <span class="type">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;template &lt;&gt; int compare&lt;char *&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当程序中同时存在模板和它的特化时，特化将被优先调用；</li>
<li>在同一个程序中，除了函数模板和它的特化外，还<strong>可以有同名的普通函数</strong>。其区别在于C++会对普通函数的调用实参进行隐式的类型转换，但<strong>不会对模板函数及特化函数的参数进行任何形式的类型转换</strong>（需要匹配或者显式实例）。</li>
<li>当同一程序中具有模板与普通函数时，其匹配顺序（调用顺序）如下： <ul>
<li>1.完全匹配的非模板函数</li>
<li>2.完全匹配的模板函数</li>
<li>3.类型相容的非模板函数</li>
</ul>
</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板可用来设计结构和成员函数完全相同，但所处理的数据类型不同的通用类。</p>
<p>类模板的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,…&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    	…… <span class="comment">// 类成员的声明与定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中T1、T2是类型参数。类模板中可以有多个模板参数，包括类型参数和非类型参数</p>
<p>非类型参数是指某种具体的数据类型，在调用模板时只能为其提供用相应类型的常数值。非类型参数是受限制的，通常可以是整型、枚举型、对象或函数的引用，以及对象、函数或类成员的指针，<strong>但不允许用浮点型（或双精度型）、类对象或void作为非类型参数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="type">int</span> T3&gt;</span><br><span class="line"><span class="comment">//在实例化时，必须为T1、T2提供一种数据类型，为T3指定一个整常数（如10），该模板才能被正确地实例化。</span></span><br></pre></td></tr></table></figure>

<p>类模板的成员函数的定义：</p>
<ul>
<li><p>类内成员函数定义，与常规成员函数的定义类似，另外 “模板参数列表”引入的“类型标识符”直接作为数据类型使用，“模板参数列表”引入的“普通数据类型常量”直接作为常量使用。</p>
</li>
<li><p>在类模板外定义，语法：</p>
<p>template &lt;模板参数列表&gt; [返回值类型] [类模板名&lt;模板参数名表&gt;::] [成员函数名] ([参数列表]){…};</p>
<p>就比普通的模板函数多了 <code> [类模板名&lt;模板参数名表&gt;::]</code>。</p>
</li>
</ul>
<p>类可以特化，与函数模板不同的是，类不仅可以全特化，也可以<strong>偏特化</strong>。</p>
<p>偏特化是指提供另一份template定义式，而其本身仍为<code>templatized</code>，这是针对于<code>template</code>参数更进一步的条件限制所设计出来的一个特化版本。也就是如果这个模板有多个类型，那么<strong>只限定其中的一部分</strong>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(T1 a, T2 b):_a(a),_b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T1 _a;</span><br><span class="line"> T2 _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) :_a(a), _b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板全特化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line"> <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板偏特化，只限定一个参数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>,T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(<span class="type">int</span> a, T b) :_a(a), _b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板偏特化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line"> T _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">1.01</span>, <span class="number">1.01</span>)</span></span>;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">int</span>, <span class="type">char</span>*&gt; <span class="title">t3</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>)</span></span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板成员函数的全特化（不能偏特化）</span></span><br><span class="line"><span class="comment">//实际上也是对类模板的特化，因为作为类的成员函数，当类的类型确定下来了自然就知道要调用哪个类型的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE;i++)&#123;</span><br><span class="line">                array[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">()</span></span>;<span class="comment">//特化</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T array[MAXSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//泛型</span></span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">Sort</span>()&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;fanxing&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span> p,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;MAXSIZE;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[p]&lt;array[j])</span><br><span class="line">                p=j;</span><br><span class="line">        &#125;</span><br><span class="line">        T t;</span><br><span class="line">        t=array[i];</span><br><span class="line">        array[i]=array[p];</span><br><span class="line">        array[p]=t;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//特化</span></span><br><span class="line"><span class="type">void</span> Array&lt;<span class="type">char</span> *&gt;::<span class="built_in">Sort</span>()&#123; <span class="comment">//注意是对Array类模板特化</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;tehua&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> p,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;MAXSIZE;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(array[p],array[j])&lt;<span class="number">0</span>)</span><br><span class="line">                p=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* t=array[i];</span><br><span class="line">        array[i]=array[p];</span><br><span class="line">        array[p]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强调：</p>
<ul>
<li>函数模板只有特化，没有偏特化；</li>
<li>模板、模板的特化和模板的偏特化都存在的情况下，编译器在编译阶段进行匹配，优先匹配特殊的（如能匹配全特化就不会匹配偏特化）；</li>
<li><strong>模板函数不能是虚函数</strong>；因为每个包含虚函数的类具有一个virtual table,包含该类的所有虚函数的地址，因此vtable的大小是确定的。模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定（函数模板可能用到，可能用不到）。所以，成员函数模板不能为虚函数。<ul>
<li>编译器在编译一个类的时候，需要确定这个类的虚函数表的大小。一般来说，如果一个类有N个虚函数，它的虚函数表的大小就是N，如果按字节算的话那么就是4*N。 如果允许一个成员模板函数为虚函数的话，因为我们可以为该成员模板函数实例化出很多不同的版本，也就是可以实例化出很多不同版本的虚函数</li>
<li>那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的，所以才规定成员模板函数不能够为虚函数。</li>
</ul>
</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>提供<strong>异常</strong>的<strong>基本目的</strong>就是为了处理上面的问题。<strong>基本思想</strong>是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。也就是《C++ primer》中说的：将<strong>问题检测</strong>和<strong>问题处理</strong>相分离。</p>
<p>优点有以下几点：</p>
<ul>
<li>异常处理可以在调用<strong>跳级</strong>。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的<strong>栈展开</strong>机制，只需要在一处进行处理就可以了，不需要每级函数都处理。<ul>
<li>栈展开：如果在一个函数内部抛出异常（throw），而此异常并未在该函数内部被捕捉（catch），就将导致该函数的运行在抛出异常处结束，所有已经分配在<strong>栈</strong>上的局部变量都要被释放。然后会接着向下线性的搜索函数调用栈，来寻找异常处理者，并且带有异常处理的函数（也就是有catch捕捉到）之前的所有实体（每级函数），都会从函数调用栈中删除。</li>
<li>栈展开危害：在栈展开的过程中，如果被释放的局部变量中有指针，而该指针在此前已经用new运算申请了空间，就有可能导致内存泄露。因为栈展开的时候并不会自动对指针变量执行delete（或delete[]）操作。</li>
</ul>
</li>
<li>整型返回值没有任何语义信息。而异常却<strong>包含语义信息</strong>，有时你从类名就能够体现出来。</li>
<li>整型返回值缺乏相关的<strong>上下文信息</strong>。异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。</li>
</ul>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会<strong>抛出一个异常</strong>。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序<strong>捕获异常</strong>。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 try 块在不同的情境下会抛出不同的异常，</span></span><br><span class="line"><span class="comment">//这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。</p>
<p>析构的顺序与构造的顺序相反，这一过程称为栈的<strong>解旋</strong>(unwinding).</p>
<ul>
<li><p>在try中抛出的异常被相应的catch捕获</p>
</li>
<li><p>在catch中抛出的异常可以被上层函数调用的catch捕获</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;yichang&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;in fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// throw to main</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fun</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;in main, get it&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码会捕获一个类型为 ExceptionName 的异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>catch的匹配过程是找<strong>最先匹配</strong>的，不是最佳匹配。</li>
<li>catch的匹配过程中，对类型的要求比较<strong>严格</strong>。<strong>不</strong>允许<strong>标准算术转换</strong>和<strong>类类型的转换</strong>。（类类型的转化包括<strong>两</strong>种：通过构造函数的<strong>隐式类型转化</strong>和通过<strong>转化操作符</strong>的类型转化）。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;<span class="comment">//被throw的是const char* 类型的</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：<code>Division by zero condition!</code></p>
<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在<code>&lt;exception&gt;</code>中，我们可以在程序中使用这些标准的异常。</p>
<table>
<thead>
<tr>
<th><strong>std::exception</strong></th>
<th>该异常是所有标准 C++ 异常的父类。</th>
</tr>
</thead>
<tbody><tr>
<td>std::bad_alloc</td>
<td>该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_cast</td>
<td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td>std::bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td><strong>std::logic_error</strong></td>
<td>理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::domain_error</td>
<td>当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td>std::invalid_argument</td>
<td>当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td>std::length_error</td>
<td>当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td>std::out_of_range</td>
<td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td><strong>std::runtime_error</strong></td>
<td>理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::overflow_error</td>
<td>当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td>std::range_error</td>
<td>当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td>std::underflow_error</td>
<td>当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>这部分看看就行，比较冷门且不常用。</p>
<ul>
<li><strong>建议</strong>自己的异常类要<strong>继承标准异常类</strong>。因为C++中可以抛出任何类型的异常，所以我们的异常类<strong>可以不继承</strong>自标准异常，但是这样可能会导致程序混乱，尤其是当我们多人协同开发时。 </li>
<li>当继承标准异常类时，应该重载父类的<strong>what函数</strong>和<strong>虚析构函数</strong>。 </li>
<li>因为栈展开的过程中，要<strong>复制</strong>异常类型，那么要根据你在类中添加的成员考虑是否提供自己的<strong>复制构造函数</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure>

<h2 id="函数声明后面加throw"><a href="#函数声明后面加throw" class="headerlink" title="函数声明后面加throw()"></a>函数声明后面加throw()</h2><p>C++函数后面加关键字throw(<em>something</em>)限制，是对这个函数的<strong>异常安全作出限制</strong>；这是一种异常规范，只会出现在声明函数时，表示这个函数可能抛出任何类型的异常。</p>
<ul>
<li>void fun() throw();      &#x2F;&#x2F;表示fun函数不允许抛出任何异常，即fun函数是异常安全的，一旦异常，将是意想不到的严重错误。</li>
<li>void fun() throw(…);    &#x2F;&#x2F;表示fun函数可以抛出任何形式的异常。</li>
<li>void fun() throw(exceptionType);    &#x2F;&#x2F; 表示fun函数只能抛出exceptionType类型的异常。</li>
</ul>
<p>例如：</p>
<ul>
<li>void GetTag() throw(int);                     &#x2F;&#x2F; 表示只抛出int类型异常</li>
<li>void GetTag() throw(int，char);         &#x2F;&#x2F; 表示抛出int，char类型异常</li>
<li>void GetTag() throw();                         &#x2F;&#x2F; 表示不会抛出任何类型异常，一旦异常，将是意想不到的严重错误</li>
<li>void GetTag() throw(…);                      &#x2F;&#x2F; 表示抛出任何类型异常</li>
</ul>
<p>void GetTag() throw(int); 表示只抛出int类型异常，并不表示一定会抛出异常，但是一旦抛出异常只会抛出int类型，如果抛出非int类型异常，调用unexsetpion()函数，退出程序。</p>
<h2 id="来自C-之父Bjarne-Stroustrup的建议"><a href="#来自C-之父Bjarne-Stroustrup的建议" class="headerlink" title="来自C++之父Bjarne Stroustrup的建议"></a>来自C++之父Bjarne Stroustrup的建议</h2><ul>
<li>当局部的控制能够处理时，不要使用异常； </li>
<li>使用“资源分配即初始化”技术去管理资源； </li>
<li>尽量少用try-catch语句块，而是使用“资源分配即初始化”技术。 </li>
<li>如果构造函数内发生错误，通过抛出异常来指明。</li>
<li>避免在析构函数中抛出异常。 </li>
<li>保持普通程序代码和异常处理代码分开。 </li>
<li>小心通过new分配的内存在发生异常时，可能造成内存泄露。 </li>
<li>如果一个函数可能抛出某种异常，那么我们调用它时，就要假定它一定会抛出该异常，即要进行处理。 </li>
<li>要记住，不是所有的异常都继承自exception类。 </li>
<li>编写的供别人调用的程序库，不应该结束程序，而应该通过抛出异常，让调用者决定如何处理（因为调用者必须要处理抛出的异常）。</li>
</ul>
<h1 id="文件与流"><a href="#文件与流" class="headerlink" title="文件与流"></a>文件与流</h1><h2 id="文件流的分类"><a href="#文件流的分类" class="headerlink" title="文件流的分类"></a>文件流的分类</h2><p>文件流是以外存文件未输入输出对象的数据流。输出文件流是从内存流向外存文件的数据，输入文件流是从外存文件流向内存的数据。每一个文件流都有一个内存缓冲区与之对应。</p>
<p>C++有三个用于文件操作的文件类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream <span class="comment">//文件的写操作（输出），主要是从内存写入存储设备（如磁盘），继承了istream类</span></span><br><span class="line">ifstream <span class="comment">//文件的读操作（输入），主要是从存储设备中读取数据到内存，继承了ostream类</span></span><br><span class="line">    </span><br><span class="line">fstream <span class="comment">//文件的读写操作，对打开的文件可进行读写操作，继承了iostream类，</span></span><br><span class="line">    	<span class="comment">//这意味着它可以创建文件，向文件写入信息，从文件读取信息。</span></span><br></pre></td></tr></table></figure>

<p>想要使用文件流对文件进行操作，修必须要先定义它。<br>定义时须包含头文件<code>#include&lt; fstream &gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;	<span class="comment">// 声明命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1》</span></span><br><span class="line">	<span class="comment">// 声明输出文件流，用于创建文件并向文件写入信息。</span></span><br><span class="line">	ofstream outFile;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2》</span></span><br><span class="line">	<span class="comment">// 声明输入文件流，用于从文件读取信息。</span></span><br><span class="line">	ifstream inFIle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3》</span></span><br><span class="line">	<span class="comment">// 声明输入和输出文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</span></span><br><span class="line">	fstream stream;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p><strong>打开文件操作主要是把我们的文件流类对象和一个文件相关联起来，这样这个被打开的文件可以用类对象表示，之后我们对文件流类对象所做的输入和输出操作其实就是对这个文件所做的操作。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,ios_base::openmode mode)</span></span>;</span><br><span class="line"><span class="comment">//参数的含义：</span></span><br><span class="line">   filename：　　要打开的文件名</span><br><span class="line">　　mode：　　　　要打开文件的方式</span><br></pre></td></tr></table></figure>

<p>其中<code>mode</code>定义在所有<code>IO</code>的基类中：即<code>ios</code>类，它包括如下几种方式：</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>读方式打开文件（ifstream对象默认方式）</td>
</tr>
<tr>
<td>ios::out</td>
<td>写方式打开文件 （ofstream对象默认）</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果此文件已经存在, 就会打开文件之前把文件长度设置为0</td>
</tr>
<tr>
<td>ios::app</td>
<td>尾部最加方式(在尾部写入)</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后, 定位到文件尾</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式(默认是文本方式)</td>
</tr>
<tr>
<td>ios::nocreate</td>
<td>不建立文件，所以文件不存在时打开失败</td>
</tr>
<tr>
<td>ios::noreplace</td>
<td>不覆盖文件，所以打开文件时如果文件存在失败</td>
</tr>
</tbody></table>
<p>mode参数可以组合起来使用，但是两个参数之间必须要用操作符|隔开，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;  <span class="comment">//声明一个ofstream对象out</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app);  <span class="comment">//往text.txt文件中输入内容,输入方式在文件的末尾追加内容，且不清空原有的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个声明方式是调用了ofstream有参构造函数，该构造函数会自动调用open函数。</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app)</span>；</span></span><br></pre></td></tr></table></figure>

<h2 id="判断文件是否打开成功"><a href="#判断文件是否打开成功" class="headerlink" title="判断文件是否打开成功"></a>判断文件是否打开成功</h2><p>使用is_open()函数进行文件的判断<br>当成功打开文件返回真（true），失败返回假（false）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fstream stream;</span><br><span class="line"></span><br><span class="line">stream.<span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 判断文件是否打开成功</span></span><br><span class="line"><span class="keyword">if</span> (!stream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当我们完成对文件的操作后，需要调用成员函数<code>close</code>来关闭我们的文件流，<code>close</code>函数的作用其实就是清空该类对象在缓存中的内容并且关闭该对象和文件的关联关系，然后该对象可以和其他文件进行关联。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofstream file;  <span class="comment">//声明一个ofstream对象file</span></span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app);  </span><br><span class="line">file.<span class="built_in">close</span>();  <span class="comment">//关闭&quot;text.txt&quot;文件</span></span><br></pre></td></tr></table></figure>

<p>为了防止一个类对象被销毁后，还和某个文件保留关联关系，所以文件流类的析构函数都会自动调用<code>close</code>函数。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h3><p>文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">插入器(&lt;&lt;) 向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write</span><br><span class="line">Stdout”&lt;&lt;‘n’;就表示把字符串&quot;Write Stdout&quot;和换行字符(‘n’)输出到标准输出流。</span><br><span class="line"></span><br><span class="line">析取器(&gt;&gt;)</span><br><span class="line">从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据</span><br></pre></td></tr></table></figure>

<p>比如读取写入txt文件，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;d:\\test.txt&quot;</span>, ios::out)</span></span>;<span class="comment">//定义了一个对象f，只写，&quot;d:\\test.txt&quot;文件不存在则创建，存在则清空原内容</span></span><br><span class="line">    f &lt;&lt; <span class="number">1234</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">3.14</span> &lt;&lt; <span class="string">&#x27;A&#x27;</span> &lt;&lt; <span class="string">&quot;How are you&quot;</span>; <span class="comment">//写入数据，这是c++一般的写入形式</span></span><br><span class="line">    f.<span class="built_in">close</span>();<span class="comment">//关闭文件以使其重新变为可访问，函数一旦调用，原先的流对象就可以被用来打开其它的文件</span></span><br><span class="line">    f.<span class="built_in">open</span>(<span class="string">&quot;d:\\test.txt&quot;</span>,ios::in);<span class="comment">//打开文件，只读</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line">    f &gt;&gt; i &gt;&gt; d &gt;&gt; c;   <span class="comment">//读取数据，从左向右读取相应类型的数据，比如int就读1234，因为后面空格截断了(输入中无法包含空格)</span></span><br><span class="line">    					<span class="comment">//char就读一个&#x27;A&#x27;。每次读完游标都指向读完的地方，因此能继续读。</span></span><br><span class="line">    f.<span class="built_in">getline</span>(s, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;    <span class="comment">//显示各数据</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;   <span class="comment">//endl是一种格式，表示输出一个换行符，并刷新此流，ends只输出一个空字符</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    f.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="头文件-lt-iomanip-gt"><a href="#头文件-lt-iomanip-gt" class="headerlink" title="头文件&lt;iomanip&gt;"></a>头文件&lt;iomanip&gt;</h3><table>
<thead>
<tr>
<th>控  制  符</th>
<th>作       用</th>
</tr>
</thead>
<tbody><tr>
<td>dec</td>
<td>设置整数为十进制</td>
</tr>
<tr>
<td>hex</td>
<td>设置整数为十六进制</td>
</tr>
<tr>
<td>oct</td>
<td>设置整数为八进制</td>
</tr>
<tr>
<td>setbase(n)</td>
<td>设置整数为n进制(n&#x3D;8,10,16)</td>
</tr>
<tr>
<td>setfill(n)</td>
<td>设置字符填充，c可以是字符常或字符变量</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>设置浮点数的有效数字为n位</td>
</tr>
<tr>
<td>setw(n)</td>
<td>设置字段宽度为n位</td>
</tr>
<tr>
<td>setiosflags(ios::fixed)</td>
<td>设置浮点数以固定的小数位数显示</td>
</tr>
<tr>
<td>setiosflags(ios::scientific)</td>
<td>设置浮点数以科学计数法表示</td>
</tr>
<tr>
<td>setiosflags(ios::left)</td>
<td>输出左对齐</td>
</tr>
<tr>
<td>setiosflags(ios::right)</td>
<td>输出右对齐</td>
</tr>
<tr>
<td>setiosflags(ios::skipws)</td>
<td>忽略前导空格</td>
</tr>
<tr>
<td>setiosflags(ios::uppercase)</td>
<td>在以科学计数法输出E与十六进制输出X以大写输出，否则小写。</td>
</tr>
<tr>
<td>setiosflags(ios::showpos)</td>
<td>输出正数时显示”+”号</td>
</tr>
<tr>
<td>setiosflags(ios::showpoint)</td>
<td>强制显示小数点</td>
</tr>
<tr>
<td>resetiosflags()</td>
<td>终止已经设置的输出格式状态，在括号中应指定内容</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对一个数操作时，先对输出流（ostream）进行格式化，最后再输出目标。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>]=<span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line">    <span class="type">double</span> digit=<span class="number">-36.96656</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">30</span>)&lt;&lt;left&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;digit&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;<span class="number">15</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//setbase(int x)设置进制后，后面所有操作都是按照这个进制来计算！</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setbase</span>(<span class="number">10</span>)&lt;&lt;<span class="number">15</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//四舍五入,并保留2位有效数组</span></span><br><span class="line">    <span class="type">float</span> x=<span class="number">6.6937</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">float</span>(<span class="built_in">int</span>(x*<span class="number">1000</span>+<span class="number">0.5</span>)/<span class="number">1000.0</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">this is a string**************</span></span><br><span class="line"><span class="comment">-36.97</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">6.694</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前缀0表示八进制 前缀0x表示十六进制 不带前缀表示十进制</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">22.0</span>/<span class="number">7.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setbase(n) 设置整数为n进制(n=8,10,16)</span></span><br><span class="line">    <span class="comment">// oct 八进制 dec 十进制 hex 十六进制</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::showbase) 显示进制的前缀</span></span><br><span class="line">    <span class="comment">// 数值默认十进制显示输出</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;oct: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">8</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::oct &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dec: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">10</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::dec &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hex: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::hex &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setprecision(n) 设置浮点数的有效数字为n位</span></span><br><span class="line">    <span class="comment">// 有效位数默认是6位，即setprecision(6)，即小数点前面和小数点后面加起来的位数为6个有效数字（注意会四舍五入）</span></span><br><span class="line">    std::cout &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setfill(n) 设置字符填充，c可以是字符常或字符变量</span></span><br><span class="line">    <span class="comment">// setw(n) 设置字段宽度为n位, 若是实际宽度大于被设置的，则setw函数此时失效, 只针对其后的第一个输出项有效</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::left) 输出左对齐</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::right) 输出右对齐 默认右对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; std::right &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; std::left &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示</span></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setiosflags(ios::scientific)  设置浮点数以科学计数法表示 科学计数法输出E与十六进制输出默认是以小写的，要换成大写需添加uppercase</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resetiosflags() 终止已经设置的输出格式状态，在括号中应指定内容</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::scientific) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; std::<span class="built_in">resetiosflags</span>(std::ios::scientific) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">oct: 0173 0173</span></span><br><span class="line"><span class="comment">dec: 123 123</span></span><br><span class="line"><span class="comment">hex: 0x7b 0x7b</span></span><br><span class="line"><span class="comment">3.14286</span></span><br><span class="line"><span class="comment">3.14285714286</span></span><br><span class="line"><span class="comment">*******3.14285714286</span></span><br><span class="line"><span class="comment">*******3.14285714286</span></span><br><span class="line"><span class="comment">3.14285714286*******</span></span><br><span class="line"><span class="comment">3.142857142857</span></span><br><span class="line"><span class="comment">3.142857142857e+00</span></span><br><span class="line"><span class="comment">3.142857142857E+00</span></span><br><span class="line"><span class="comment">3.142857142857E+00   3.14285714286</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h3><p>二进制文件的操作需要在打开文件的时候指定打开方式为<code>ios::binary</code>，并且还可以指定为既能输入又能输出的文件，我们通过成员函数 <code>read</code>和 <code>write</code>来读写二进制文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span> <span class="params">( <span class="type">char</span> * buffer, streamsize size)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span> <span class="params">(<span class="type">char</span> * buffer, streamsize size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;d:\\test.txt&quot;</span>, ios::out|ios::binary)</span></span>;</span><br><span class="line">f.<span class="built_in">read</span>(buffer,size);<span class="comment">//读完指针会到下一个位置，因此下一个read读出的数据是不同的</span></span><br><span class="line">f.<span class="built_in">write</span>(buffer,size);</span><br></pre></td></tr></table></figure>

<h3 id="eof"><a href="#eof" class="headerlink" title="eof()"></a>eof()</h3><p>infile.eof()判断读入文件是否达到文件尾部，若是则返回true。while(!infile.eof())就常常用来判断是否达到文件尾部，注意要在while循环体内不断地read，向下读，否则会死循环，因为eof()本身并不读取数据。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">char</span> *name, <span class="type">char</span> *id, <span class="type">int</span> math, <span class="type">int</span> chinese, <span class="type">int</span> english)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(Name,name);</span><br><span class="line">		<span class="built_in">strcpy</span>(Id,id);</span><br><span class="line">		Math = math;</span><br><span class="line">		Chinese = chinese;</span><br><span class="line">		English = english;</span><br><span class="line">		Sum = Math+Chinese+English;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;Name&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Id&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Math&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Chinese&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;English&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> Id[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> Math;</span><br><span class="line">	<span class="type">int</span> Chinese;</span><br><span class="line">	<span class="type">int</span> English;</span><br><span class="line">	<span class="type">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>],Id[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> Math, Chinese, English;</span><br><span class="line">	</span><br><span class="line">	fstream ioFile;</span><br><span class="line">	ioFile.<span class="built_in">open</span>(<span class="string">&quot;./ex10_info.dat&quot;</span>,ios::out|ios::app);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;-----------------building students&#x27; infomation-----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the name: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Name;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the id: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Id;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the math score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Math;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the chinese score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Chinese;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the english score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;English;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//输入好了之后构建一个对象，然后要把对象的地址送给文件的内存缓冲区指针，使得文件可以从地址里读取per的内容（根据sizeof指定，因为地址只是给了初始的位置，必须知道大小）写到文件里。</span></span><br><span class="line">        <span class="comment">//&amp;per 不是 char * 类型，因此要进行强制类型转换（都是8个字节），使得能以字符形式读取内容</span></span><br><span class="line">        <span class="comment">//sizeof返回值类型为size_t，write函数会获得具体的大小</span></span><br><span class="line">		<span class="function">person <span class="title">per</span><span class="params">(Name,Id,Math,Chinese,English)</span></span>;</span><br><span class="line">		ioFile.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;per,<span class="built_in">sizeof</span>(per));<span class="comment">//不是写入地址，而是写入地址处的内容，每个per的地址都是一样的（复用了），但是内容不一样</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;continue to enter infomation?(y/n)&quot;</span>;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">	&#125;<span class="keyword">while</span>(ch==<span class="string">&#x27;y&#x27;</span>||ch==<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	ioFile.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	ioFile.<span class="built_in">open</span>(<span class="string">&quot;./ex10_info.dat&quot;</span>,ios::in);</span><br><span class="line">	person p;</span><br><span class="line">	ioFile.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//再从文件中读取对象的内容，给出p的地址把内容送入到地址对应的缓冲区中，这里的每个p的地址是一样的（复用了）</span></span><br><span class="line">		<span class="comment">//&amp;p 不是 char * 类型，因此要进行强制类型转换，使得能以字符形式读取内容</span></span><br><span class="line">	vector&lt;person&gt; v;</span><br><span class="line">	vector&lt;person&gt;::iterator vt;</span><br><span class="line">	<span class="keyword">while</span>(!ioFile.<span class="built_in">eof</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(p);<span class="comment">//然后把p放入vector中，</span></span><br><span class="line">        	<span class="comment">//注意vector实际上是另开了一块空间，把p的内容存入，所以这里就导致每个内容（最后存在的对象）对应的地址都不一样了，因此前面的复用不会引发覆盖</span></span><br><span class="line">		ioFile.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	ioFile.<span class="built_in">close</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;the infomation is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(vt=v.<span class="built_in">begin</span>();vt!=v.<span class="built_in">end</span>();vt++)</span><br><span class="line">		(*vt).<span class="built_in">display</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位到 fileObject 的末尾</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( <span class="number">0</span>, ios::end );</span><br></pre></td></tr></table></figure>

<h2 id="getline、get、gets和put函数"><a href="#getline、get、gets和put函数" class="headerlink" title="getline、get、gets和put函数"></a>getline、get、gets和put函数</h2><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>由于流提取运算符(&gt;&gt;)会以空白符分割，所以我们的输入中无法包含空格。而使用getline函数可以指定分隔符，这样就可以读入包含空格的文本了（如：New York）。getline函数定义在头文件<string>中，f.getline()定义在<iostream>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(ifstream&amp; input, string s, <span class="type">char</span> delimitChar)<span class="comment">//getline接受的字符串长度不受限制</span></span><br><span class="line"><span class="comment">//input是输入的对象，可以是一个文件，也可以是标准输入（cin）</span></span><br><span class="line"><span class="comment">//s是接受字符串，所读取的信息存储在s中</span></span><br><span class="line"><span class="comment">//delimitChar是分隔符，默认是&#x27;\n&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">getline</span>(cin, city, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">//从标准输入（键盘）读入到字符串city中，并使用换行作为分隔符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为流的成员函数：getline(&lt;字符数组chs&gt;，&lt;读取字符的个数n&gt;，&lt;终止符&gt;)</span></span><br><span class="line">f.<span class="built_in">getline</span>(str,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>当函数读到分隔符或文件末尾时，就会停止。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get函数会从输入对象读取<strong>一个字符</strong>，而put函数会向输出对象写入一个字符。</p>
<p>get函数有三个版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//无参数的，返回从输入对象读取的一个字符。</span></span></span><br><span class="line"><span class="function">ifstream* <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; ch)</span> <span class="comment">//有一个参数的，将字符存在字符ch中，并返回输入对象的引用</span></span></span><br><span class="line"><span class="function">ifstream* <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; ch, <span class="type">int</span> n, <span class="type">char</span> delimitChar=<span class="string">&#x27;\n&#x27;</span>)</span> <span class="comment">//有三个参数的，读取n-1个字符，</span></span></span><br><span class="line"><span class="function">    <span class="comment">//赋给指定的字符数组(或字符指针指向的数组)，如果在读取n-1个字符之前遇到指定的终止字符，则提前结束读取</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//调用，这里使用cin标准输入流，也可以是其他文件输入流</span></span></span><br><span class="line"><span class="function">cin.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cin.<span class="built_in">get</span>(ch,<span class="number">10</span>);<span class="comment">//相当于cin.get(ch,10,&#x27;\n&#x27;);</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch,<span class="number">10</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用getline函数从输入流读字符时，遇到终止标志字符时结束，指针移到该终止标志字符之后，<strong>下一个getline函数将从该终止标志的下一个字符开始接着读入，</strong>如本程序运行结果所示那样。如果用cin.get()函数从输入流读字符时，遇终止标志字符时停止读取，指针不向后移动，仍然停留在原位置。下一次读取时仍从该终止标志字符开始。这是getline函数和get函数不同之处。</p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><p>引入cstdio头文件（#include <cstdio>），才能进行调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br></pre></td></tr></table></figure>

<p>从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<p>如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> <span class="comment">//这个头文件包含gets()函数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本函数可以无限读取，不会判断上限，所以程序员应该确保 buffer的空间足够大，以便在执行读操作时不发生溢出。如果溢出，多出来的字符将被写入到 堆栈中，这就 <strong>覆盖了堆栈原先的内容</strong>，破坏一个或多个不相关变量的值。这个事实导致gets函数只适用于玩具程序,为了避免这种情况，我们可以用fgets(stdin) </p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p> fstream 和 ofstream 类对象都可以调用 put() 方法。</p>
<p>当 fstream 和 ofstream 文件流对象调用 put() 方法时，该方法的功能就变成了向指定文件中写入单个字符。put() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span> <span class="params">(<span class="type">char</span> c)</span></span>;<span class="comment">//c 用于指定要写入文件的字符。</span></span><br><span class="line"><span class="comment">//该方法会返回一个调用该方法的对象的引用形式。例如，obj.put() 方法会返回 obj 这个对象的引用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">//以二进制形式打开文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">        <span class="comment">//将字符 c 写入 out.txt 文件</span></span><br><span class="line">        outFile.<span class="built_in">put</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cstring库常用函数"><a href="#cstring库常用函数" class="headerlink" title="cstring库常用函数"></a>cstring库常用函数</h1><h2 id="字符数组复制"><a href="#字符数组复制" class="headerlink" title="字符数组复制"></a>字符数组复制</h2><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p><code>strcpy</code>的作用是复制整个字符数组到另一个字符数组，因此也就非常简洁，只有两个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个参数是要复制到的目标数组起始位置，后一个是被复制的源数组起始位置。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Sample string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str2, str1);</span><br><span class="line">    <span class="built_in">strcpy</span> (str3, <span class="string">&quot;copy successful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><p><code>strncpy</code>与<code>strcpy</code>很类似，只是可以指定复制多少个字符。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前两个参数的含义与strcpy相同，第三个参数num就是要复制的字符个数。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line">						<span class="comment">//size_t表示无符号整数，为方便系统移植定义的，32位为unsigned int，64位为unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;To be or not to be&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 整个字符串进行复制: */</span></span><br><span class="line">    <span class="built_in">strncpy</span> ( str2, str1, <span class="built_in">sizeof</span>(str2) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 部分复制(这里是复制5个字符): */</span></span><br><span class="line">    <span class="built_in">strncpy</span> ( str3, str2, <span class="number">5</span> );</span><br><span class="line">    str3[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">/* 部分复制不会自动添加结尾，添加结尾符 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span> (str1);</span><br><span class="line">    <span class="built_in">puts</span> (str2);</span><br><span class="line">    <span class="built_in">puts</span> (str3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符数组连接"><a href="#字符数组连接" class="headerlink" title="字符数组连接"></a>字符数组连接</h2><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><p><code>strcat</code>的功能是把一个字符数组连接到另一个字符数组的后面。它的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是目标数组，后一个是要添加到后面的源数组。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str, <span class="string">&quot;these &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;strings &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;are &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;concatenated.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是：these strings are concatenated.</span></span><br></pre></td></tr></table></figure>

<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h3><p>指定字符数的拼接，原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str1, <span class="string">&quot;To be &quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (str2, <span class="string">&quot;or not to be&quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span> (str1, str2, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符数组比较"><a href="#字符数组比较" class="headerlink" title="字符数组比较"></a>字符数组比较</h2><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较方式是：（字典序）两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>str1&gt;str2：则返回值&gt;0；</li>
<li>str1&lt;str2：则返回值&lt;0；</li>
<li>str1&#x3D;str2：则返回值&#x3D;0；</li>
</ul>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2, <span class="type">size_t</span> num )</span></span></span><br></pre></td></tr></table></figure>

<p>比较ptr1、ptr2指向的字符串，直到遇到不相同的字符或者空字符结束<strong>或者比较完前面的num bytes结束</strong>。如果都相同则返回0，如果第一个不同byte ptr1的小于ptr2的，返回负数，否则返回正数。</p>
<h2 id="字符数组查找"><a href="#字符数组查找" class="headerlink" title="字符数组查找"></a>字符数组查找</h2><h3 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h3><p><code>strchr</code>函数可以在一个字符数组里找某个字符第一次出现的位置，如果未找到该字符则返回 NULL。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是原字符数组，后一个是要查找的字符。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">strchr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str, <span class="type">int</span> character )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> ch = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">   <span class="type">char</span> *ret;</span><br><span class="line"></span><br><span class="line">   ret = <span class="built_in">strchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;|%c| 之后的字符串是 - |%s|\n&quot;</span>, ch, ret);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：|.| 之后的字符串是 - |.runoob.com|</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将 st 指针指向的字符串在换行的地方加入文本结束字符，else 将多余的换行符消耗掉：</span></span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);  <span class="comment">//查找换行符</span></span><br><span class="line"><span class="keyword">if</span> (find)  <span class="comment">//如果地址不是NULL</span></span><br><span class="line">    *find = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//在此处放置一个空字符</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h3><p><code>strstr</code>函数可以在一个字符数组里查找另一个字符数组第一次出现的位置。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是文本串，后一个是模式串。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;This is a simple string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *pch;</span><br><span class="line">    pch = <span class="built_in">strstr</span>(str, <span class="string">&quot;simple&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span> (pch, <span class="string">&quot;sample&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向同一个字符串，但pch的位置在simple的s处，然后替换</span></span><br><span class="line"><span class="comment">//输出结果：This is a sample string</span></span><br></pre></td></tr></table></figure>

<h2 id="字符数组长度"><a href="#字符数组长度" class="headerlink" title="字符数组长度"></a>字符数组长度</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p><code>strlen</code>用于求一个字符数组的长度，注意它是从给定的起始位置开始不断往后尝试，直到遇到’\0’为止的，因此<strong>它的时间复杂度并不是常数级别的，而是取决于字符数组的长度，在字符数组没有变动的情况下请务必不要重复调用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szInput[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Enter a sentence: &quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span> (szInput);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;The sentence entered is %u characters long.\n&quot;</span>, (<span class="type">unsigned</span>)<span class="built_in">strlen</span>(szInput));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Enter sentence: just testing</span></span><br><span class="line"><span class="comment">//The sentence entered is 12 characters long.</span></span><br></pre></td></tr></table></figure>

<h2 id="内存复制"><a href="#内存复制" class="headerlink" title="内存复制"></a>内存复制</h2><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><p>从source指向的地址拷贝num <strong>bytes</strong>到destination指向的地址。不检查source中的空字符，总是拷贝num bytes，可能产生溢出，当destination和source的大小小于num时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* destination,<span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str1</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li><strong>str2</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li><strong>n</strong> – 要被复制的字节数。</li>
<li>该函数返回一个指向目标存储区 str1 的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串复制到数组 dest 中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：dest = http://www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 s 中第 11 个字符开始的 6个连续字符复制到 d 中:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *s=<span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">  <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(d, s+<span class="number">11</span>, <span class="number">6</span>);<span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">  <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">  d[<span class="number">6</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：runoob</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//覆盖原有部分数据:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">  <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//使用 memcpy 前: abcdefg</span></span><br><span class="line"><span class="comment">//使用 memcpy 后: ***defg</span></span><br></pre></td></tr></table></figure>

<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h3><p>从source指向的地址拷贝num bytes到destination指向的地址。常用于同一字符串的改变。不检查source中的空字符，总是拷贝num bytes，可能产生溢出，当destination和source的大小小于num时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* destination,<span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span></span><br></pre></td></tr></table></figure>

<p>在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够<strong>保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中</strong>，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如一个字符串123abc456，拷贝123abc到abc456的位置，当顺序覆盖时，abc先被覆盖成了123即123123456，</span><br><span class="line">接下来原本456是要被abc覆盖的，但是abc变成了123，就产生了问题。</span><br><span class="line"></span><br><span class="line">memcpy函数会出现上面的问题，因为没有中间变量。</span><br><span class="line">而memmove不会出现问题，使用了一个中间变量先保存好原来的字符串123abc456，这样就不会被覆盖掉正确的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> dest[] = <span class="string">&quot;oldstring&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> src[]  = <span class="string">&quot;newstring&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Before memmove dest = %s, src = %s\n&quot;</span>, dest, src);</span><br><span class="line">   <span class="built_in">memmove</span>(dest, src, <span class="number">9</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;After memmove dest = %s, src = %s\n&quot;</span>, dest, src);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before memmove dest = oldstring, src = newstring</span></span><br><span class="line"><span class="comment">//After memmove dest = newstring, src = newstring</span></span><br></pre></td></tr></table></figure>

<h2 id="内存比较"><a href="#内存比较" class="headerlink" title="内存比较"></a>内存比较</h2><h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span> <span class="params">( <span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2, <span class="type">size_t</span> num )</span></span></span><br></pre></td></tr></table></figure>

<p>比较ptr1、ptr2指向的内存块的前面num bytes，如果都相同则返回0，如果第一个不同byte ptr1的小于ptr2的，返回负数，否则返回正数。如果前面都相同，<strong>即使中间遇到空字符，也会继续比较下去，直到比较完所有的num bytes</strong>。</p>
<h2 id="内存检索"><a href="#内存检索" class="headerlink" title="内存检索"></a>内存检索</h2><h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memchr</span> <span class="params">( <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ptr</strong> – 指向要执行搜索的内存块。</li>
<li><strong>value</strong> – 以 int 形式传递的值，但是函数在每次字节搜索时是使用该值的无符号字符形式。</li>
<li><strong>num</strong> – 要被分析的字节数。</li>
</ul>
<p>在ptr指向的内存中的前num bytes中搜索值value，返回第一个value的指针，如果没有找到返回空指针。</p>
<h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置ptr指向的内存的前面num bytes的值为value</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memset</span> <span class="params">( <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">  <span class="type">char</span> str[] = <span class="string">&quot;almost every programmer should know memset!&quot;</span>;</span><br><span class="line">  <span class="built_in">memset</span> (str,<span class="string">&#x27;-&#x27;</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">puts</span> (str);</span><br><span class="line"><span class="comment">//输出：------ every programmer should know memset!</span></span><br></pre></td></tr></table></figure>

<h1 id="cmath库常用函数"><a href="#cmath库常用函数" class="headerlink" title="cmath库常用函数"></a>cmath库常用函数</h1><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>std::abs: 计算绝对值，包括整数类型；</p>
<p>std::fabs: 计算绝对值，不包括整数类型；</p>
<p>std::sqrt: 计算平方根；</p>
<p>std::cbrt: 计算立方根；</p>
<p>std::hypot: 计算两个数平方的和的平方根；</p>
<p>std::pow：幂运算；</p>
<p>std::exp: e^x;</p>
<p>std::exp2: 2^x;</p>
<p>std::log: ln(x);</p>
<p>std::log2: log2(x);</p>
<p>std::log10: log10(x);</p>
<p>std::fmod: 两数除法操作的余数(rounded towards zero)；</p>
<p>std::remainder: 两数除法操作的余数(rounded to nearest)；</p>
<p>std::remquo: 两数除法操作的余数；</p>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>std::ceil: 不小于给定值的最近整数；</p>
<p>std::floor: 不大于给定值的最近整数；</p>
<p>std::trunc: 不大于给定值的最近整数；</p>
<p>std::modf: 将一个浮点数分解为整数及小数部分；</p>
<p>std::round: 舍入取整；</p>
<p>std::lround: 舍入取整, 返回long int；</p>
<p>std::llround: 舍入取整, 返回long long int；</p>
<h2 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h2><p>std::sin: 正弦；</p>
<p>std::asin: 反正弦；</p>
<p>std::cos: 余弦；</p>
<p>std::acos: 反正弦；</p>
<p>std::tan：正切；</p>
<p>std::atan：反正切；</p>
<p>std::atan2: 反正切；</p>
<p>std::sinh: 双曲正弦；</p>
<p>std::asinh: 双曲反正弦；</p>
<p>std::cosh: 双曲余弦；</p>
<p>std::acosh: 双曲反余弦；</p>
<p>std::tanh: 双曲正切；</p>
<p>std::atanh: 双曲反正切；</p>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>std::nan: Generatequiet NaN;</p>
<p>std::isfinite: 检测是否是有限值；</p>
<p>std::isinf: 检测是否是无穷大值；</p>
<p>std::isnan: 检测是否是非数型；</p>
<p>std::isnormal: 检测是否是normal值，neitherinfinity, NaN, zero or subnormal；</p>
<p>std::signbit: 检测是否是负数；</p>
<p>std::isgreater: 检测第一个数是否大于第二个数；</p>
<p>std::isgreaterequal:检测第一个数是否大于或等于第二个数；</p>
<p>std::isless: 检测第一个数是否小于第二个数；</p>
<p>std::islessequal:检测第一个数是否小于或等于第二个数；</p>
<p>std::islessgreater:检测第一个数是否不等于第二个数；</p>
<p>std::isunordered:检测两个浮点数是否是无序的.</p>
<h2 id="其他不常用"><a href="#其他不常用" class="headerlink" title="其他不常用"></a>其他不常用</h2><p>std::fma(x,y,z):x*y+z;</p>
<p>std::nearbyint: 使用当前的舍入模式取整(fegetround())；</p>
<p>std::rint: 使用当前的舍入模式取整(fegetround())；</p>
<p>std::lrint: 使用当前的舍入模式取整(fegetround()),返回long int；</p>
<p>std::llrint: 使用当前的舍入模式取整(fegetround())，返回long longint；</p>
<p>std::frexp: 将一个浮点数分解为有效数(significand)及以2为底的幂(x &#x3D; significand* 2exp);</p>
<p>std::ldexp: x *2exp;</p>
<p>std::expm1: ex-1;</p>
<p>std::scalbn: x *FLT_RADIXn;</p>
<p>std::scalbln: x* FLT_RADIXn;</p>
<p>std::ilogb: 返回以FLT_RADIX为底，|x|的对数值，返回值为整数；</p>
<p>std::log1p: ln(1+x);</p>
<p>std::logb: 返回以FLT_RADIX为底，|x|的对数值，返回值为浮点数；</p>
<p>std::erf: 误差函数；</p>
<p>std::erfc: 互补(complementary)误差函数；</p>
<p>std::tgamma: 伽玛函数；</p>
<p>std::lgamma: log-伽玛函数；</p>
<p>std::copysign(x,y):返回x的值及y的正负符号组成的浮点数；</p>
<p>std::nextafter(x,y): 返回x之后y方向上的下一个可表示值；</p>
<p>std::nexttoward(x,y): 返回x之后y方向上的下一个可表示值；</p>
<p>std::fdim(x,y): Thefunction returns x-y if x&gt;y, and zero otherwise;</p>
<p>std::fmax: 返回较大的值;</p>
<p>std::fmin: 返回较小的值;</p>
<p>std::fpclassify:为浮点值归类，返回一个类型为int的值；</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmath.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fenv.h&gt;</span> <span class="comment">// fegetround, FE_*</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span> <span class="comment">// FLT_RADIX</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// reference: http://www.cplusplus.com/reference/cmath/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> cmath_ &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_abs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::abs: double/float/long double/T</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs (3.141611111) = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>(<span class="number">3.141611111</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3.14161</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs (-10.6)  = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>(<span class="number">-10.6f</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10.6</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs ((int)-10)  = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>((<span class="type">int</span>)<span class="number">-10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fabs: double/float/long double/T</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;fabs (3.141611111) = &quot;</span> &lt;&lt; std::<span class="built_in">fabs</span>(<span class="number">3.141611111</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3.14161</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;fabs (-10.6)  = &quot;</span> &lt;&lt; std::<span class="built_in">fabs</span>(<span class="number">-10.6f</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10.6</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fma: Returns x*y+z</span></span><br><span class="line">	<span class="type">double</span> x, y, z, result;</span><br><span class="line">	x = <span class="number">10.0</span>, y = <span class="number">20.0</span>, z = <span class="number">30.0</span>;</span><br><span class="line"> </span><br><span class="line">	result = std::<span class="built_in">fma</span>(x, y, z);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;10.0 * 20.0 + 30.0 = %f\n&quot;</span>, result); <span class="comment">// 230.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_triangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::sin: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">30.0</span>;</span><br><span class="line">	result = std::<span class="built_in">sin</span>(param*PI / <span class="number">180</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The sine of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 0.5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::asin: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">0.5</span>;</span><br><span class="line">	result = std::<span class="built_in">asin</span>(param) * <span class="number">180.0</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc sine of %f is %f degrees\n&quot;</span>, param, result); <span class="comment">// 30.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::sinh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">sinh</span>(param);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The hyperbolic sine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 0.75</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::asinh double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">exp</span>(<span class="number">2</span>) - std::<span class="built_in">cosh</span>(<span class="number">2</span>);</span><br><span class="line">	result = std::<span class="built_in">asinh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic sine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 2.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cos double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">60.0</span>;</span><br><span class="line">	result = std::<span class="built_in">cos</span>(param * PI / <span class="number">180.0</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The cosine of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 0.5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;<span class="comment">// std::acos: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">0.5</span>;</span><br><span class="line">	result = std::<span class="built_in">acos</span>(param) * <span class="number">180.0</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc cosine of %f is %f degrees.\n&quot;</span>, param, result); <span class="comment">// 60.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cosh double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">cosh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The hyperbolic cosine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 1.25</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::acosh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">exp</span>(<span class="number">2</span>) - std::<span class="built_in">sinh</span>(<span class="number">2</span>);</span><br><span class="line">	result = std::<span class="built_in">acosh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic cosine of %f is %f radians.\n&quot;</span>, param, result); <span class="comment">// 2.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::tan: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">45.0</span>;</span><br><span class="line">	result = std::<span class="built_in">tan</span>(param * PI / <span class="number">180.0</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The tangent of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 1.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atan: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">1.0</span>;</span><br><span class="line">	result = std::<span class="built_in">atan</span>(param) * <span class="number">180</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc tangent of %f is %f degrees\n&quot;</span>, param, result); <span class="comment">// 45.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atan2: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> x, y, result;</span><br><span class="line">	x = <span class="number">-10.0</span>;</span><br><span class="line">	y = <span class="number">10.0</span>;</span><br><span class="line">	result = std::<span class="built_in">atan2</span>(y, x) * <span class="number">180</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc tangent for (x=%f, y=%f) is %f degrees\n&quot;</span>, x, y, result); <span class="comment">// 135.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::tanh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">tanh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The hyperbolic tangent of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 0.6</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atanh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">tanh</span>(<span class="number">1</span>);</span><br><span class="line">	result = std::<span class="built_in">atanh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic tangent of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_pow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::sqrt(x): Returns the square root of x</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">1024.0</span>;</span><br><span class="line">	result = std::<span class="built_in">sqrt</span>(param);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sqrt(%f) = %f\n&quot;</span>, param, result); <span class="comment">// 32.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cbrt: Compute cubic root</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">27.0</span>;</span><br><span class="line">	result = std::<span class="built_in">cbrt</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;cbrt (%f) = %f\n&quot;</span>, param, result); <span class="comment">// 3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::hypot(x, y): sqrt(x^2+y^2)</span></span><br><span class="line">	<span class="type">double</span> leg_x, leg_y, result;</span><br><span class="line">	leg_x = <span class="number">3</span>;</span><br><span class="line">	leg_y = <span class="number">4</span>;</span><br><span class="line">	result = std::<span class="built_in">hypot</span>(leg_x, leg_y);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%f, %f and %f form a right-angled triangle.\n&quot;</span>, leg_x, leg_y, result); <span class="comment">// 5.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::pow(x, y): x^y</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;7 ^ 3 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">7.0</span>, <span class="number">3.0</span>)); <span class="comment">// 343.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;4.73 ^ 12 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">4.73</span>, <span class="number">12.0</span>)); <span class="comment">// 125410439.217423</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;32.01 ^ 1.54 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">32.01</span>, <span class="number">1.54</span>)); <span class="comment">// 208.036691</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;4 ^ 3 = %f\n&quot;</span>, std::<span class="built_in">pow</span>((<span class="type">int</span>)<span class="number">4</span>, (<span class="type">int</span>)<span class="number">3</span>)); <span class="comment">// 64.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_integer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::ceil(x): returning the smallest integral value that is not less than x</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of 2.3 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">2.3</span>)); <span class="comment">// 3.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of 3.8 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">3.8</span>)); <span class="comment">// 4.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of -2.3 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of -3.8 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">-3.8</span>)); <span class="comment">// -3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::floor returning the largest integral value that is not greater than x</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of 2.3 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">2.3</span>)); <span class="comment">// 2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of 3.8 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">3.8</span>)); <span class="comment">// 3.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of -2.3 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of -3.8 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">-3.8</span>)); <span class="comment">// -3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fmod: Returns the floating-point remainder of numer/denom(rounded towards zero)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fmod of 5.3 / 2 is %f\n&quot;</span>, std::<span class="built_in">fmod</span>(<span class="number">5.3</span>, <span class="number">2</span>)); <span class="comment">// fmod of 5.3 / 2 is 1.3</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fmod of 18.5 / 4.2 is %f\n&quot;</span>, std::<span class="built_in">fmod</span>(<span class="number">18.5</span>, <span class="number">4.2</span>)); <span class="comment">// fmod of 18.5 / 4.2 is 1.7</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::trunc(x): Rounds x toward zero, returning the nearest integral value that is not larger in magnitude than x.</span></span><br><span class="line">  <span class="comment">// std::round(x): Returns the integral value that is nearest to x</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * format = <span class="string">&quot;%.1f \t%.1f \t%.1f \t%.1f \t%.1f\n&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value\tround\tfloor\tceil\ttrunc\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----\t-----\t-----\t----\t-----\n&quot;</span>);				 <span class="comment">// round  floor  ceil  trunc</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">2.3</span>, std::<span class="built_in">round</span>(<span class="number">2.3</span>), std::<span class="built_in">floor</span>(<span class="number">2.3</span>), std::<span class="built_in">ceil</span>(<span class="number">2.3</span>), std::<span class="built_in">trunc</span>(<span class="number">2.3</span>));	 <span class="comment">// 2.0     2.0    3.0   2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">3.8</span>, std::<span class="built_in">round</span>(<span class="number">3.8</span>), std::<span class="built_in">floor</span>(<span class="number">3.8</span>), std::<span class="built_in">ceil</span>(<span class="number">3.8</span>), std::<span class="built_in">trunc</span>(<span class="number">3.8</span>));	 <span class="comment">// 4.0     3.0    4.0   3.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">5.5</span>, std::<span class="built_in">round</span>(<span class="number">5.5</span>), std::<span class="built_in">floor</span>(<span class="number">5.5</span>), std::<span class="built_in">ceil</span>(<span class="number">5.5</span>), std::<span class="built_in">trunc</span>(<span class="number">5.5</span>));	 <span class="comment">// 6.0     5.0    6.0   5.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-2.3</span>, std::<span class="built_in">round</span>(<span class="number">-2.3</span>), std::<span class="built_in">floor</span>(<span class="number">-2.3</span>), std::<span class="built_in">ceil</span>(<span class="number">-2.3</span>), std::<span class="built_in">trunc</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0    -3.0   -2.0  -2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-3.8</span>, std::<span class="built_in">round</span>(<span class="number">-3.8</span>), std::<span class="built_in">floor</span>(<span class="number">-3.8</span>), std::<span class="built_in">ceil</span>(<span class="number">-3.8</span>), std::<span class="built_in">trunc</span>(<span class="number">-3.8</span>)); <span class="comment">// -4.0    -4.0   -3.0  -3.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-5.5</span>, std::<span class="built_in">round</span>(<span class="number">-5.5</span>), std::<span class="built_in">floor</span>(<span class="number">-5.5</span>), std::<span class="built_in">ceil</span>(<span class="number">-5.5</span>), std::<span class="built_in">trunc</span>(<span class="number">-5.5</span>)); <span class="comment">// -6.0    -6.0   -5.0  -5.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::lround: Returns the integer value that is nearest in value to x</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (2.3) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">2.3</span>)); <span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (3.8) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">3.8</span>)); <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (-2.3) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">-2.3</span>)); <span class="comment">// -2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (-3.8) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">-3.8</span>)); <span class="comment">// -4</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::llround(x): Returns the integer value that is nearest in value to x</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (2.3) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">2.3</span>)); <span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (3.8) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">3.8</span>)); <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (-2.3) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">-2.3</span>)); <span class="comment">// -2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (-3.8) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">-3.8</span>)); <span class="comment">// -4</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::nearbyint: Round to nearby integral value</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rounding using &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (<span class="built_in">fegetround</span>()) &#123;</span><br><span class="line">	<span class="keyword">case</span> FE_DOWNWARD: <span class="built_in">printf</span>(<span class="string">&quot;downward&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FE_TONEAREST: <span class="built_in">printf</span>(<span class="string">&quot;to-nearest&quot;</span>); <span class="keyword">break</span>; <span class="comment">// to-nearest</span></span><br><span class="line">	<span class="keyword">case</span> FE_TOWARDZERO: <span class="built_in">printf</span>(<span class="string">&quot;toward-zero&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FE_UPWARD: <span class="built_in">printf</span>(<span class="string">&quot;upward&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; rounding:\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (2.3) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">2.3</span>)); <span class="comment">// 2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (3.8) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">3.8</span>)); <span class="comment">// 4.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (-2.3) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (-3.8) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">-3.8</span>)); <span class="comment">// -4.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::remainder: Returns the floating-point remainder of numer/denom(rounded to nearest)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;remainder of 5.3 / 2 is %f\n&quot;</span>, std::<span class="built_in">remainder</span>(<span class="number">5.3</span>, <span class="number">2</span>)); <span class="comment">// remainder of 5.3 / 2 is -0.7</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;remainder of 18.5 / 4.2 is %f\n&quot;</span>, std::<span class="built_in">remainder</span>(<span class="number">18.5</span>, <span class="number">4.2</span>)); <span class="comment">// remainder of 18.5 / 4.2 is 1.7</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::remquo: Returns the same as remainder, but it additionally stores the quotient</span></span><br><span class="line">  <span class="comment">// internally used to determine its result in the object pointed by quot</span></span><br><span class="line">	<span class="type">double</span> numer = <span class="number">10.3</span>;</span><br><span class="line">	<span class="type">double</span> denom = <span class="number">4.5</span>;</span><br><span class="line">	<span class="type">int</span> quot;</span><br><span class="line">	<span class="type">double</span> result = std::<span class="built_in">remquo</span>(numer, denom, <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>numerator: %f\n<span class="string">&quot;, numer); // 10.3</span></span><br><span class="line"><span class="string">	printf(&quot;</span>denominator: %f\n<span class="string">&quot;, denom); // 4.5</span></span><br><span class="line"><span class="string">	printf(&quot;</span>remainder: %f\n<span class="string">&quot;, result); // 1.3</span></span><br><span class="line"><span class="string">	printf(&quot;</span>quotient: %d\n<span class="string">&quot;, quot); // 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::rint: Round to integral value</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">2.3</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(2.3)); // 2.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">3.8</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(3.8)); // 4.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">-2.3</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(-2.3)); // -2.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">-3.8</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(-3.8)); // -4.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::lrint: Rounds x to an integral value, and returns it as a value of type long int.</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">2.3</span>) = %ld\n<span class="string">&quot;, std::lrint(2.3)); // 2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">3.8</span>) = %ld\n<span class="string">&quot;, std::lrint(3.8)); // 4</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">-2.3</span>) = %ld\n<span class="string">&quot;, std::lrint(-2.3)); // -2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">-3.8</span>) = %ld\n<span class="string">&quot;, std::lrint(-3.8)); // -4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::llrint: Rounds x to an integral value,returns it as a value of type long long int</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">2.3</span>) = %lld\n<span class="string">&quot;, std::llrint(2.3)); // 2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">3.8</span>) = %lld\n<span class="string">&quot;, std::llrint(3.8)); // 4</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">-2.3</span>) = %lld\n<span class="string">&quot;, std::llrint(-2.3)); // -2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">-3.8</span>) = %lld\n<span class="string">&quot;, std::llrint(-3.8)); // -4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_exp()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::exp: Returns the base-e exponential function of x, e^x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::exp(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>The exponential value of %f is %f.\n<span class="string">&quot;, param, result); // 1.0 2.718282</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::frexp(x, int* exp):Breaks the floating point number x into its binary significand</span></span><br><span class="line"><span class="string">  // (a floating point with an absolute value between 0.5(included) and 1.0(excluded)) and an integral exponent for 2</span></span><br><span class="line"><span class="string">  // x = significand * (2 ^ exponent)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 8.0;</span></span><br><span class="line"><span class="string">	result = std::frexp(param, &amp;n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f = %f * <span class="number">2</span>^%d\n<span class="string">&quot;, param, result, n); // 8.0 = 0.5 * 2^4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::ldexp: Returns the result of multiplying x (the significand) by 2 raised to the power of exp (the exponent)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 0.95;</span></span><br><span class="line"><span class="string">	n = 4;</span></span><br><span class="line"><span class="string">	result = std::ldexp(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * <span class="number">2</span>^%d = %f\n<span class="string">&quot;, param, n, result); // 0.95 * 2^4 = 15.2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::exp2: Returns the base-2 exponential function of x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 8.0;</span></span><br><span class="line"><span class="string">	result = std::exp2(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="number">2</span> ^ %f = %f.\n<span class="string">&quot;, param, result); // 2^8 = 256</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::expm1: Compute exponential minus one</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::expm1(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">expm1</span> (%f) = %f.\n<span class="string">&quot;, param, result); // expm1(1.0) = 1.718282</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::scalbn: Scales x by FLT_RADIX raised to the power of n</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 1.50;</span></span><br><span class="line"><span class="string">	n = 4;</span></span><br><span class="line"><span class="string">	result = std::scalbn(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * %d^%d = %f\n<span class="string">&quot;, param, FLT_RADIX, n, result); // 1.5 * 2^4 = 24.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::scalbln: Scales x by FLT_RADIX raised to the power of n</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	long n;</span></span><br><span class="line"><span class="string">	param = 1.50;</span></span><br><span class="line"><span class="string">	n = 4L;</span></span><br><span class="line"><span class="string">	result = std::scalbln(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * %d^%d = %f\n<span class="string">&quot;, param, FLT_RADIX, n, result); // 1.5 * 2^4 = 24.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_log()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::log: Returns the natural logarithm of x</span></span><br><span class="line"><span class="string">  // The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 5.5;</span></span><br><span class="line"><span class="string">	result = std::log(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log</span>(%f) = %f\n<span class="string">&quot;, param, result); // ln(5.5) = 1.704748</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log10: Returns the common (base-10) logarithm of x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1000.0;</span></span><br><span class="line"><span class="string">	result = std::log10(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log10</span>(%f) = %f\n<span class="string">&quot;, param, result); // log10(1000.0) = 3.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::modf: Breaks x into an integral and a fractional part</span></span><br><span class="line"><span class="string">	double param, fractpart, intpart;</span></span><br><span class="line"><span class="string">	param = 3.14159265;</span></span><br><span class="line"><span class="string">	fractpart = std::modf(param, &amp;intpart);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f = %f + %f \n<span class="string">&quot;, param, intpart, fractpart); // 3.14159265 = 3.0 + 0.141593</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::ilogb: Returns the integral part of the logarithm of |x|, using FLT_RADIX as base for the logarithm.</span></span><br><span class="line"><span class="string">	double param;</span></span><br><span class="line"><span class="string">	int result;</span></span><br><span class="line"><span class="string">	param = 10.0;</span></span><br><span class="line"><span class="string">	result = std::ilogb(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">ilogb</span>(%f) = %d\n<span class="string">&quot;, param, result); // ilogb(10.0) = 3</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log1p: Returns the natural logarithm of one plus x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::log1p(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log1p</span> (%f) = %f.\n<span class="string">&quot;, param, result); // log1p(1.0) = 0.693147</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log2: Returns the binary (base-2) logarithm of x.</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1024.0;</span></span><br><span class="line"><span class="string">	result = std::log2(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log2</span> (%f) = %f.\n<span class="string">&quot;, param, result); // log2(1024.0) = 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::logb: Returns the logarithm of |x|, using FLT_RADIX as base for the logarithm</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1024.0;</span></span><br><span class="line"><span class="string">	result = std::logb(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">logb</span> (%f) = %f.\n<span class="string">&quot;, param, result); // logb(1024.0) = 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_error()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::erf: Returns the error function value for x.</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::erf(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">erf</span> (%f) = %f\n<span class="string">&quot;, param, result); // erf(1.0) = 0.842701</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::erfc: Returns the complementary error function value for x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::erfc(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">erfc</span>(%f) = %f\n<span class="string">&quot;, param, result); // erfc(1.0) = 0.157299</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::tgamma: Compute gamma function</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 0.5;</span></span><br><span class="line"><span class="string">	result = std::tgamma(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">tgamma</span>(%f) = %f\n<span class="string">&quot;, param, result); // tgamma(0.5) = 1.772454</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::lgamma: Compute log-gamma function</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 0.5;</span></span><br><span class="line"><span class="string">	result = std::lgamma(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lgamma</span>(%f) = %f\n<span class="string">&quot;, param, result); // lgamma(0.5) = 0.572365</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_1()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::copysign: Returns a value with the magnitude of x and the sign of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> ( <span class="number">10.0</span>,<span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::copysign(10.0, -1.0)); // -10.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> (<span class="number">-10.0</span>,<span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::copysign(-10.0, -1.0)); // -10.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> (<span class="number">-10.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::copysign(-10.0, 1.0)); // 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nan: Returns a quiet NaN (Not-A-Number) value of type double.</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nextafter: Returns the next representable value after x in the direction of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value greater than zero: %e\n<span class="string">&quot;, std::nextafter(0.0, 1.0)); // 4.940656e-324</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value less than zero: %e\n<span class="string">&quot;, std::nextafter(0.0, -1.0)); // -4.940656e-324</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nexttoward: Returns the next representable value after x in the direction of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value greater than zero: %e\n<span class="string">&quot;, std::nexttoward(0.0, 1.0L)); // 4.940656e-324</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value less than zero: %e\n<span class="string">&quot;, std::nexttoward(0.0, -1.0L)); // -4.940656e-324</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_2()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::fdim: The function returns x-y if x&gt;y, and zero otherwise.</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">2.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fdim(2.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">1.0</span>, <span class="number">2.0</span>) = %f\n<span class="string">&quot;, std::fdim(1.0, 2.0)); // 0.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">-2.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fdim(-2.0, -1.0)); // 0.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">-1.0</span>, <span class="number">-2.0</span>) = %f\n<span class="string">&quot;, std::fdim(-1.0, -2.0)); // 1.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::fmax: Returns the larger of its arguments: either x or y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmax(100.0, 1.0)); // 100.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">-100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmax(-100.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">-100.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fmax(-100.0, -1.0)); // -1.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::fmin: Returns the smaller of its arguments: either x or y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmin(100.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">-100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmin(-100.0, 1.0)); // -100.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">-100.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fmin(-100.0, -1.0)); // -100.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_classify()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::fpclassify: Returns a value of type int that matches one of the classification</span></span><br><span class="line"><span class="string">  // macro constants, depending on the value of x</span></span><br><span class="line"><span class="string">	double d = std::sqrt(-1.0); // 1.0 / 0.0;</span></span><br><span class="line"><span class="string">	switch (std::fpclassify(d)) &#123;</span></span><br><span class="line"><span class="string">		case FP_INFINITE:  printf(&quot;</span>infinite<span class="string">&quot;);  break;</span></span><br><span class="line"><span class="string">		case FP_NAN:       printf(&quot;</span>NaN<span class="string">&quot;);       break; // NaN</span></span><br><span class="line"><span class="string">		case FP_ZERO:      printf(&quot;</span>zero<span class="string">&quot;);      break;</span></span><br><span class="line"><span class="string">		case FP_SUBNORMAL: printf(&quot;</span>subnormal<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FP_NORMAL:    printf(&quot;</span>normal<span class="string">&quot;);    break;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	if (std::signbit(d)) printf(&quot;</span> negative\n<span class="string">&quot;); // negative</span></span><br><span class="line"><span class="string">	else printf(&quot;</span> positive <span class="keyword">or</span> <span class="type">unsigned</span>\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isfinite: Returns whether x is a finite value</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isfinite(0.0)); // 1</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isfinite(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isfinite(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isfinite</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isfinite(std::sqrt(-1.0))); // 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isinf: Returns whether x is an infinity value </span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isinf(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isinf(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isinf(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isinf</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isinf(std::sqrt(-1.0))); // 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isnan: Returns whether x is a NaN (Not-A-Number) value.</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isnan(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isnan(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isnan(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnan</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isnan(std::sqrt(-1.0))); // 1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isnormal: Returns whether x is a normal value</span></span><br><span class="line"><span class="string">  // i.e., whether it is neither infinity, NaN, zero or subnormal</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">1.0</span>)    : %d\n<span class="string">&quot;, std::isnormal(1.0)); // 1</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">0.0</span>)    : %d\n<span class="string">&quot;, std::isnormal(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">1.0</span>/<span class="number">0.0</span>): %d\n<span class="string">&quot;, std::isnormal(1.0 / 0.0));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::signbit: Returns whether the sign of x is negative</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::signbit(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::signbit(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::signbit(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">signbit</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::signbit(std::sqrt(-1.0))); // 1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_compare()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	double result;</span></span><br><span class="line"><span class="string">	result = std::log(10.0);</span></span><br><span class="line"><span class="string">&#123; // std::isgreater: Returns whether x is greater than y</span></span><br><span class="line"><span class="string">	if (std::isgreater(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is positive\n<span class="string">&quot;); // log(10.0) is positive</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> positive\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isgreaterequal: Returns whether x is greater than or equal to y</span></span><br><span class="line"><span class="string">	if (std::isgreaterequal(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> negative\n<span class="string">&quot;); // log(10.0) is not negative</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is negative\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isless: Returns whether x is less than y</span></span><br><span class="line"><span class="string">	if (std::isless(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is negative\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> negative\n<span class="string">&quot;); // log(10.0) is not negative</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::islessequal: Returns whether x is less than or equal to y</span></span><br><span class="line"><span class="string">	if (std::islessequal(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> positive\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is positive\n<span class="string">&quot;); // log(10.0) is positive</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::islessgreater: Returns whether x is less than or greater than y</span></span><br><span class="line"><span class="string">	if (islessgreater(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> zero\n<span class="string">&quot;); // log(10.0) is not zero</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is zero\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isunordered: Returns whether x or y are unordered values</span></span><br><span class="line"><span class="string">	double result;</span></span><br><span class="line"><span class="string">	result = std::sqrt(-1.0);</span></span><br><span class="line"><span class="string">	if (std::isunordered(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">sqrt</span>(<span class="number">-1.0</span>) <span class="keyword">and</span> <span class="number">0.0</span> cannot be ordered\n<span class="string">&quot;); // sqrt(-1.0) and 0.0 cannot be ordered</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">sqrt</span>(<span class="number">-1.0</span>) <span class="keyword">and</span> <span class="number">0.0</span> can be ordered\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; // namespace cmath_</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/07/30/%E6%B5%85%E5%AD%A6MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E6%B5%85%E5%AD%A6MySQL/" class="post-title-link" itemprop="url">MySQL学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 20:34:45" itemprop="dateCreated datePublished" datetime="2022-07-30T20:34:45+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-01 22:42:52" itemprop="dateModified" datetime="2022-08-01T22:42:52+08:00">2022-08-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天把《MySQL必知必会》看完了，书本讲解的内容比较实用，注重命令的教学，对原理的涉及比较少。</p>
<p>这篇博客再回顾、梳理一遍书本，记录一些重点的内容。</p>
<p>2022-07-30</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul>
<li>数据库（database）：保存有组织的数据的容器。</li>
<li>数据库软件（dbms）：称为DBMS（数据库管理系统）。数据库是通过DBMS创建和操纵的容器。</li>
<li>表（table）：某种特定类型数据的结构化清单（文件）。每个表都有一个名字，用来标识自己。</li>
<li>模式（schema）：关于数据库和表的布局及特性的信息。这些特性定义了数据如何存储。</li>
<li>列（column）：表中的一个字段。所有表都是由一个或多个列组成的。可以理解为一类信息放在一列，每个列都有相应的数据类型。</li>
<li>行（row）：表中的一个记录（record）。</li>
<li>主键（primary key）：一列（或一组列），其值能够唯一区分表中每个行。任何列都可以作为主键，只要它满足以下条件：<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主键的最好习惯 除MySQL强制实施的规则外，应该坚持的几个普遍认可的最好习惯为： </span><br><span class="line">不更新主键列中的值；</span><br><span class="line">不重用主键列的值；</span><br><span class="line">不在主键列中使用可能会更改的值。</span><br></pre></td></tr></table></figure>

<ul>
<li>SQL:(发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库通信的语言。</li>
<li>MySQL服务器部分:负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。</li>
<li>MySQL客户机部分：是与用户打交道的软件，向服务器作出请求。</li>
</ul>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>假设拥有的一个数据库名字为<strong>sample</strong>。</p>
<p>语句用<code>;</code>结束，SQL语句不区分大小写，USE和use是一样的，一般关键字都用<strong>大写</strong>，这样易于阅读和调试。</p>
<p>SQL语句可以在一行上给出，也可以<strong>分成许多行</strong>。多数SQL开发人员认为将SQL语句分成多行更容易阅读和调试。</p>
<h2 id="使用和显示"><a href="#使用和显示" class="headerlink" title="使用和显示"></a>使用和显示</h2><ul>
<li>USE：最初连接到MySQL时，没有任何数据库打开供你使用。在执行任意数据库操作前，需要<strong>选择一个数据库</strong>。为此，可使用<strong>USE</strong>关键字（<code>USE sample;</code>）。必须先使用USE打开数据库，才能读取其中的数据。</li>
<li>SHOW DATABASES：<code>SHOW DATABASES;</code>返回可用数据库的一个列表。</li>
<li>SHOW TABLES：为了获得一个数据库内的表的列表，使用<code>SHOW TABLES;</code>。这个数据库是前面USE的数据库。</li>
<li>SHOW COLUMNS：<code>SHOW COLUMNS FROM customers;</code>要求给出一个表名（FROM someTable），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息。<ul>
<li><code>DESCRIBE customers;</code>是<code>SHOW COLUMNS FROM customers;</code>的一种快捷方式。</li>
</ul>
</li>
<li>其他SHOW语句（少用）：<ul>
<li>SHOW STATUS，用于显示广泛的服务器状态信息；</li>
<li>SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句;</li>
<li>SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；</li>
<li>SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。</li>
</ul>
</li>
</ul>
<h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 检索单列-- </span><br><span class="line">SELECT prod_name </span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>

<p>上述语句利用SELECT语句从products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p>
<ul>
<li>未排序数据：如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 检索多列-- </span><br><span class="line">SELECT prod_id,prod_price,prod_name </span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">-- 检索所有列-- </span><br><span class="line">SELECT *</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>

<p>如果给定一个通配符（*），则返回表中所有列。一般，除非你确实需要表中的每个列，否则<strong>最好别使用*通配符</strong>。虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。可以用于检索<strong>未知列</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 检索不同值（若相同则只返回一次）-- </span><br><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>

<p>DISTINCT 关键字指示MySQL只返回不同的值。</p>
<p>不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。<strong>相当于同时比较两个列，只有一行对应的两个元素都相同才视为真的相同</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 限制结果为前面n行-- </span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5;</span><br><span class="line"></span><br><span class="line">-- 限制结果为某个区间-- </span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5,5;</span><br></pre></td></tr></table></figure>

<p><code>LIMIT 5</code>指示MySQL返回<strong>不多于</strong>5行。</p>
<p><code>LIMIT 5, 5</code>指示MySQL返回<strong>从行5开始</strong>（位置从0开始计）的5行。两个数字容易搞混，因此有一种代替语法：<code>LIMIT 4 OFFSET 3</code>意为从行3开始取4行，就像LIMIT 3, 4一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 完全限定名写法，限定某个列是哪个表的（表名也可以限定为哪个数据库的）-- </span><br><span class="line">SELECT products.prod_name</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>一般返回的顺序是数据最初添加到表中的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 排序单列-- </span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>

<p><code>ORDER BY</code>指示MySQL对prod_name列以字母顺序排序，通常，ORDER BY子句中<strong>使用的列将是为显示所选择的列</strong>。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 排序多列-- </span><br><span class="line">SELECT prod_id,prod_price,prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price,prod_name;</span><br></pre></td></tr></table></figure>

<p>在按多个列排序时，排序完全按所规定的顺序进行。换句话说，对于上述例子中的输出，<strong>仅在多个行具有相同</strong>的prod_price值时才对产品按prod_name进行排序。如果prod_price列中所有的值都是唯一的，则不会按prod_name排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 指定排序方向-- </span><br><span class="line">SELECT prod_id,prod_price,prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC,prod_name;</span><br></pre></td></tr></table></figure>

<p>数据排序不限于升序排序（从A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（从Z到A）顺序排序。为了进行<strong>降序</strong>排序，必须指定<strong>DESC关键字</strong>。</p>
<p>DESC关键字<strong>只应用到直接位于其前面的列名</strong>。在上例中，只对prod_price列指定DESC，对prod_name列不指定。因此，prod_price列以降序排序，而prod_name列（在每个价格内）仍然按标准的升序排序。</p>
<p>与DESC相反的关键字是ASC（ASCENDING），在升序排序时可以指定它。但实际上，ASC没有多大用处，因为<strong>升序是默认的</strong>。</p>
<p><em>在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。必须请求数据库管理员的帮助。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 应用：找最大值-- </span><br><span class="line">SELECT prod_price</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure>

<p>prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行。</p>
<p>在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。<strong>因为SELECT-FROM这一对给出了结果，然后再调用ORDER BY 来排序，最后用LIMIT取第一行。</strong></p>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用WHERE子句过滤-- </span><br><span class="line">SELECT prod_name,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price = 2.50;</span><br></pre></td></tr></table></figure>

<p>这条语句从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行。</p>
<p>在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误（因为先过滤完再排序）</p>
<ul>
<li>WHERE子句操作符：<ul>
<li>&#x3D;：等于</li>
<li>&lt;&gt;：不等于</li>
<li>！&#x3D;：不等于</li>
<li>&lt;：小于</li>
<li>&lt;&#x3D;：小于等于</li>
<li>&gt;：大于</li>
<li>&gt;&#x3D;：大于等于</li>
<li>BETWEEN：在指定的两个值之间</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 检查单个值-- </span><br><span class="line">SELECT prod_name,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price = &#x27;fuses&#x27;;</span><br><span class="line"></span><br><span class="line">-- 范围检查-- </span><br><span class="line">SELECT prod_name,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 10;</span><br><span class="line"></span><br><span class="line">SELECT prod_name,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10; -- 两个值必须用AND分隔开-- </span><br><span class="line"></span><br><span class="line">-- 不匹配检查-- </span><br><span class="line">SELECT prod_name,vend_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id &lt;&gt; 1003;</span><br><span class="line"></span><br><span class="line">-- 空值检查-- </span><br><span class="line">SELECT prod_name,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price IS NULL; -- 注意这里用了IS关键字-- </span><br></pre></td></tr></table></figure>

<ul>
<li>NULL：无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。</li>
<li>NULL与不匹配：在通过过滤选择出<strong>不具有特定值</strong>的行时，你可能<strong>希望返回</strong>具有NULL值的行。但是不行。因为未知具有特殊的含义，数据库<strong>不知道它们是否匹配</strong>，所以在匹配过滤或不匹配过滤时<strong>不返回它们</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- AND操作符-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br><span class="line"></span><br><span class="line">-- OR操作符-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003 OR vend_id = 1005;</span><br><span class="line"></span><br><span class="line">-- 使用优先级组合-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price &lt;= 10;</span><br><span class="line"></span><br><span class="line">-- 使用圆括号组合-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE (vend_id = 1002 OR vend_id) = 1003 AND prod_price &lt;= 10;</span><br></pre></td></tr></table></figure>

<ul>
<li>AND：用在WHERE子句中的关键字，用来指示检索满足<strong>所有</strong>给定条件的行。</li>
<li>OR：WHERE子句中使用的关键字，用来表示检索匹配<strong>任一</strong>给定条件的行。</li>
<li>优先级：SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。此问题的解决方法是使用<strong>圆括号</strong>明确地分组相应的操作符。<em>任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符，它能消除歧义。</em></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- IN操作符-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1002,1003);</span><br></pre></td></tr></table></figure>

<p>IN操作符完成与OR相同的功能，IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。优点：</p>
<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li>
<li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 </li>
<li>IN操作符一般比OR操作符清单执行更快。</li>
<li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- NOT操作符-- </span><br><span class="line">SELECT prod_name,prod_price,prod_id</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id NOT IN (1002,1003);</span><br></pre></td></tr></table></figure>

<p>这里的NOT否定跟在它之后的条件，在更复杂的子句中，NOT是非常有用的。在与IN操作符联合使用时，NOT使找出与条件列表不匹配的行非常简单。</p>
<p><em>MySQL支持使用NOT对IN、BETWEEN和EXISTS子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</em></p>
<h2 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h2><ul>
<li><p>通配符（wildcard）：用来匹配值的一部分的特殊字符。</p>
</li>
<li><p>搜索模式（search pattern）：由字面值、通配符或两者组合构成的搜索条件。</p>
</li>
<li><p>百分号**%**代表搜索模式中给定位置的0个、1个或多个字符。</p>
</li>
<li><p>下划线**_**总是匹配一个字符，不能多也不能少。</p>
</li>
</ul>
<p>为在搜索子句中使用通配符，必须使用<strong>LIKE</strong>操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;jet%&#x27;;</span><br></pre></td></tr></table></figure>

<p>此例子使用了搜索模式**’jet%’<strong>。在执行这条子句时，将检索任意以jet起头的词。%告诉MySQL接受jet之后的</strong>任意字符**，不管它有多少字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;%anvil%&#x27;;</span><br></pre></td></tr></table></figure>

<p>搜索模式**’%anvil%’<strong>表示匹配任何位置</strong>包含文本anvil**的值，而不论它之前或之后出现什么字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;s%e&#x27;;</span><br></pre></td></tr></table></figure>

<p>这个例子找出以s起头以e结尾的所有产品。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用_通配符-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &#x27;_ ton anvil&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>尾空格可能会干扰通配符匹配。例如，在保存词anvil 时，如果它后面有一个或多个空格，则子句<code>WHERE prod_name LIKE &#39;%anvil&#39;</code>将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数去掉首尾空格。</li>
<li>注意NULL：虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</li>
</ul>
<p>使用通配符是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索<strong>所花时间更长</strong>。技巧：</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，除非绝对有必要，否则<strong>不要</strong>把它们用在搜索模式的<strong>开始处</strong>。把通配符置于搜索模式的开始处，搜索起来是<strong>最慢的</strong>。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- REGEXP关键字-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;1000&#x27;;</span><br></pre></td></tr></table></figure>

<p>这个语句检索列prod_name<strong>包含文本1000</strong>的所有行（注意，用LIKE要使用通配符才能检查’’包含’’），关键字LIKE被REGEXP代替，它告诉MySQL：REGEXP后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- REGEXP关键字-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;.000&#x27;;</span><br></pre></td></tr></table></figure>

<p>这里使用了正则表达式.000。**.<strong>是正则表达式语言中一个特殊的字符。它表示</strong>匹配任意一个字符**，因此，1000和2000都匹配且返回。</p>
<ul>
<li>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用<strong>BINARY</strong>关键字，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- OR匹配-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;1000|2000&#x27;;</span><br></pre></td></tr></table></figure>

<p>语句中使用了正则表达式1000|2000。|为正则表达式的OR操作符。它表示匹配其中之一，因此1000和2000都匹配并返回。可以有两个以上的OR条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 匹配几个字符之一-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[123] Ton&#x27;;</span><br></pre></td></tr></table></figure>

<p>这里，使用了正则表达式[123] Ton。[123]定义一组字符，它的意思是匹配1或2或3，因此，1 ton和2 ton都匹配且返回（没有3 ton）。</p>
<p>[]是另一种形式的OR语句。事实上，正则表达式[123]Ton为[1|2|3]Ton的缩写，也可以使用后者。但是，需要<strong>用[]来定义OR语句查找什么</strong>。如果直接用<code>&#39;1|2|3 Ton&#39;</code>，MySQL则假定你的意思是’1’或’2’或’3 ton’。</p>
<ul>
<li><p>字符集合也可以被<strong>否定</strong>，即，它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个<strong>^</strong>即可。因此，尽管[123]匹配字符1、2或3，但**[^123]**却匹配除这些字符外的任何东西。</p>
</li>
<li><p>如果要匹配数字，则为集合[0123456789]，一种简化的写法为[0-9]（用’-‘定义一个范围）。范围不限于完整的集合，[1-3]和[6-9]也是合法的范围。此外，范围不一定只是数值的，[a-z]匹配任意字母字符。</p>
</li>
<li><p>如果要匹配’.’，不能直接REGEXP ‘.’，因为这会匹配任意一个字符。需要用两个反斜杠转义，即在特殊字符前加<code>\\</code>。如<code>\\.</code>。</p>
<ul>
<li>为了匹配反斜杠（\）字符本身，需要使用<code>\\\</code>。</li>
<li>MySQL要求两个反斜杠（MySQL自己解释一个，正则表达式库解释另一个）。</li>
<li><code>\\</code>也用来引用元字符，如<code>\\f</code>表示换页。</li>
</ul>
</li>
</ul>
<p>存在找出经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类（character class）：</p>
<ul>
<li>[:alnum:] ：任意字母和数字（同[a-zA-Z0-9]）</li>
<li>[:alpha:] ：任意字符（同[a-zA-Z]）</li>
<li>[:blank:] ：空格和制表（同[\t]）</li>
<li>[:cntrl:] ：ASCII控制字符（ASCII 0到31和127）</li>
<li>[:digit:] ：任意数字（同[0-9]）</li>
<li>[:graph:] ：与[:print:]相同，但不包括空格</li>
<li>[:lower:] ：任意小写字母（同[a-z]）</li>
<li>[:print:] ：任意可打印字符</li>
<li>[:punct:] ：既不在[:alnum:]又不在[:cntrl:]中的任意字符</li>
<li>[:space:] ：包括空格在内的任意空白字符（同[\f\n\r\t\v]）</li>
<li>[:upper:] ：任意大写字母（同[A-Z]）</li>
<li>[:xdigit:] ：任意十六进制数字（同[a-fA-F0-9]）</li>
</ul>
<h3 id="字符汇总"><a href="#字符汇总" class="headerlink" title="字符汇总"></a>字符汇总</h3><ul>
<li>.：匹配任意一个字符</li>
<li>|：表示OR（条件或）</li>
<li>[]：另一种形式的OR语句，来定义OR语句查找什么</li>
<li>^：否定</li>
<li>-：定义范围</li>
<li>\\：转义</li>
<li>[: :]：前面所示的一些字符类</li>
<li>*：0个或多个匹配，置于某字符后</li>
<li>+：1个或多个匹配（等于{1,}），置于某字符后</li>
<li>？：0个或1个匹配（等于{0,1}），置于某字符后</li>
<li>{n}：指定数目的匹配，置于某字符后</li>
<li>{n,}：不少于指定数目的匹配，置于某字符后</li>
<li>{n,m}：匹配数目的范围（m不超过255），置于某字符后</li>
<li>^：文本的开始（双重用途），放在串的开头</li>
<li>$：文本的结尾，放在串的结尾</li>
<li>[[:&lt;:]]：词的开始</li>
<li>[[:&gt;:]]：词的结尾</li>
</ul>
<p><strong>^</strong>的双重用途：^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处，如^[0-9\\.]（后面有例子）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用？-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;\\([0-9] sticks?\\)&#x27;;</span><br></pre></td></tr></table></figure>

<p>正则表达式\\([0-9] sticks?\\)需要解说一下。\\(匹配(，[0-9]匹配任意数字，sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它<strong>前面</strong>的任何字符的0次或1次出现），\\)匹配)。没有?，匹配stick和sticks会非常困难。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 匹配连在一起的4位数字-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[:digit:]&#123;4&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>[:digit:]匹配任意数字，因而它为数字的一个集合。{4}确切地要求它前面的字符（任意数字）出现4次。</p>
<p>如果想找出<strong>以一个数（包括以小数点开始的数）开始</strong>的所有产品，怎么办？简单搜索[0-9\\.]（或[[:digit:]\\.]）不行，因为它将在文本内<strong>任意位置</strong>查找匹配（正则是查找”包含“）。解决办法是使用^定位符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &#x27;^[0-9\\.]&#x27;;</span><br></pre></td></tr></table></figure>

<p>^匹配串的开始。因此，^[0-9\\.]只在.或任意数字为串中第一个字符时才匹配它们。</p>
<ul>
<li>使REGEXP起类似LIKE的作用 ：前面说过，LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过<strong>用^开始每个表达式，用$结束每个表达式</strong>，可以使REGEXP的作用与LIKE一样。</li>
</ul>
<h1 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h1><h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><ul>
<li>字段（field） ：基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接字段-- </span><br><span class="line">SELECT Concat(vend_name,&#x27;(&#x27;,vend_country,&#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>Concat()拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p>
<p>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除右侧多余空格-- </span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>RTrim()函数去掉值右边的所有空格。通过使用RTrim()，各个列都进行了整理。MySQL除了支持RTrim()（正如刚才所见，它去掉串右边的空格），还支持LTrim()（去掉串左边的空格）以及Trim()（去掉串左右两边的空格）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用别名-- </span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>计算字段之后跟了文本AS vend_title。它指示SQL创建一个包含指定计算的名为vend_title的计算字段。别名有时也称为导出列（derived column）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 算术计算-- </span><br><span class="line">SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>

<p>输出中显示的expanded_price列为一个计算字段，此计算为quantity*item_price。客户机应用现在可以使用这个新计算列，就像使用其他列一样。</p>
<ul>
<li>测试计算：SELECT提供了测试和试验函数与计算的一个很好的办法。虽然SELECT通常用来从表中检索数据，但可以省略FROM子句以便简单地访问和处理表达式。例如，SELECT 3*2;将返回6，SELECT Trim(‘abc’);将返回abc，而SELECT Now()利用Now()函数返回当前日期和时间。通过这些例子，可以明白如何根据需要使用SELECT进行试验。</li>
</ul>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><ul>
<li><p>RTrim(str)：去掉串尾的空格来整理数据。</p>
</li>
<li><p>Right(str)：返回串右边的字符。</p>
</li>
<li><p>Upper(str)：将文本转换为大写并返回。</p>
</li>
<li><p>Lower(str)：将文本转换为小写并返回。</p>
</li>
<li><p>Length(str)：返回串的长度。</p>
</li>
<li><p>Locate(substr,str)：substr待查找的子串，str待查找的串。如果 substr 不在 str 中返回 0。</p>
</li>
<li><p>Locate(substr,str,pos)：返回子串 substr 在字符串 str 中的第 pos 位置后第一次出现的位置。如果 substr 不在 str 中返回 0。</p>
</li>
<li><p>Position(substr IN str)：返回substr在str中第一次出现的位置。</p>
</li>
<li><p>SubString(str,pos)：返回从第pos位置出现的子串的字符。</p>
</li>
<li><p>substring(str, pos, len)：substring(str, pos, len)。作用：返回从pos位置开始长度为len的子串的字符。</p>
</li>
<li><p>Soundex(str)：返回串的SOUNDEX值。</p>
<ul>
<li><p>SOUNDEX是一个将任何文本串转换为描述其<strong>语音表示</strong>的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</p>
</li>
<li><p>&#96;&#96;&#96;mysql<br>– 匹配Y.Lee与Y.Lie–<br>SELECT cust_name,cust_contact<br>FROM customers<br>WHERE Soundex(cust_contact) &#x3D; Soundex(‘Y.Lie’);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 日期和时间处理函数</span><br><span class="line"></span><br><span class="line">* AddDate() ：增加一个日期（天、周等）</span><br><span class="line">* AddTime() ：增加一个时间（时、分等）</span><br><span class="line">* CurDate() ：返回当前日期</span><br><span class="line">* CurTime() ：返回当前时间</span><br><span class="line">* Date() ：返回日期时间的日期部分</span><br><span class="line">* DateDiff() ：计算两个日期之差</span><br><span class="line">* Date_Add() ：高度灵活的日期运算函数</span><br><span class="line">* Date_Format() ：返回一个格式化的日期或时间串</span><br><span class="line">* Day() ：返回一个日期的天数部分</span><br><span class="line">* DayOfWeek() ：对于一个日期，返回对应的星期几</span><br><span class="line">* Hour() ：返回一个时间的小时部分</span><br><span class="line">* Minute() ：返回一个时间的分钟部分</span><br><span class="line">* Month() ：返回一个日期的月份部分</span><br><span class="line">* Now() ：返回当前日期和时间</span><br><span class="line">* Second() ：返回一个时间的秒部分</span><br><span class="line">* Time() ：返回一个日期时间的时间部分</span><br><span class="line">* Year() ：返回一个日期的年份部分</span><br><span class="line"></span><br><span class="line">需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性。</span><br><span class="line"></span><br><span class="line">因为一个记录里面的日期格式可能不一样，比如有可能这个日期还包括**当天时间**，这样就需要指示MySQL**仅将给出的日期与列中的日期部分进行比较**，而不是将给出的日期与整个列值进行比较。为此，必须使用Date()函数。Date(order_date)指示MySQL仅提取列的日期部分。</span><br><span class="line"></span><br><span class="line">```mysql</span><br><span class="line">SELECT cust_id,order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) = &#x27;2005-09-01&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><em>如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 检索某月1:需要知道一个月有多少天-- </span><br><span class="line">SELECT cust_id,order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) BETWEEN &#x27;2005-09-01&#x27; AND &#x27;2005-09-30&#x27;;</span><br><span class="line"></span><br><span class="line">-- 检索某月2-- </span><br><span class="line">SELECT cust_id,order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Year(order_date)=2005 ANd Month(order_date)=9;</span><br></pre></td></tr></table></figure>

<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><ul>
<li>Abs() ：返回一个数的绝对值</li>
<li>Cos() ：返回一个角度的余弦</li>
<li>Exp() ：返回一个数的指数值</li>
<li>Mod() ：返回除操作的余数</li>
<li>Pi() ：返回圆周率</li>
<li>Rand() ：返回一个随机数</li>
<li>Sin() ：返回一个角度的正弦</li>
<li>Sqrt() ：返回一个数的平方根</li>
<li>Tan() ：返回一个角度的正切</li>
</ul>
<h3 id="聚焦函数（汇总数据）"><a href="#聚焦函数（汇总数据）" class="headerlink" title="聚焦函数（汇总数据）"></a>聚焦函数（汇总数据）</h3><p>利用标准的算术操作符，所有聚集函数都可用来<strong>执行多个列上的计算</strong>（如两个列乘法，取平均、最大、求和）。这些函数是高效设计的，它们返回结果一般比在自己的客户机应用程序中计算要快得多。</p>
<ul>
<li>AVG() ：返回某列的平均值，只能用于特定列，忽略NULL的行。</li>
<li>COUNT() ：返回某列的行数，指定列忽略NULL，count(*)包含NULL。</li>
<li>MAX() ：返回某列的最大值，忽略NULL，可用于数值、日期、文本。</li>
<li>MIN() ：返回某列的最小值，忽略NULL，可用于数值、日期、文本。</li>
<li>SUM() ：返回某列值之和，忽略NULL。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 整体AVG()-- </span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products;</span><br><span class="line">-- 部分AVG()-- </span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br><span class="line"></span><br><span class="line">-- 所有COUNT()-- </span><br><span class="line">SELECT COUNT(*) AS num_cust</span><br><span class="line">FROM customers;</span><br><span class="line">-- 指定COUNT()-- </span><br><span class="line">SELECT COUNT(cust_email) AS num_cust</span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">-- MAX()-- </span><br><span class="line">SELECT MAX(prod_price) AS max_price</span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">-- MIN()-- </span><br><span class="line">SELECT MIN(prod_price) AS min_price</span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">-- 多列算术SUM()-- </span><br><span class="line">SELECT SUM(item_price*quantity) AS total_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>

<p>聚焦不同值： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；只包含不同的值，指定<strong>DISTINCT</strong>参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 所有聚焦函数都可用DISTINCT-- </span><br><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。</li>
<li>虽然DISTINCT从技术上可用于MIN()和MAX()，但这样做实际上没有价值。一个列中的最小值和最大值不管是否包含不同值都是相同的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 组合-- </span><br><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">	   MIN(prod_price) AS price_min,</span><br><span class="line">	   MAX(prod_price) AS price_max,</span><br><span class="line">	   AVG(prod_price) AS price_avg,</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>指定别名</strong>以包含某个聚集函数的结果时，不应该使用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure>

<p>上面的SELECT语句指定了两个列，vend_id包含产品供应商的ID，num_prods为计算字段（用COUNT(*)函数建立）。<strong>GROUP BY子句指示MySQL按vend_id排序并分组数据，然后对每个组进行聚焦</strong>。这导致对每个vend_id而不是整个表计算num_prods一次。</p>
<p>使用ROLLUP，可以把NULL也分组，否则不会。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id WITH ROLLUP;</span><br></pre></td></tr></table></figure>

<p>在具体使用GROUP BY子句前，需要知道一些重要的规定：</p>
<ul>
<li>GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</li>
<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 </li>
<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 过滤分组-- </span><br><span class="line">SELECT cust_id,COUNT(*) AS orders</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*)&gt;=2;</span><br></pre></td></tr></table></figure>

<p>WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。HAVING非常类似于WHERE。事实上，目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。</p>
<p>这条SELECT语句的前3行类似于上面的语句。最后一行增加了HAVING子句，它过滤COUNT(*) &gt;&#x3D;2（两个以上的订单）的那些分组。</p>
<p><em>这里有另一种理解方法，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 都使用-- </span><br><span class="line">SELECT cust_id,COUNT(*) AS orders</span><br><span class="line">FROM orders</span><br><span class="line">WHERE prod_price&gt;=10</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*)&gt;=2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 排序-- </span><br><span class="line">SELECT order_num,SUM(quantity*item_price) AS ordertotal</span><br><span class="line">FROM orderitems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING SUM(quantity*item_price)&gt;=50</span><br><span class="line">ORDER BY ordertotal;</span><br></pre></td></tr></table></figure>

<p>一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。</p>
<p>SELECT子句及其顺序：</p>
<p><code>SELECT -- &gt; FROM -- &gt; WHERE -- &gt; GROUP BY -- &gt; HAVING -- &gt; ORDER BY -- &gt; LIMIT</code></p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>查询（query）：任何SQL语句都是查询。但此术语一般指SELECT语句。</li>
<li>递归的子查询将下层的查询结果返回给上层利用，一般在WHERE子句里通过IN利用。</li>
<li>迭代的子查询将上层第一次迭代的结果拿来给自身的循环利用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 嵌套子查询，相当于递归-- </span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                      FROM orderitems</span><br><span class="line">                                      WHERE prod_id = &#x27;TNT2&#x27;));</span><br></pre></td></tr></table></figure>

<ul>
<li>列必须匹配：在WHERE子句中使用子查询（如这里所示），应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</li>
<li>虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（&#x3D;）、不等于（&lt;&gt;）等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 在SELECT上子查询，迭代的，相当于多层循环-- </span><br><span class="line">SELECT cust_name,cust_state,(SELECT COUNT(*)</span><br><span class="line">                             FROM orders</span><br><span class="line">                             WHERE orders.cust_id=customers.cust_id) AS orders</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>

<p>每次外部执行一次，得到一个id，用此id去orders里面遍历一次查询来次数。</p>
<p>这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。</p>
<h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><h3 id="基础联结"><a href="#基础联结" class="headerlink" title="基础联结"></a>基础联结</h3><ul>
<li>外键（foreign key）：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</li>
<li>关于外键的作用、优缺点，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/ycl295644/article/details/49924301">(27条消息) 数据库外键的使用和原则_守枫竹清的博客-CSDN博客_数据库外键</a></li>
</ul>
<p><em>关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。</em></p>
<p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建联结-- </span><br><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors,products  -- 多个表-- </span><br><span class="line">WHERE vendors.vend_id = products.vend_id  -- 联结-- </span><br><span class="line">ORDER BY vend_name,prod_name;</span><br></pre></td></tr></table></figure>

<p>上面例子的步骤是：先检索第一项vend_name的一项（对应一个id），然后发现接下来是另一个表的内容（实际上在表检索的过程有遍历的先后次序，是<strong>嵌套</strong>的，具体是看FROM哪个表先，两个表是n*n的复杂度），则在这个表中检索一遍，匹配id。WHERE子句指示MySQL匹配vendors表中的vend_id和products表中的vend_id。如果没有WHERE，则对vend_name的一项都对应另一个表的所有项。</p>
<ul>
<li>笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。也即第一个表的一项都匹配了第二个表的所有项（这里可以看出实质上是嵌套遍历的）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 另一种写法，内部联结-- </span><br><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors INNER JOIN products  -- 多个表，指明了嵌套关系-- </span><br><span class="line">ON vendors.vend_id = products.vend_id  -- 联结条件-- </span><br><span class="line">ORDER BY vend_name,prod_name;</span><br></pre></td></tr></table></figure>

<p>两个表之间的关系是FROM子句的组成部分，以INNER JOIN指定。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。</p>
<p>ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件，有时候这样做也能影响性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INNER JOIN嵌套语法</span><br><span class="line"></span><br><span class="line">INNER JOIN 连接两个数据表的用法：</span><br><span class="line">SELECT * FROM 表1 INNER JOIN 表2 ON 表1.字段号=表2.字段号</span><br><span class="line"></span><br><span class="line">INNER JOIN 连接三个数据表的用法：</span><br><span class="line">SELECT * FROM (表1 INNER JOIN 表2 ON 表1.字段号=表2.字段号) INNER JOIN 表3 ON 表1.字段号=表3.字段号</span><br><span class="line"></span><br><span class="line">INNER JOIN 连接四个数据表的用法：</span><br><span class="line">SELECT * FROM ((表1 INNER JOIN 表2 ON 表1.字段号=表2.字段号) INNER JOIN 表3 ON 表1.字段号=表3.字段号) INNER JOIN 表4 ON 表1.字段号=表4.字段号</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 联结多个表-- </span><br><span class="line">SELECT prod_name,vend_name,prod_price,quantity</span><br><span class="line">FROM orderitems,products,vendors</span><br><span class="line">WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005;</span><br><span class="line"></span><br><span class="line">-- INNER JOIN写法-- </span><br><span class="line">SELECT prod_name,vend_name,prod_price,quantity</span><br><span class="line">FROM （orderitems INNER JOIN products ON orderitems.prod_id = products.prod_id) INNER JOIN vendors </span><br><span class="line">  		         ON orderitems.prod_id = vendors.vend_id</span><br><span class="line">WHERE orderitems.order_num = 20005;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-前面的子查询-- </span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                      FROM orderitems</span><br><span class="line">                                      WHERE prod_id = &#x27;TNT2&#x27;));</span><br><span class="line">                                      </span><br><span class="line">-- 改用联结-- </span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers,orders,orderitems</span><br><span class="line">WHERE customers.cust_id = orders_cust_id AND orderitems.order_num = orders.order_num AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>子查询的意思是从orderitems表查到order_num，然后去orders表根据这个order_num查找cust_id，然后再去customers找name和contact。</p>
<p>而使用联结，则先在customers表查第一项，得到id，然后去orders表查到这个id的项获得num，然后去orderitems表根据num获得prod_id，检查是不是’TNT2’，是的话算一个结果，然后继续下一项，就相当于<strong>循环迭代</strong>。</p>
<p>实际上这两个方法的核心都是：<strong>给定的索引与目标记录不在一个表中</strong>。那么可以递归不断换个表，也可以更清晰地用外键联结这几个表。</p>
<h3 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h3><p>使用别名，能够在单条SELECT语句中多次使用相同的表，并缩短语句长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 使用别名-- </span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers AS c,orders AS o,orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 子查询-- </span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">                 FROM products</span><br><span class="line">                 WHERE prod_id = &#x27;DTNTR&#x27;);</span><br><span class="line">                 </span><br><span class="line">-- 自联结-- </span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id AND p2.prod_id = &#x27;DTNTR&#x27;;</span><br><span class="line">-- 从p2中找到一条记录，从p1中找到多条记录。虽然是相同的表，但每个实例执行的条件不一样。从循环迭代的角度看，条件有传递的感觉-- </span><br></pre></td></tr></table></figure>

<p>此查询中需要的两个表实际上是相同的表，因此products表在FROM子句中出现了两次。虽然这是完全合法的，但对products的引用具有二义性，因为MySQL不知道你引用的是products表中的哪个实例。为解决此问题，使用了表别名。products的第一次出现为别名p1，第二次出现为别名p2。现在可以将这些别名用作表名。</p>
<ul>
<li>自然联结是这样一种联结，只能选择那些唯一的列。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。事实上，这里迄今为止建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</li>
<li>外部联结联结包含了那些在相关表中没有关联行的行，使用OUTER JOIN关键字。在使用<strong>OUTER JOIN</strong>语法时，必须使用<strong>RIGHT</strong>或<strong>LEFT</strong>关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 外部联结-- </span><br><span class="line">SELECT customers.cust_id,orders.order_num</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>上面这条语句会把所有的cust_id都打印，因为使用的LEFT关键字指定了customers的表，而右边order_num是不是NULL都会打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 聚焦函数与联结-- </span><br><span class="line">SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br><span class="line"></span><br><span class="line">-- 对客户表，联结订单表。-- </span><br><span class="line">-- 对客户分组，然后对于每个客户通过联结条件匹配订单表的对应客户，接着计算匹配的订单数量-- </span><br></pre></td></tr></table></figure>

<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）</p>
<p>有两种基本情况，其中需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<p>可用<strong>UNION</strong>操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 组合查询-- </span><br><span class="line">SELECT vend_id,prod_id,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price&lt;=5  -- 注意，这条语句没有分号-- </span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1001,1002);</span><br></pre></td></tr></table></figure>

<p>这条语句由前面的两条SELECT语句组成，语句中用UNION关键字分隔。UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。</p>
<p>并是非常容易使用的。但在进行并时有几条规则需要注意:</p>
<ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间<strong>用关键字UNION分隔</strong>（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 </li>
<li>UNION中的每个查询必须<strong>包含相同</strong>的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<p>UNION从查询结果集中自动<strong>去除了重复的行</strong>，这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果想返回所有匹配行，可使用<strong>UNION ALL</strong>而不是UNION。</p>
<p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，<strong>只能使用一条ORDER BY子句</strong>，它必须出现<strong>在最后一条SELECT语句之后</strong>。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句。</p>
<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并非所有引擎都支持全文本搜索 </span><br><span class="line">MySQL支持几种基本的数据库引擎。并非所有的引擎都支持本书所描述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。这就是为什么虽然本书中创建的多数样例表使用 InnoDB ，而有一个样例表（productnotes表）却使用MyISAM的原因。如果你的应用中需要全文本搜索功能，应该记住这一点。</span><br></pre></td></tr></table></figure>

<h3 id="FULLTEXT"><a href="#FULLTEXT" class="headerlink" title="FULLTEXT"></a>FULLTEXT</h3><p>一般在创建表时启用全文本搜索。CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">	note_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">    prod_id char(10) NOT NULL,</span><br><span class="line">    note_date datetime NOT NULL,</span><br><span class="line">    note_text text NULL,</span><br><span class="line">    PRIMARY KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。不要在导入数据时使用FULLTEXT ，要花很多时间。</p>
<p>在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;rabbit&#x27;);</span><br></pre></td></tr></table></figure>

<p>此SELECT语句检索单个列note_text。由于WHERE子句，一个全文本搜索被执行。Match(note_text)指示MySQL针对指定的列进行搜索，Against(‘rabbit’)指定词rabbit作为搜索文本。由于有两行包含词rabbit，这两个行被返回。传递给 Match() 的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。</p>
<p>全文本搜索的一个重要部分就是<strong>对结果排序</strong>。具有<strong>较高等级的行先返回</strong>（因为这些行很可能是你真正想要的行）。</p>
<ul>
<li>文本中词靠前的行的等级值比词靠后的行的等级值高。</li>
<li>如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值。</li>
</ul>
<p><em>除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询扩展-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>

<p>利用查询扩展，能找出可能相关的结果，即使它们并不精确包含所查找的词。比如某一行x确实包含词anvils，另一行不包含，但这行包含了行x中的几个词，那么也有可能被检索出来。</p>
<h3 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h3><p>以布尔方式，可以提供关于如下内容的细节：</p>
<ul>
<li>要匹配的词；</li>
<li>要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）； </li>
<li>排列提示（指定某些词比其他词更重要，更重要的词等级更高）； </li>
<li>表达式分组；</li>
<li>另外一些内容。</li>
</ul>
<p>即使没有FULLTEXT索引也可以使用：布尔方式不同于迄今为止使用的全文本搜索语法的地方在于，即使没有定义FULLTEXT索引，也可以使用它。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 布尔模式-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>

<p>此全文本搜索检索包含词heavy的所有行（有两行）。其中使用了关键字IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。</p>
<p>为了匹配包含heavy但不包含任意以rope开始的词的行，可使用以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 布尔模式-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>

<p>这一次仍然匹配词heavy，但-rope*明确地指示MySQL排除包含rope*（任何以rope开始的词，包括ropes）的行。</p>
<p>布尔操作符：</p>
<ul>
<li>+ ：包含，词必须存在</li>
<li>- ：排除，词必须不出现</li>
<li>&gt; ：包含，而且增加等级值</li>
<li>&lt; ：包含，且减少等级值</li>
<li>() ：把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）</li>
<li>~ ：取消一个词的排序值</li>
<li>* ：词尾的通配符</li>
<li>“” ：定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</li>
</ul>
<p>在布尔方式中，不按等级值降序排序返回的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 匹配包含rabbit、bait至少一个词的行，这种叫单词列表-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;rabbit bait&#x27; IN BOOLEAN MODE);</span><br><span class="line"></span><br><span class="line">-- 匹配包含词rabbit、bait的行-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;+rabbit +bait&#x27; IN BOOLEAN MODE);</span><br><span class="line"></span><br><span class="line">-- 匹配短语rabbit bait-- </span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;&quot;rabbit bait&quot;&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条<strong>50%规则</strong>，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。</li>
<li>如果表中的行数<strong>少于3行</strong>，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。</li>
<li>忽略词中的单引号。例如，don’t索引为dont。</li>
<li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。</li>
<li>如前所述，仅在MyISAM数据库引擎中支持全文本搜索。</li>
</ul>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h2><p>INSERT语句一般不会产生输出。有两种方式</p>
<p><em>不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 简单的方式-- </span><br><span class="line">INSERT INTO customers</span><br><span class="line">VALUES(&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">      &#x27;100 Main Street&#x27;,</span><br><span class="line">      &#x27;Los Angeles&#x27;,</span><br><span class="line">      &#x27;CA&#x27;,</span><br><span class="line">      &#x27;90046&#x27;,</span><br><span class="line">      &#x27;USA&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      NULL);</span><br><span class="line"></span><br><span class="line">-- 更安全、建议的插入方式-- </span><br><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_email)</span><br><span class="line">VALUES(&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">      &#x27;100 Main Street&#x27;,</span><br><span class="line">      &#x27;Los Angeles&#x27;,</span><br><span class="line">      &#x27;CA&#x27;,</span><br><span class="line">      &#x27;90046&#x27;,</span><br><span class="line">      &#x27;USA&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      NULL);</span><br></pre></td></tr></table></figure>

<p>在表名后的括号里明确地给出了列名。在插入行时，MySQL将用VALUES列表中的相应值填入列表中的对应项。VALUES中的第一个值对应于第一个指定的列名。第二个值对应于第二个列名，如此等等。</p>
<p>存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。如果某个列没有值（如上面的cust_contact和cust_email列），应该使用<strong>NULL</strong>值（假定表允许对该列指定空值）。</p>
<p>cust_id可以不填也可以为NULL。这是因为每次插入一个新行时，该列由MySQL自动增量。如果某一列要省略，必须满足：该列定义为允许NULL，或者在表定义时给出了默认值。</p>
<p>INSERT可能会降低等待处理的SELECT语句的性能，如果数据检索是重要的，那么可以在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，如下所示：<code>INSERT LOW_PRIORITY INTO</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 插入多个行-- </span><br><span class="line">INSERT INTO customers(cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_email)</span><br><span class="line">VALUES(&#x27;Pep E. LaPew&#x27;,</span><br><span class="line">      &#x27;100 Main Street&#x27;,</span><br><span class="line">      &#x27;Los Angeles&#x27;,</span><br><span class="line">      &#x27;CA&#x27;,</span><br><span class="line">      &#x27;90046&#x27;,</span><br><span class="line">      &#x27;USA&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      NULL),</span><br><span class="line">     (&#x27;Lep E. PaPew&#x27;,</span><br><span class="line">      &#x27;100 Main Street&#x27;,</span><br><span class="line">      &#x27;Los Angeles&#x27;,</span><br><span class="line">      &#x27;CA&#x27;,</span><br><span class="line">      &#x27;90046&#x27;,</span><br><span class="line">      &#x27;USA&#x27;,</span><br><span class="line">      NULL,</span><br><span class="line">      NULL);</span><br></pre></td></tr></table></figure>

<p>只要每条INSERT语句中的列名（和次序）相同，可以一次插入多个行。其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 插入检索出来的行-- </span><br><span class="line">INSERT INTO customers(cust_id,</span><br><span class="line">                     cust_name,</span><br><span class="line">                     cust_address,</span><br><span class="line">                     cust_city,</span><br><span class="line">                     cust_state,</span><br><span class="line">                     cust_zip,</span><br><span class="line">                     cust_country,</span><br><span class="line">                     cust_contact,</span><br><span class="line">                     cust_email)</span><br><span class="line">SELECT cust_id,</span><br><span class="line">       cust_name,</span><br><span class="line">       cust_address,</span><br><span class="line">       cust_city,</span><br><span class="line">       cust_state,</span><br><span class="line">       cust_zip,</span><br><span class="line">       cust_country,</span><br><span class="line">       cust_contact,</span><br><span class="line">       cust_email</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure>

<p>这个例子使用<strong>INSERT SELECT</strong>从custnew中将所有数据导入customers。SELECT语句从custnew检索出要插入的值，而不是列出它们。SELECT中列出的每个列对应于customers表名后所跟的列表中的每个列。这条语句将<strong>插入多少行有赖于custnew表中有多少行</strong>。如果这个表为空，则没有行被插入（也不产生错误，因为操作仍然是合法的）。如果这个表确实含有数据，则所有数据将被插入到customers。</p>
<p>为简单起见，这个例子在INSERT和SELECT语句中使用了相同的列名。但是，不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名，它使用的是列的位置。</p>
<h2 id="更新行"><a href="#更新行" class="headerlink" title="更新行"></a>更新行</h2><p>UPDATE语句由3部分组成，分别是：</p>
<ul>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新行的过滤条件。</li>
</ul>
<p>实际上，UPDATE是选定某列更新，不过用WHERE来选中某些行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>

<p>UPDATE语句总是以要更新的表的名字开始。在此例子中，要更新的表的名字为customers。SET命令用来将新值赋给被更新的列。如这里所示，SET子句设置cust_email列为指定的值：<code>SET cust_email = &#39;elmer@fudd.com&#39;</code>。</p>
<p>UPDATE语句<strong>以WHERE子句结束</strong>，它告诉MySQL更新哪一行。没有WHERE子句，MySQL将会用这个电子邮件地址更新customers表中所有行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 更新多个列的行-- </span><br><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = &#x27;elmer@fudd.com&#x27;,</span><br><span class="line">	cust_name = &#x27;The Fudds&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>

<p>在更新多个列时，只需要使用单个SET命令，每个“列&#x3D;值”对之间用逗号分隔（最后一列之后不用逗号）。</p>
<p>IGNORE关键字：如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为<strong>即使是发生错误，也继续进行更新</strong>，可使用IGNORE关键字，如下所示： <code>UPDATE IGNORE customers… </code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 删除某列，设置为NULL-- </span><br><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = NULL;</span><br></pre></td></tr></table></figure>

<p>没有WHERE子句则更新所有行。</p>
<h2 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h2><p>DELETE直接删除一整行，不能选择列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM customers</span><br><span class="line">WHERE cust_id = 10006;</span><br></pre></td></tr></table></figure>

<p>这条语句很容易理解。DELETE FROM要求指定从中删除数据的表名。WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。如果省略WHERE子句，它将删除表中每个客户。</p>
<p>DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身。</p>
<p>如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。</p>
<p><em>MySQL没有撤销（undo）按钮。应该非常小心地使用UPDATE和DELETE，否则你会发现自己更新或删除了错误的数据。</em></p>
<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>在创建新表时，指定的表名必须不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id      int          NOT NULL AUTO_INCREMENT, -- 自动增量-- </span><br><span class="line"> cust_name    char(10)     NOT NULL,</span><br><span class="line"> cust_address char(50)     NOT NULL, -- 不允许NULL-- </span><br><span class="line"> cust_city    char(50)     NULL, -- 允许NULL-- </span><br><span class="line"> ...</span><br><span class="line"> PRIMARY KEY(cust_id)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>表名紧跟在CREATE TABLE关键字后面。实际的表定义（所有列）括在圆括号之中。各列之间用逗号分隔。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型。表的主键可以在创建表时用PRIMARY KEY关键字指定。这里，列cust_id指定作为主键列。忽略ENGINE时，整条语句由右圆括号后的分号结束。</p>
<p>NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。<strong>不允许NULL值的列不接受该列没有值的行</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 多个主键列-- </span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id      int          NOT NULL AUTO_INCREMENT, -- 自动增量-- </span><br><span class="line"> cust_name    char(10)     NOT NULL,</span><br><span class="line"> cust_address char(50)     NOT NULL, -- 不允许NULL-- </span><br><span class="line"> cust_city    char(50)     NULL, -- 允许NULL-- </span><br><span class="line"> ...</span><br><span class="line"> PRIMARY KEY(cust_id,cust_name)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。</p>
<ul>
<li>每个表<strong>只允许一个AUTO_INCREMENT列</strong>，而且它必须被索引（如，通过使它成为主键）。要指定某个自动增量的值，可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将开始使用该手工插入的值。</li>
<li>让MySQL生成（通过自动增量）主键的一个缺点是你不知道这些值都是谁。如何在使用AUTO_INCREMENT列时获得这个值呢？可使用last_insert_id()函数获得这个值：<code>SELECT last_insert_id()</code>。此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 指定默认值-- </span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line"> cust_id      int          NOT NULL AUTO_INCREMENT, -- 自动增量-- </span><br><span class="line"> cust_name    char(10)     NOT NULL DEFAULT &#x27;xiaoming&#x27;, -- 有默认值-- </span><br><span class="line"> cust_address char(50)     NOT NULL, -- 不允许NULL-- </span><br><span class="line"> cust_city    char(50)     NULL, -- 允许NULL-- </span><br><span class="line"> ...</span><br><span class="line"> PRIMARY KEY(cust_id,cust_name)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL不允许使用函数作为默认值，它只支持常量。</li>
<li>许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。</li>
</ul>
<p>如果省略ENGINE&#x3D;语句，则使用漠人引擎（很可能是MyISAM），不同表可以使用不同的引擎类型，但<strong>外键不能跨引擎</strong>。引擎类型：</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索；</li>
<li>MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）； </li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。</li>
</ul>
<p>注：创建表为避免名称重复，可以用<code>CREATE TABLE IF NOT EXISTS</code>。</p>
<h2 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h2><p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：</p>
<ul>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）； </li>
<li>所做更改的列表。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 更新表，添加一个列-- </span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">ADD vend_phone CHAR(20); -- 默认NULL-- </span><br><span class="line"></span><br><span class="line">-- 更新表，删除一个列-- </span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">DROP COLUMN vend_phone;</span><br><span class="line"></span><br><span class="line">-- 常见用途：定义外键-- </span><br><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders(order_num);</span><br></pre></td></tr></table></figure>

<p>使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</p>
<h2 id="删除和重命名表"><a href="#删除和重命名表" class="headerlink" title="删除和重命名表"></a>删除和重命名表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表-- </span><br><span class="line">DROP TABLE customers;</span><br><span class="line"></span><br><span class="line">-- 重命名表-- </span><br><span class="line">RENAME TABLE customers TO customers2;</span><br></pre></td></tr></table></figure>

<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图就是把类似SELECT语句的结果保存（但不是真实的保存了数据），在以后需要这些数据时直接用这个视图不用重新SELECT。因为视图<strong>不包含数据</strong>，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。</p>
<ul>
<li>视图用<code>CREATE VIEW</code>语句来创建。</li>
<li>使用<code>SHOW CREATE VIEW viewname；</code>来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为<code>DROP VIEW viewname;</code>。 </li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接用<code>CREATE OR REPLACE VIEW</code>。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图-- </span><br><span class="line">CREATE VIEW productcustomers AS</span><br><span class="line">SELECT cust_name,cust_contact,prod_id</span><br><span class="line">FROM customers,orders,orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">AND orderitems.order_num = orders.order_num;</span><br><span class="line"></span><br><span class="line">-- 使用视图-- </span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure>

<p>视图还可以用来格式化检索的结果，加入经常需要某个格式的结果。不必在每次需要时执行一些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 具有某种格式的视图-- </span><br><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>

<p>也可以用来过滤某些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 具有过滤功能的视图-- </span><br><span class="line">CREATE VIEW customeremaillist AS</span><br><span class="line">SELECT cust_id,cust_name,cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>

<p>视图与计算字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 包含计算字段的视图-- </span><br><span class="line">CREATE VIEM orderitemsexpanded AS </span><br><span class="line">SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems;</span><br></pre></td></tr></table></figure>

<p>通常，视图是<strong>可更新</strong>的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，<strong>实际上是对其基表增加或删除行</strong>。</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p>
<ul>
<li>分组（使用GROUP BY和HAVING）；</li>
<li>联结；</li>
<li>子查询；</li>
<li>并；</li>
<li>聚集函数（Min()、Count()、Sum()等）；</li>
<li>DISTINCT； </li>
<li>导出（计算）列。</li>
</ul>
<p>一般，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。</p>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。</p>
<p>使用存储过程的一些理由，换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能：</p>
<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作。</li>
<li>由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。</li>
<li>简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。</li>
<li>提高性能。因为使用存储过程比使用单独的SQL语句要快。</li>
<li>存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 创建存储过程，无参数-- </span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products; -- 注意这里有个分号，直接这样在命令行写会导致语句到这里就停止，有错误-- </span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 使用-- </span><br><span class="line">CALL productpricing();</span><br><span class="line"></span><br><span class="line">-- 删除，如果不存在将产生错误-- </span><br><span class="line">DROP PROCEDURE productpricing; -- 注意没有()-- </span><br><span class="line"></span><br><span class="line">-- 删除，如果不存在也不会产生错误-- </span><br><span class="line">DROP PROCEDURE productpricing IF EXISTS；</span><br></pre></td></tr></table></figure>

<p>对于mysql命令行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">默认的MySQL语句分隔符为;（正如你已经在迄今为止所使用的MySQL语句中所看到的那样）。mysql命令行实用程序也使用;作为语句分隔符。如果命令行实用程序要解释存储过程自身内的;字符，则它们最终不会成为存储过程的成分，这会使存储过程中的SQL出现句法错误。解决办法是临时更改命令行实用程序的语句分隔符，如下所示（delimiter是分隔符的意思）：</span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END//</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">其中，DELIMITER //告诉命令行实用程序使用//作为新的语句结束分隔符，可以看到标志存储过程结束的END定义为END //而不是END;。这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔符。</span><br><span class="line">除\符号外，任何字符都可以用作语句分隔符。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 有参数的存储过程-- </span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">	OUT pl DECIMAL(8,2),</span><br><span class="line">	OUT ph DECIMAL(8,2),</span><br><span class="line">	OUT pa DECIMAL(8,2))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT MIN(prod_price) INTO pl FROM products;</span><br><span class="line">	SELECT MAX(prod_price) INTO ph FROM products;</span><br><span class="line">	SELECT Avg(prod_price) INTO pa FROM products;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 使用-- </span><br><span class="line">CALL productpricing(@pricelow,@pricehigh,@priceaverage); -- 调用，但不返回结果，而是保存在变量里-- </span><br></pre></td></tr></table></figure>

<p>这个存储过程执行三条语句，接受3个参数，pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须<strong>具有指定的类型</strong>，这里使用十进制值。关键字<strong>OUT</strong>指出相应的参数用来从存储过程传出一个值（返回给调用者），关键字<strong>IN</strong>用来给存储过程传入一个值。通过指定<strong>INTO</strong>关键字，把检索的值保存到相应的变量。</p>
<p>记录集不是允许的类型，因此不能通过一个参数返回多个行和列。这就是前面的例子为什么要使用3个参数（和3 条SELECT语句）的原因。</p>
<ul>
<li><p>变量名：所有MySQL变量都必须以@开始。当传入这样一个@开始的变量时，会自动创建并保存。</p>
</li>
<li><p>然后可以检索这个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @priceaverage;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 有传入参数 --  </span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT SUM(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO ototal; -- 检索结果放入变量-- </span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 使用 -- </span><br><span class="line">CALL ordertotal(20005,@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>

<p>onumber定义为IN，因为订单号被传入存储过程。ototal定义为OUT，因为要从存储过程返回合计。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 一个复杂的例子--</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	IN taxable BOOLEAN,</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)COMMENT &#x27;obtain order total, optionally adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE total DECIMAL(8,2); -- 声明局部变量</span><br><span class="line">	DECLARE taxrate INT DEFAULT 6; -- 声明税率，默认为6%</span><br><span class="line">	</span><br><span class="line">	SELECT SUM(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO total;</span><br><span class="line">	</span><br><span class="line">	IF taxtable THEN</span><br><span class="line">		SELECT total+(total/100*taxrate) INTO total; -- 使用SELECT把计算式的结果检索，然后放入变量</span><br><span class="line">	END IF;</span><br><span class="line">	</span><br><span class="line">	SELECT total INTO ototal; -- 实际上，这个total局部变量有点没必要</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">--使用--</span><br><span class="line">CALL ordertotal(20005,0,@total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>

<p>添加了另外一个参数taxable，它是一个布尔值（如果要增加税则为真，否则为假）。在存储过程体中，用DECLARE语句定义了两个局部变量。DECLARE要求指定变量名和数据类型，它也支持可选的默认值（这个例子中的taxrate的默认被设置为6%）。IF语句检查taxable是否为真，如果为真，则用另一SELECT语句增加营业税到局部变量total。</p>
<ul>
<li>COMMENT关键字：本例子中的存储过程在CREATE PROCEDURE语句中包含了一个COMMENT值。它不是必需的，但如果给出，将在<code>SHOW PROCEDURE STATUS</code>的结果中显示。</li>
<li>IF语句：这个例子给出了MySQL的IF语句的基本用法。IF语句还支持ELSEIF和ELSE子句（前者还使用THEN子句，后者不使用）。在以后章节中我们将会看到IF的其他用法（以及其他流控制语句）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 检查CREATE创建存储过程时用到的语句--</span><br><span class="line">SHOW CREATE PROCEDURE ordertotal;</span><br><span class="line"></span><br><span class="line">-- 获取何时、由谁创建等详细信息的存储过程列表--</span><br><span class="line">SHOW PROCEDURE STATUS;</span><br><span class="line"></span><br><span class="line">-- 限制状态结果，使用LIKE过滤--</span><br><span class="line">SHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h2><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。不像多数DBMS，MySQL游标<strong>只能用于存储过程（和函数）</strong>。</p>
<p>游标用DECLARE语句创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建游标--</span><br><span class="line">CREATE PROCEDURE processorders() -- 存储过程</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR -- 创建游标</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>游标用OPEN CURSOR语句来打开，由CLOSE CURSOR语句关闭，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了。如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 打开游标--</span><br><span class="line">OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">-- 关闭游标--</span><br><span class="line">CLOSE ordernumbers;</span><br></pre></td></tr></table></figure>

<p>在一个游标被打开后，可以使用FETCH语句分别访问它的每一行(将<strong>自动从第一行开始</strong>）。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还<strong>向前移动</strong>游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	DECLARE o INT;</span><br><span class="line">	</span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	-- 获取一行数据</span><br><span class="line">	FETCH ordernumbers INTO o;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 使用循环--</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	DECLARE o INT;</span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	-- 定义处理器</span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1;</span><br><span class="line">	</span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	-- 开始循环</span><br><span class="line">	REPEAT</span><br><span class="line">		FETCH ordernumbers INTO o; -- 获取一行数据</span><br><span class="line">	-- 结束循环</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>与前一个例子不一样的是，这个例子中的FETCH是在REPEAT内，因此它反复执行直到done为真（由UNTIL done END REPEAT;规定）为使它起作用，用一个DEFAULT 0（假，不结束）定义变量done。</p>
<p><code>DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done=1;</code>这条语句定义了一个CONTINUE HANDLER，它是在<strong>条件出现时被执行的代码</strong>。它指出当SQLSTATE ‘02000’出现时，SET done&#x3D;1。SQLSTATE ‘02000’是一个<strong>未找到条件</strong>，当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- 复杂的例子--</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	-- 定义局部变量</span><br><span class="line">	DECLARE o INT;</span><br><span class="line">	DECLARE t DECIMAL(8,2);</span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	-- 定义游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	-- 定义处理器</span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1;</span><br><span class="line">	</span><br><span class="line">	-- 创建一个表来存储结果</span><br><span class="line">	CREATE TABLE IF NOT EXISTS ordertotals</span><br><span class="line">		(order_num INT,total DECIMAL(8,2));</span><br><span class="line">		</span><br><span class="line">	-- 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	-- 开始循环</span><br><span class="line">	REPEAT</span><br><span class="line">	</span><br><span class="line">		FETCH ordernumbers INTO o; -- 获取一行数据</span><br><span class="line">		CALL ordertotal(o,1,t); -- 这是存储过程章节中写的一个存储过程，因为变量定义过了，不用加@</span><br><span class="line">		INSERT INTO ordertotals(order_num,total)</span><br><span class="line">		VALUES(o,t); -- 插入表中</span><br><span class="line">		</span><br><span class="line">	-- 结束循环</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line">	</span><br><span class="line">	-- 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p>
<ul>
<li>DELETE； </li>
<li>INSERT； </li>
<li>UPDATE。</li>
</ul>
<p>其他MySQL语句不支持触发器。</p>
<p><strong>只有表才支持触发器，视图不支持（临时表也不支持）。</strong>每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。<strong>单一触发器不能与多个事件或多个表关联。</strong></p>
<p>在创建触发器时，需要给出4条信息：</p>
<ul>
<li>唯一的触发器名(尽可能保持每个数据库的触发器名唯一）；</li>
<li>触发器关联的表；</li>
<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li>
<li>触发器何时执行（处理之前或之后）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYSQL5以后，不允许触发器返回任何结果，因此使用into @变量名，将结果赋值到变量中，用select调用即可。修改为</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &#x27;Product added&#x27; INTO @asn;</span><br></pre></td></tr></table></figure>

<p>CREATE TRIGGER用来创建名为newproduct的新触发器。触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。这个触发器还指定FOR EACH ROW，因此代码对每个插入行执行。</p>
<p><em>如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除触发器--</span><br><span class="line">DROP TRIGGER newproduct;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<p><strong>在MySQL中用old和new表示执行前和执行后的数据。</strong></p>
<h3 id="INSERT触发器"><a href="#INSERT触发器" class="headerlink" title="INSERT触发器"></a>INSERT触发器</h3><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p>
<ul>
<li>在INSERT触发器代码内，可引用一个<strong>名为NEW的虚拟表</strong>，访问被插入的行；</li>
<li>在BEFORE INSERT触发器中，NEW中的值也<strong>可以被更新</strong>（允许更改被插入的值）； </li>
<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num INTO @asn;</span><br></pre></td></tr></table></figure>

<p>此代码创建一个名为neworder的触发器，它按照AFTER INSERT ON orders执行。在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。触发器从<strong>NEW. order_num</strong>取得这个值并返回它。此触发器必须<strong>按照AFTER INSERT执行</strong>，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。</p>
<p><em>通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。</em></p>
<h3 id="DELETE-触发器"><a href="#DELETE-触发器" class="headerlink" title="DELETE 触发器"></a>DELETE 触发器</h3><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p>
<ul>
<li>在DELETE触发器代码内，你可以引用一个<strong>名为OLD的虚拟表</strong>，访问被删除的行；</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archive_orders(order_num,order_date,cust_id)</span><br><span class="line">	VALUES(OLD.order_num,OLD.order_date,OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_ orders的存档表中。</p>
<p><em>使用BEGIN END块的好处是触发器能容纳多条SQL语句（在BEGIN END块中一条挨着一条）。</em></p>
<h3 id="UPDATE触发器"><a href="#UPDATE触发器" class="headerlink" title="UPDATE触发器"></a>UPDATE触发器</h3><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p>
<ul>
<li>在UPDATE触发器代码中，你可以引用一个<strong>名为OLD的虚拟表访问以前（UPDATE语句前）的值</strong>，引用一个<strong>名为NEW的虚拟表访问新更新的值</strong>；（这是因为INSERT不存在OLD（插入了就是新的），DELETE不存在NEW（删除的肯定的旧的））</li>
<li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW </span><br><span class="line">SET NEW.vend_state = Upper(NEW.vend_state);</span><br></pre></td></tr></table></figure>

<p>这个例子可以看出一些<strong>NEW的本质</strong>，实际上NEW中的值就是将要插入或更新的内容，当有触发器时，先写到NEW，再写到表中。因此这里在写到表前（BEFORE)，先对NEW中的内容进行改变（SET）。</p>
<h3 id="一些重点"><a href="#一些重点" class="headerlink" title="一些重点"></a>一些重点</h3><ul>
<li>创建触发器可能需要特殊的安全访问权限，但是，触发器的执行是自动的。如果INSERT、UPDATE或DELETE语句能够执行，则相关的触发器也能执行。</li>
<li>应该用触发器来<strong>保证数据的一致性</strong>（大小写、格式等）。在触发器中执行这种类型的处理的优点是它总是进行这种处理，而且是透明地进行，与客户机应用无关。</li>
<li>触发器的一种非常有意义的使用是<strong>创建审计跟踪</strong>。使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。</li>
<li>MySQL触发器中<strong>不支持CALL语句</strong>。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。</li>
</ul>
<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证<strong>成批的MySQL操作要么完全执行</strong>，要么完全不执行。</p>
<p>利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p>
<p>下面是关于事务处理需要知道的几个术语：</p>
<ul>
<li>事务（transaction）指一组SQL语句；</li>
<li>回退（rollback）指撤销指定SQL语句的过程；</li>
<li>提交（commit）指将未存储的SQL语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>事务处理用来管理<strong>INSERT</strong>、<strong>UPDATE</strong>和<strong>DELETE</strong>语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 开始事务--</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 撤销--</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 例子--</span><br><span class="line">SELECT * FROM ordertotals;</span><br><span class="line">START TRANSACTION; -- 开启事务</span><br><span class="line">DELETE FROM ordertotals; -- 删除</span><br><span class="line">SELECT * FROM ordertotals; -- 确实删除了</span><br><span class="line">ROLLBACK; -- 回退（撤销）</span><br><span class="line">SELECT * FROM ordertotals; -- 内容又存在了</span><br></pre></td></tr></table></figure>

<p>这个例子从显示ordertotals表的内容开始。首先执行一条SELECT以显示该表不为空。然后开始一个事务处理，用一条DELETE语句删除ordertotals中的所有行。另一条SELECT语句验证ordertotals确实为空。这时用一条ROLLBACK语句回退START TRANSACTION之后的所有语句，最后一条SELECT语句显示该表不为空。</p>
<p>显然，ROLLBACK只能在一个事务处理内使用（在执行一条STARTTRANSACTION命令之后）。</p>
<p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的<strong>隐含提交（implicit commit）</strong>，即提交（写或保存）操作是自动进行的。在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用<strong>COMMIT</strong>语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT; -- 提交</span><br></pre></td></tr></table></figure>

<p>最后的COMMIT语句<strong>仅在不出错时写出更改</strong>。如果第一条DELETE起作用，但第二条失败，则DELETE不会提交（实际上，它是被自动撤销的）。</p>
<p><em>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</em></p>
<p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。这些占位符称为保留点。为了创建占位符，可使用<strong>SAVEPOINT</strong>语句。每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建保留点--</span><br><span class="line">SAVEPOINT delete1;</span><br><span class="line"></span><br><span class="line">-- 回退保留点--</span><br><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>

<p>保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后<strong>自动释放</strong>。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。</p>
<p>如果要取消自动提交，可以用：<code>SET autocommit = 0;</code></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><p>数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和字符），适应不同的排序和检索数据的方法。在讨论多种语言和字符集时，将会遇到以下重要术语：</p>
<ul>
<li><strong>字符集</strong>为字母和符号的集合；</li>
<li><strong>编码</strong>为某个字符集成员的内部表示；</li>
<li><strong>校对</strong>为规定字符如何比较的指令。</li>
</ul>
<p><em><strong>校对为什么重要：</strong>排序英文正文很容易，对吗？或许不。考虑词APE、apex和Apple。它们处于正确的排序顺序吗？这有赖于你是否想区分大小写。使用区分大小写的校对顺序，这些词有一种排序方式，使用不区分大小写的校对顺序有另外一种排序方式。这不仅影响排序（如用ORDER BY排序数据），还影响搜索（例如，寻找apple的WHERE子句是否能找到APPLE）。在使用诸如法文à或德文ö这样的字符时，情况更复杂，在使用不基于拉丁文的字符集（日文、希伯来文、俄文等）时，情况更为复杂。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查看所支持的字符集完整列表--</span><br><span class="line">SHOW CHARACTER SET; </span><br><span class="line">-- 这条语句显示所有可用的字符集以及每个字符集的描述和默认校对。</span><br><span class="line"></span><br><span class="line">-- 查看所支持的校对的完整列表--</span><br><span class="line">SHOW COLLATION; </span><br><span class="line">-- 此语句显示所有可用的校对，以及它们适用的字符集。许多校对出现两次，一次区分大小写（由_cs表示），一次不区分大小写（由_ci表示）。</span><br></pre></td></tr></table></figure>

<p>通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，可以使用以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 百分号作为通配符，匹配0，1，多个任意字符--</span><br><span class="line">SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;collation%&#x27;;</span><br></pre></td></tr></table></figure>

<p>实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">	columnn1 INT,</span><br><span class="line">	columnn2 VARCHAR(10)</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果指定<strong>CHARACTER SET</strong>和<strong>COLLATE</strong>两者，则使用这些值。</li>
<li>如果只指定<strong>CHARACTER SET</strong>，则使用此字符集及其默认的校对（如SHOW CHARACTER SET的结果中所示）。 </li>
<li>如果既不指定CHARACTER SET，也不指定COLLATE，则使用数据库默认。</li>
</ul>
<p>MySQL还允许对每个列设置它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">	columnn1 INT,</span><br><span class="line">	columnn2 VARCHAR(10),</span><br><span class="line">	columnn3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>校对在对用ORDER BY子句检索出来的数据排序时起重要的作用。也可以在SELECT语句中排序时指定校对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM customers</span><br><span class="line">ORDER BY lastname,firstname COLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>

<p>上面的SELECT语句演示了在通常不区分大小写的表上进行区分大小写搜索的一种技术。当然，反过来也是可以的。</p>
<p>除了这里看到的在ORDER BY子 句中使用以外，COLLATE还可以用于<strong>GROUP BY、HAVING、聚集函数、别名</strong>等。</p>
<p>值得注意的是，如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数：</p>
<ul>
<li>类型转换<ul>
<li><code>cast(expr AS type)</code></li>
<li><code>convert(expr, type)</code></li>
</ul>
</li>
<li>编码转换<ul>
<li><code>cast(string AS CHAR[(N)] CHARACTER SET charset_name)</code></li>
<li><code>convert(expr USING transcoding_name)</code>或<code>convert(string, CHAR[(N)] CHARACTER SET charset_name</code></li>
</ul>
</li>
</ul>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>应该严肃对待root登录的使用。仅在绝对需要时使用它（或许在你不能登录其他管理账号时使用）。不应该在日常的MySQL操作中使用root。</p>
<p>mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列，它存储用户登录名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 获取所有用户账号列表--</span><br><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;</span><br></pre></td></tr></table></figure>

<p><strong>用户定义为user@host：</strong>MySQL的权限用用户名和主机名结合定义。如果不指定主机名，则使用默认的主机名%（授予用户访问权限而不管主机名）。**%代表所有ip段都可以使用这个用户<strong>，也可以指定host为某个ip或ip段，这样会</strong>仅允许在指定的ip主机使用该数据库用户**。</p>
<p>为了创建一个新用户账号，使用CREATE USER语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个新用户--</span><br><span class="line">CREATE USER ben IDENTIFIED BY &#x27;password&#x27;; </span><br></pre></td></tr></table></figure>

<p>CREATE USER创建一个新用户账号。在创建用户账号时不一定需要口令，不过这个例子用IDENTIFIED BY 给出了口令。</p>
<ul>
<li>IDENTIFIED BY指定的口令为纯文本，MySQL将在保存到user表之前对其进行加密。为了作为散列值指定口令，使用IDENTIFIED BY PASSWORD。</li>
<li>使用GRANT或INSERT：GRANT语句（稍后介绍）也可以创建用户账号，但一般来说<strong>CREATE USER是最清楚和最简单的句子</strong>。此外，也可以通过<strong>直接插入行到user表</strong>来增加用户，不过为安全起见，一般<strong>不建议这样做</strong>（不建议插入）。MySQL用来存储用户账号信息的表（以及表模式等）极为重要，对它们的任何毁坏都可能严重地伤害到MySQL服务器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 重命名一个账号--</span><br><span class="line">RENAME USER ben TO bforta;</span><br><span class="line"></span><br><span class="line">-- 删除用户--</span><br><span class="line">DROP USER bforta;</span><br></pre></td></tr></table></figure>

<p>在创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。为看到赋予用户账号的权限，使用SHOW GRANTS FOR:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查看用户权限--</span><br><span class="line">SHOW GRANTS FOR bforta;</span><br></pre></td></tr></table></figure>

<p>为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限；</li>
<li>被授予访问权限的数据库或表；</li>
<li>用户名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 设置单个权限--</span><br><span class="line">GRANT SELECT ON some_database.* TO bforta;</span><br><span class="line"></span><br><span class="line">-- 设置多个权限--</span><br><span class="line">GRANT SELECT,INSERT ON some_database.* TO bforta;</span><br></pre></td></tr></table></figure>

<p>此GRANT允许用户在some_database.*（some_database数据库的所有表）上使用SELECT（INSERT）。通过只授予SELECT访问权限，用户bforta对some_database数据库中的所有数据具有只读访问权限。</p>
<p>GRANT的反操作为REVOKE，用它来撤销特定的权限(被撤销的访问权限必须存在，否则会出错。)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON some_database.* FROM bforta;</span><br></pre></td></tr></table></figure>

<p>GRANT和REVOKE可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用GRANT ALL和REVOKE ALL； </li>
<li>整个数据库，使用ON database.*； </li>
<li>特定的表，使用ON database.table； </li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<p>下面列出可以授予或撤销的每个权限（前面是语句，后面是能拥有的功能）：</p>
<ul>
<li>ALL ：除GRANT OPTION外的所有权限</li>
<li>ALTER ：使用ALTER TABLE</li>
<li>ALTER ROUTINE ：使用ALTER PROCEDURE和DROP PROCEDURE</li>
<li>CREATE ：使用CREATE TABLE</li>
<li>CREATE ROUTINE ：使用CREATE PROCEDURE</li>
<li>CREATE TEMPORARY TABLES：使用CREATE TEMPORARY TABLE</li>
<li>CREATE USER ：使用CREATE USER、DROP USER、RENAME USER和REVOKE ALL PRIVILEGES</li>
<li>CREATE VIEW ：使用CREATE VIEW</li>
<li>DELETE ：使用DELETE</li>
<li>DROP ：使用DROP TABLE</li>
<li>EXECUTE ：使用CALL和存储过程</li>
<li>FILE ：使用SELECT INTO OUTFILE和LOAD DATA INFILE</li>
<li>GRANT OPTION ：使用GRANT和REVOKE</li>
<li>INDEX ：使用CREATE INDEX和DROP INDEX</li>
<li>INSERT ：使用INSERT</li>
<li>LOCK TABLES ：使用LOCK TABLES</li>
<li>PROCESS ：使用SHOW FULL PROCESSLIST</li>
<li>RELOAD ：使用FLUSH</li>
<li>REPLICATION CLIENT ：服务器位置的访问</li>
<li>REPLICATION SLAVE ：由复制从属使用</li>
<li>SELECT ：使用SELECT</li>
<li>SHOW DATABASES ：使用SHOW DATABASES</li>
<li>SHOW VIEW ：使用SHOW CREATE VIEW</li>
<li>SHUTDOWN ：使用mysqladmin shutdown（用来关闭MySQL）</li>
<li>SUPER ：使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER和SET GLOBAL。还允许mysqladmin调试登录</li>
<li>UPDATE ：使用UPDATE</li>
<li>USAGE ：无访问权限</li>
</ul>
<p>在使用GRANT和REVOKE时，<strong>用户账号必须存在</strong>，但对所涉及的<strong>对象没有这个要求</strong>。这允许管理员在创建数据库</p>
<p>和表之前设计和实现安全措施。这样做的副作用是，当某个数据库或表被删除时（用DROP语句），相关的访问权限<strong>仍然存在</strong>。而且，如果将来<strong>重新创建该数据库或表，这些权限仍然起作用</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 更改口令（密码）--</span><br><span class="line">SET PASSWORD FOR bforta = Passord(&#x27;new password&#x27;);</span><br></pre></td></tr></table></figure>

<p>SET PASSWORD更新用户口令。新口令必须传递到Password()函数进行加密。</p>
<p>在不指定用户名时（没有FOR bforta），SET PASSWORD更新当前登录用户的口令。</p>
<h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><p>像所有数据一样，MySQL的数据也必须经常备份。由于MySQL数据库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。</p>
<p>下面列出这个问题的可能解决方案：</p>
<ul>
<li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序）。 </li>
<li>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORETABLE来复原。</li>
</ul>
<p><strong>首先刷新未写数据：</strong>为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。</p>
<p>MySQL提供了一系列的语句，可以（应该）用来保证数据库正确和正常运行。</p>
<ul>
<li><p>ANALYZE TABLE，用来检查表键是否正确，返回如下表的一些状态信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE orders;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删除的链接并进行键检验，QUICK只进行快速扫描。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE orders,orderitems;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在排除<strong>系统启动问题</strong>时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行mysqld启动。下面是几个重要的mysqld命令行选项：</p>
<ul>
<li>–help显示帮助——一个选项列表；</li>
<li>–safe-mode装载减去某些最佳配置的服务器；</li>
<li>–verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）； </li>
<li>–version显示版本信息然后退出。</li>
</ul>
<p>MySQL维护管理员依赖的一系列<strong>日志文件</strong>。主要的日志文件有以下几种。</p>
<ul>
<li>错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。此日志名可用–log-error命令行选项更改。</li>
<li>查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用–log命令行选项更改。</li>
<li>二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL 5中添加的，以前的MySQL版本中使用的是更新日志。</li>
<li>缓慢查询日志。顾名思义，此日志记录执行缓慢的任何查询。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ，位于 data 目录中。此名字可以用–log-slow-queries命令行选项更改。</li>
</ul>
<p>在使用日志时，可用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p>
<h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ul>
<li>首先，MySQL（与所有DBMS一样）具有特定的硬件建议。在学习和研究MySQL时，使用任何旧的计算机作为服务器都可以。但对用于生产的服务器来说，应该坚持遵循这些硬件建议。</li>
<li><strong>一般来说，关键的生产DBMS应该运行在自己的专用服务器上。</strong></li>
<li>MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用SHOW VARIABLES;和SHOW STATUS;。）</li>
<li>MySQL一个<strong>多用户多线程</strong>的DBMS，换言之，它经常同时执行多个任务。如果这些任务中的<strong>某一个执行缓慢，则所有请求都会执行缓慢</strong>。如果你遇到显著的性能不良，可使用<strong>SHOW PROCESSLIST</strong>显示所有活动进程（以及它们的线程ID和执行时间）。你还可以用<strong>KILL命令</strong>终结某个特定的进程（使用这个命令需要作为管理员登录）。</li>
<li>总是有不止一种方法编写同一条SELECT语句。应该试验联结、并、子查询等，找出最佳的方法。</li>
<li>使用<strong>EXPLAIN</strong>语句让MySQL解释它将如何执行一条SELECT语句。（在 select 语句之前增加explain 关键字，MySQL 会在查询上设置一个标记，执行查询会返回执行计划的信息，并不会执行这条SQL。）</li>
<li>一般来说，<strong>存储过程执行得比一条一条地执行其中的各条MySQL语句快</strong>。</li>
<li>应该总是使用<strong>正确的数据类型</strong>。</li>
<li>决不要检索比需求还要多的数据。换言之，**不要用SELECT ***（除非你真正需要每个列）。</li>
<li>有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该<strong>关闭自动提交</strong>。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能。<strong>确定索引什么</strong>不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中<strong>使用的列</strong>（或几个列）就是需要<strong>索引的对象</strong>。</li>
<li>你的SELECT语句中有一系列复杂的OR条件吗？<strong>通过使用多条SELECT语句和连接它们的UNION语句</strong>，你能看到极大的性能改进。</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。）</li>
<li><strong>LIKE很慢</strong>。一般来说，最好是使用FULLTEXT而不是LIKE。</li>
<li>数据库是<strong>不断变化</strong>的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。</li>
</ul>
<p>关于索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/Weixiaohuai/article/details/109696261</span><br><span class="line"></span><br><span class="line">数据库索引是为了提高查询速度而对表字段附加的一种标识。简单来说，索引其实是一种数据结构。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</span><br><span class="line"></span><br><span class="line">首先我们需要明白为什么索引会提高查询速度，数据库在执行一条SQL语句的时候，默认扫描方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以数据库索引能明显提高查询的速度。</span><br><span class="line"></span><br><span class="line">下面列举几种适合建立索引的情况：</span><br><span class="line"></span><br><span class="line">1.经常在where条件中作为查询条件的字段可以建立索引；</span><br><span class="line">2.外键关联列可以建立索引；</span><br><span class="line">3.order by排序后面的字段可以建立索引；</span><br><span class="line">4.group by分组后的字段可以建立索引；</span><br><span class="line"></span><br><span class="line">当然，并不是所有情况下都适合建立索引，如下几种情况就不太适合建立索引：</span><br><span class="line"></span><br><span class="line">1.经常增、删、改的字段不适合建立索引，每次执行，索引需重新建立；</span><br><span class="line">2.数据过滤性很差的字段不适合建立索引，如性别字段；</span><br><span class="line">3.当表数据量过少的时候不太适合建立索引，因为索引占用存储空间；</span><br></pre></td></tr></table></figure>

<ul>
<li>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。</li>
<li>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</li>
<li>索引是对数据库表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行<strong>排序</strong>的结构。</li>
<li>例如这样一个查询：select * from table1 where id&#x3D;10000。如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于索引是经过某种<strong>算法优化过</strong>的，因而查找次数要少的多。可见，索引是用来定位的。</li>
<li>从数据搜索实现的角度来看，索引也是另外一类文件&#x2F;记录，它包含着可以指示出相关数据记录的各种记录。其中，每一索引都有一个相对应的搜索码，字符段的任意一个子集都能够形成一个搜索码。这样，索引就相当于所有数据目录项的一个集合，它能为既定的搜索码值的所有数据目录项提供定位所需的各种有效支持</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="串数据类型"><a href="#串数据类型" class="headerlink" title="串数据类型"></a>串数据类型</h2><ul>
<li>CHAR ：1～255个字符的定长串。它的长度必须在创建时指定，否则MySQL假定为CHAR(1)</li>
<li>ENUM ：接受最多64 K个串组成的一个预定义集合的某个串</li>
<li>LONGTEXT ：与TEXT相同，但最大长度为4 GB </li>
<li>MEDIUMTEXT ：与TEXT相同，但最大长度为16 K </li>
<li>SET：接受最多64个串组成的一个预定义集合的零个或多个串</li>
<li>TEXT ：最大长度为64 K的变长文本</li>
<li>TINYTEXT ：与TEXT相同，但最大长度为255字节</li>
<li>VARCHAR ：长度可变，最多不超过255字节。如果在创建时指定为VARCHAR(n)，则可存储0到n个字符的变长串（其中n≤255）</li>
</ul>
<p>不管使用何种形式的串数据类型，<strong>串值都必须括在引号内</strong>（通常单引号更好）。</p>
<p>当数值不是数值时：你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是，这样 做却是不可取的。<strong>如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。</strong></p>
<p>需要遵守的基本规则是：如果数值是计算（求和、平均等）中使用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p>
<h2 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h2><p>有符号或无符号：所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。有符号数值列可以存储正或负的数值，无符号数值列只能存储正数。默认情况为有符号，但如果你知道自己不需要存储负值，可以使用<strong>UNSIGNED</strong>关键字，这样做将允许你存储两倍大小的值。</p>
<ul>
<li>BIT ：位字段，1～64位。（在MySQL 5之前，BIT在功能上等价于TINYINT</li>
<li>BIGINT ：整数值，支持9223372036854775808～9223372036854775807（如果是UNSIGNED，为0~18446744073709551615）的数</li>
<li>BOOLEAN（或BOOL） ：布尔标志，或者为0或者为1，主要用于开&#x2F;关（on&#x2F;off）标志</li>
<li>DECIMAL（或DEC） ：精度可变的浮点值</li>
<li>DOUBLE ：双精度浮点值</li>
<li>FLOAT ：单精度浮点值</li>
<li>INT（或INTEGER） ：整数值，支持-2147483648～2147483647（如果是UNSIGNED， 为0～4294967295）的数</li>
<li>MEDIUMINT ：整数值，支持-8388608～8388607（如果是UNSIGNED，为0～16777215）的数</li>
<li>REAL ：4字节的浮点值</li>
<li>SMALLINT：整数值，支持-32768～32767（如果是UNSIGNED，为0～65535）的数</li>
<li>TINYINT ：整数值，支持-128～127（如果为UNSIGNED，为0～255）的数</li>
</ul>
<p>与串不一样，数值不应该括在引号内。</p>
<p>存储货币数据类型：MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)：总长度为8,小数位数为2位的数值，整数有效位为6。</p>
<h2 id="日期和时间数据类型"><a href="#日期和时间数据类型" class="headerlink" title="日期和时间数据类型"></a>日期和时间数据类型</h2><ul>
<li>DATE ：表示1000-01-01～9999-12-31的日期，格式为YYYY-MM-DD</li>
<li>DATETIME ：DATE和TIME的组合</li>
<li>TIMESTAMP ：功能和DATETIME相同（但范围较小）</li>
<li>TIME ：格式为HH:MM:SS</li>
<li>YEAR ：用2位数字表示，范围是70（1970年）～69（2069年），用4位数字表示，范围是1901年～2155年</li>
</ul>
<h2 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h2><ul>
<li>BLOB ：Blob最大长度为64 KB </li>
<li>MEDIUMBLOB ：Blob最大长度为16 MB </li>
<li>LONGBLOB ：Blob最大长度为4 GB </li>
<li>TINYBLOB ：Blob最大长度为255字节</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>写这篇博客比看书花的时间还要久 (；′⌒&#96;)</p>
<p>书上的内容并不太难，实际上，在写这篇博客的过程中，对书上的内容也有了自己的思路，因此在内容规划上有些许不同，不过章节上为了图方便就是按顺序来的。代码基本都自己又敲了一遍，有新的体会，其中也写了许多自己的见解和注释，补充了一些内容，但主要还是当日后复习用。</p>
<p>2022-08-01</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/06/20/STL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/STL%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">《STL源码剖析》学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 14:32:28" itemprop="dateCreated datePublished" datetime="2022-06-20T14:32:28+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 22:20:38" itemprop="dateModified" datetime="2023-02-08T22:20:38+08:00">2023-02-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>48k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>44 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重返C++，先从STL入手。这里会记录一些重点。</p>
<p>follow 侯捷大师的《STL源码剖析》</p>
<p><strong>声明</strong></p>
<p>博客大部分内容都来源于《STL源码剖析》这本书（copy了个人认为重要的部分，包括代码），对于一些不容易明白的地方会查找其他资料进行补充。</p>
<p>由于电子的文字版只有前四章，因此后面的章节只能截扫描版的图。由于cdn加速不稳定，图片可能要用<code>魔法</code>才能加载(′⌒&#96;) </p>
<h1 id="概念与基础"><a href="#概念与基础" class="headerlink" title="概念与基础"></a>概念与基础</h1><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>1.容器（containers）：各种数据结构，如vector, list, deque, set, map，用来存放数据。从实作的角度看，STL 容器是一种 class template。就体积而言，这一部份很像冰山在海面下的比率。</p>
<p>2.算法（algorithms）：各种常用算法如sort, search, copy, erase…。从实作的角度看，STL 算法是一种 function template。</p>
<p>3.迭代器（iterators）：扮演容器与算法之间的胶着剂，是所谓的「泛型指标」。共有五种类型，以及其它衍生变化。从实作的角度看，迭代器是一种将operator*, operator-&gt;, operator++, operator–等指标相关操作予以多载化的 class template。所有STL容器都附带有自己专属的迭代器—是的，只有容器设计者才知道如何巡访自己的元素。原生指标（native pointer）也是一种迭代器。</p>
<p>4.仿函式（functors）：行为类似函式，可做为算法的某种策略（policy）。从实作的角度看，仿函式是一种重载了 operator()的 class 或class template。一般函式指标可视为狭义的仿函式。</p>
<p>5.配接器（adapters）：一种用来修饰容器（containers）或仿函式（functors）或迭代器（iterators）接口的东西。例如 STL 提供的 queue 和stack，虽然看似容器，其实只能算是一种容器配接器，因为它们的底部完全借重 deque，所有动作都由底层的 deque供应。改变functor接口者，称为function adapter，改变container接口者，称为container adapter，改变iterator界面者，称为iterator adapter。配接器的实作技术很难一言以蔽之，必须逐一分析。</p>
<p>6.配置器（allocators）：负责空间配置与管理，详见第 2 章。从实作的角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。 </p>
<p><strong>STL六大组件的交互关系：</strong>Container透过Allocator取得数据储存空间，Algorithm透过Iterator存取Container内容，Functor可以协助 Algorithm完成不同的策略变化，Adapter可以修饰或套接 Functor。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="image-20220620143742620"></p>
<h2 id="SGI-STL文件分布与简介"><a href="#SGI-STL文件分布与简介" class="headerlink" title="SGI STL文件分布与简介"></a>SGI STL文件分布与简介</h2><p>概略可分为五组： </p>
<ul>
<li><p>C++标准规范下的 C 头文件（无扩展名），例如cstdio, cstdlib, cstring… </p>
</li>
<li><p>C++标准链接库中不属于 STL范畴者，例如 stream, string…相关文件。</p>
</li>
<li><p>STL标准头文件（无扩展名），例如vector, deque, list, map, algorithm, functional… </p>
</li>
<li><p><em>C++ Standard</em> 定案前，HP 所规范的 STL 头文件，例如vector.h, deque.h, list.h, map.h, algo.h, function.h… </p>
</li>
<li><p>SGI STL 内部文件（STL 真正实作于此），例如stl_vector.h, stl_deque.h, stl_list.h, stl_map.h, stl_algo.h, stl_function.h…</p>
</li>
</ul>
<h2 id="SGI-STL-的编译器组态设定-configuration"><a href="#SGI-STL-的编译器组态设定-configuration" class="headerlink" title="SGI STL 的编译器组态设定(configuration)"></a>SGI STL 的编译器组态设定(configuration)</h2><p>不同的<strong>编译器</strong>对C++语言的支持程度不尽相同。做为一个希望具备广泛移植能力的链接库，SGI STL 准备了一个环境组态文件&lt;stl_config.h&gt;，其中定义许多常数，标示某些状态的成立与否。所有 STL 头文件都会直接或间接含入这个组态文件，并以条件式写法，让前处理器（pre-processor）根据各个常数决定取舍哪一段程序码。</p>
<p>&lt;stl_config.h&gt;文件起始处有一份常数定义说明，然后即针对各家不同的编译器以及可能的不同版本，给予常数设定。</p>
<p>这里先介绍&lt;stl_config.h&gt;中的预定义<strong>组态配置项</strong>：</p>
<ul>
<li><p><strong>__STL_STATIC_TEMPLATE_MEMBER_BUG</strong></p>
<p>如果编译器无法处理static member of template classes(模板类静态成员)就定义</p>
</li>
<li><p><strong>__STL_CLASS_PARTIAL_SPECIALIZATION</strong></p>
<p>如果编译器支持 partial specialization of class templates(模板类偏特化)就定义。</p>
<p><strong>偏特化</strong>：模板为什么要特化，因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。</p>
<p>模板分为<strong>类模板</strong>与<strong>函数模板</strong>，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。</p>
<p>使用template定义类时可以使用const *等做特殊设计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//泛型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&#123;....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&lt;T*, <span class="type">const</span> T* &gt; &#123;....&#125;;<span class="comment">//偏特化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_FUNCTION_TMPL_PARTIAL_ORDER</strong></p>
<p>如果编译器支持partial ordering of function templates或者说partial specialization of function templates就定义，可以理解为对<strong>函数模板的重载</strong>的支持</p>
<p>对于一个函数模板，如果定义了另一个函数模板且函数名相同，会根据template的参数表进行调用，要注意的是，第二个函数模板需要知道参数，可以在函数后面加上例如，max&lt;T,T&gt;或者函数之前声明类struct&lt;T,T&gt;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T1 <span class="type">const</span>&amp; t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;In Bar&lt;T1, T2&gt;(&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&lt;<span class="type">int</span>, T2&gt;<span class="comment">//声明&lt;T1,T2&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;In Bar&lt;int, T2&gt;(&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 下列代码也可以</span></span><br><span class="line"><span class="comment">template&lt;typename T2&gt;</span></span><br><span class="line"><span class="comment">void operator()&lt;int, T2&gt;(int t1, T2 const&amp; t2)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">    std::cerr &lt;&lt; &quot;In Bar&lt;int, T2&gt;(&quot; &lt;&lt; t1 &lt;&lt; &quot;, &quot; &lt;&lt; t2 &lt;&lt; &quot;)\n&quot;;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T1 <span class="type">const</span>&amp; t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Bar&lt;T1, T2&gt; b;</span><br><span class="line">   <span class="built_in">b</span>(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_MEMBER_TEMPLATES</strong></p>
<p>如果编译器支持template members of classes 就定义，看英文就知道，模板类中<strong>嵌套模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">TT</span>&gt; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(TT a,TT b)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_LIMITED_DEFAULT_TEMPLAES</strong></p>
<p>用到前一个模板的模板形参的某一个具现体作为当前模板的模板形参的默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Se</span> = queue&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> test &#123;....&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_NON_TYPE_TMPL_PARAM_BUG</strong></p>
<p>测试类模板是否使用非类型模板参数（non-type template parameters），或着是否template 可以使用无参数类型模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> m_data[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        CTest&lt;<span class="number">10</span>&gt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非类型模板</strong>：非类型模板参数(nontype template parameters), 可以使用<strong>整型类型</strong>(integral type)，<strong>指针</strong>(pointer)或者是<strong>引用</strong>(reference);绑定非类型整数形参(nontype integral parameter) 的 实参(argument) 必须是<strong>常量表达式(constant expression, constexpr)<strong>；不能把</strong>普通的局部对象</strong>或者<strong>动态对象</strong> 绑定指针或引用的非类型形参, 可以使用<strong>全局类型</strong>进行绑定。</p>
</li>
<li><p><strong>__STL_NULL_TMPL_ARGS</strong></p>
<p>友元约束模板：可以依据之前对非友元函数的定义来对友元函数进行约束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T,Sequence&gt;&amp; x,<span class="type">const</span> stack&lt;T,Sequence&gt;&amp; y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//friend bool operator==&lt;T&gt;(const stack&lt;T&gt;&amp;,const stack&lt;T&gt;&amp;);</span></span><br><span class="line">    <span class="comment">//下面的都是等价于上面的</span></span><br><span class="line">    <span class="comment">//friend bool operator== &lt;T&gt;(const stack&amp;,const stack&amp;);</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== &lt;&gt;(<span class="type">const</span> stack&amp;,<span class="type">const</span> stack&amp;);</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T,Sequence&gt; &amp;x,<span class="type">const</span> stack&lt;T,Sequence&gt; &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cout&lt;&lt;<span class="string">&quot;operator==&quot;</span>&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; y;</span><br><span class="line">    cout&lt;&lt;(x==y)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; y1;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;(x==y1)&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_TEMPLATE_NULL</strong></p>
<p>即 template &lt;&gt; 显式的模板特化，对template进行具体化，在定义参数时就可以使用具体化的定义。函数同理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">test</span> &#123;....&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">test</span>&lt;<span class="type">int</span>&gt;&#123;.....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Any&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Any &amp;,Any &amp;b)</span></span>&#123;......;&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;,<span class="type">int</span> &amp;)&#123;......;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下是 GNU C++ 2.91.57 &lt;stl_config.h&gt;的完整内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CONFIG_H </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CONFIG_H </span></span><br><span class="line"><span class="comment">//文件所做的事情：</span></span><br><span class="line"><span class="comment">// (1) 如果编译器没有定义 bool, true, false，就定义它们</span></span><br><span class="line"><span class="comment">// (2) 如果编译器的标准链接库᳾支持 drand48()函式，就定义 __STL_NO_DRAND48 </span></span><br><span class="line"><span class="comment">// (3) 如果编译器无法处理 static members of template classes，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="comment">// (4) 如果编译器᳾支持关键词 typename，就将&#x27;typename&#x27;定义为一个 null macro. </span></span><br><span class="line"><span class="comment">// (5) 如果编译器支持 partial specialization of class templates，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_CLASS_PARTIAL_SPECIALIZATION. </span></span><br><span class="line"><span class="comment">// (6) 如果编译器支持 partial ordering of function templates（亦称为</span></span><br><span class="line"><span class="comment">// 		partial specialization of function templates），就定义</span></span><br><span class="line"><span class="comment">// 		__STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="comment">// (7) 如果编译器允许我们在呼叫一个 function template时可以明白指定其</span></span><br><span class="line"><span class="comment">// 		template arguments，就定义__STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="comment">// (8) 如果编译器支持 template members of classes，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_MEMBER_TEMPLATES. </span></span><br><span class="line"><span class="comment">// (9) 如果编译器不支持关键词 explicit，就定义&#x27;explicit&#x27;为一个 null macro. </span></span><br><span class="line"><span class="comment">// (10) 如果编译器无法根据前一个 template parameters设定下一个 template </span></span><br><span class="line"><span class="comment">// 		parameters 的默认值，就定义__STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="comment">// (11) 如果编译器针对 non-type template parameters 执行 function template </span></span><br><span class="line"><span class="comment">// 		的自变量推导（argument deduction）时有问题，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_NON_TYPE_TMPL_PARAM_BUG. </span></span><br><span class="line"><span class="comment">// (12) 如果编译器无法支持迭代器的 operator-&gt;，就定义</span></span><br><span class="line"><span class="comment">// 		__SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="comment">// (13) 如果编译器（在你所选择的模式中）支持 exceptions，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="comment">// (14) 定义__STL_USE_NAMESPACES 可使我们自动获得 using std::list;之类的叙句</span></span><br><span class="line"><span class="comment">// (15) 如果本链接库由 SGI编译器来编译，而且使用者并未选择 pthreads </span></span><br><span class="line"><span class="comment">// 		或其它 threads，就定义__STL_SGI_THREADS. </span></span><br><span class="line"><span class="comment">// (16) 如果ᴀ链接库由一个 WIN32 编译器编译，并且在多绪模式下，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_WIN32THREADS</span></span><br><span class="line"><span class="comment">// (17) 适当地定义与 namespace相关的 macros 如 __STD, __STL_BEGIN_NAMESPACE。</span></span><br><span class="line"><span class="comment">// (18) 适当地定义 exception 相关的 macros 如 __STL_TRY, __STL_UNWIND。</span></span><br><span class="line"><span class="comment">// (19) 根据__STL_ASSERTIONS是否定义，将 __stl_assert 定义为一个</span></span><br><span class="line"><span class="comment">// 		测试动作或一个 null macro。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _PTHREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_PTHREADS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) </span></span><br><span class="line"><span class="comment">//使用 SGI STL但却不是使用 GNU C++ </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_BOOL) <span class="comment">//没有BOOL就定义</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_TYPENAME_IS_KEYWORD) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_SGI_THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"># ifdef__GNUC__</span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;_G_config.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> <span class="comment">// 这里可看出 GNUC 2.8+ 的能力</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it. </span></span><br><span class="line"><span class="comment"> It should be upgraded to glibc 2.0 or later. */</span> </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_PTHREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__COMO__) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">//侯捷注：VC6的版ᴀ号码是 1200 </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(_MSC_VER) </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> _MSC_VER &gt; 1000 </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;yvals.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="comment">//此文件在 MSDEV\VC98\INCLUDE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NO_DRAND48 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> _MSC_VER &lt; 1100 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _CPPUNWIND </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _MT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_WIN32THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">//侯捷注：Inprise Borland C++builder也定义有此常数。</span></span><br><span class="line"><span class="comment">// C++Builder 的表现岂有如下所示这般差劲？</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__BORLANDC__) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NO_DRAND48 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _CPPUNWIND </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __MT__ </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_WIN32THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_NEED_BOOL) </span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>; </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> true 1 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> false 0 </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> typename<span class="comment">//侯捷：难道不该 #define typename class 吗？</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> explicit</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"># ifdef__STL_EXPLICIT_FUNCTION_TMPL_ARGS</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NULL_TMPL_ARGS<span class="string">&lt;&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NULL_TMPL_ARGS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"># ifdef__STL_CLASS_PARTIAL_SPECIALIZATION</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TEMPLATE_NULLtemplate<span class="string">&lt;&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TEMPLATE_NULL </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces </span></span><br><span class="line"><span class="comment">// without having to edit library headers. </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD std </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_NAMESPACE namespacestd &#123; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_NAMESPACE &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD_RELOPS std </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> __STL_USE_NAMESPACE_FOR_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TRY try </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CATCH_ALL catch(...) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_RETHROWthrow </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NOTHROWthrow() </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TRY </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CATCH_ALL <span class="keyword">if</span> (false) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_RETHROW </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NOTHROW </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_UNWIND(action) </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_ASSERTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr) \ </span></span><br><span class="line"> <span class="keyword">if</span> (!(expr)) &#123;<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s:%d STL assertion failure: %s\n&quot;</span>, \ </span><br><span class="line"> __FILE__, __LINE__,<span class="meta"># expr);abort(); &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span> </span></span><br><span class="line"><span class="comment">// Local Variables: </span></span><br><span class="line"><span class="comment">// mode:C++ </span></span><br><span class="line"><span class="comment">// End:</span></span><br></pre></td></tr></table></figure>

<p>下面这个小程序，用来测试 <strong>GCC</strong> 的常数设定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config.cpp </span></span><br><span class="line"><span class="comment">// test configurations defined in &lt;stl_config.h&gt; </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// which included &lt;stl_algobase.h&gt;, </span></span></span><br><span class="line"><span class="comment">// and then &lt;stl_config.h&gt; </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__sgi) </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__sgi&quot;</span> &lt;&lt; endl; <span class="comment">// none! </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__GNUC__) </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__GNUC__&quot;</span> &lt;&lt; endl; <span class="comment">// __GNUC__ </span></span><br><span class="line"> cout &lt;&lt; __GNUC__ &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; __GNUC_MINOR__ &lt;&lt; endl; <span class="comment">// 2 91 </span></span><br><span class="line"> <span class="comment">// cout &lt;&lt; __GLIBC__ &lt;&lt; endl; // __GLIBC__ undeclared </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_NO_DRAND48 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_NO_DRAND48 defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_NO_DRAND48 undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 5 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 6 </span></span><br><span class="line">...以下写法类似。详见文件 config.cpp（可自侯捷网站下载）。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下，由此可窥见 GCC 对各种 C++特性的支持程度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__GNUC__ </span><br><span class="line">2 91 </span><br><span class="line">__STL_NO_DRAND48 undefined </span><br><span class="line">__STL_STATIC_TEMPLATE_MEMBER_BUG undefined </span><br><span class="line">__STL_CLASS_PARTIAL_SPECIALIZATION defined </span><br><span class="line">__STL_FUNCTION_TMPL_PARTIAL_ORDER defined </span><br><span class="line">__STL_EXPLICIT_FUNCTION_TMPL_ARGS defined </span><br><span class="line">__STL_MEMBER_TEMPLATES defined </span><br><span class="line">__STL_LIMITED_DEFAULT_TEMPLATES undefined </span><br><span class="line">__STL_NON_TYPE_TMPL_PARAM_BUG undefined </span><br><span class="line">__SGI_STL_NO_ARROW_OPERATOR undefined </span><br><span class="line">__STL_USE_EXCEPTIONS defined </span><br><span class="line">__STL_USE_NAMESPACES undefined </span><br><span class="line">__STL_SGI_THREADS undefined </span><br><span class="line">__STL_WIN32THREADS undefined </span><br><span class="line">__STL_NO_NAMESPACES undefined </span><br><span class="line">__STL_NEED_TYPENAME undefined </span><br><span class="line">__STL_NEED_BOOL undefined </span><br><span class="line">__STL_NEED_EXPLICIT undefined </span><br><span class="line">__STL_ASSERTIONS undefined</span><br></pre></td></tr></table></figure>

<h2 id="C-一些特殊语法"><a href="#C-一些特殊语法" class="headerlink" title="C++ 一些特殊语法"></a>C++ 一些特殊语法</h2><h3 id="暂时对象产生与运用"><a href="#暂时对象产生与运用" class="headerlink" title="暂时对象产生与运用"></a>暂时对象产生与运用</h3><p>所谓暂时对象（临时对象），就是一种无名对象（unnamed objects）。它的出现如果不在程序员的预期之下（例如任何pass by value动作都会引发copy动作，于是形成一个暂时对象），往往造成效率上的负担。</p>
<p>有时候刻意制造一些暂时对象，却又是使程序干净清爽的技巧。刻意制造暂时对象的方法是，在型别名称之后直接加<strong>一对小括号</strong>，并可指定初值，例如Shape(3,5)或int(8)，其意义相当于<strong>唤起相应的constructor</strong>且<strong>不指定物件名称</strong> 。<br>STL 中将暂时对象技巧用于仿函式（functor）与算法搭配，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config-temporary-object.cpp </span></span><br><span class="line"><span class="comment">//ᴀ例测试仿函式用于 for_each() 的情形</span></span><br><span class="line"><span class="comment">// vc6[o] cb4[o] gcc[o] </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; elem)</span> <span class="comment">// operator() 多载化</span></span></span><br><span class="line"><span class="function"> </span>&#123; cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> ia[<span class="number">6</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;; </span><br><span class="line"> <span class="function">vector&lt; <span class="type">int</span> &gt; <span class="title">iv</span><span class="params">(ia, ia+<span class="number">6</span>)</span></span>; </span><br><span class="line"> <span class="comment">// print&lt;int&gt;() 是一个暂时对象，不是一个函式呼叫动作</span></span><br><span class="line"> for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行便是产生「function template具现体」print<int>的一个暂时对象。这个对象将被传入for_each()之中起作用。当for_each()结束，这个暂时对象也就结束了它的生命。</p>
<h3 id="静态常量整数成员在类内直接初始化"><a href="#静态常量整数成员在类内直接初始化" class="headerlink" title="静态常量整数成员在类内直接初始化"></a>静态常量整数成员在类内直接初始化</h3><p>如果 class内含 const static <em>integral</em> data member，那么根据 C++标准规格，可以在class之内直接给予初值。所谓<em>integral</em>泛指所有整数型别，不单只是指int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config-inclass-init.cpp </span></span><br><span class="line"><span class="comment">// test in-class initialization of static const integral members </span></span><br><span class="line"><span class="comment">// ref. C++ Primer 3/e, p.643 </span></span><br><span class="line"><span class="comment">// vc6[x] cb4[o] gcc[o] </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// expedient </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> _datai = <span class="number">5</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal = <span class="number">3L</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac = <span class="string">&#x27;c&#x27;</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datai &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datal &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datac &lt;&lt; endl; <span class="comment">// c </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="increment-x2F-decrement-x2F-dereference运算子"><a href="#increment-x2F-decrement-x2F-dereference运算子" class="headerlink" title="increment&#x2F;decrement&#x2F;dereference运算子"></a>increment&#x2F;decrement&#x2F;dereference运算子</h3><p>increment &#x2F; dereference 运算子在迭代器的实作上占有非常重要的地位，因为任何一个迭代器都必须实作出前进（<em>increment</em>,operator++ ）和取值（<em>dereference</em>, operator*）功能，前者还分为前置式（prefix）和后置式（postfix）两种，有非常规律的写法。有些迭代器具备双向移动功能，那么就必须再提供 decrement 运算子（也分前置式和后置式两种）。</p>
<h3 id="前闭后开区间表示法"><a href="#前闭后开区间表示法" class="headerlink" title="前闭后开区间表示法[)"></a>前闭后开区间表示法[)</h3><p>任何STL 算法都需要获得由一对迭代器（泛型指针）所表示的区间，表示操作范围，这一对所表示的区间是前闭后开的，[first ,lasr) 表示 first 到 last - 1。迭代器 last 所指的是「最后一个元素的下一位置」。这种<em>off by one</em>（偏移一格，或说 <em>pass the end</em>）的标示法，带来许多方便。</p>
<h3 id="function-call-函数调用-运算子（operator-）"><a href="#function-call-函数调用-运算子（operator-）" class="headerlink" title="function call(函数调用) 运算子（operator()）"></a>function call(函数调用) 运算子（operator()）</h3><p>函式呼叫动作（C++ 语法中的左右小括号）也可以被多载化（重载）。许多STL算法都提供两个版本，一个用于<strong>一般状况</strong>（例如排序时以递增方式排列），一个用于<strong>特殊状况</strong>（例如排序时由使用者指定以何种特殊关系进行排列）。像这种情况，需要使用者指定某个条件或某个策略，而条件或策略的背后由一整组动作构成，便需要某种特殊的东西来代表这「一整组动作」。代表「一整组动作」的，当然是<strong>函式</strong>。过去 C语言时代，欲将函式当做参数传递，唯有透过函式指针（pointer to function，或称 function pointer）才能达成。<br>但是函数指针使用时有缺点：1. 无法持有自己的状态（所谓区域状态，local states）；2.无法达到组件技术中的可配接性（adaptability）—也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>
<p>STL 算法的特殊版本所接受的所谓「条件」或「策略」或「一整组动作」，都以仿函式形式呈现。所谓仿函式（functor）就是使用起来像函式一样的东西。如果你针对某个 class 进行operator() 多载化，它就成为一个仿函式。</p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。</p>
<p>仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须<strong>重载 operator()</strong> 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p>
<p>使用：对类进行operator() 进行重载，这个类就是仿函数，可以通过编码使仿函数变为可配接的，对象当做函数名</p>
<p>优点：</p>
<ul>
<li>仿函数是对象，可以拥有成员函数和成员变量，即仿函数拥有状态(states)</li>
<li>每个仿函数都有自己的类型</li>
<li>仿函数通常比一般函数快（很多信息编译期确定）</li>
</ul>
<p>仿函数与函数指针相比的优势</p>
<ul>
<li>仿函数是一个类，是数据以及对数据操作的行为的集合，要成为仿函数必须重载<code>()</code>。函数指针是无法保存数据的，所以仿函数比函数指针功能更强，因为它<strong>可以保存数据</strong>，这一特性，是函数指针无法比拟的优势。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一章只是简单介绍了一下stl，包括组件基本内容和组件之间的关系，其实后面具体去了解了也就明白了。而组态部分比较繁杂（个人感觉），是关于编译器对stl支持程度的设定，这部分目前还不知道有什么作用、怎么去学习，因此也就没有具体去看，实际上后面的内容也基本与组态无关。</p>
<p>然后是一些特殊语法，没有讲多细致，后面具体学就行，注意前闭后开这个贯穿全文的条件即可。</p>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p><em>以STL 的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在一切组件（更具体地说是指容器，container）的背后，默默工作默默付出。但若以STL 的实作角度而言，第一个需要介绍的就是空间配置器，因为整个STL的操作对象（所有的数值）都存放在容器之内，而容器一定需要配置空间以置放数据。不先掌握空间配置器的原理，难免在观察其它 STL 组件的实作时处处遇到挡路石。</em></p>
<p><em>为什么不说allocator是内存配置器而说它是空间配置器呢？因为，空间不一定是内存，空间也可以是磁盘或其它辅助储存媒体。是的，你可以写一个 allocator，直接向硬盘取空间。以下介绍的是 SGI STL 提供的配置器，配置的对象，呃，是的，是内存 。</em></p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种type</span></span><br><span class="line">allocator::value_type </span><br><span class="line">allocator::pointer </span><br><span class="line">allocator::const_pointer </span><br><span class="line">allocator::reference </span><br><span class="line">allocator::const_reference </span><br><span class="line">allocator::size_type </span><br><span class="line">allocator::difference_type</span><br><span class="line">    </span><br><span class="line">allocator::rebind </span><br><span class="line"><span class="comment">//一个巢状的（nested）class template。class rebind&lt;U&gt;拥有唯一成员other，那是一个 typedef，代表allocator&lt;U&gt;。</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>() </span><br><span class="line"><span class="comment">//default constructor。//默认构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;) </span><br><span class="line"><span class="comment">//copy constructor。//拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;) </span><br><span class="line"><span class="comment">//泛化的copy constructor。//泛化的拷贝构造</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>() </span><br><span class="line"><span class="comment">//default constructor。//析构函数</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回某个对象的地址。算式a.address(x)等同于&amp;x。//返回某个对象的地址</span></span></span><br><span class="line"><span class="function">const_pointer <span class="title">allocator::address</span><span class="params">(const_reference x)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回某个const对象的地址。算式a.address(x)等同于&amp;x。//返回某个const对象的地址</span></span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n, cosnt <span class="type">void</span>* = <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//配置空间，足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来增进区域性（locality），或完全忽略之。</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p, size_type n)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//归还先前配置的空间。</span></span></span><br><span class="line"><span class="function">size_type <span class="title">allocator::max_size</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回可成功配置的最大量。</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer p, <span class="type">const</span> T&amp; x)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//等同于new(const void*) p) T(x)。//构造T对象</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//等同于p-&gt;~T()。//对象T的析构</span></span></span><br></pre></td></tr></table></figure>

<h3 id="设计一个简单的空间配置器JJ-allocator"><a href="#设计一个简单的空间配置器JJ-allocator" class="headerlink" title="设计一个简单的空间配置器	JJ::allocator"></a>设计一个简单的空间配置器	JJ::allocator</h3><p>根据前述的标准接口，我们可以自行完成一个 功能简单、接口不怎么齐全的allocator如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 2jjalloc.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _JJALLOC_ </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _JJALLOC_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// for placement new. </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span> <span class="comment">// for ptrdiff_t, size_t </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for exit() </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span> <span class="comment">// for UINT_MAX </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// for cerr </span></span></span><br><span class="line"><span class="keyword">namespace</span> JJ</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//使用operator new 分配空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> T* _allocate(<span class="type">ptrdiff_t</span> size, T*) &#123; </span><br><span class="line"> <span class="built_in">set_new_handler</span>(<span class="number">0</span>); <span class="comment">//注释1</span></span><br><span class="line"> T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));<span class="comment">//注释2 </span></span><br><span class="line"> <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123; </span><br><span class="line"> cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//使用operator delete回收空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _deallocate(T* buffer) &#123; </span><br><span class="line"> ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//在指定内存上构造一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1* p, <span class="type">const</span> T2&amp; value) &#123; </span><br><span class="line"> <span class="keyword">new</span>(p) <span class="built_in">T1</span>(value); <span class="comment">// placement new. invoke ctor of T1. </span></span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//析构一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr) &#123; </span><br><span class="line"> ptr-&gt;~<span class="built_in">T</span>(); </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//遵循allocator的标准定义相关结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> ptrdiff_tdifference_type; </span><br><span class="line"><span class="comment">// rebind allocator of type U </span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> allocator&lt;U&gt; other; </span><br><span class="line"> &#125;; </span><br><span class="line"><span class="comment">// hint used for locality. ref.[Austern],p189 </span></span><br><span class="line"> <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type n, <span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>&#123; _deallocate(p); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line">_construct(p, value); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;_destroy(p); &#125; </span><br><span class="line"> <span class="function">pointer <span class="title">address</span><span class="params">(reference x)</span> </span>&#123; <span class="keyword">return</span> (pointer)&amp;x; &#125; </span><br><span class="line"> <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(UINT_MAX/<span class="built_in">sizeof</span>(T)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; <span class="comment">// end of namespace JJ </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _JJALLOC_</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释1：<strong>set_new_handler(0);</strong></p>
<p>new_handler，顾名思义就是一个处理程序，当程序向内存的分配请求无法满足时将有两种可能:</p>
<ol>
<li>抛出异常</li>
<li>设置一个异常处理函数，这就是所谓的new_handler（类似于中断机制，本质上来说就是一个函数指针）</li>
</ol>
<p>当第二种情况发生以后，我们可以通过new_handler删除无用的内存，以及设置新的new_handler，而这个set_new_handler就是来进行设置的。</p>
<p>set_new_handler(0)主要是为了卸载目前的内存分配异常处理函数，这样一来一旦分配内存失败的话，C++就会强制性抛出std:bad_alloc异常，而不是跑到处理某个异常处理函数去处理。</p>
</li>
<li><p>注释2：*<em>T *tmp&#x3D;(T*)(::operator new((size_t)(size</em>sizeof(T)))); **<code>::</code>访问符放到最前面的意思是使用全局版本，这个<code>operator new</code>就得好好说说。</p>
<p><strong>new 的三种形式</strong></p>
<ul>
<li>1.new operator (就是我们常用的new)</li>
<li>2.operator new</li>
<li>3.placement new</li>
</ul>
<p>我们在程序中使用new的时候，实际上做了两件事情：<br>一、申请内存<br>二、构造对象<br>简单的理解，new完成了一套比较完备的服务，而<code>operator new</code>，只是申请内存，<code>placement new</code>是在申请的内存中进行构造对象，第2、3中形式就是对new的拆分。</p>
</li>
</ul>
<p><strong>简单应用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 2jjalloc.cpp </span></span><br><span class="line"><span class="comment">// VC6[o], BCB4[o], GCC2.9[x]. </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;jjalloc.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> i; </span><br><span class="line"> vector&lt;<span class="type">int</span>,JJ::allocator&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">iv</span>(ia, ia+<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); i++) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具备次配置力（sub-allocation）的-SGI-空间配置器"><a href="#具备次配置力（sub-allocation）的-SGI-空间配置器" class="headerlink" title="具备次配置力（sub-allocation）的 SGI 空间配置器"></a>具备次配置力（sub-allocation）的 SGI 空间配置器</h2><p>SGI STL 的配置器与众不同 ， 也与标准规范不同，其名称是alloc而非allocator，而且不接受任何自变量。换句话说如果你要在程序中明白采用SGI 配置器，不能采用标准写法：<code>vector&lt;int,**std::allocator&lt;int&gt;** &gt; iv;// in VC or CB</code>。</p>
<p>必须这么写：<code>vector&lt;int,**std::alloc**&lt;int&gt;&gt; iv; // in GCC </code></p>
<p>SGI STL allocator未能符合标准规格，这个事实通常不会对我们带来困扰，因为通常我们使用预设的空间配置器，很少需要自行指定配置器名称，而SGI STL的每一个容器都已经指定其预设的空间配置器为alloc。</p>
<h3 id="SGI-标准的空间配置器std-allocator"><a href="#SGI-标准的空间配置器std-allocator" class="headerlink" title="SGI 标准的空间配置器	std::allocator"></a>SGI 标准的空间配置器	std::allocator</h3><p>虽然 SGI 也定义有一个符合部份标准、名为allocator的配置器，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不彰，只把 C++的::operator new和::operator delete做一层薄薄的包装而已。</p>
<h3 id="SGI-特殊的空间配置器std-alloc"><a href="#SGI-特殊的空间配置器std-alloc" class="headerlink" title="SGI 特殊的空间配置器	std::alloc"></a>SGI 特殊的空间配置器	std::alloc</h3><p>allocator只是基层内存配置&#x2F;解放行为（也就是::operator new和::operator delete）的一层薄薄包装，并没有考虑到任何效率上的强化。SGI 另有法宝供本身内部使用。</p>
<p>一般而言，我们所习惯的 C++ 内存配置动作和释放动作是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; ... &#125;; </span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;<span class="comment">//配置内存，然后建构对象</span></span><br><span class="line"><span class="keyword">delete</span> pf; <span class="comment">//将对象解构，然后释放内存</span></span><br></pre></td></tr></table></figure>

<p>这其中的 new算式内含两阶段动作：</p>
<ul>
<li><p>(1) 呼叫::operator new配置内存；</p>
</li>
<li><p>(2) 呼叫Foo::Foo()建构对象内容。</p>
</li>
</ul>
<p>delete算式也内含两阶段动作：</p>
<ul>
<li><p>(1)呼叫 Foo::~Foo()将对象解构；</p>
</li>
<li><p>(2)呼叫::operator delete释放内存。</p>
</li>
</ul>
<p>为了精密分工，STL allocator决定将这两阶段动作区分开来。内存配置动作由alloc:allocate()负责，内存释放动作由alloc::deallocate()负责；对象建构动作由::construct()负责，对象解构动作由::destroy()负责。</p>
<p>STL标准规格告诉我们，配置器定义于<memory>之中，SGI <memory>内含以下两个文件：</p>
<p>#include &lt;stl_alloc.h&gt; &#x2F;&#x2F;负责内存空间的配置与释放</p>
<p>#include &lt;stl_construct.h&gt; &#x2F;&#x2F;负责对象内容的建构与解构</p>
<p>内存空间的配置&#x2F;释放与对象内容的建构&#x2F;解构，分别着落在这两个文件身上。其中&lt;stl_construct.h&gt;定义有两个基本函数：建构用的 construct()和解构用的destroy()。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/STL_memory%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="image-20220621205109870"></p>
<h3 id="建构和解构基本工具：construct-和-destroy"><a href="#建构和解构基本工具：construct-和-destroy" class="headerlink" title="建构和解构基本工具：construct() 和 destroy()"></a>建构和解构基本工具：construct() 和 destroy()</h3><p>下面是&lt;stl_construct.h&gt; 的部份内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span> <span class="comment">//欲使用placement new，需先含入此文件</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123; </span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T1</span>(value); <span class="comment">//placement new;唤起 T1::T1(value); 就是在指针p所指向的内存空间创建一个T1类型的对象，但是对象的内容是从T2类型的对象转换过来的（调用了T1的构造函数，T1::T1(value)）。在已有空间的基础上重新调整分配的空间，类似于realloc函数。这个操作就是把已有的空间当成一个缓冲区来使用，这样子就减少了分配空间所耗费的时间，因为直接用new操作符分配内存的话，在堆中查找足够大的剩余空间速度是比较慢的。</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是 destroy()第一版本，接受一个指标。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line">pointer-&gt;~<span class="built_in">T</span>(); <span class="comment">//唤起 dtor ~T() </span></span><br><span class="line"><span class="comment">//以下是 destroy()第二版本，接受两个迭代器。此函式设法找出元素的数值型别，</span></span><br><span class="line"><span class="comment">//进而利用 __type_traits&lt;&gt;求取最适当措施。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123; </span><br><span class="line">__destroy(first, last, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//判断元素的数值型别（value type）是否有trivial destructor </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; </span><br><span class="line">__destroy_aux(first, last, <span class="built_in">trivial_destructor</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果元素的数值型别（value type）有non-trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123; </span><br><span class="line"> <span class="keyword">for</span> ( ; first &lt; last; ++first) </span><br><span class="line"><span class="built_in">destroy</span>(&amp;*first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果元素的数值型别（value type）有trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125; <span class="comment">//什么也不做</span></span><br><span class="line"><span class="comment">//以下是 destroy()第二版本针对迭代器为 char*和 wchar_t*的特化版</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123;&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/construct()%E5%92%8Cdrestroy()%E7%A4%BA%E6%84%8F.png" alt="image-20220621211422260"></p>
<p>这两个做为建构、解构之用的函式被设计为全域函式，符合 STL 的规范。此外STL 还规定配置器必须拥有名为 construct()和destroy()的两个成员函式，然而真正在 SGI STL 中大显身手的那个名为 std::alloc 的配置器并未遵守此一规则。</p>
<p>上述construct()接受一个指标p和一个初值value，此函式的用途就是将初值设定到指标所指的空间上。C++ 的placement new运算子可用来完成此一 任务。</p>
<p>destroy()有两个版本，第一版本接受一个指标，准备将该指标所指之物解构掉。 这很简单，直接呼叫该对象的解构式即可。第二版本接受first和last两个迭代器（所谓迭代器，第三章有详细介绍），准备将[first,last)范围内的所有物件解构掉。我们不知道这个范围有多大，万一很大，而每个物件的解构式都无关痛痒（所谓 <em>trivial</em>destructor），那么一次次呼叫这些无关痛痒的解构式，对效率是一种蕲伤。</p>
<p>因此，这里首先利用value_type()获得迭代器所指物件的型别， 再利用 <code>__type_traits&lt;T&gt;</code> 判别该型别的解构式是否无关痛痒 。若是（<code>__true_type</code>），什么也不做就结束；若否（<code>__false_type</code>），这才以循环方式巡访整个范围，并在循环中每经历一个对象就呼叫第一个版本的 destroy()。</p>
<h3 id="空间的配置与释放std-alloc"><a href="#空间的配置与释放std-alloc" class="headerlink" title="空间的配置与释放	std::alloc"></a>空间的配置与释放	std::alloc</h3><p>看完了内存配置后的对象建构行为，和内存释放前的对象解构行为，现在我们来看看内存的配置和释放。</p>
<p>对象建构前的空间配置，和对象解构后的空间释放，由&lt;stl_alloc.h&gt;负责，SGI 对此的设计哲学如下： </p>
<ul>
<li>向 system heap要求空间。</li>
<li>考虑多绪（multi-threads）状态。</li>
<li>考虑内存不足时的应变措施。</li>
<li>考虑过多「小型区块」可能造成的内存破碎（fragment）问题。</li>
</ul>
<p><em>为了将问题控制在一定的复杂度内，以下的讨论以及所摘录的源码，皆排除多绪状态的处理。</em></p>
<p>C++的记忆体配置基本动作是::operator new() ，记忆体释放基本动作是::operator delete()。这两个全域函式相当于 C 的 malloc()和 free() 函式。是的，正是如此，SGI 正是以malloc() 和free() 完成内存的配置与释放。</p>
<p>考虑小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，第一级配置器直接使用 malloc()和free()，第二级配置器则视情况采用不同的策略：</p>
<ul>
<li><p>当配置区块超过128bytes，视之为「足够大」，便呼叫第一级配置器；</p>
</li>
<li><p>当配置区块小于 128bytes，视之为「过小」，为了降低额外负担（overhead），便采用复杂的memory pool整理方式，而不再求助于第一级配置器。整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于<code>__USE_MALLOC</code>是否被定义（可以轻易测试出来，SGI STL 并未定义<code>__USE_MALLOC</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc; </span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">//令 alloc为第一级配置器</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//令 alloc 为第二级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></span><br></pre></td></tr></table></figure>

<p>其 中 <code>__malloc_alloc_template</code>就 是 第 一 级 配 置 器 ，<code> __default_alloc__template</code>就是第二级配置器。再次提醒，<strong>alloc</strong>并不接受任何 template 型别参数。</p>
</li>
</ul>
<p>无论<strong>alloc</strong>被定义为第一级或第二级配置器，SGI 还为它再包装一个<strong>接口</strong>如下，使配置器的接口能够符合 STL规格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其内部四个成员函式其实都是单纯的转呼叫，呼叫传入之配置器（可能是第一级，也可能是第二级）的成员函式。这个接口使配置器的配置单位从 bytes转为个别元素的大小（sizeof(T)）。SGI STL 容器全都使用这个 simple_alloc 接口，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; <span class="comment">// 预设使用 alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt;data_allocator; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (...) </span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start); </span><br><span class="line"> &#125; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一、二级配置器的关系，接口包装，及实际运用方式，可于下图略见端倪。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E4%B8%8E%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8.png" alt="image-20220621214155381"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%85%8D%E7%BD%AE%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%BF%90%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="image-20220622142742725"></p>
<h3 id="第一级配置器-malloc-alloc-template"><a href="#第一级配置器-malloc-alloc-template" class="headerlink" title="第一级配置器	__malloc_alloc_template"></a>第一级配置器	__malloc_alloc_template</h3><p>第一级配置器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0 </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;new&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __THROW_BAD_ALLOC throw bad_alloc </span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> !defined(__THROW_BAD_ALLOC) </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __THROW_BAD_ALLOC cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; exit(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// malloc-based allocator. 通常比稍后介绍的 default alloc 速度慢，</span></span><br><span class="line"><span class="comment">//一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。</span></span><br><span class="line"><span class="comment">//以下是第一级配置器。</span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」。至于「非型别参数」inst，完全没派上用场。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">//以下都是函式指标，所代表的函式将用来处理内存不足的情况。</span></span><br><span class="line"><span class="comment">// oom : out of memory. </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">void</span> *result =<span class="built_in">malloc</span>(n);<span class="comment">//第一级配置器直接使用 malloc() </span></span><br><span class="line"> <span class="comment">// 以下，无法满足需求时，改用 oom_malloc() </span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n); </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//第一级配置器直接使用 free() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">void</span> * result =<span class="built_in">realloc</span>(p, new_sz);<span class="comment">//第一级配置器直接使用 realloc() </span></span><br><span class="line"> <span class="comment">// 以下，无法满足需求时，改用 oom_realloc() </span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz); </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它，</span></span><br><span class="line"><span class="comment">//指定你自己的 out-of-memory handler </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">void</span> (* old)() = __malloc_alloc_oom_handler; </span><br><span class="line">__malloc_alloc_oom_handler = f; </span><br><span class="line"> <span class="keyword">return</span>(old); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="comment">//初值为 0。有待客端设定。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="built_in">void</span> (* my_malloc_handler)(); </span><br><span class="line"> <span class="type">void</span> *result; </span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//不断尝试释放、配置、再释放、再配置…</span></span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; </span><br><span class="line"> (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。</span></span><br><span class="line"> result = <span class="built_in">malloc</span>(n); <span class="comment">//再次尝试配置内存。</span></span><br><span class="line"> <span class="keyword">if</span> (result) <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="built_in">void</span> (* my_malloc_handler)(); </span><br><span class="line"> <span class="type">void</span> *result; </span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//不断尝试释放、配置、再释放、再配置…</span></span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; </span><br><span class="line"> (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。</span></span><br><span class="line"> result = <span class="built_in">realloc</span>(p, n);<span class="comment">//再次尝试配置内存。</span></span><br><span class="line"> <span class="keyword">if</span> (result) <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//注意，以下直接将参数 inst指定为 0。</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>

<p>第一级配置器以malloc(), free(), realloc()等 C函式执行实际的内存配置、释放、重配置动作，并实作出类似 C++ new-handler的机制。它不能直接运用 C++ new-handler机制，因为它并非使用::operator new来配置内存。</p>
<p>所谓 C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务，在丢出<em>std::bad_alloc</em>异常状态之前，会先呼叫由客端指定的处理例程。此处理例程通常即被称为 new-handler。</p>
<h3 id="第二级配置器-default-alloc-template"><a href="#第二级配置器-default-alloc-template" class="headerlink" title="第二级配置器	__default_alloc_template"></a>第二级配置器	__default_alloc_template</h3><p>第二级配置器多了一些机制，避免太多小额区块造成内存的破碎。小额区块带来的其实不仅是内存破碎而已，配置时的额外负担（overhead）也是一大问题。额外负担永远无法避免，毕竟系统要靠这多出来的空间来管理内存，但是区块愈小，额外负担所占的比例就愈大、愈显得浪费。 额外负担图示如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9D%97%E9%A2%9D%E5%A4%96%E8%B4%9F%E6%8B%85.png" alt="image-20220622143926124"></p>
<p>SGI第二级配置器的作法是，如果区块够大，超过 128 bytes，就移交第一级配置器处理。当区块<strong>小于 128 bytes</strong>，则以<strong>内存池（memory pool）</strong>管理，此法又称为次层配置（sub-allocation）：每次配置一大块内存，并维护对应之自由串行（<em>free-list</em>）。下次若再有相同大小的内存需求，就直接从<em>free-lists</em>中拨出。如果客端释还小额区块，就由配置器回收到<em>free-lists</em>中—配置器除了负责配置，也负责回收。为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数（例如客端要求 30 bytes，就自动调整为 32 bytes），并维护 16 个 <em>free-lists</em>，各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。<em>free-lists</em> 的节点结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unionobj &#123; </span><br><span class="line"> <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link; </span><br><span class="line"> <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span> </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>或许会想，为了维护串行（lists），每个节点需要额外的指标（指向下一个节点），这不又造成另一种额外负担吗？这个顾虑是对的，但早已有好的解决办法。注意，上述obj所用的是union（联合），由于union之故，从其第一字段观之，obj可被视为一个指标，指向相同形式的另一个obj。从其第二字段观之，obj可被视为一个指标，指向实际区块，如下图。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%87%AA%E7%94%B1%E4%B8%B2%E8%A1%8C%E5%AE%9E%E4%BD%9C%E6%8A%80%E5%B7%A7.png" alt="image-20220622145056139"></p>
<p>一物二用的结果是，不会为了维护串行所必须的指针而造成内存的另一种浪费。这种技巧在强型（strongly typed）语言如 Java 中行不通，但是在非强型语言如 C++ 中十分普遍</p>
<p>注：<strong>Union</strong>在C++内存模型，可以理解为一块“共享内存”(不是多线（进）程概念中的共享内存)。Union开辟的大小，是其内部定义的所有元素中最大的元素。“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，已达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。</p>
<p>第二级配置器的部份实作内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;<span class="comment">//free-lists个数</span></span><br><span class="line"><span class="comment">//以下是第二级配置器。</span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」，且第二参数完全没派上用场。</span></span><br><span class="line"><span class="comment">//第一参数用于多绪环境下。本书不讨论多绪环境。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> <span class="comment">// ROUND_UP() 将 bytes上调至 8的倍数。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>)); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> unionobj &#123; <span class="comment">//free-lists 的节点构造</span></span><br><span class="line"> <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link; </span><br><span class="line"> <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span> </span><br><span class="line"> &#125;; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">// 16 个 free-lists </span></span><br><span class="line"> <span class="type">static</span> obj * volatilefree_list[__NFREELISTS]; </span><br><span class="line"><span class="comment">// 以下函式根据区块大小，决定使用第 n号 free-list。n 从 1 起算。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>); </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 传回一个大小为 n的对象，并可能加入大小为 n的其它区块到free list. </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="comment">// 配置一大块空间，可容纳 nobjs 个大小为 &quot;size&quot; 的区块。</span></span><br><span class="line"> <span class="comment">// 如果配置 nobjs个区块有所不便，nobjs可能会降低。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>; </span><br><span class="line"> <span class="comment">// Chunk allocation state. </span></span><br><span class="line"> <span class="type">static</span> <span class="type">char</span> *start_free;<span class="comment">//记忆池起始位置。只在 chunk_alloc()中变化</span></span><br><span class="line"> <span class="type">static</span> <span class="type">char</span> *end_free;<span class="comment">//记忆池结束位置。只在 chunk_alloc()中变化</span></span><br><span class="line"> <span class="type">static</span> <span class="type">size_t</span> heap_size; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后 */</span> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后 */</span> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//以下是 static data member 的定义与初值设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line">size_t__default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj *<span class="keyword">volatile</span> </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="空间配置函式-allocate"><a href="#空间配置函式-allocate" class="headerlink" title="空间配置函式	 allocate()"></a>空间配置函式	 allocate()</h3><p>身为一个配置器，__default_alloc_template 拥有配置器的标准介面函式allocate()。此函式首先判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就检查对应的 <em>free list</em>。如果<em>free list</em>之内有可用的区块，就直接拿来用，如果没有可用区块，就将区块大小上调至 8 倍数边界，然后呼叫refill()，准备为 <em>free list</em> 重新填充空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n must be &gt; 0 </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"> obj * result; </span><br><span class="line"><span class="comment">// 大于 128 就呼叫第一级配置器</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) </span><br><span class="line"> <span class="keyword">return</span>(malloc_alloc::<span class="built_in">allocate</span>(n)); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 寻找 16 个 free lists 中适当的一个</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"> result = *my_free_list; </span><br><span class="line"> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 没找到可用的 free list，准备重新填充 free list</span></span><br><span class="line"> <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n)); </span><br><span class="line"> <span class="keyword">return</span> r; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 调整 free list</span></span><br><span class="line"><span class="comment">//下节详述</span></span><br><span class="line"> *my_free_list = result -&gt; free_list_link; </span><br><span class="line"> <span class="keyword">return</span> (result); </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>区块自<em>free list</em>拨出的操作如下图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8C%BA%E5%9D%97%E8%87%AAfreelist%E8%B0%83%E5%87%BA.png" alt="image-20220622150916002"></p>
<h3 id="空间释还函式-deallocate"><a href="#空间释还函式-deallocate" class="headerlink" title="空间释还函式	 deallocate()"></a>空间释还函式	 deallocate()</h3><p>身为一个配置器，__default_alloc_template 拥有配置器标准介面函式deallocate()。此函式首先判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就找出对应的 <em>free list</em>，将区块回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以是 0 </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> obj *q = (obj *)p; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list; </span><br><span class="line"><span class="comment">// 大于 128 就呼叫第一级配置器</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123; </span><br><span class="line">malloc_alloc::<span class="built_in">deallocate</span>(p, n); </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 寻找对应的 free list</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"><span class="comment">// 调整 free list，回收区块</span></span><br><span class="line"> q -&gt; free_list_link = *my_free_list; </span><br><span class="line"> *my_free_list = q; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>区块回收纳入<em>free list</em>的动作，如下图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8C%BA%E5%9D%97%E5%9B%9E%E6%94%B6%E7%BA%B3%E5%85%A5freelist.png" alt="image-20220622151423842"></p>
<h3 id="重新充填-free-lists"><a href="#重新充填-free-lists" class="headerlink" title="重新充填 	free lists"></a>重新充填 	<em>free list</em>s</h3><p>讨论先前说过的 allocate()。当它发现<em>free list</em>中没有可用区块了，就呼叫refill() 准备为<em>free list</em>重新填充空间。新的空间将取自内存池（经由chunk_alloc()完成）。预设取得20个新节点（新区块），但万一内存池空间不足，获得的节点数（区块数）可能小于 20：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传回一个大小为 n的对象，并且有时候会为适当的freelist增加节点. </span></span><br><span class="line"><span class="comment">//假设 n已经适当上调至 8的倍数。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> nobjs = <span class="number">20</span>; </span><br><span class="line"><span class="comment">// 呼叫 chunk_alloc()，尝试取得 nobjs个区块做为 free list的新节点。</span></span><br><span class="line"> <span class="comment">// 注意参数 nobjs是pass by reference。</span></span><br><span class="line"> <span class="type">char</span> * chunk =<span class="built_in">chunk_alloc</span>(n, nobjs); <span class="comment">//下节详述</span></span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list; </span><br><span class="line"> obj * result; </span><br><span class="line"> obj * current_obj, * next_obj; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"><span class="comment">// 如果只获得一个区块，这个区块就拨给呼叫者用，free list无新节点。</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk); </span><br><span class="line"><span class="comment">// 否则准备调整 free list，纳入新节点。</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"><span class="comment">// 以下在 chunk空间内建立freelist</span></span><br><span class="line"> result = (obj *)chunk; <span class="comment">//这一块准备传回给客端</span></span><br><span class="line"><span class="comment">// 以下导引 free list指向新配置的空间（取自内存池）</span></span><br><span class="line"> *my_free_list = next_obj = (obj *)(chunk + n); </span><br><span class="line"><span class="comment">// 以下将 free list 的各节点串接起来。</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;<span class="comment">//从 1 开始，因为第 0 个将传回给客端</span></span><br><span class="line"> current_obj = next_obj; </span><br><span class="line"> next_obj = (obj *)((<span class="type">char</span> *)next_obj + n); </span><br><span class="line"> <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123; </span><br><span class="line"> current_obj -&gt; free_list_link = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> current_obj -&gt; free_list_link = next_obj; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池（memory-pool）"><a href="#内存池（memory-pool）" class="headerlink" title="内存池（memory pool）"></a>内存池（memory pool）</h3><p>从内存池中取空间给<em>free list</em>使用，是 chunk_alloc()的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设 size 已经适当上调至 8的倍数。</span></span><br><span class="line"><span class="comment">//注意参数 nobjs是pass by reference。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span>* </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"><span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">char</span> * result; </span><br><span class="line"> <span class="type">size_t</span> total_bytes = size * nobjs; </span><br><span class="line"> <span class="type">size_t</span> bytes_left = end_free - start_free;<span class="comment">// 内存池剩余空间</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间完全满足需求量。</span></span><br><span class="line"> result = start_free; </span><br><span class="line"> start_free += total_bytes;</span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间不能完全满足需求量，但足够供应一个（含）以上的区块。</span></span><br><span class="line"> nobjs = bytes_left/size; </span><br><span class="line"> total_bytes = size * nobjs; </span><br><span class="line"> result = start_free; </span><br><span class="line"> start_free += total_bytes; </span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间连一个区块的大小都无法提供。</span></span><br><span class="line"> <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>); </span><br><span class="line"><span class="comment">// 以下试着让内存池中的残余零头还有利用价值。</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 内存池内还有一些零头，先配给适当的 free list，因为其他free list区块可能更小</span></span><br><span class="line"><span class="comment">// 首先寻找适当的 free list。</span></span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list = </span><br><span class="line"> free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left); </span><br><span class="line"><span class="comment">// 调整 free list，将内存池中的残余空间编入。</span></span><br><span class="line"> ((obj *)start_free) -&gt; free_list_link = *my_free_list; </span><br><span class="line"> *my_free_list = (obj *)start_free; </span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">// 配置 heap 空间</span></span><br><span class="line"> start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get); </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123; </span><br><span class="line"><span class="comment">// heap 空间不足，malloc() 失败。</span></span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list, *p; </span><br><span class="line"><span class="comment">// 试着检视我们手上拥有的东西。这不会造成伤害。我们不打算尝试配置</span></span><br><span class="line"> <span class="comment">// 较小的区块，因为那在多行程（multi-process）机器上容易导致灾难</span></span><br><span class="line"><span class="comment">// 以下搜寻适当的 free list，</span></span><br><span class="line"> <span class="comment">// 所谓适当是指「尚有未用区块，且区块够大」之 free list。</span></span><br><span class="line"> <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; </span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i); </span><br><span class="line"> p = *my_free_list; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;<span class="comment">//free list 内尚有未用区块。</span></span><br><span class="line"> <span class="comment">// 调整 free list以释出未用区块</span></span><br><span class="line"> *my_free_list = p -&gt; free_list_link; </span><br><span class="line"> start_free = (<span class="type">char</span> *)p; </span><br><span class="line"> end_free = start_free + i; </span><br><span class="line"><span class="comment">// 递归呼叫自己，为了修正 nobjs。</span></span><br><span class="line"> <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); </span><br><span class="line"><span class="comment">// 注意，任何残余零头终将被编入适当的 free-list中备用。</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> end_free = <span class="number">0</span>; <span class="comment">// 如果出现意外（山穷水尽，到处都没内存可用了）</span></span><br><span class="line"><span class="comment">// 呼叫第一级配置器，看看out-of-memory机制能否尽点力</span></span><br><span class="line"> start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get); </span><br><span class="line"><span class="comment">// 这会导致掷出异常（exception），或内存不足的情况获得改善。</span></span><br><span class="line">     &#125; </span><br><span class="line"> heap_size += bytes_to_get; </span><br><span class="line"> end_free = start_free + bytes_to_get; </span><br><span class="line"> <span class="comment">// 递归呼叫自己，为了修正 nobjs。</span></span><br><span class="line"> <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的 chunk_alloc()函式以end_free - start_free 来判断内存池的“水量”。如果水量<strong>充足</strong>，就直接拨出 20 个区块传回给 <em>free list</em>。如果水量不足以提供 20 个区块，但还足够供应<strong>一个以上的区块</strong>，就拨出这不足20个区块的空间出去。这时候其pass by reference 的 nobjs 参数将被修改为实际能够供应的区块数。如果内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() <strong>从 heap 中配置内存</strong>，为内存池注入活水源头以应付需求。新水量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。</p>
<p>一个例子见下图，假设程序一开始，客端就呼叫chunk_alloc(32,20)，于是malloc()配置 40个 32bytes区块，其中第 1 个交出，另 19 个交给free_list[3] 维护，余20个留给内存池。接下来客端呼叫chunk_alloc(64,20)，此时free_list[7] 空空如也，必须向内存池要求支持。内存池只够供应 (32*20)&#x2F;64&#x3D;10 个 64bytes区块，就把这 10 个区块传回，第 1 个交给客端，余 9个由 free_list[7] 维护。此时内存池全空。接下来再呼叫chunk_alloc(96, 20)，此时 free_list[11] 空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以malloc()配 置 40+n（附加量）个 96bytes 区块，其中第 1 个交出，另 19 个交给 free_list[11] 维护，余 20+n（附加量）个区块留给内存池……。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%86%85%E5%AD%98%E6%B1%A0%E6%93%8D%E7%BB%83%E7%BB%93%E6%9E%9C.png" alt="image-20220622152750430"></p>
<p>万一整个<strong>system heap 空间都不够了</strong>（以至无法为内存池注入活水源头），malloc()行动失败，chunk_alloc()就四处寻找有无<strong>「尚有未用区块，且区块够大」之<em>free lists</em></strong>。找到的话就挖一块交出，找不到的话就<strong>呼叫第一级配置器</strong>。第一级配置器其实也是使用malloc()来配置内存，但它有 out-of-memory 处理机制（类似 new-handler 机制），或许有机会<strong>释放其它的内存</strong>拿来此处使用。如果可以，就成功，否则发出<strong><em>bad_alloc</em>异常</strong>。 </p>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义有五个全域函式，作用于未初始化空间上。这样的功能对于容器的实作很有帮助。</p>
<p>前两个函式是用于建构的construct()和用于解构的destroy()，另三个函式是uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()，分别对应于高阶函式copy()、fill()、fill_n()——这些都是 STL 算法。如果要使用本节的三个低阶函式，应该含入<memory>，不过SGI 把它们实际定义于<stl_uninitialized>。</p>
<h3 id="uninitialized-copy（复制迭代器）"><a href="#uninitialized-copy（复制迭代器）" class="headerlink" title="uninitialized_copy（复制迭代器）"></a>uninitialized_copy（复制迭代器）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputIterator：输入迭代器。支持对容器元素的逐个遍历，以及对元素的读取（input)；</span><br><span class="line">OutputIterator：输出迭代器。支持对容器元素的逐个遍历，以及对元素的写入（output)。</span><br><span class="line">ForwardIterator：前向迭代器。向前逐个遍历元素。可以对元素读取；</span><br><span class="line">BidirectionalIterator：双向迭代器。支持向前向后逐个遍历元素，可以对元素读取。</span><br><span class="line">RandomAccessIterator：随机访问迭代器。支持O(1)时间复杂度对元素的随机位置访问，支持对元素的读取。</span><br><span class="line"></span><br><span class="line">输出迭代器可以修改元素，这可能会导致内部结构的调整，进而导致原有的迭代器失效！可能的情况有：</span><br><span class="line">	结构和元素顺序变更：比如对map，set，priority_queue插入元素；</span><br><span class="line">	内存变化：比如对vector插入元素，可能导致重新申请内存并拷贝</span><br></pre></td></tr></table></figure>

<p>uninitialized_copy() 使我们能够将内存的配置与对象的建构行为分离开来。如果做为输出目的地的 [result, result+(last-first)) 范围内的每一个迭代器都指向未初始化区域，则 uninitialized_copy() 会使用copy constructor，为身为输入来源之 [first,last) 范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器 i，此函式会呼叫<code>construct(&amp;*(result+(i-first)),*i)</code>，产生*i的复制品，放置于输出范围的相对位置上。</p>
<p>如果需要实作一个容器，uninitialized_copy()这样的函式会带来很大的帮助，因为容器的全范围建构式（range constructor）通常以两个步骤完成：</p>
<ul>
<li><p>配置内存区块，足以包含范围内的所有元素。</p>
</li>
<li><p>使用uninitialized_copy()，在该内存区块上建构元素。</p>
</li>
</ul>
<p>C++标准规格书要求uninitialized_copy()具有 “<em>commit</em> or <em>rollback</em>“语意，意思是要不就<strong>「建构出所有必要元素」</strong>，要不就（当有任何一个copy constructor 失败时）<strong>「不建构任何东西」</strong>。</p>
<h3 id="uninitialized-fill-（填充给定对象的值）"><a href="#uninitialized-fill-（填充给定对象的值）" class="headerlink" title="uninitialized_fill （填充给定对象的值）"></a>uninitialized_fill （填充给定对象的值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>uninitialized_fill() 也能够使我们将内存配置与对象的建构行为分离开来。如果[first,last)范围内的每个迭代器都指向未初始化的内存，那么</p>
<p>uninitialized_fill()会在该范围内产生x（上式第三参数）的复制品。换句话说uninitialized_fill()会针对操作范围内的每个迭代器 i ，呼叫construct(&amp;*i, x)，在i所指之处产生x的复制品。</p>
<p>和 uninitialized_copy()一样，uninitialized_fill() 必须具备 “<em>commit</em> or <em>rollback</em>“语意，换句话说它要不就产生出所有必要元素，要不就不产生任何元素。如果有任何一个copy constructor丢出异常（exception），uninitialized_fill() 必须能够将已产生之所有元素解构掉。</p>
<h3 id="uninitialized-fill-n-（fill的不同参数写法）"><a href="#uninitialized-fill-n-（fill的不同参数写法）" class="headerlink" title="uninitialized_fill_n （fill的不同参数写法）"></a>uninitialized_fill_n （fill的不同参数写法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>uninitialized_fill_n()能够使我们将内存配置与对象建构行为分离开来。它会为指定范围内的所有元素设定相同的初值。</p>
<p>如果[first, first+n)范围内的每一个迭代器都指向未初始化的内存，那么uninitialized_fill_n()会呼叫copy constructor，在该范围内产生x（上式第三参数）的复制品。也就是说面对 [first,first+n)范围内的每个迭代器 i，uninitialized_fill_n()会呼叫construct(&amp;*i, x)，在对应位置处产生x 的复制品。</p>
<p>uninitialized_fill_n()也具有 “<em>commit</em> or <em>rollback</em>“语意：要不就产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常（exception），uninitialized_fill_n() 必须解构已产生的所有元素。 </p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h4><p>本函式接受三个参数：</p>
<ul>
<li><p>迭代器first指向欲初始化空间的起始处</p>
</li>
<li><p>n表示欲初始化空间的大小</p>
</li>
<li><p>x表示初值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIteratorfirst, Size n, <span class="type">const</span> T&amp;x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line"> <span class="comment">// 以上，利用 value_type() 取出 first的 value type. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 first 的 <em>value type</em>（详见下节），然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*)</span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 以下 __type_traits&lt;&gt; 技法，详见下节</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_typeis_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>POD</strong>意指 <strong>Plain Old Data</strong>，也就是纯量型别（scalar types）或传统的 C struct型别。POD型别必然拥有 <em>trivial</em>ctor&#x2F;dtor&#x2F;copy&#x2F;assignment函式，因此，可以对POD型别采取最有效率的初值填写手法，而对non-POD 型别采取最保险安全的作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);<span class="comment">//交由高阶函式执行。见第6节。//注：实际上就是走访容器，执行赋值构造函数（因为pod型必有assignment构造函数）</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果不是 POD 型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type) &#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur) </span><br><span class="line"> <span class="built_in">construct</span>(&amp;*cur, x); <span class="comment">//注：调用placement new</span></span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h4><p>本函式接受三个参数：</p>
<ul>
<li>迭代器first指向输入端的起始位置</li>
<li>迭代器last指向输入端的结束位置（前闭后开区间）</li>
<li>迭代器result指向输出端（欲初始化空间）的起始处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_copy(first, last, result,<span class="built_in">value_type</span>(result)); </span><br><span class="line"> <span class="comment">// 以上，利用 value_type() 取出 first的 value type. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_copy(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, T*) &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result,<span class="built_in">is_POD</span>()); </span><br><span class="line"> <span class="comment">// 以上，企图利用 is_POD() 所获得的结果，让编译器做自变量推导。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, </span><br><span class="line">__true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">copy</span>(first, last, result);<span class="comment">//呼叫 STL算法 copy() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果是 non-POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, </span><br><span class="line">__false_type) &#123; </span><br><span class="line"> ForwardIterator cur = result; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; first != last; ++first, ++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, *first);<span class="comment">//必须一个一个元素地建构，无法批量进行</span></span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对char<em>和wchar_t</em>两种型别，可以最具效率的作法memmove（直接搬移内存内容）来执行复制行为。因此 SGI 得以为这两种型别设计一份特化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是针对 const char*的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>*<span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">char</span>* result)</span> </span>&#123; </span><br><span class="line"><span class="built_in">memmove</span>(result, first, last - first); </span><br><span class="line"> <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是针对 const wchar_t* 的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">wchar_t</span>* result)</span> </span>&#123; </span><br><span class="line"><span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last - first)); </span><br><span class="line"> <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h4><p>本函式接受三个参数：</p>
<ul>
<li>迭代器first指向输出端（欲初始化空间）的起始处</li>
<li>迭代器last指向输出端（欲初始化空间）的结束处（前闭后开区间） </li>
<li>x表示初值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line">__uninitialized_fill(first, last, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 first 的 <em>value type</em>，然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, T1*) &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD; </span><br><span class="line">__uninitialized_fill_aux(first, last, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, __true_type) </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">fill</span>(first, last, x);<span class="comment">//呼叫 STL算法 fill() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果是 non-POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> </span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, __false_type) </span><br><span class="line">&#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; cur != last; ++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, x);<span class="comment">//必须一个一个元素地建构，无法批量进行</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是三个内存基本函数的泛型版本和特化版本图示</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%B8%89%E4%B8%AA%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%89%88%E6%9C%AC%E5%92%8C%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC.png" alt="image-20220622225921035"></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>空间配置器是最底层的操作之一，STL把传统的new（new operator）分成两步来做（这是核心），也即operator new（配置内存）和placement new（建构元素）。其中建构元素的操作对应使用construct()和destroy()函数，配置内存的操作使用allocate()和deallocate()函数。（分开来可以提高效率，比如重新建构元素就不用直接从分配空间开始，用原来的空间即可）</p>
<p>配置内存分为一级配置和二级配置，根据<code>__USE_MALLOC </code>是否定义区分使用，如果为true则为第一级配置器。第一级配置器直接使用malloc(), free(), realloc()等 C函式执行实际的内存动作（包括自定义handler）。第二级配置器的作法是，如果区块够大，超过 128 bytes，就移交第一级配置器处理。当区块小于 128 bytes，则以内存池（memory pool）管理。首先第二级配置器有一个串行，有16个节点，每个节点有许多内存区块，大小为8*（n+1），其中n是节点编号。每次调用allocate()就找合适的区块，deallocate()把区块空间归还即可。而内存池负责给予串行内存区块，涉及内存不够时的一些其他操作（比如从其他区块拿，或者从堆拿空间）。</p>
<p>在泛型的同时判别一些特化版本，进一步提高效率。</p>
<h1 id="迭代器（iterators）概念-与traits-编程技法"><a href="#迭代器（iterators）概念-与traits-编程技法" class="headerlink" title="迭代器（iterators）概念 与traits 编程技法"></a>迭代器（iterators）概念 与traits 编程技法</h1><p>迭代器（iterators）是一种抽象的设计概念，现实程序语言中并没有直接对映于这个概念的实物。《<em>Design Patterns</em>》一书提供有 23 个设计样式（design patterns）的完整描述，其中 <em>iterator</em> 样式定义如下：提供一种方法，俾得依序巡访某个聚合物（容器）所含的各个元素，而又无需曝露该聚合物的内部表述方式。</p>
<h2 id="迭代器设计思维—STL-关键所在"><a href="#迭代器设计思维—STL-关键所在" class="headerlink" title="迭代器设计思维—STL 关键所在"></a>迭代器设计思维<strong>—</strong>STL 关键所在</h2><p>STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++ 的 class templates 和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题。</p>
<p>以下是容器、算法、迭代器（iterator，扮演黏胶角色）的合作展示。以算法 find() 为例，它接受两个迭代器和一个「搜寻标的」：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摘自 SGI &lt;stl_algo.h&gt; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, </span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">while</span> (first != last &amp;&amp; *first != value) </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要给予不同的迭代器，find()便能够对不同的容器做搜寻动作。</p>
<h2 id="迭代器（iterator）是一种-smart-pointer"><a href="#迭代器（iterator）是一种-smart-pointer" class="headerlink" title="迭代器（iterator）是一种 smart pointer"></a>迭代器（iterator）是一种 smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是<strong>内容提领（<em>dereference</em>）</strong>和<strong>成员取用（member access）</strong>，因此迭代器最重要的编程工作就是对 <strong>operator</strong>* 和 <strong>operator-&gt;</strong> 进行多载化（<em>overloading</em>）工程。</p>
<p>C++ 标准链接库有一个auto_ptr可供我们参考。任何一本详尽的 C++ 语法书籍都应该谈到auto_ptr，这是一个用来包装原生指标（native pointer）的对象，声名狼藉的内存漏洞（memory leak）问题可藉此获得解决。auto_ptr用法如下，和原生指标一模一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;jjhou&quot;</span>))</span></span>; </span><br><span class="line"> cout &lt;&lt; *ps &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; ps-&gt;<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">//输出：jjhou </span></span><br><span class="line"><span class="comment">//输出：5 </span></span><br><span class="line"><span class="comment">// 离开前不需 delete, auto_ptr 会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函式第一行的意思是，以算式new 动态配置一个初值为”jjhou”的string物件，并将所得结果（一个原生指针）做为<code>auto_ptr&lt;string&gt;</code>对象的初值。注意，auto_ptr 角括号内放的是<strong>「原生指针所指对象」</strong>的型别，而不是<strong>原生指标</strong>的型别。</p>
<p>auto_ptr的源码在头文件<memory>中，这里就不给出了。</p>
<p>现在来为list（串行）设计一个迭代器。假设 list 及其节点的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 3mylist.h </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> <span class="comment">//容器</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream &amp;os = std::cout)</span> <span class="type">const</span></span>; </span><br><span class="line"> <span class="comment">// ... </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> ListItem&lt;T&gt;* _end; </span><br><span class="line"> ListItem&lt;T&gt;* _front; </span><br><span class="line"> <span class="type">long</span> _size; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span> <span class="comment">//节点结构，值和指针</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125; </span><br><span class="line"> <span class="function">ListItem* <span class="title">next</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _next; &#125; </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> T _value; </span><br><span class="line"> ListItem* _next; <span class="comment">// 单向串行（single linked list）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要将这个List套用到先前所说的find()，需要为它设计一个行为类似指标的外衣，也就是一个迭代器。当我们提领（<em>dereference</em>）此一迭代器（用***<strong>），传回的应该是个ListItem 对象；当我们累加该迭代器（用</strong>++**），它应该指向下一个ListItem 物件。为了让此迭代器适用于任何型态的节点，而不只限于ListItem，我们可以将它设计为一个 class template： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 3mylist-iter.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;3mylist.h&quot;</span> </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt; <span class="comment">// Item 可以是单向串行节点或双向串行节点。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span> <span class="comment">//此处这个迭代器特定只为串行服务，因为其</span></span><br><span class="line">&#123; <span class="comment">//独特的 operator++ 之故。</span></span><br><span class="line"> Item* ptr;<span class="comment">//保持与容器之间的一个联系（keep a reference to Container）</span></span><br><span class="line"> <span class="built_in">ListIter</span>(Item* p = <span class="number">0</span>) <span class="comment">// default ctor </span></span><br><span class="line"> : <span class="built_in">ptr</span>(p) &#123; &#125; </span><br><span class="line"><span class="comment">// 不必实作 copy ctor，因为编译器提供的预设行为已足够。</span></span><br><span class="line"> <span class="comment">// 不必实作 operator=，因为编译器提供的预设行为已足够。</span></span><br><span class="line"> Item&amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; <span class="comment">//注：返回一个左值，可以赋值，要用引用</span></span><br><span class="line"> Item*<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125; <span class="comment">//注：返回一个指针</span></span><br><span class="line"><span class="comment">// 以下两个 operator++ 遵循标准作法，参见[Meyers96]条款 6 </span></span><br><span class="line"><span class="comment">// (1) pre-increment operator </span></span><br><span class="line"> ListIter&amp;<span class="keyword">operator</span>++() </span><br><span class="line"> &#123; ptr = ptr-&gt;<span class="built_in">next</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line"><span class="comment">// (2) post-increment operator </span></span><br><span class="line"> ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)<span class="comment">//注：tmp是临时变量，因此函数返回类型不能用引用，也不是左值</span></span><br><span class="line"> &#123; ListIter tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span> </span><br><span class="line"> &#123; <span class="keyword">return</span> ptr == i.ptr; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span> </span><br><span class="line"> &#123; <span class="keyword">return</span> ptr != i.ptr; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们可以这样子将 List和find()藉由ListIter 黏合起来（使自己设计的List能通过ListIter来使用find()）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3mylist-iter-test.cpp </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> List&lt;<span class="type">int</span>&gt; mylist; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123; </span><br><span class="line"> mylist.<span class="built_in">insert_front</span>(i); </span><br><span class="line"> mylist.<span class="built_in">insert_end</span>(i+<span class="number">2</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> mylist.<span class="built_in">display</span>(); <span class="comment">// 10 ( 4 3 2 1 0 2 3 4 5 6 ) </span></span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">begin</span>(mylist.<span class="built_in">front</span>()); </span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt;end; <span class="comment">// default 0, null </span></span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; iter; <span class="comment">// default 0, null</span></span><br><span class="line"> iter = <span class="built_in">find</span>(begin, end, <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (iter == end) </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;found. &quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 执行结果：found. 3 </span></span><br><span class="line"> iter = <span class="built_in">find</span>(begin, end, <span class="number">7</span>); </span><br><span class="line"> <span class="keyword">if</span> (iter == end) </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;found. &quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 执行结果：not found </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于find()函式内以*iter !&#x3D; value来检查元素值是否吻合，而本例之中value的型别是int，iter的型别是<code>ListItem&lt;int&gt;</code>，两者之间并无可供使用的operator!&#x3D;，所以我必须另外写一个全域的operator!&#x3D;多载函式，并以int和<code>ListItem&lt;int&gt;</code>做为它的两个参数型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListItem&lt;T&gt;&amp; item,T n) </span><br><span class="line">&#123; <span class="keyword">return</span> item.<span class="built_in">value</span>() != n; &#125;</span><br></pre></td></tr></table></figure>

<p>从以上实作可以看出，为了完成一个针对 List 而设计的迭代器，我们无可避免地 曝露了太多List实作细节：在main()之中为了制作begin和end两个迭代器，我们曝露了ListItem；在ListIter class之中为了达成operator++的目的，我们曝露了 ListItem 的操作函式next()。</p>
<p>如果不是为了迭代器，ListItem 原本应该完全隐藏起来不曝光的。换句话说，要设计出 ListIter，首先必须对 List 的实作细节有非常丰富的了解。既然这无可避免，干脆就把迭代器的开发工作交给List的设计者好了，如此一来所有实作细节反而得以封装起来不被使用者看到。这正是为什么每一种 STL容器都提供有专属迭代器的缘故。</p>
<h2 id="迭代器相应型别（associated-types）"><a href="#迭代器相应型别（associated-types）" class="headerlink" title="迭代器相应型别（associated types）"></a>迭代器相应型别（associated types）</h2><p>上述的ListIter提供了一个迭代器雏形。如果将思想拉得更高远一些，我们便会发现，算法之中运用迭代器时，很可能会用到其相应型别（associated type）。什么是相应型别？迭代器所指之物的型别便是其一。</p>
<p>假设算法中有必要宣告一 个变量，以「迭代器所指对象的型别」为型别，如何是好？毕竟C++只支援**sizeof()<strong>，并未支持</strong>typeof()**。</p>
<p>解决办法是：利用 function template （函数模板）的<strong>自变量推导（argument deducation）</strong>机制，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span> <span class="comment">//多了类型T，T是迭代器指向对象的类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> T tmp; <span class="comment">// 这里解决了问题。T就是迭代器所指之物的型别，本例为 int </span></span><br><span class="line"><span class="comment">// ... 这里做原本 func()应该做的全部工作</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">func_impl</span>(iter,*iter);<span class="comment">// func 的工作全部移往 func_impl </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="built_in">func</span>(&amp;i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以func()为对外界面，却**把实际动作全部置于func_impl() **之中。由于func_impl()是一个 function template，一旦被呼叫，编译器会自动进行 template 自变量推导。于是导出型别T，顺利解决了问题。</p>
<p>迭代器相应型别（associated types）不只是「迭代器所指对象的型别」一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template自变量推导机制来取得。我们需要更全面的解法。</p>
<h2 id="Traits-编程技法——STL-源码门钥"><a href="#Traits-编程技法——STL-源码门钥" class="headerlink" title="Traits 编程技法——STL 源码门钥"></a>Traits 编程技法——STL 源码门钥</h2><p>迭代器所指物件的型别，称为该迭代器的<em>value type</em>。上述的自变量型别推导技巧虽然可用于 <em>value type</em>，却非全面可用：万一<em>value type</em>必须用于函式的传回值，就束手无策了，毕竟函式的「template 自变量推导机制」推而导之的只是自变量，无法推导函式的回返值型别。</p>
<p>声明内嵌型别似乎是个好主意，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIter</span> </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明（nested type）</span></span><br><span class="line"> T* ptr; </span><br><span class="line"> <span class="built_in">MyIter</span>(T* p=<span class="number">0</span>) : <span class="built_in">ptr</span>(p) &#123; &#125; </span><br><span class="line"> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; </span><br><span class="line"> <span class="comment">// ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; <span class="comment">//注：I指上面的MyIter</span></span><br><span class="line"><span class="keyword">typename</span> I::value_type <span class="comment">//这一整行是 func的回返值型别</span></span><br><span class="line"><span class="built_in">func</span>(I ite) </span><br><span class="line">&#123; <span class="keyword">return</span> *ite; &#125; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="function">MyIter&lt;<span class="type">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">8</span>))</span></span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(ite); <span class="comment">//输出：8</span></span><br></pre></td></tr></table></figure>

<p>注意，func()的回返型别必须加上关键词 typename，因为T是一个 template参数，在它被编译器具现化之前，编译器对T一无所悉，换句话说编译器此时并不知道<code>MyIter&lt;T&gt;::value_type</code>代表的是一个型别或是一个 member function或是一个 data member。关键词typename的用意在告诉编译器说这是一个型别，如此才能顺利通过编译。</p>
<p>看起来不错。但是有个隐晦的陷阱：并不是所有迭代器都是 class type。原生指标就不是。如果不是 class type，就无法为它定义内嵌型别。但 STL（以及整个泛型思维）绝对必须接受原生指标做为一种迭代器，所以上面这样还不够。更好的方式是使用template partial specialization（模板偏特化）。</p>
<p><strong>Partial Specialization（偏特化）的意义</strong>：如果 class template拥有一个以上的 template 参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。换句话说我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。</p>
<p>假设有一个 class template如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V, <span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>partial specialization的字面意义容易误导我们以为，所谓「偏特化版」一定是对template参数 U 或 V 或 T（或某种组合）指定某个自变量值。事实不然，「所谓partial specialization的意思是提供<strong>另一份 template</strong>定义式，而其本身仍为 templatized」。《泛型技术》 一书对 partial specialization 的定义是：「针对（任何）template 参数更进一步的条件限制，所设计出来的一个特化版本」。</p>
<p>由此，面对以下这么一个 class template：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; ... &#125;; <span class="comment">// 这个泛化版本允许（接受）T为任何型别</span></span><br></pre></td></tr></table></figure>

<p>我们便很容易接受它有一个型式如下的partial specialization：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt; &#123; ... &#125;; <span class="comment">//这个特化版本仅适用于「T为原生指针」的情况</span></span><br><span class="line"> <span class="comment">// 「T为原生指针」便是「T 为任何型别」的一个更进一步的条件限制</span></span><br></pre></td></tr></table></figure>

<p>注：原生指针即  (类型名*p)样子的指针，类型名可以是基础类型，如int，double等，也可以是一个自己定义的Class类。相反的如果一个类重载了‘<strong>*’</strong>和‘**-&gt;*<em>’的运算符，可以像指针一样用‘</em>’和‘-&gt;’操作，就不是原生的，如iterator等。</p>
<p>有了这项利器，我们便可以解决前述「内嵌型别」未能解决的问题。先前的问题是，原生指针并非 class，因此无法为它们定义内嵌型别。现在，我们可以针对「迭代器之 template自变量为指标」者，设计特化版的迭代器。</p>
<p>下面这个 class template专门用来「萃取」迭代器的特性，而 <em>value type</em> 正是迭代器的特性之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; <span class="comment">// traits 意为「特性」</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个所谓的<strong>traits</strong>，其意义是，如果I定义有自己的<em>value type</em>，那么透过这个<strong>traits</strong>的作用，萃取出来的value_type就是I::value_type。换句话说如果I 定义有自己的<em>value type</em>，先前那个func()可以改写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type <span class="comment">// 这一整行是函式回返型别，注：此时类I内定义了value_type</span></span><br><span class="line"><span class="built_in">func</span>(I ite) </span><br><span class="line">&#123; <span class="keyword">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处是<strong>traits</strong>可以拥有特化版本。现在，我们令 iterator_traites拥有一个partial specializations 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; <span class="comment">//偏特化版—迭代器是个原生指标，注：此时T（比如int）也许没有定义value_type，则可以根据T* 获取T，也就得到了type</span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，原生指标int* 虽然不是一种 class type，亦可透过<strong>traits</strong>取其<em>value type</em>。这就解决了先前的问题。</p>
<p>但是请注意，针对「指向常数对象的指针（pointer-to-const）」，下面这个式子得到什么结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;<span class="type">const</span> <span class="type">int</span>*&gt;::value_type</span><br></pre></td></tr></table></figure>

<p>获得的是const int而非int。这不是所期望的。我们希望利用这种机制来宣告一个<strong>暂时变量</strong>，使其型别与迭代器的<em>value type</em>相同，而现在，宣告一个无法赋值（因const之 故 ）的暂时变数，没什么用！因此，如果迭代器是个pointer-to-const，我们应该设法令其<em>value type</em>为一个 non-const型别。只要另外设计一个特化版本，就能解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123; <span class="comment">// 偏特化版—当迭代器是个pointer-to-const ，注：这个版本多了const，针对const的实例会进入这个版本，萃取T</span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; <span class="comment">// 萃取出来的型别应该是 T 而非 const T</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>现在，不论面对的是迭代器MyIter，或是原生指标int<em>或const int</em>，都可以透过<strong>traits</strong>取出正确的（我们所期望的）<em>value type</em>。 </p>
<p>下图说明<strong>traits</strong>所扮演的「特性萃取机」角色，萃取各个迭代器的特性。这里所谓的迭代器特性，指的是迭代器的相应型别（associated types）。当然，若要这个「特性萃取机」<strong>traits</strong>能够有效运作，<strong>每一个迭代器必须遵循约定</strong>，自行以内嵌型别定义（nested typedef）的方式定义出相应型别（associated types）。这种一个约定，谁不遵守这个约定，谁就不能相容于 STL 这个大家庭。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/traits%E7%89%B9%E6%80%A7%E8%90%83%E5%8F%96%E6%9C%BA.png" alt="image-20220623154430152"></p>
<p>根据经验，最常用到的迭代器相应型别有五种：</p>
<ul>
<li>value type</li>
<li>difference type</li>
<li>pointer</li>
<li>reference</li>
<li>iterator catagory</li>
</ul>
<p>如果你希望你所开发的容器能与 STL 水乳交融，一 定要为你的容器的迭代器定义这五种相应型别。「特性萃取机」<strong>traits</strong> 会很忠实地 </p>
<p>将原汁原味榨取出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator_traits必须针对传入之型别为 pointer 及 pointer-to-const者，设计特化版本，见下节。</p>
<h3 id="迭代器相应型别之一：value-type"><a href="#迭代器相应型别之一：value-type" class="headerlink" title="迭代器相应型别之一：value type"></a>迭代器相应型别之一：<em>value type</em></h3><p>所谓<em>value type</em>，是指迭代器<strong>所指对象的型别</strong>。任何一个打算与 STL算法有完美搭配的 class，都应该定义自己的 <em>value type</em> 内嵌型别，作法就像上节所述。</p>
<h3 id="迭代器相应型别之二：difference-type"><a href="#迭代器相应型别之二：difference-type" class="headerlink" title="迭代器相应型别之二：difference type"></a>迭代器相应型别之二：<em>difference type</em></h3><p><em>difference type</em> 用来表示<strong>两个迭代器之间的距离</strong>，也因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</p>
<p>如果一个泛型算法提供计数功能，例如 STL的count()，其传回值就必须使用迭代器的 <em>difference type</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type <span class="comment">//这一整行是函式回返型别</span></span><br><span class="line"><span class="built_in">count</span>(I first, I last, <span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> ( ; first != last; ++first) </span><br><span class="line"> <span class="keyword">if</span> (*first == value) </span><br><span class="line"> ++n; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对相应型别<em>difference type</em>，<strong>traits</strong>的两个（针对原生指标而写的）特化版本如下，以C++内建的ptrdiff_t（定义于<cstddef>头文件）做为原生指标的<em>difference type</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化（partial specialization）」版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化（partial specialization）」版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，任何时候当我们需要任何迭代器 I的<em>difference type</em>，可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type</span><br></pre></td></tr></table></figure>

<h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：<em>reference type</em></h3><p>从<strong>「迭代器所指之物的内容是否允许改变」</strong>的角度观之，迭代器分为两种：不允许改变「所指对象之内容」者，称为constant iterators，例如const int* pic；允许改变「所指对象之内容」者，称为 mutable iterators，例如int* pi。</p>
<p>当我们对一个 mutable iterators做提领动作时，获得的不应该是个右值（rvalue），应该是个左值（lvalue），因为右值不允许赋值动作（assignment），左值才允许：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>); </span><br><span class="line">*pi = <span class="number">7</span>; <span class="comment">// 对 mutable iterator做提领动作时，获得的应该是个左值，允许赋值。</span></span><br><span class="line">*pci = <span class="number">1</span>; <span class="comment">// 这个动作不允许，因为 pci是个constant iterator，</span></span><br><span class="line"><span class="comment">// 提领 pci所得结果，是个右值，不允许被赋值。</span></span><br></pre></td></tr></table></figure>

<p>在 C++中，函式如果要传回<strong>左值</strong>，都是以<strong>by reference</strong>的方式进行，所以当p是个 mutable iterators时，如果其<em>value type</em>是T，那么*p的型别不应该是T，应该是 T&amp;（因为传回引用才是左值，才能进行赋值）。将此道理扩充，如果 p是一个 constant iterators，其<em>value type</em>是 T，那么*p的型别不应该是const T，而应该是const T&amp;。这里所讨论的*p的型别，即所谓的<em>reference type</em>。实作细节将在下一小节一并展示。</p>
<h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：<em>pointer type</em></h3><p>pointers和 references 在 C++中有非常密切的关连。如果「传回一个左值，令它代表p所指之物」是可能的，那么「传回一个左值，令它代表p所指之物的位址」也一定可以。也就是说我们能够传回一个 pointer，指向迭代器所指之物。</p>
<p>这些相应型别已在先前的ListIter class中出现过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; </span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br></pre></td></tr></table></figure>

<p>Item&amp;便是 ListIter的<em>reference type</em>而 Item*便是其<em>pointer type</em>。</p>
<p>现在把 <em>reference type</em>和<em>pointer type</em> 这两个相应型别加入<strong>traits</strong>内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：<em>iterator_category</em></h3><p>最后一个（第五个）迭代器相应型别会引发较大规模的写码工程。在那之前，必须先讨论迭代器的分类。</p>
<p>根据移动特性与施行动作，迭代器被分为五类：（注：这里的只读和只写或读写，可以理解为作为<strong>左值还是右值</strong>）</p>
<ul>
<li>Input Iterator：这种迭代器所指对象，不允许外界改变。<strong>只读（read only）</strong>。</li>
<li>Output Iterator：<strong>唯写（write only）</strong>。</li>
<li>Forward Iterator：允许「写入型」算法（例如replace()）在此种迭代器所形成的区间上做<strong>读写</strong>动作。</li>
<li>Bidirectional Iterator：可<strong>双向移动</strong>。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），就可以使用 Bidirectional Iterators。</li>
<li>Random Access Iterator：前四种迭代器都只供应一部份指标算术能力（前三 种支持operator++，第四种再加上operator–），第五种则涵盖所有指标算术能力，包括p+n, p-n, p[n], p1-p2, p1&lt;p2。</li>
</ul>
<p>这些迭代器的分类与从属关系，可以用下图表示。直线与箭头代表的并非 C++ 的继承关系，而是所谓concept（概念）与refinement（强化）的关系。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E4%BB%8E%E5%B1%9E%E5%85%B3%E7%B3%BB.png" alt="image-20220624144559043"></p>
<p>设计算法时，如果可能，我们尽量针对图中的某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一种定义，这样才能在不同情况下提供最大效率。研究STL 的过程中，每一分每一秒我们都要明确，效率是个重要课题。假设有个算法可接受<em>Forward Iterator</em>，你以<em>Random Access Iterator</em>喂给它，它当然也会接受，因为一个<em>Random Access Iterator</em>必然是一个<em>Forward Iterator</em>（如图）。但是可用并不代表最佳！</p>
<p><strong>以 advanced()为例</strong></p>
<p>拿advance() 来说（这是许多算法内部常用的一个函式），此函式有两个参数，迭代器p和数值n；函式内部将p累进n次（前进n距离）。下面有三份定义，一份针对<em>Input Iterator</em>，一份针对<em>Bidirectional Iterator</em>，另一份针对<em>Random Access Iterator</em>。倒是没有针对<em>ForwardIterator</em>而设计的版本，因为那和针对<em>InputIterator</em>而设计的版本完全一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 单向，逐一前进</span></span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; <span class="comment">//或写 for ( ; n &gt; 0; --n, ++i );</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectionalIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 双向，逐一前进</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//或写 for ( ; n &gt; 0; --n, ++i ); </span></span><br><span class="line"><span class="comment">//或写 for ( ; n &lt; 0; ++n, --i ); </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_RAI</span><span class="params">(RandomAccessIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 双向，跳跃前进</span></span><br><span class="line"> i += n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当程序呼叫 advance()，应该选用（呼叫）哪一份函式定义呢？如果选择advance_II()，对<em>Random Access Iterator</em>而言极度缺乏效率，原本<em>O(1)<em>的操作竟成为</em>O(N)<em>。如果选择advance_RAI()，则它无法接受</em>Input Iterator</em>。我们需要将三者合一，下面是一种作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">is_random_access_iterator</span>(i)) <span class="comment">//此函式有待设计</span></span><br><span class="line">	<span class="built_in">advance_RAI</span>(i, n); </span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_bidirectional_iterator</span>(i))<span class="comment">//此函式有待设计</span></span><br><span class="line">	<span class="built_in">advance_BI</span>(i, n); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">advance_II</span>(i, n); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是像这样在执行时期才决定使用哪一个版本，会影响程序效率。最好能够在<strong>编译期</strong>就选择正确的版本。多载化函式机制可以达成这个目标：</p>
<p>前述三个advance_xx()都有两个函式参数，型别都未定（因为都是 template参数）。为了令其同名，形成<strong>多载化函式</strong>，我们必须加上一个<strong>型别已确定</strong>的函式参数，使函式多载化机制得以有效运作起来。</p>
<p>设计考虑如下：如果<strong>traits</strong>有能力萃取出迭代器的种类，我们便可利用这个「迭代器类型」相应型别做为advanced()的第三参数。这个相应型别一定必须是个class type，不能只是数值号码类的东西，因为编译器需仰赖它（一个型别）来进行多载化决议程序（overloaded resolution）。下面定义五个 classes，代表五种迭代器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个做为标记用的型别（tag types）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;; <span class="comment">//继承，见后面的分析</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123; &#125;; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;<span class="comment">//继承</span></span><br></pre></td></tr></table></figure>

<p>这些 classes只做为标记用，所以不需要任何成员。至于为什么运用继承机制，稍后再解释。现在重新设计 __advance()（由于只在内部使用，所以函式名称加上特定的前导符），并加上第三参数，使它们形成多载化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 单向，逐一前进</span></span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这是一个单纯的转呼叫函式（trivial forwarding function）。稍后讨论如何免除之。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(ForwardIterator&amp; i, Distance n, forward_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 单纯地进行转呼叫（forwarding），注：可以透过继承消除，直接做InputIterator版的，这个ForwardIterator版可以不写</span></span><br><span class="line"> <span class="built_in">advance</span>(i, n, <span class="built_in">input_iterator_tag</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidiectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(BidiectionalIterator&amp; i, Distance n, bidirectional_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 双向，逐一前进</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 双向，跳跃前进</span></span><br><span class="line"> i += n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述语法，每个 __advance()的最后一个参数都<strong>只宣告型别</strong>，并<strong>未指定参数名称</strong>，因为它<strong>纯粹只是用来启动多载化机制</strong>，函式之中根本不使用该参数。如果硬要加上参数名称也可以，画蛇添足罢了。</p>
<p>行进至此，还需要一个对外开放的上层控制介面，呼叫上述各个多载化的__advance()。此一上层介面只需两个参数，当它准备将工作转给上述的__advance()时，才自行加上第三自变量：迭代器类型。因此，这个上层函式必须有能力从它所获得的迭代器中推导出其类型—这份工作自然是交给 <strong>traits</strong> 机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> __advance(i, n, iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());<span class="comment">//括号是为了产生暂时对象，否则只是一个类型名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述语法，<code>iterator_traits&lt;Iterator&gt;::iterator_category() </code>将产生一个暂时对象（道理就像 int()会产生一个 int 暂时对象一样），其型别应该隶属前述五个迭代器类型之一。然后，根据这个型别，编译器才决定呼叫哪一个__advance()多载函式。 </p>
<p>因此，为了满足上述行为，<strong>traits</strong>必须再增加一个相应型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"><span class="comment">// 注意，原生指标是一种 Random Access Iterator</span></span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; </span><br><span class="line"> ... </span><br><span class="line"><span class="comment">// 注意，原生的 pointer-to-const是一种 Random Access Iterator</span></span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>任何一个迭代器，其类型永远应该落在「该迭代器所隶属之各种类型中，<strong>最强化</strong>的那个」。例如int*既是<em>Random Access Iterator</em>又是 <em>Bidirectional Iterator</em>，同时也是<em>Forward Iterator</em>，而且也是<em>Input Iterator</em>，那么，其类型应该归属为<em>random_access_iterator_tag</em>。</p>
<p>你是否注意到advance()的 template参数名称取得好像不怎么理想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>按说advanced()既然可以接受各种类型的迭代器，就不应将其型别参数命名为InputIterator。这其实是 STL 算法的一个命名规则：以算法所能接受之<strong>最低阶</strong>迭代器类型，来为其迭代器型别参数命名。（注：毕竟只是命名，传入之后可以自动推导类型）</p>
<p>**消除「单纯转呼叫函式」 **</p>
<p>以 <strong>class</strong> 来定义迭代器的各种分类标签，不仅可以促成多载化机制的成功运作（使编译器得以正确执行多载化决议程序，overloaded resolution），另一个好处是，透过<strong>继承</strong>，我们可以不必再写<strong>「单纯只做转呼叫」</strong>的函式（例如前述的advance() <em>ForwardIterator</em>版）。考虑下面这个小例子，从其输出结果可以看出端倪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 3tag-test.cpp </span></span><br><span class="line"><span class="comment">//模拟测试 tag types继承关系所带来的影响。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : <span class="keyword">public</span> B &#123; &#125;; </span><br><span class="line"><span class="comment">// B 可比拟为 InputIterator </span></span><br><span class="line"><span class="comment">// D1 可比拟为 ForwardIterator </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D1 &#123; &#125;; <span class="comment">// D2 可比拟为 BidirectionalIterator </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="built_in">func</span>(I&amp; p, B) </span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;B version&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="built_in">func</span>(I&amp; p, D2) </span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;D2 version&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span>* p; </span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">B</span>()); <span class="comment">// 参数与自变量完全吻合。输出: &quot;B version&quot; </span></span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">D1</span>()); <span class="comment">// 参数与自变量未能完全吻合；因继承关系而自动转呼叫。输出:&quot;B version&quot; </span></span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">D2</span>()); <span class="comment">// 参数与自变量完全吻合。输出: &quot;D2 version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%B1%BB%E5%88%AB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="image-20220624151349583"></p>
<p><strong>以 distance()为例</strong></p>
<p>关于「迭代器类型标签」的应用，以下再举一例。distance() 也是常用的一个迭代器操作函式，用来计算两个迭代器之间的距离。针对不同的迭代器类型，它可以有不同的计算方式，带来不同的效率。整个设计模式和前述的advance()如出一辙：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">__distance(InputIterator first, InputIterator last,  input_iterator_tag) &#123; </span><br><span class="line"> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 逐一累计距离</span></span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123; </span><br><span class="line"> ++first; ++n; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type </span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123; </span><br><span class="line"> <span class="comment">// 直接计算差距</span></span><br><span class="line"> <span class="keyword">return</span> last - first; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type </span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> __distance(first, last, <span class="built_in">category</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，distance()可接受任何类型的迭代器；其 template型别参数之所以命名为InputIterator，是为了遵循STL 算法的命名规则：以算法所能接受之最初级类型来为其迭代器型别参数命名。</p>
<p>此外也请注意，由于迭代器类型之间存在着继承关系，「转呼叫（<em>forwarding</em>）」的行为模式因此自然存在——这一点已在前一节讨论过。换句话说，当客端呼叫distance()并使用 <em>Output Iterator</em>s 或 <em>Forward Iterator</em>s 或<em>Bidirectional Iterator</em>s，统统都会转呼叫 <em>Input Iterator</em>版的那个__distance() 函式。（注：这时因为有继承，就不用对这3类迭代器写单纯的呼叫函数了）</p>
<h2 id="std-iterator-的保证"><a href="#std-iterator-的保证" class="headerlink" title="std::iterator 的保证"></a>std::iterator 的保证</h2><p>为了符合规范，任何迭代器都应该<strong>提供五个内嵌相应型别</strong>，以利<strong>traits</strong>萃取，否则便是自外于整个STL架构，可能无法与其它 STL 组件顺利搭配。然而写码难免挂一漏万，谁也不能保证不会有粗心大意的时候。如果能够将事情简化，就好多了。STL提供了一个<strong>iterators class</strong>如下，如果每个新设计的迭代器<strong>都继承自它</strong>，就保证符合 STL 所需之规范：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line"> <span class="keyword">class</span> Pointer = T*, </span><br><span class="line"> <span class="keyword">class</span> Reference = T&amp;&gt; </span><br><span class="line"><span class="keyword">struct</span> iterator &#123; </span><br><span class="line"> <span class="keyword">typedef</span> Category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Distance difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> Pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Referencereference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator class不含任何成员，纯粹只是型别定义，所以继承它并不会招致任何额外负担。由于后三个参数皆有默认值，新的迭代器只需<strong>提供前两个参数</strong>即可。</p>
<p>先前的 ListIter，如果改用正式规格，应该这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span> : </span><br><span class="line"> <span class="keyword">public</span> std::iterator&lt;std::forward_iterator_tag, Item&gt; </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="iterator-源码完整重列"><a href="#iterator-源码完整重列" class="headerlink" title="iterator 源码完整重列"></a>iterator 源码完整重列</h2><p>以下重新列出 SGI STL &lt;stl_iterator.h&gt;头文件内与本章相关的程序代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节录自 SGI STL &lt;stl_iterator.h&gt; </span></span><br><span class="line"><span class="comment">//五种迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="comment">//为避免写码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line"> <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt; </span><br><span class="line"><span class="keyword">struct</span> iterator &#123; </span><br><span class="line"> <span class="keyword">typedef</span> Category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Distance difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> Pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//「萃取机」traits </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标（native pointer）而设计的 traits 偏特化版。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;  </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生之pointer-to-const 而设计的 traits 偏特化版。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;  </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的类型（category）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category </span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">category</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的 distance type </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type* </span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的 value type </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* </span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是整组 distance 函式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">__distance(InputIterator first, InputIterator last, input_iterator_tag) &#123; </span><br><span class="line"> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123; </span><br><span class="line"> ++first; ++n; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type </span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">return</span> last - first;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type </span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> __distance(first, last,<span class="built_in">category</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是整组 advance函式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(BidirectionalIterator&amp; i, Distance n, bidirectional_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag) &#123; </span><br><span class="line"> i += n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123; </span><br><span class="line">__advance(i, n, <span class="built_in">iterator_category</span>(i)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SGI-STL-的私房菜：-type-traits-（选看）"><a href="#SGI-STL-的私房菜：-type-traits-（选看）" class="headerlink" title="SGI STL 的私房菜： __type_traits （选看）"></a>SGI STL 的私房菜： __type_traits （选看）</h2><p><strong>traits</strong>编程技法很棒，适度弥补了 C++ 语言本身的不足。STL只对迭代器加以规范，制定出iterator_traits这样的东西。SGI 把这种技法进一步扩大到迭代器以外的世界，于是有了所谓的**__type_traits<strong>。双底线前缀词意指这是SGI STL 内部所用的东西，</strong>不在 STL 标准规范之内**。</p>
<p>iterator_traits负 责萃 取 迭 代器 的特 性，__type_traits 则负责萃取<strong>型别（type）</strong>的特性。此处我们所关注的型别特性是指：这个型别是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivialassignment operator？是否具备 non-trivialdtor？如果答案是否定的，我们在对这个型别进行建构、解构、拷贝、赋值等动作时，就可以采用最有效率的措施（例如根本不唤起那些constructor, destructor），而采用内存直接处理动作如malloc()、memcpy()等等，获得最高效率。这对于大规模而动作频繁的容器，有着显著的效率提升。</p>
<p>定义于 SGI &lt;type_traits.h&gt;中的__type_traits，提供了一种机制，允许针对不同的型别属性（type attributes），在<strong>编译时期完成函式派送</strong>决定（function dispatch）。这对于撰写 template很有帮助，例如，当我们准备对一个「元素型别未知」的数组执行 copy 动作时，如果我们能事先知道其元素型别是否有一个 trivial copy constructor ， 便 能 够 帮 助 我 们 决 定 是 否 可 使 用 快 速 的memcpy()或memmove()。 </p>
<p>从iterator_traits得来的经验，我们希望，程式之中可以这样运用__type_traits&lt;T&gt;，T代表任意型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor </span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure>

<p>我们希望上述式子响应我们「真」或「假」（以便我们决定采取什么策略），但其结果不应该只是个bool值，应该是个有着真&#x2F;假性质的「对象」，因为我们希望利用其响应结果来进行自变量推导，而编译器只有面对 class object形式的自变量，才会做自变量推导。为此，上述式子应该传回这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>这两个空白 classes没有任何成员，不会带来额外负担，却又能够标示真假，满足我们所需。 </p>
<p>为了达成上述五个式子， __type_traits内必须定义一些typedefs，其值不是__true_type就是__false_type。下面是 SGI的作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line"> <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first; </span><br><span class="line"> <span class="comment">/* 不要移除这个成员。它通知「有能力自动将 __type_traits 特化」</span></span><br><span class="line"><span class="comment">的编译器说，我们现在所看到的这个 __type_traits template 是特</span></span><br><span class="line"><span class="comment">殊的。这是为了确保万一编译器也使用一个名为 __type_traits而其</span></span><br><span class="line"><span class="comment">实与此处定义并无任何关联的 template 时，所有事情都仍将顺利运作。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"> <span class="comment">/* 以下条件应被遵守，因为编译器有可能自动为各型别产生专属的 __type_traits </span></span><br><span class="line"><span class="comment">特化版ᴀ：</span></span><br><span class="line"><span class="comment"> - 你可以重新排列以下的成员次序</span></span><br><span class="line"><span class="comment"> - 你可以移除以下任何成员</span></span><br><span class="line"><span class="comment"> - 绝对不可以将以下成员重新命名而却没有改变编译器中的对应名称</span></span><br><span class="line"><span class="comment"> - 新加入的成员会被视为一般成员，除非你在编译器中加上适当支持。*/</span> </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_default_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_destructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type is_POD_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么SGI 把所有内嵌型别都定义为__false _type呢？是的，SGI 定义出最保守的值，然后（稍后可见）再针对每一个纯量型别（scalar types）设计适当的__type_traits特化版本，这样就解决了问题。 </p>
<p>上述 __type_traits可以接受任何型别的自变量，五个typedefs将经由以下管道获得实值：</p>
<p>一般具现体（general instantiation），内含对所有型别都必定有效的保守值。 上述各个has_trivial_xxx型别都被定义为__false_type，就是对所有型别都必定有效的保守值。经过宣告的特化版本，例如&lt;type_traits.h&gt; 内对所有 C++纯量型别（scalar types）提供了对映的特化宣告。这里源码不做展示了。</p>
<p>__types_traits在SGI STL中的应用很广。下面我举几个实例。第一个例子是uninitialized_fill_n()全域函式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIteratoruninitialized_fill_n</span><span class="params">(ForwardIterator first, </span></span></span><br><span class="line"><span class="params"><span class="function"> Size n, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函式以 x为蓝本，自迭代器first开始建构 n个元素。为求取最大效率，首先 以value_type()萃取出迭代器first的<em>value type</em>，再利用__type_traits判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下就「是否为 POD型别」采取最适当的措施：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不是 POD型别，就会派送（dispatch）到这里</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type) &#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅简化，以下将原本有的异常处理（exception handling）去除。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur) </span><br><span class="line">	<span class="built_in">construct</span>(&amp;*cur, x); </span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果是 POD型别，就会派送（dispatch）到这里。下两行是原文件所附注解。</span></span><br><span class="line"><span class="comment">//如果 copy construction等同于 assignment，而且有 trivial destructor，</span></span><br><span class="line"><span class="comment">//以下就有效。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);<span class="comment">//交由高阶函式执行，如下所示。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是定义于 &lt;stl_algobase.h&gt; 中的 fill_n() </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">OutputIteratorfill_n</span>(OutputIterator first, Size n, <span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first) </span><br><span class="line"> *first = value; </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此如果你是 SGI STL的使用者，你可以在自己的程式中充份运用这个__type_traits。假设我自行定义了一个Shape class，__type_traits 会对它产生什么效应？如果编译器够厉害（例如Silicon Graphics 的N32 和 N64 编译器），你会发现，__type_traits针对Shape萃取出来的每一个特性，其结果将取决于我的Shape是否有 trivialdefalt ctor或trivialcopy ctor或trivial assignment operator或 trivialdtor而定。但对大部份缺乏这种特异功能的编译器而言，__type_traits 针对 Shape 萃取出来的每一个特性都是__false_type ，即使Shape是个 POD型别。这样的结果当然过于保守，但是别无选择，除非我针对 Shape，自行设计一个__type_traits 特化版本，明白地告诉编译器以下事实（举例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> __true_type has_trivial_default_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_destructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type is_POD_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>究竟一个 class什么时候该有自己的 non-trivial default constructor, non-trivial copy constructor, non-trivial assignment operator, non-trivial destructor 呢？一个简单的判断准则是：如果 class 内含指标成员，并且对它进行内存动态配置，那么这个class就需要实作出自己的 non-trivial-xxx。</p>
<p>即使你无法全面针对你自己定义的型别，设计__type_traits特化版本，无论如何，至少，有了这个__type_traits之后，当我们设计新的泛型算法时，面对C++纯量型别，便有足够的信息决定采用最有效的拷贝动作或赋值动作—因为每一个纯量型别都有对应的__type_traits 特化版ᴀ，其中每一个 typedef 的值都是__true_type。 </p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这章主要介绍迭代器，迭代器是一个行为类似指针的对象，重载了*和-&gt;的动作。特别的，关于重载*，涉及到了左值和右值，这里*动作提领的内容是允许赋值的，因此是左值，故而operator函数需要返回的类型是T&amp;，是引用，否则只是创建了临时对象（可以作为右值）。迭代器为了走访容器，要重载++动作；为了判别元素，要重载&#x3D;&#x3D;、！&#x3D;动作。</p>
<p>在算法中，可能需要临时对象，其类型是迭代器指向对象的类型，这就需要能够根据迭代器知道这个类型。函数模板可以自动推导类型，然而这仅能推导一种类型，并且无法推导返回类型。使用traits编程技法可以更加全面。基本思想是在迭代器类内定义好类型（比如value_type），因为迭代器的模板T就告知了这样的类型。那么在算法内就可以使用这个由迭代器定义出的类型。但不是所有类型都可以自己来定义，原生类（如int）就没办法。因此需要traits来进行中间介入：使用模板偏特化。如果是自己定义的类，那么traits出来的就是类定义的value_type，如果是原生指针T*或const指针（会进入偏特化版而不使用泛化版），则萃取出来的是指针原类型T。</p>
<p>进一步，迭代器也有自己的类型，不同类型支持不同的操作，对算法而言一个确定的类型可以拥有最好的效率。与前面一样，可以每个迭代器定义自己的tag，用来选择执行算法不同的版本。然而为了在编译时就确定执行哪个版本（而不是用if这种，在运行才确定），要使用函数多载化，具体就是用tag作为一个新的参数，这个参数没有名称，纯粹用来选择版本，传入时加括号产生临时对象即可。依然有偏特化版本，原生指针是Random Access Iterator。</p>
<p>然后，为了避免单纯转呼叫动作，比如forward迭代器版本也用的是input迭代器版本的算法，如果只按上面的讨论，forward迭代器版本的算法要转呼叫input迭代器的算法。通过继承可以省去这一步，如果forward版本未定义，发现其父类input版本有定义，就自动执行input版本。这个继承被允许是因为高层级的迭代器都支持低层级迭代器的操作，呼叫低层级迭代器算法不会有冲突。再者，因为要用继承，因此tag必须是一个类（class或strut），这些tag类是预定义好的。为了方便迭代器设计，可以继承std::iterator这个类。</p>
<p>最后，SGI STL不只使用了5个type的traits，扩展到了更大的范围，不过原理是一样的，作用依然是提高效率。</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式，以利搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构（Data Structures）。大学信息相关教育里头，与编程最有直接关系的科目，首推数据结构与算法（Algorithms）。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL 容器即是将运用最广的一些数据结构实作出来。</p>
<p>常用的数据结构不外乎 array（数组）、list（串行）、tree（树）、stack （堆栈）、queue（队列）、hash table（杂凑表）、set（集合）、map（映像表）等等。根据「资料在容器中的排列」特性，这些数据结构分为序列式（sequence）和关系型（associative）两种。</p>
<h2 id="序列式容器（sequential-containers）"><a href="#序列式容器（sequential-containers）" class="headerlink" title="序列式容器（sequential containers）"></a>序列式容器（sequential containers）</h2><p>所谓序列式容器，其中的元素都可序（<em>ordered</em>），但未排序（<em>sorted</em>）。C++ 语言本身提供了一个序列式容器array，STL另外再提供vector,list,deque, stack,queue,priority-queue等等序列式容器。其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器（adapter），但仍把它们放在本章讨论。本章将带你仔细看过各种序列式容器的关键实作细节。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式，与array非常像似。两者的唯一差别在于<strong>空间的运用弹性</strong>。array是静态空间，一旦配置了就不能改变；如果要换个大（或小） 一点的空间，一切细琐需由客端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，然后再把原来的空间释还给系统。vector是<strong>动态空间</strong>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的樽节与运用弹性有很大的帮助，我们再也不必因为害怕空间不足而一开始就要求一个大块头array了，我们可以安心使用vector，需要多少用多少。</p>
<p>vector的实作技术，关键在于其对大小的控制以及重新配置时的数据搬移效率。</p>
<p>一旦vector旧有空间满载，如果客端每新增一个元素，vector内部只是扩充一 个元素的空间，实为不智，因为所谓扩充空间（不论多大），是「配置新空间 &#x2F;数据搬移 &#x2F;释还旧空间」的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。</p>
<h3 id="vector-定义式摘要"><a href="#vector-定义式摘要" class="headerlink" title="vector 定义式摘要"></a>vector 定义式摘要</h3><p>以下是vector定义式的源码摘录。虽然 STL规定，欲使用vector者必须先含入<code>&lt;vector&gt;</code>，但 SGI STL 将vector实作于更底层的<code>&lt;stl_vector.h&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc是 SGI STL的空间配置器，见第二章。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// vector 的内嵌型别定义</span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* iterator; </span><br><span class="line"> <span class="keyword">typedef</span> value_type&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="comment">// 以下，simple_alloc 是 SGI STL的空间配置器，见 2.2.4节。</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator; </span><br><span class="line"> iterator start; </span><br><span class="line"> iterator finish; </span><br><span class="line"> <span class="comment">//表示目前使用空间的头</span></span><br><span class="line"> <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage; <span class="comment">//表示目前可用空间的尾</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> start = <span class="built_in">allocate_and_fill</span>(n, value); </span><br><span class="line"> finish = start + n; </span><br><span class="line"> end_of_storage = finish; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125; </span><br><span class="line"> <span class="comment">//构造函数</span></span><br><span class="line"> <span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125; </span><br><span class="line"> <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="built_in">vector</span>(<span class="type">int</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="built_in">vector</span>(<span class="type">long</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125; <span class="comment">//注：T()产生临时对象</span></span><br><span class="line"> ~<span class="built_in">vector</span>() &#123;</span><br><span class="line"> <span class="built_in">destroy</span>(start, finish); <span class="comment">//全域函式，见 2.2.3节。注：消除元素</span></span><br><span class="line"> <span class="built_in">deallocate</span>(); <span class="comment">// 这是 vector 的一个 member function 。注：回收内存</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125; <span class="comment">//第一个元素</span></span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;<span class="comment">//最后一个元素</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123; </span><br><span class="line"> <span class="comment">//将元素安插至最尾端</span></span><br><span class="line"> <span class="built_in">construct</span>(finish, x); <span class="comment">//全域函式，见 2.2.3节。注：这里内存已经有了，直接建构元素</span></span><br><span class="line"> ++finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">// 这是 vector 的一个 member function </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; <span class="comment">//将最尾端元素取出</span></span><br><span class="line">  --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; <span class="comment">//清除某位置上的元素</span></span><br><span class="line"> <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) <span class="comment">//注：如果不是最后一个元素</span></span><br><span class="line"> 	<span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);<span class="comment">//后续元素往前搬移</span></span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> <span class="keyword">return</span> position; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line"> <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123;<span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 配置空间并填满内容</span></span><br><span class="line"> <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> 	iterator result =data_allocator::<span class="built_in">allocate</span>(n); <span class="comment">//分配内存</span></span><br><span class="line"> 	<span class="built_in">uninitialized_fill_n</span>(result, n, x); <span class="comment">// 全域函式，见 2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector-的迭代器"><a href="#vector-的迭代器" class="headerlink" title="vector 的迭代器"></a>vector 的迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，<strong>普通指针</strong>都可以做为 vector的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如 operator*,operator-&gt;,operator++,operator–,operator+, operator-, operator+&#x3D;,operator-&#x3D;，普通指针天生就具备。vector支持随机存取，而普通指针正有着这样的能力。所以，vector 提供的是 <em>Random Access Iterators</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// vector 的迭代器是普通指针</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上述定义，如果客端写出这样的码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator ivite; </span><br><span class="line">vector&lt;Shape&gt;::iterator svite;</span><br></pre></td></tr></table></figure>

<p>ivite的型别其实就是int*，svite的型别其实就是 Shape*。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, classAlloc = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> iterator start; <span class="comment">//表示目前使用空间的头</span></span><br><span class="line"> iterator finish; <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage; <span class="comment">//表示目前可用空间的尾，注意“使用”与“可用”之间的差别</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的观念。换句话说一个 vector 的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。</p>
<p>运用start, finish, end_of_storage三个迭代器，便可轻易提供首尾标示、大小、容量、空容器判断、注标（[ ]）运算子、最前端元素值、最后端元素值…等机能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, classAlloc = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span>*(<span class="built_in">begin</span>() + n); &#125; <span class="comment">//重载[]运算</span></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125; </span><br><span class="line"> ... </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>大致的示意图如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/vector%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20220628153235013"></p>
<h3 id="vector-的建构与内存管理：constructor-push-back"><a href="#vector-的建构与内存管理：constructor-push-back" class="headerlink" title="vector 的建构与内存管理：constructor, push_back"></a>vector 的建构与内存管理：constructor, push_back</h3><p>下面是个小小的测试程序，观察重点在建构的方式、元素的添加，以及大小、容量的变化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4vector-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(<span class="number">2</span>,<span class="number">9</span>)</span></span>; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=2 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=2</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=3 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=4</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">2</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=4 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=4</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 1 2 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">5</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=7 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 1 2 3 4 5 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=4 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator ivite =<span class="built_in">find</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ivite)iv.<span class="built_in">erase</span>(ivite);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=3 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), <span class="number">2</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite) ivec.<span class="built_in">insert</span>(ite,<span class="number">3</span>,<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 7 7 7 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">clear</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector预设使用alloc（第二章）做为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="comment">// simple_alloc&lt;&gt; 见 2.2.4 节</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，<code>data_allocator::allocate(n)</code>表示配置 n 个元素空间。</p>
<p>vector 提供许多constructors，其中一个允许我们指定空间大小及初值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建构式，允许指定 vector 大小 n和初值 value </span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"><span class="comment">// 充填并予初始化</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> start =<span class="built_in">allocate_and_fill</span>(n, value); </span><br><span class="line"> finish = start + n; <span class="comment">//指向下一个空的位置</span></span><br><span class="line"> end_of_storage = finish; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 配置而后充填</span></span><br><span class="line"> <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line"> iterator result =data_allocator::<span class="built_in">allocate</span>(n); <span class="comment">// 配置 n 个元素空间</span></span><br><span class="line"> <span class="built_in">uninitialized_fill_n</span>(result, n, x); <span class="comment">// 全域函式，见 2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>uninitialized_fill_n()会根据第一参数的型别特性（type traits，3.7 节），决定使用算法 fill_n()或反复呼叫 construct() 来完成任务（见 2.3 节描述）。</p>
<p>当我们以push_back()将新元素安插于vector 尾端，该函式首先检查是否还有备用空间？如果有就直接在备用空间上建构元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新配置、搬移数据、释放原空间）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">//还有备用空间</span></span><br><span class="line">	<span class="built_in">construct</span>(finish, x); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> 	++finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//已无备用空间</span></span><br><span class="line">     <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">// vector member function，见以下列表</span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x) &#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123;<span class="comment">//还有备用空间</span></span><br><span class="line"><span class="comment">// 在备用空间起始处建构一个元素，并以 vector 最后一个元素值为其初值。</span></span><br><span class="line"><span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); </span><br><span class="line"><span class="comment">// 调整水位。</span></span><br><span class="line"> ++finish; </span><br><span class="line"> T x_copy = x; </span><br><span class="line"> <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>); </span><br><span class="line">     <span class="comment">//不要被 copy_backward() 算法的名称所误导，它不会逆转元素的顺序。它只会像 copy() 那样复制元素，但是顺序是从最后一个元素开始直到第一个元素。</span></span><br><span class="line"> *position = x_copy; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//已无备用空间</span></span><br><span class="line"> <span class="type">const</span> size_type old_size = <span class="built_in">size</span>(); </span><br><span class="line"> <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 以上配置原则：如果原大小为 0，则配置 1（个元素大小）；</span></span><br><span class="line"> <span class="comment">// 如果原大小不为 0，则配置原大小的两倍，</span></span><br><span class="line"> <span class="comment">// 前半段用来放置原资料，后半段准备用来放置新资料。</span></span><br><span class="line"> iterator new_start =data_allocator::<span class="built_in">allocate</span>(len); <span class="comment">//实际配置</span></span><br><span class="line"> iterator new_finish = new_start; </span><br><span class="line"> <span class="keyword">try</span> &#123; <span class="comment">//异常处理模型的trycatch</span></span><br><span class="line"><span class="comment">// 将原 vector 的内容拷贝到新 vector。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); <span class="comment">//[start,position)，左闭右开</span></span><br><span class="line"><span class="comment">// 为新元素设定初值 x </span></span><br><span class="line"><span class="built_in">construct</span>(new_finish, x); <span class="comment">//new_finish=position位置，是原来尾巴的下一个未用空间</span></span><br><span class="line"><span class="comment">// 调整水位。</span></span><br><span class="line"> ++new_finish;  </span><br><span class="line"><span class="comment">// 将原 vector 的备用空间中的内容也忠实拷贝过来(作者疑惑：啥用途？)</span></span><br><span class="line"> new_finish =<span class="built_in">uninitialized_copy</span>(position, finish, new_finish); </span><br><span class="line">     <span class="comment">//个人理解：实际上这个函数是在某个位置上插入x，只是恰好也有扩充空间的作用，因而拿来push_back()中扩充；</span></span><br><span class="line">     <span class="comment">//如果再考虑插入的情况，position不是最后的位置，就需要把原来后面的元素再拷贝过来</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"><span class="comment">// &quot;commit or rollback&quot; semantics. </span></span><br><span class="line"> <span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(new_start, len); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 解构并释放原 vector </span></span><br><span class="line"> <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); </span><br><span class="line"> <span class="built_in">deallocate</span>(); </span><br><span class="line"><span class="comment">// 调整迭代器，指向新 vector </span></span><br><span class="line"> start = new_start; </span><br><span class="line"> finish = new_finish; </span><br><span class="line"> end_of_storage = new_start + len; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后建构新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。</p>
<h3 id="vector-的元素操作：pop-back-erase-clear-insert"><a href="#vector-的元素操作：pop-back-erase-clear-insert" class="headerlink" title="vector 的元素操作：pop_back, erase, clear, insert"></a>vector 的元素操作：pop_back, erase, clear, insert</h3><p>vector所提供的元素操作动作很多，无法在有限篇幅中一一讲解——其实也没有这种必要。为搭配先前对空间配置的讨论，这里挑选数个相关函式做为解说对象。这些函式也出现在先前的测试程序中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将尾端元素拿掉，并调整大小。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//将尾端标记往前移一格，表示将放弃尾端元素。</span></span><br><span class="line"> <span class="comment">// destroy是全域函式，见第 2 章</span></span><br><span class="line"> <span class="comment">// 清除 [first,last) 中的所有元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> iterator i = <span class="built_in">copy</span>(last, finish, first);<span class="comment">// copy 是全域函式，第 6 章</span></span><br><span class="line"> <span class="built_in">destroy</span>(i, finish);<span class="comment">// destroy是全域函式，第 2 章</span></span><br><span class="line"> finish = finish - (last - first); </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 清除某个位置上的元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) </span><br><span class="line"> <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position); <span class="comment">// copy 是全域函式，第 6 章</span></span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">// destroy是全域函式，2.2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> position; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;<span class="comment">// erase()就定义在上面</span></span><br></pre></td></tr></table></figure>

<p>下图展示 erase(first, last)的动作。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B1%80%E9%83%A8%E5%8C%BA%E9%97%B4%E7%9A%84%E6%B8%85%E9%99%A4%E5%8A%A8%E4%BD%9Cerase(first,last).png" alt="image-20220628163842260"></p>
<p>下面是vector::insert()实作内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 position 开始，安插 n个元素，元素初值为 x </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;<span class="comment">// 当 n != 0 才进行以下所有动作</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) </span><br><span class="line"> <span class="comment">// 备用空间大于等于「新增元素个数」</span></span><br><span class="line"> T x_copy = x; </span><br><span class="line"> <span class="comment">// 以下计算安插点之后的现有元素个数</span></span><br><span class="line"> <span class="type">const</span> size_type elems_after = finish - position; </span><br><span class="line"> iterator old_finish = finish; </span><br><span class="line"> <span class="keyword">if</span> (elems_after &gt; n) </span><br><span class="line"> <span class="comment">// 「安插点之后的现有元素个数」大于「新增元素个数」</span></span><br><span class="line"> 	<span class="built_in">uninitialized_copy</span>(finish - n, finish, finish); <span class="comment">//分两步后移n位腾出空间</span></span><br><span class="line"> finish += n;<span class="comment">//将 vector 尾端标记后移</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish); <span class="comment">//注：使用这个函数，只需要知道这一段元素的结尾应该copy到哪个位置（因为是从后往前copy），而不需要知道开头位置，实际上开头位置也可以算出来，但使用这个函数就不需要计算</span></span><br><span class="line"> <span class="built_in">fill</span>(position, position + n, x_copy);<span class="comment">//从安插点开始填入新值</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">// 「安插点之后的现有元素个数」小于等于「新增元素个数」</span></span><br><span class="line"> <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy); <span class="comment">//注：先把一些空间填上去先，而不是直接后移腾出空间（不过感觉差不多，因为要移动到的位置下面的finish也计算出来了）</span></span><br><span class="line"> finish += n - elems_after; </span><br><span class="line"> <span class="built_in">uninitialized_copy</span>(position, old_finish, finish); <span class="comment">//再把余下占用元素后移</span></span><br><span class="line"> finish += elems_after; </span><br><span class="line"> <span class="built_in">fill</span>(position, old_finish, x_copy); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">// 备用空间小于「新增元素个数」（那就必须配置额外的内存）</span></span><br><span class="line"> <span class="comment">// 首先决定新长度：旧长度的两倍，或旧长度+新增元素个数。</span></span><br><span class="line"> <span class="type">const</span> size_type old_size = <span class="built_in">size</span>(); </span><br><span class="line"> <span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n); </span><br><span class="line"> <span class="comment">// 以下配置新的 vector 空间</span></span><br><span class="line"> iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); </span><br><span class="line"> iterator new_finish = new_start; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> <span class="comment">// 以下首先将旧 vector的安插点之前的元素复制到新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); </span><br><span class="line"> <span class="comment">// 以下再将新增元素（初值皆为 n）填入新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x); </span><br><span class="line"> <span class="comment">// 以下再将旧 vector 的安插点之后的元素复制到新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> <span class="comment">// 如有异常发生，实现 &quot;commit or rollback&quot; semantics. </span></span><br><span class="line"><span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(new_start, len); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta"># <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line"> <span class="comment">// 以下清除并释放旧的 vector </span></span><br><span class="line"><span class="built_in">destroy</span>(start, finish); </span><br><span class="line"><span class="built_in">deallocate</span>(); </span><br><span class="line"><span class="comment">// 以下调整水位标记</span></span><br><span class="line">start = new_start; </span><br><span class="line">finish = new_finish;  </span><br><span class="line">end_of_storage = new_start + len; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，安插完成后，新节点将位于标兵迭代器（上例之 position，标示出安插点）所指之节点的前方—这是STL对于「安插动作」的标准规范。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B51.png" alt="image-20220628165729556"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B52.png" alt="image-20220628165749526"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B53.png" alt="image-20220628165819539"></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次安插或删除一个元素，就配置或释放一个元素空间。因此，list对于<strong>空间的运用有绝对的精准</strong>，一点也不浪费。而且，对于任何位置的元素<strong>安插</strong>或元素<strong>移除</strong>，list永远是<strong>常数时间</strong>。</p>
<p>list和vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器，必须视元素的多寡、元素的构造复杂度（有无 non-trivial copy constructor, non-trivial copy assignmen operator）、元素存取行为的特性而定。</p>
<h3 id="list-的节点（node）"><a href="#list-的节点（node）" class="headerlink" title="list 的节点（node）"></a>list 的节点（node）</h3><p>list本身和 list的节点是不同的结构，需要分开设计。以下是 STL list的节点（node）结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer; </span><br><span class="line"> void_pointer prev; <span class="comment">//型别为 void*。其实可设为 __list_node&lt;T&gt;* </span></span><br><span class="line"> void_pointer next; </span><br><span class="line"> T data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然这是一个双向串行（有前后指针）。</p>
<h3 id="list-的迭代器"><a href="#list-的迭代器" class="headerlink" title="list 的迭代器"></a>list 的迭代器</h3><p>list不再能够像vector一样以普通指针做为迭代器，因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点，并有能力做正确的递增、递减、取值、成员存取…等动作。所谓「list迭代器正确的递增、递减、取值、成员取用」动作是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的值，成员取用时取用的是节点的成员。</p>
<p>由于STL list是一个双向串行（double linked-list），迭代器必须具备前移、后移的能力。所以list提供的是<em>Bidirectional Iterator</em>s。</p>
<p>list有一个重要性质：安插动作（insert）和接合动作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vector的安插动作可能造成内存重新配置，导致原有的迭代器全部失效。甚至list的元素删除动作（erase），也只有「指向被删除元素」的那个迭代器失效，其它迭代器不受任何影响。</p>
<p>以下是list迭代器的设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self; <span class="comment">//注：感觉self和iterator没多大区别？</span></span><br><span class="line"> <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> link_type node; <span class="comment">//迭代器内部当然要有一个指针，指向 list 的节点</span></span><br><span class="line"><span class="comment">// constructor </span></span><br><span class="line"> __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> __list_iterator() &#123;&#125; </span><br><span class="line"> __list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125; <span class="comment">//注：复制构造函数</span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125; </span><br><span class="line"><span class="comment">// 以下对迭代器取值（dereference），取的是节点的资料值。</span></span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125; </span><br><span class="line"><span class="comment">// 以下是迭代器的成员存取（member access）运算子的标准作法。</span></span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; <span class="comment">//注：这个指针，指向data的地址，如果对它使用*就能取出值</span></span><br><span class="line"><span class="comment">// 对迭代器累加 1，就是前进一个节点</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> node = (link_type)((*node).next); </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> ++*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 对迭代器递减 1，就是后退一个节点</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>--()</span><br><span class="line"> node = (link_type)((*node).prev); </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> --*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="list-的数据结构"><a href="#list-的数据结构" class="headerlink" title="list 的数据结构"></a>list 的数据结构</h3><p>SGI list不仅是一个双向串行，而且还是一个环状双向串行。所以它只需要一个指标，便可以完整表现整个串行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;<span class="comment">// 预设使用 alloc 为配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> list_node* link_type; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> link_type node;<span class="comment">// 只要一个指标，便可表示整个环状双向串行</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果让指标node指向刻意置于<strong>尾端的一个空白节点</strong>，node便能符合 STL对于「前闭后开」区间的要求，成为last迭代器。</p>
<p>示意图如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/list%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20220628201940409"></p>
<p>这么一来，以下几个函式便都可以轻易完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125; </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125; </span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">size_type result = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result); <span class="comment">// 全域函式，第 3 章。</span></span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取头节点的内容（元素值）。</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125; </span><br><span class="line"><span class="comment">// 取尾节点的内容（元素值）。</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-的建构与内存管理：constructor-push-back-insert"><a href="#list-的建构与内存管理：constructor-push-back-insert" class="headerlink" title="list 的建构与内存管理：constructor, push_back, insert"></a>list 的建构与内存管理：constructor, push_back, insert</h3><p>下面是一个测试程序，观察重点在建构的方式以及大小的变化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4list-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> list&lt;<span class="type">int</span>&gt; ilist; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0 </span></span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">0</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">2</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> list&lt;<span class="type">int</span>&gt;::iterator ite; </span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> ilist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 99 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> cout &lt;&lt; *(ilist.<span class="built_in">erase</span>(ite)) &lt;&lt; endl; <span class="comment">// 2 </span></span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 2 99 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list预设使用alloc 做为空间配置器 ， 并据此另外定义了一个list_node_allocator，为的是更方便地以节点大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;<span class="comment">// 预设使用 alloc 为配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node; </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个节点大小：</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，list_node_allocator(n)表示配置n个节点空间。以下四个函式，分别用来配置、释放、建构、摧毁一个节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 配置一个节点并传回</span></span><br><span class="line"> <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>(); &#125; </span><br><span class="line"> <span class="comment">// 释放一个节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::<span class="built_in">deallocate</span>(p); &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 产生（配置并建构）一个节点，带有元素值</span></span><br><span class="line"> <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> link_type p = <span class="built_in">get_node</span>(); </span><br><span class="line"> <span class="built_in">construct</span>(&amp;p-&gt;data, x); <span class="comment">//全域函式，建构/解构基本工具。</span></span><br><span class="line"> <span class="keyword">return</span> p; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 摧毁（解构并释放）一个节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123; </span><br><span class="line"> <span class="built_in">destroy</span>(&amp;p-&gt;data); <span class="comment">//全域函式，建构/解构基本工具</span></span><br><span class="line"> <span class="built_in">put_node</span>(p);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list提供有许多constructors，其中一个是default constructor，允许我们不指定任何参数做出一个空的list出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">list</span>() &#123;<span class="built_in">empty_initialize</span>(); &#125; <span class="comment">//产生一个空串行。</span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> node </span>=<span class="built_in">get_node</span>(); <span class="comment">//配置一个节点空间，令 node 指向它。</span></span><br><span class="line"> node-&gt;next = node;<span class="comment">//令 node头尾都指向自己，不设元素值。</span></span><br><span class="line"> node-&gt;prev = node; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/emptylist%EF%BC%88%E7%A9%BA%E4%B8%B2%E8%A1%8C%EF%BC%89.png" alt="image-20220629142749124"></p>
<p>当我们以 push_back() 将新元素安插于 list 尾端，此函式内部呼叫insert()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125;</span><br></pre></td></tr></table></figure>

<p>insert()是一个多载化函式，有多种型式，其中最简单的一种如下，符合以上所需。首先配置并建构一个节点，然后在尾端做适当的指标动作，将新节点安插进去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函式目的：在迭代器 position 所指位置安插一个节点，内容为 x。</span></span><br><span class="line"> <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> link_type tmp =<span class="built_in">create_node</span>(x); <span class="comment">//产生一个节点（设内容为 x）</span></span><br><span class="line"> <span class="comment">// 调整双向指标，使 tmp安插进去。</span></span><br><span class="line"> tmp-&gt;next = position.node; <span class="comment">//注：从这里可以看出是在position前面安插</span></span><br><span class="line"> tmp-&gt;prev = position.node-&gt;prev; </span><br><span class="line"> (<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp; </span><br><span class="line"> position.node-&gt;prev = tmp; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意，安插完成后，新节点将位于标兵迭代器（标示出安插点）所指之节点的前方——这是STL对于「安插动作」的标准规范。由于 list 不像 vector 那样有可能在空间不足时做重新配置、数据搬移的动作，所以安插前的所有迭代器在安插动作之后都仍然有效。</p>
<h3 id="list-的元素操作"><a href="#list-的元素操作" class="headerlink" title="list 的元素操作"></a>list 的元素操作</h3><p>元素操作的手段包括：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort </code></p>
<p>list所提供的元素操作动作很多，无法在有限的篇幅中一一讲解——其实也没有这种必要。为搭配先前对空间配置的讨论，我挑选数个相关函式做为解说对象。先前示例中出现有尾部安插动作（push_back），现在我们来看看其它的安插动作和移除动作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安插一个节点，做为头节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x); &#125; </span><br><span class="line"><span class="comment">// 安插一个节点，做为尾节点（上一小节才介绍过）</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125; </span><br><span class="line"><span class="comment">// 移除迭代器 position 所指节点</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; </span><br><span class="line"> link_type next_node = <span class="built_in">link_type</span>(position.node-&gt;next); </span><br><span class="line"> link_type prev_node = <span class="built_in">link_type</span>(position.node-&gt;prev); </span><br><span class="line"> prev_node-&gt;next = next_node; </span><br><span class="line"> next_node-&gt;prev = prev_node; </span><br><span class="line"> <span class="comment">//跟换指针指向的操作都是四个动作</span></span><br><span class="line"> <span class="built_in">destroy_node</span>(position.node); </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>()); &#125; </span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> iterator tmp </span>= <span class="built_in">end</span>(); </span><br><span class="line"> <span class="built_in">erase</span>(--tmp); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//清除所有节点（整个串行）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>() </span><br><span class="line">&#123; </span><br><span class="line"> link_type cur = (link_type) node-&gt;next; <span class="comment">// begin() </span></span><br><span class="line"> <span class="keyword">while</span> (cur != node) &#123;<span class="comment">//巡访每一个节点</span></span><br><span class="line"> link_type tmp = cur; </span><br><span class="line"> cur = (link_type) cur-&gt;next; </span><br><span class="line"> <span class="built_in">destroy_node</span>(tmp); <span class="comment">//摧毁（解构并释放）一个节点</span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 恢复 node 原始状态</span></span><br><span class="line"> node-&gt;next = node; </span><br><span class="line"> node-&gt;prev = node; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数值为 value之所有元素移除</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last = <span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123;<span class="comment">//巡访每一个节点</span></span><br><span class="line"> iterator next = first; </span><br><span class="line"> ++next; </span><br><span class="line"> <span class="keyword">if</span> (*first == value)<span class="built_in">erase</span>(first); <span class="comment">//找到就移除</span></span><br><span class="line"> first = next; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//移除数值相同的连续元素。注意，只有「连续而相同的元素」，才会被移除剩一个。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>() &#123; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last = <span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;<span class="comment">//空串行，什么都不必做。</span></span><br><span class="line"> iterator next = first; </span><br><span class="line"> <span class="keyword">while</span> (++next != last) &#123; <span class="comment">//巡访每一个节点</span></span><br><span class="line"> <span class="keyword">if</span> (*first == *next) <span class="comment">//如果在此区段中有相同的元素</span></span><br><span class="line"> 	<span class="built_in">erase</span>(next); <span class="comment">//移除之</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     first = next; <span class="comment">//调整指标</span></span><br><span class="line"> next = first; <span class="comment">//修正区段范围</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于list是一个双向环状串行，只要我们把边际条件处理好，那么，在头部或尾部安插元素（push_front和push_back），动作几乎是一样的，在头部或尾部移除元素（pop_front和pop_back），动作也几乎是一样的。移除（erase）某个迭代器所指元素，只是做一些指标搬移动作而已，并不复杂。</p>
<p>list内部提供一个所谓的迁移动作（transfer）：将某连续范围的元素迁移到某个特定位置之前。技术上很简单，节点间的指标移动而已。这个动作为其它的复杂动作如splice, sort, merge等奠定良好的基础。下面是transfer的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 将 [first,last) 内的所有元素搬移到 position 之前。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position != last) &#123; </span><br><span class="line"> (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node; <span class="comment">// (1) </span></span><br><span class="line"> (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node; <span class="comment">// (2) </span></span><br><span class="line"> (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node; <span class="comment">// (3) </span></span><br><span class="line"> link_type tmp = <span class="built_in">link_type</span>((*position.node).prev); <span class="comment">// (4)</span></span><br><span class="line"> (*position.node).prev = (*last.node).prev; <span class="comment">// (5)</span></span><br><span class="line"> (*last.node).prev = (*first.node).prev; <span class="comment">// (6)</span></span><br><span class="line"> (*first.node).prev = tmp; <span class="comment">// (7)</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上七个动作，一步一步地显示于下图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/transfer%E7%9A%84%E5%8A%A8%E4%BD%9C%E7%A4%BA%E6%84%8F.png" alt="image-20220629144350474"></p>
<p>transfer所接受的[first,last)区间，是否可以在同一个list之中呢？答案是可以。你只要想象上图所画的两条lists其实是同一个list的两个区段，就不难得到答案了。</p>
<p>上述的 transfer并非公开界面。list公开提供的是所谓的接合动作（splice）：将某连续范围的元素从一个list搬移到另一个（或同一个）list的某个定点。如果接续先前 4list-test.cpp 程序的最后执行点，继续执行以下splice动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iv[<span class="number">5</span>] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;; </span><br><span class="line"> <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist2</span><span class="params">(iv, iv+<span class="number">5</span>)</span></span>; </span><br><span class="line"> <span class="comment">// 目前，ilist的内容为 0 2 99 3 4 </span></span><br><span class="line"> ite = <span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">99</span>); </span><br><span class="line"> ilist.<span class="built_in">splice</span>(ite,ilist2); <span class="comment">// 0 2 5 6 7 8 9 99 3 4</span></span><br><span class="line"> ilist.<span class="built_in">reverse</span>(); <span class="comment">// 4 3 99 9 8 7 6 5 2 0 </span></span><br><span class="line"> ilist.<span class="built_in">sort</span>();<span class="comment">// 0 2 3 4 5 6 7 8 9 99</span></span><br></pre></td></tr></table></figure>

<p>很容易便可看出效果，接合动作技术上很简单，只是节点间的指标移动而已，这些动作已完全由transfer()做掉了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8E%A5%E5%90%88%EF%BC%88splice%EF%BC%89%E5%8A%A8%E4%BD%9C.png" alt="image-20220629145208401"></p>
<p>为了提供各种接口弹性，list<T>::splice有许多版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// 将 x接合于 position 所指位置之前。x必须不同于 *this。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (!x.<span class="built_in">empty</span>()) </span><br><span class="line"><span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 将 i 所指元素接合于 position 所指位置之前。position 和 i 可指向同一个 list。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span> </span>&#123; </span><br><span class="line"> iterator j = i; </span><br><span class="line"> ++j; </span><br><span class="line"> <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>; </span><br><span class="line"><span class="built_in">transfer</span>(position, i, j); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 将 [first,last) 内的所有元素接合于 position所指位置之前。</span></span><br><span class="line"> <span class="comment">// position 和[first,last)可指向同一个 list，</span></span><br><span class="line"> <span class="comment">// 但 position 不能位于[first,last)之内。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (first != last) </span><br><span class="line"><span class="built_in">transfer</span>(position, first, last); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以下是merge(), reverse(), sort()的源码。有了transfer()在手，这些动作都不难完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge()将 x合并到 *this身上。两个 lists 的内容都必须先经过递增排序。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123; </span><br><span class="line"> iterator first1 = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last1 = <span class="built_in">end</span>(); </span><br><span class="line"> iterator first2 = x.<span class="built_in">begin</span>(); </span><br><span class="line"> iterator last2 = x.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="comment">// 注意：前提是，两个 lists都已经过递增排序，</span></span><br><span class="line"> <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) <span class="comment">//注：如同归并排序的合并部分</span></span><br><span class="line"> <span class="keyword">if</span> (*first2 &lt; *first1) &#123; </span><br><span class="line"> iterator next = first2; </span><br><span class="line"> <span class="built_in">transfer</span>(first1, first2, ++next); </span><br><span class="line"> first2 = next; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> ++first1; </span><br><span class="line"> <span class="keyword">if</span> (first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse()将 *this的内容逆向重置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下判断，如果是空白串行，或仅有一个元素，就不做任何动作。</span></span><br><span class="line"> <span class="comment">// 使用 size() == 0 || size() == 1来判断，虽然也可以，但是比较慢。</span></span><br><span class="line"> <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123; </span><br><span class="line"> iterator old = first; </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first); <span class="comment">//左闭右开，把第2个插到最前面，把第3个插到最前面...一直下去就倒序了</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 不能使用 STL 算法 sort()，必须使用自己的 sort() member function，</span></span><br><span class="line"><span class="comment">//因为 STL 算法 sort() 只接受 RamdonAccessIterator. </span></span><br><span class="line"><span class="comment">//本函式采用 quick sort. </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下判断，如果是空白串行，或仅有一个元素，就不做任何动作。</span></span><br><span class="line"> <span class="comment">// 使用 size() == 0 || size() == 1来判断，虽然也可以，但是比较慢。</span></span><br><span class="line"> <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> <span class="comment">// 一些新的 lists，做为中介数据存放区</span></span><br><span class="line"> list&lt;T, Alloc&gt; carry; </span><br><span class="line"> list&lt;T, Alloc&gt; counter[<span class="number">64</span>]; </span><br><span class="line"> <span class="type">int</span> fill = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>()); </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> counter[i].<span class="built_in">merge</span>(carry); </span><br><span class="line"> carry.<span class="built_in">swap</span>(counter[i++]); </span><br><span class="line"> &#125; </span><br><span class="line"> carry.<span class="built_in">swap</span>(counter[i]); </span><br><span class="line"> <span class="keyword">if</span> (i == fill) ++fill; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) </span><br><span class="line"> counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]); </span><br><span class="line"><span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector和list对比总结"><a href="#vector和list对比总结" class="headerlink" title="vector和list对比总结"></a>vector和list对比总结</h2><p>vector类似数组（不过是动态的）使用连续空间、普通指针，迭代器是随机访问类型的；list类似链表，使用分散的空间、节点指针，迭代器是双向串行类型的。vector只针对尾部操作，而list可以针对头部和尾部。</p>
<p>两者在内存配置有很大的差别，vector需要预先配置一块连续空间，有元素需求时再建构元素（这样建构效率高），但连续空间一旦空间不足就需要重新配置。list则是直接重新分配一个节点，包括空间配置和元素建构。</p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque-概述"><a href="#deque-概述" class="headerlink" title="deque 概述"></a>deque 概述</h3><p>vector是<strong>单向开口</strong>的连续线性空间，deque则是一种<strong>双向开口</strong>的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的安插和删除动作。vector当然也可以在头尾两端做动作（从技术观点），但是其<strong>头部动作效率奇差</strong>，无法被接受。（注：因为是连续空间，头部元素不能往前扩充，vector只能整体后移或整体前移）</p>
<p>deque和vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的安插或移除动作，二在于deque没有所谓容量（capacity）观念，因为它是动态地以<strong>分段连续空间</strong>组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样「因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间」这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留（reserve）功能。</p>
<p>虽然deque也提供<em>Ramdon Access Iterator</em>，但它的迭代器并不是普通指针，其复杂度和vector不可以道里计（稍后看到源码，你便知道），这当然在在影响了各个运算层面。因此，除非必要，我们应<strong>尽可能选择使用vector而非deque</strong>。 对 deque进行的排序动作，为了最高效率，可将deque先完整复制到一个 vector 身上，将vector排序后（利用 STL sort算法），再复制回 deque。</p>
<h3 id="deque-的中控器"><a href="#deque-的中控器" class="headerlink" title="deque 的中控器"></a>deque 的中控器</h3><p>deque是连续空间（至少逻辑看来如此），deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的界面。避开了「重新配置、复制、释放」的轮回，代价则是复杂的迭代器架构。 </p>
<p>受到分段连续线性空间的字面影响，可能以为deque的实作复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既曰分段连续线性空间，就必须有<strong>中央控制</strong>，而为了维护整体连续的假象，数据结构的设计及迭代器前进后退等动作都颇为繁琐。deque的实作码份量远比vector或list都多得多。</p>
<p>deque采用一块所谓的<em><strong>map</strong></em>（注意，不是 STL 的map容器）做为主控。这里所谓<em>map</em>是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指标，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL允许我们指定缓冲区大小，默认值 0表示将使用 512 bytes缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic types </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"> <span class="comment">// 元素的指针的指针（pointer of pointer of T）</span></span><br><span class="line"> <span class="keyword">typedef</span> pointer* map_pointer; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Data members</span></span><br><span class="line"> map_pointer map; <span class="comment">//指向 map，map 是块连续空间，其内的每个元素</span></span><br><span class="line"> <span class="comment">// 都是一个指标（称为节点），指向一块缓冲区。</span></span><br><span class="line"> size_type map_size;<span class="comment">// map 内可容纳多少指标。</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>map</em>其实是一个T**，也就是说它是一个指标，所指之物又是一 个指标，指向型别为T的一块空间</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1map.png" alt="image-20220629151506642"></p>
<h3 id="deque-的迭代器"><a href="#deque-的迭代器" class="headerlink" title="deque 的迭代器"></a>deque 的迭代器</h3><p>deque是分段连续空间 。维护其「整体连续」假象的任务 ，着落在迭代器的operator++和operator– 两个运算子身上。</p>
<p>让我们思考一下，deque迭代器应该具备什么结构。首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（<em>map</em>）。下面这种实作方式符合需求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123;<span class="comment">//未继承 std::iterator </span></span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt; const_iterator; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125; </span><br><span class="line"><span class="comment">// ᳾继承 std::iterator，所以必须自行撰写五个必要的迭代器相应型别（第 3 章）</span></span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1) </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; <span class="comment">// (2)</span></span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// (3) </span></span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; <span class="comment">// (4) </span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;<span class="comment">// (5) </span></span><br><span class="line"> <span class="keyword">typedef</span> T** map_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator self; </span><br><span class="line"> <span class="comment">// 保持与容器的联结</span></span><br><span class="line"> T* cur;<span class="comment">//此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line"> T* first;<span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line"> T* last;<span class="comment">//此迭代器所指之缓冲区的尾（含备用空间）</span></span><br><span class="line"> map_pointer node;<span class="comment">//指向管控中心</span></span><br><span class="line"> ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中用来决定<strong>缓冲区大小</strong>的函式buffer_size()，呼叫__deque_buf_size()，后者是个全域函式，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 n不为 0，传回 n，表示 buffer size 由使用者自定。</span></span><br><span class="line"><span class="comment">//如果 n为 0，表示 buffer size使用默认值，那么</span></span><br><span class="line"><span class="comment">//如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，</span></span><br><span class="line"><span class="comment">//如果 sz 不小于 512，传回 1。</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque的中控器、缓冲区、迭代器的相互关系如下图，中控器控制缓冲区，迭代器能控制缓冲区，也能获取中控器的信息。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="image-20220629152413832"></p>
<p>假设现在我们产生一个<code>deque&lt;int&gt;</code>，并令其缓冲区大小为32，于是每个缓冲区可容纳 32&#x2F;sizeof(int)&#x3D;4 个元素。经过某些操作之后，deque 拥有 20 个元素，那么其begin()和end()所传回的两个迭代器应该如下图。这两个迭代器事实上一直保持在deque内，名为start和finish，稍后在deque数据结构中 便可看到）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84begin%E5%92%8Cend.png" alt="image-20220629152706622"></p>
<p>20个元素需要 20&#x2F;8 &#x3D; 3 个缓冲区，所以<em>map</em>之内运用了三个节点。迭代器 start 内的 cur指标当然指向缓冲区的第一个元素，迭代器 finish内的 cur指标当然指向缓冲区的最后元素（的下一位置）。注意，最后一个缓冲区尚有备用空间。稍后如果有新元素要安插于尾端，可直接拿此备用空间来使用。</p>
<p>下面是deque迭代器的几个关键行为。由于迭代器内对各种指标运算都做了多载化动作，所以各种指标运算如加、减、前进、后退…都不能直观视之。其中最重点的关键就是：一旦行进时<strong>遇到缓冲区边缘</strong>，要特别当心，视前进或后退而定，可能需要呼叫set_node()跳一个缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123; </span><br><span class="line">node = new_node; </span><br><span class="line">first = *new_node; </span><br><span class="line">last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//以下各个多载化运算子是 __deque_iterator&lt;&gt; 成功运作的关键。</span></span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125; </span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"> difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>++() &#123; </span><br><span class="line"> ++cur; <span class="comment">//切换至下一个元素。</span></span><br><span class="line"> <span class="keyword">if</span> (cur == last) &#123; <span class="comment">//如果已达所在缓冲区的尾端，</span></span><br><span class="line"> <span class="built_in">set_node</span>(node + <span class="number">1</span>);<span class="comment">//就切换至下一节点（亦即缓冲区）的第一个元素。</span></span><br><span class="line"> cur = first; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;<span class="comment">//后置式，标准写法</span></span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> ++*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>--() &#123; </span><br><span class="line"> <span class="keyword">if</span> (cur == first) &#123; <span class="comment">//如果已达所在缓冲区的头端，</span></span><br><span class="line"> <span class="built_in">set_node</span>(node - <span class="number">1</span>);<span class="comment">//就切换至前一节点（亦即缓冲区）的最后一个元素。</span></span><br><span class="line"> cur = last; </span><br><span class="line"> &#125; </span><br><span class="line"> --cur; <span class="comment">//切换至前一个元素。</span></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;<span class="comment">//后置式，标准写法</span></span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> --*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n个距离。</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123; </span><br><span class="line"> difference_type offset = n + (cur - first); </span><br><span class="line"> <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) </span><br><span class="line"> <span class="comment">// 标的位置在同一缓冲区内</span></span><br><span class="line"> 	cur += n; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 标的位置不在同一缓冲区内</span></span><br><span class="line"> difference_type node_offset = </span><br><span class="line"> offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 切换至正确的节点（亦即缓冲区）</span></span><br><span class="line"><span class="built_in">set_node</span>(node + node_offset); </span><br><span class="line"><span class="comment">// 切换至正确的元素</span></span><br><span class="line"> cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; <span class="comment">//*this不变</span></span><br><span class="line"> <span class="keyword">return</span> tmp += n; <span class="comment">// 唤起 operator+= </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>+= -n; &#125; </span><br><span class="line"> <span class="comment">// 以上利用 operator+= 来完成 operator-= </span></span><br><span class="line"> <span class="comment">// 参考More Effective C++, item22: Consider using op= instead of </span></span><br><span class="line"> <span class="comment">// stand-alone op. </span></span><br><span class="line"> self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp -= n; <span class="comment">// 唤起 operator-= </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n个距离。</span></span><br><span class="line"> reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125; </span><br><span class="line"> <span class="comment">// 以上唤起 operator*, operator+ </span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque-的数据结构"><a href="#deque-的数据结构" class="headerlink" title="deque 的数据结构"></a>deque 的数据结构</h3><p>deque除了维护一个先前说过的指向<em>map</em>的指标外，也维护start, finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外它当然也必须记住目前的<em>map</em>大小。因为一旦<em>map</em>所提供的节点不足，就必须重新配置更大的一块<em>map</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic types </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type;</span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Iterators </span></span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*,BufSiz&gt; iterator; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"> <span class="comment">// 元素的指针的指针（pointer of pointer of T）</span></span><br><span class="line"> <span class="keyword">typedef</span> pointer* map_pointer; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Data members </span></span><br><span class="line"> iterator start; <span class="comment">//表现第一个节点。</span></span><br><span class="line"> iterator finish; <span class="comment">//表现最后一个节点。</span></span><br><span class="line"> map_pointer map; <span class="comment">//指向 map，map 是块连续空间 ，其每个元素都是个指针，指向一个节点（缓冲区）。</span></span><br><span class="line"> size_type map_size;<span class="comment">// map 内有多少指标。</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上述结构，以下数个机能便可轻易完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic accessors </span></span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; </span><br><span class="line"> <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//唤起 __deque_iterator&lt;&gt;::operator[] </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 唤起 __deque_iterator&lt;&gt;::operator* </span></span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> iterator tmp = finish; </span><br><span class="line"> --tmp;<span class="comment">//唤起 __deque_iterator&lt;&gt;::operator-- </span></span><br><span class="line"> <span class="keyword">return</span> *tmp; <span class="comment">//唤起 __deque_iterator&lt;&gt;::operator* </span></span><br><span class="line"><span class="comment">// 以上三行何不改为：return *(finish-1); </span></span><br><span class="line"> <span class="comment">// 因为 __deque_iterator&lt;&gt; 没有为 (finish-1) 定义运算子?! </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 下行最后有两个 ‘;’，虽奇怪但合乎语法。</span></span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125; </span><br><span class="line"><span class="comment">// 以上唤起 iterator::operator- //注：并没有operator-(iterator&amp; x)的版本啊...</span></span><br><span class="line"> <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque-的建构与内存管理-ctor-push-back-push-front"><a href="#deque-的建构与内存管理-ctor-push-back-push-front" class="headerlink" title="deque 的建构与内存管理 ctor, push_back, push_front"></a>deque 的建构与内存管理 ctor, push_back, push_front</h3><p>下面是一个测试程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4deque-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="function">deque&lt;<span class="type">int</span>,alloc,32&gt; <span class="title">ideq</span><span class="params">(<span class="number">20</span>,<span class="number">9</span>)</span></span>; <span class="comment">// 注意，alloc 只适用于 G++ </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=20 </span></span><br><span class="line"><span class="comment">// 现在，应该已经建构了一个 deque，有 20 个 int 元素，初值皆为 9。</span></span><br><span class="line"> <span class="comment">// 缓冲区大小为 32bytes。</span></span><br><span class="line"><span class="comment">// 为每一个元素设定新值。</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> ideq[i] = i; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 4 5 6...19 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 在最尾端增加 3 个元素，其值为 0,1,2 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) </span><br><span class="line"> ideq.<span class="built_in">push_back</span>(i); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 ... 19 0 1 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=23 </span></span><br><span class="line"><span class="comment">// 在最尾端增加 1 个元素，其值为 3 </span></span><br><span class="line"> ideq.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 ... 19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=24 </span></span><br><span class="line"><span class="comment">// 在最前端增加 1 个元素，其值为 99 </span></span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">99</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">     cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 99 0 1 2 3...19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=25 </span></span><br><span class="line"><span class="comment">// 在最前端增加 2 个元素，其值分别为 98,97 </span></span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">98</span>); </span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">97</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 97 98 99 0 1 2 3...19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=27 </span></span><br><span class="line"><span class="comment">// 搜寻数值为 99 的元素，并打印出来。</span></span><br><span class="line"> deque&lt;<span class="type">int</span>,alloc,32&gt;::iterator itr; </span><br><span class="line"> itr =<span class="built_in">find</span>(ideq.<span class="built_in">begin</span>(), ideq.<span class="built_in">end</span>(), <span class="number">99</span>); </span><br><span class="line"> cout &lt;&lt; *itr &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line"> cout &lt;&lt; *(itr.cur) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序一开始宣告了一个deque：<code> deque&lt;int,alloc,32&gt; ideq(20,9);</code></p>
<p> 其缓冲区大小为 32 bytes，并令其保留 20 个元素空间，每个元素初值为 9。为了指定deque的第三个 template参数（缓冲区大小），我们必须将前两个参数都指明出来（这是 C++语法规则），因此必须明确指定alloc（第二章）为空间配置器。</p>
<p>deque自行定义了两个专属的空间配置器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator; </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个指针大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure>

<p>并提供有一个constructor如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> value_type&amp; value):<span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">fill_initialize</span>(n, value); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其内所呼叫的 fill_initialize()负责产生并安排好deque的结构，并将元素的初值设定妥当：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="type">const</span> value_type&amp; value) &#123; </span><br><span class="line"><span class="built_in">create_map_and_nodes</span>(n); <span class="comment">// 把 deque 的结构都产生并安排好</span></span><br><span class="line">map_pointer cur; </span><br><span class="line">__STL_TRY &#123; </span><br><span class="line"><span class="comment">// 为每个节点的缓冲区设定初值</span></span><br><span class="line"><span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur) </span><br><span class="line">	<span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value); </span><br><span class="line"><span class="comment">// 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）</span></span><br><span class="line"><span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);<span class="comment">//注意finish.cur指向末尾 </span></span><br><span class="line">&#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> ... </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 create_map_and_nodes()负责产生并安排好deque的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 </span></span><br><span class="line"> <span class="comment">// 如果刚好整除，会多配一个节点。</span></span><br><span class="line"> size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 一个 map要管理几个节点。最少 8 个，最多是 “所需节点数加 2” </span></span><br><span class="line"> <span class="comment">// （前后各预留一个，扩充时可用）。</span></span><br><span class="line"> map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>); </span><br><span class="line"> map =map_allocator::<span class="built_in">allocate</span>(map_size); </span><br><span class="line"> <span class="comment">// 以上配置出一个 “具有 map_size 个节点”的 map。</span></span><br><span class="line"> <span class="comment">// 以下令 nstart 和 nfinish 指向 map 所拥有之全部节点的最中央区段。</span></span><br><span class="line"> <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。</span></span><br><span class="line"> map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>; </span><br><span class="line"> map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>; </span><br><span class="line"> map_pointer cur; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"><span class="comment">// 为 map 内的每个现用节点配置缓冲区。所有缓冲区加起来就是 deque 的</span></span><br><span class="line"> <span class="comment">// 可用空间（最后一个缓冲区可能留有一些余裕）。</span></span><br><span class="line"> <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur) </span><br><span class="line"> *cur = <span class="built_in">allocate_node</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"><span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个不留。</span></span><br><span class="line"> ...</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// 为 deque 内的两个迭代器 start 和 end设定正确内容。</span></span><br><span class="line">start.<span class="built_in">set_node</span>(nstart); </span><br><span class="line">finish.<span class="built_in">set_node</span>(nfinish); </span><br><span class="line">start.cur = start.first; <span class="comment">// first, cur 都是 public </span></span><br><span class="line">finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>(); </span><br><span class="line"><span class="comment">// 前面说过，如果刚好整除，会多配一个节点。</span></span><br><span class="line"> <span class="comment">// 此时即令 cur 指向这多配的一个节点（所对映之缓冲区）的起头处。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来范例程序以注标运算子为每个元素重新设值，然后在尾端安插三个新元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line">ideq[i] = i; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) </span><br><span class="line">ideq.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>

<p>由于此时最后一个缓冲区仍有 4 个备用元素空间，所以不会引起缓冲区的再配置。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81413.png" alt="image-20220629200154708"></p>
<p>以下是push_back()函式内容： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// push_* and pop_* </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) </span><br><span class="line"> <span class="comment">// 最后缓冲区尚有一个以上的备用空间，注意是一个以上</span></span><br><span class="line"> <span class="built_in">construct</span>(finish.cur, t);<span class="comment">//直接在备用空间上建构元素</span></span><br><span class="line"> ++finish.cur;<span class="comment">//调整最后缓冲区的使用状态</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span></span><br><span class="line"> <span class="built_in">push_back_aux</span>(t); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果再新增加一个新元素（3）于尾端，由于尾端只剩一个元素备用空间，于是push_back()呼叫push_back_aux()，先配置一整块新的缓冲区，再设妥新元素内容，然后更改迭代器finish的状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当 finish.cur == finish.last – 1时才会被呼叫。</span></span><br><span class="line"><span class="comment">//也就是说只有当最后一个缓冲区只剩一个备用元素空间时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123; </span><br><span class="line">value_type t_copy = t; </span><br><span class="line"><span class="built_in">reserve_map_at_back</span>(); <span class="comment">// 若符合某种条件则必须重换一个 map </span></span><br><span class="line">*(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();<span class="comment">//配置一个新节点（缓冲区）</span></span><br><span class="line">__STL_TRY &#123; </span><br><span class="line"><span class="built_in">construct</span>(finish.cur, t_copy); <span class="comment">//针对标的元素设值，放在之前缓冲区的最后一个</span></span><br><span class="line">finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>); <span class="comment">//改变 finish，令其指向新节点</span></span><br><span class="line">finish.cur = finish.first; <span class="comment">//设定 finish 的状态</span></span><br><span class="line">&#125; </span><br><span class="line">__STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，deque的状态如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81414.png" alt="image-20220629200856607"></p>
<p>在deque的前端安插一个新元素99，push_front()函式动作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// push_* and pop_* </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start.cur != start.first) &#123; <span class="comment">//第一缓冲区尚有备用空间</span></span><br><span class="line"> <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接在备用空间上建构元素</span></span><br><span class="line"> --start.cur;  <span class="comment">//调整第一缓冲区的使用状态</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">// 第一缓冲区已无备用空间</span></span><br><span class="line"> <span class="built_in">push_front_aux</span>(t); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于目前状态下，第一缓冲区并无备用空间，所以呼叫push_front_aux()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当 start.cur == start.first 时才会被呼叫。</span></span><br><span class="line"><span class="comment">//也就是说只有当第一个缓冲区没有任何备用元素时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; t) </span><br><span class="line">&#123; </span><br><span class="line"> value_type t_copy = t; </span><br><span class="line"> <span class="built_in">reserve_map_at_front</span>(); <span class="comment">// 若符合某种条件则必须重换一个 map </span></span><br><span class="line"> *(start.node - <span class="number">1</span>) =<span class="built_in">allocate_node</span>();<span class="comment">//配置一个新节点（缓冲区）</span></span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>); <span class="comment">//改变 start，令其指向新节点</span></span><br><span class="line"> start.cur = start.last - <span class="number">1</span>; <span class="comment">//设定 start 的状态</span></span><br><span class="line"> <span class="built_in">construct</span>(start.cur, t_copy); <span class="comment">//针对标的元素设值</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> <span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个不留。</span></span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>); </span><br><span class="line"> start.cur = start.first; </span><br><span class="line"> <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>)); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入后如下，注意向前插入是从缓冲区尾部向前插，这样能保持空间逻辑上的连续：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81415.png" alt="image-20220629201304194"></p>
<p>回头看看一个悬而᳾解的问题：什么时候<em>map</em>需要重新整治？这个问题的判断由reserve_map_at_back()和reserve_map_at_front()进行，实际动作则由reallocate_map()执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map)) </span><br><span class="line"> <span class="comment">// 如果 map尾端的节点备用空间不足</span></span><br><span class="line"> <span class="comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line"> <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (nodes_to_add &gt; start.node - map) </span><br><span class="line"> <span class="comment">// 如果 map前端的节点备用空间不足</span></span><br><span class="line"> <span class="comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line"><span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：我要晕倒了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"> <span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="type">bool</span> add_at_front) &#123; </span><br><span class="line"> size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>; </span><br><span class="line"> size_type new_num_nodes = old_num_nodes + nodes_to_add; </span><br><span class="line"> map_pointer new_nstart; </span><br><span class="line"> <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123; <span class="comment">//注：这里不需要新开一块map，重新分配的原因是可能前面或者后面仍然有很大的空间，只需要把map平移一下即可		</span></span><br><span class="line"> new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add: <span class="number">0</span>); </span><br><span class="line"> <span class="keyword">if</span> (new_nstart &lt; start.node) <span class="comment">//注：向前向后平移的判断</span></span><br><span class="line"> <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> size_type new_map_size = map_size +<span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>; </span><br><span class="line"> <span class="comment">// 配置一块空间，准备给新 map 使用。</span></span><br><span class="line"> map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size); </span><br><span class="line"> new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 把原 map内容拷贝过来。</span></span><br><span class="line"> <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart); </span><br><span class="line"> <span class="comment">// 释放原 map </span></span><br><span class="line"> map_allocator::<span class="built_in">deallocate</span>(map, map_size); </span><br><span class="line"> <span class="comment">// 设定新 map 的起始地址与大小</span></span><br><span class="line"> map = new_map; </span><br><span class="line"> map_size = new_map_size; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 重新设定迭代器 start和 finish </span></span><br><span class="line"> start.<span class="built_in">set_node</span>(new_nstart); </span><br><span class="line"> finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque的元素操作-pop-back-pop-front-clear-erase-insert"><a href="#deque的元素操作-pop-back-pop-front-clear-erase-insert" class="headerlink" title="deque的元素操作 pop_back, pop_front, clear, erase, insert"></a>deque的元素操作 pop_back, pop_front, clear, erase, insert</h3><p>pop_back() 和pop_front()。所谓pop，是将元素拿掉。无论从deque 的最前端或最尾端取元素，都需考虑在某种条件下，将缓冲区释放掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish.cur != finish.first) &#123; <span class="comment">//注：cur原来指向下一个空的区域</span></span><br><span class="line"> <span class="comment">// 最后缓冲区有一个（或更多）元素</span></span><br><span class="line"> --finish.cur; <span class="comment">//调整指针，相当于排除了最后元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">destroy</span>(finish.cur);<span class="comment">//将最后元素解构</span></span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="comment">// 最后缓冲区没有任何元素</span></span><br><span class="line"> <span class="built_in">pop_back_aux</span>(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当 finish.cur == finish.first 时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>() &#123; </span><br><span class="line"> <span class="built_in">deallocate_node</span>(finish.first); <span class="comment">//释放最后一个缓冲区</span></span><br><span class="line"> finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);<span class="comment">//调整 finish 的状态，使指向</span></span><br><span class="line"> finish.cur = finish.last - <span class="number">1</span>; <span class="comment">// 上一个缓冲区的最后一个元素</span></span><br><span class="line"> <span class="built_in">destroy</span>(finish.cur); <span class="comment">//将该元素解构。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="comment">// 第一缓冲区有一个（或更多）元素</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur);<span class="comment">//将第一元素解构</span></span><br><span class="line"> ++start.cur; <span class="comment">//调整指针，相当于排除了第一元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="comment">// 第一缓冲区仅有一个元素</span></span><br><span class="line"> <span class="built_in">pop_front_aux</span>(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当 start.cur == start.last - 1 时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123; </span><br><span class="line"> <span class="built_in">destroy</span>(start.cur); <span class="comment">//将第一缓冲区的第一个元素解构。</span></span><br><span class="line"> <span class="built_in">deallocate_node</span>(start.first); <span class="comment">//释放第一缓冲区。</span></span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);<span class="comment">//调整 start的状态，使指向下一个缓冲区的第一个元素。</span></span><br><span class="line"> start.cur = start.first;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面这个例子是 clear()，用来清除整个 deque。请注意，deque的最初状态（无任何元素时）保有一个缓冲区，因此clear()完成之后回复初始状态，也一样要保留一个缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，最终需要保留一个缓冲区。这是 deque的策略，也是 deque的初始状态。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下针对头尾以外的每一个缓冲区（它们一定都是饱满的）</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123; </span><br><span class="line"> <span class="comment">// 将缓冲区内的所有元素解构。注意，呼叫的是 destroy() 第二版本</span></span><br><span class="line"> <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>()); </span><br><span class="line"> <span class="comment">// 释放缓冲区内存</span></span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (start.node != finish.node) &#123;<span class="comment">//至少有头尾两个缓冲区</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur, start.last);<span class="comment">//将头缓冲区的目前所有元素解构</span></span><br><span class="line"> <span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">// 将尾缓冲区的目前所有元素解构</span></span><br><span class="line"> <span class="comment">// 以下释放尾缓冲区。注意，头缓冲区保留。</span></span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span><span class="comment">//只有一个缓冲区</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur, finish.cur);<span class="comment">//将此唯一缓冲区内的所有元素解构</span></span><br><span class="line"> <span class="comment">// 注意，并不释放缓冲区空间。这唯一的缓冲区将保留。</span></span><br><span class="line"> finish = start; <span class="comment">//调整状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子是 erase()，用来清除某个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos所指的元素。pos为清除点。</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123; <span class="comment">//注：实际上是对pos.cur清除（因为调用*pos）</span></span><br><span class="line"> iterator next = pos; </span><br><span class="line"> ++next; <span class="comment">//注：pos.cur.next</span></span><br><span class="line"> difference_type index = pos - start;<span class="comment">//清除点之前的元素个数</span></span><br><span class="line"> <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">//如果清除点之前的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(start, pos, next);<span class="comment">//就搬移清除点之前的元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">pop_front</span>(); <span class="comment">//搬移完毕，最前一个元素赘余，去除之</span></span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//清除点之后的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy</span>(next, finish, pos);<span class="comment">//就搬移清除点之后的元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">pop_back</span>(); <span class="comment">//搬移完毕，最后一个元素赘余，去除之</span></span><br><span class="line"> <span class="keyword">return</span> start + index; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子是 erase()，用来清除[first,last)区间内的所有元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123; </span><br><span class="line"> <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;<span class="comment">// 如果清除区间就是整个 deque </span></span><br><span class="line"> <span class="built_in">clear</span>();  <span class="comment">//直接呼叫 clear()即可</span></span><br><span class="line"> <span class="keyword">return</span> finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> difference_type n = last - first;  <span class="comment">//清除区间的长度</span></span><br><span class="line"> difference_type elems_before = first - start;<span class="comment">//清除区间前方的元素个数</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//注：这里的搬运是因为清除一个区间可能截断了连续的数据空间，因此要把可能产生的前后两端连接起来</span></span><br><span class="line"> <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123; <span class="comment">//如果前方的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(start, first, last); <span class="comment">//向后搬移前方元素（覆盖清除区间）</span></span><br><span class="line"> iterator new_start = start + n; <span class="comment">//标记 deque的新起点</span></span><br><span class="line"> <span class="built_in">destroy</span>(start, new_start); <span class="comment">//搬移完毕，将赘余的元素解构</span></span><br><span class="line"> <span class="comment">// 以下将赘余的缓冲区释放</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> start = new_start;<span class="comment">//设定 deque 的新起点</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;<span class="comment">//如果清除区间后方的元素比较少</span></span><br><span class="line"> <span class="built_in">copy</span>(last, finish, first); <span class="comment">//向前搬移后方元素（覆盖清除区间）</span></span><br><span class="line"> iterator new_finish = finish - n;<span class="comment">//标记 deque的新尾点</span></span><br><span class="line"> <span class="built_in">destroy</span>(new_finish, finish); <span class="comment">//搬移完毕，将赘余的元素解构</span></span><br><span class="line"> <span class="comment">// 以下将赘余的缓冲区释放</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> finish = new_finish;<span class="comment">//设定 deque 的新尾点</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> start + elems_before; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个例子是insert。deque为这个功能提供了许多版本，最基础最重要的是以下版本，允许在某个点（之前）安插一个元素，并设定其值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 position 处安插一个元素，其值为 x </span></span><br><span class="line"> <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position.cur == start.cur) &#123;<span class="comment">//如果安插点是 deque最前端</span></span><br><span class="line"> <span class="built_in">push_front</span>(x); <span class="comment">//交给 push_front 去做</span></span><br><span class="line"> <span class="keyword">return</span> start; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123; <span class="comment">// 如果安插点是 deque最尾端</span></span><br><span class="line"> <span class="built_in">push_back</span>(x); <span class="comment">//交给 push_back去做</span></span><br><span class="line"> iterator tmp = finish; </span><br><span class="line"> --tmp;</span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x); <span class="comment">//交给 insert_aux 去做</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line"> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x) &#123; </span><br><span class="line"> difference_type index = pos - start;<span class="comment">//安插点之前的元素个数</span></span><br><span class="line"> value_type x_copy = x; </span><br><span class="line"> <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123; <span class="comment">//如果安插点之前的元素个数比较少</span></span><br><span class="line">     <span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//在最前端加入与第一元素同值的元素。注：相当于把安插点前面的元素向前移一格</span></span><br><span class="line">     iterator front1 = start; <span class="comment">//以下标示记号，然后进行元素搬移... </span></span><br><span class="line">     ++front1; </span><br><span class="line">     iterator front2 = front1; </span><br><span class="line">     ++front2; </span><br><span class="line">     pos = start + index; </span><br><span class="line">     iterator pos1 = pos; </span><br><span class="line">     ++pos1; </span><br><span class="line">     <span class="built_in">copy</span>(front2, pos1, front1); <span class="comment">//元素搬移，注：把原来的头元素覆盖，这样position位置就空出来了</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//安插点之后的元素个数比较少</span></span><br><span class="line">     <span class="built_in">push_back</span>(<span class="built_in">back</span>()); <span class="comment">//在最尾端加入与最后元素同值的元素。注：相当于把安插点后面的元素向后移一格</span></span><br><span class="line">     iterator back1 = finish;<span class="comment">//以下标示记号，然后进行元素搬移... </span></span><br><span class="line">     --back1; </span><br><span class="line">     iterator back2 = back1; </span><br><span class="line">     --back2; </span><br><span class="line">     pos = start + index; </span><br><span class="line">     <span class="built_in">copy_backward</span>(pos, back2, back1); <span class="comment">//元素搬移，注：把原来的尾元素覆盖，这样position位置就空出来了</span></span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line"> *pos = x_copy;<span class="comment">//在安插点上设定新值</span></span><br><span class="line"> <span class="keyword">return</span> pos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>deque相比vector和list要复杂很多，是一个二级结构。第一级是map，一块连续的空间，其中每个node又指向第二级的一块连续的空间（缓冲区），这些连续空间可以不连续（但逻辑上连续）。为了维护这个逻辑连续，迭代器（指向map的node，也指向缓冲区的节点）的设计就变得十分复杂。同时map中的节点是从中间向两边扩展，这就使得从头部插入、删除节点与从尾部插入、删除节点的动作是对称的，使得相比vector来说，头部操作的效率变好了。当空间不足时，一定是map除了问题，可以整体前移、后移，或是重新分配一个更大的空间。</p>
<p>为了兼容算法的接口，迭代器所“代表”的元素就是迭代器的cur节点指向的元素（重载了的*、++等运算，都是针对cur节点）。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出（First In Last Out，FILO）的数据结构。stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取stack的其它元素。换言之stack不允许有走访行为。</p>
<p>将元素推入 stack 的动作称为 <em>push</em>，将元素推出 stack 的动作称为<em>pop</em>。</p>
<h3 id="stack-定义式完整列表"><a href="#stack-定义式完整列表" class="headerlink" title="stack 定义式完整列表"></a>stack 定义式完整列表</h3><p>以某种既有容器做为底部结构，将其接口改变，使符合「先进后出」的特性，形成一个stack，是很容易做到的。deque是双向开口的数据结构，若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。因此，SGI STL 便 以deque做为预设情况下的stack底部结构，stack的实作因而非常简单，源码十分简短，本处完整列出。</p>
<p>由于stack系以底部容器完成其所有工作，而具有这种「<strong>修改某物接口</strong>，形成另一种风貌」之性质者，称为<strong>adapter</strong>（配接器），因此 STL stack往往不被归类为 container（容器），而被归类为<strong>container adapter</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; </span><br><span class="line"><span class="keyword">class</span> stack &#123; </span><br><span class="line"> <span class="comment">// 以下的 __STL_NULL_TMPL_ARGS 会开展为 &lt;&gt;</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;); </span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//底层容器</span></span><br><span class="line"><span class="comment">// 以下完全利用 Sequence c 的操作，完成 stack的操作。</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"><span class="comment">// deque是两头可进出，stack是末端进，末端出（所以后进者先出）。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c == y.c; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c &lt; y.c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack 所有元素的进出都必须符合「先进后出」的条件，只有 stack 顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。</p>
<h3 id="以-list做为-stack-的底层容器"><a href="#以-list做为-stack-的底层容器" class="headerlink" title="以 list做为 stack 的底层容器"></a>以 list做为 stack 的底层容器</h3><p>除了deque之外，list 也是双向开口的数据结构。上述 stack 源码中使用的底层容器的函式有empty, size, back, push_back, pop_back，凡此种种 list 都具备。因此若以list为底部结构并封闭其头端开口，一样能够轻易形成一个stack。下面是作法示范。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 4stack-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> stack&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt; &gt; istack; </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">5</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4 </span></span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue-概述"><a href="#queue-概述" class="headerlink" title="queue 概述"></a>queue 概述</h3><p>queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出，没有任何其它方法可以存取queue 的其它元素。换言之 queue 不允许有走访行为。</p>
<p>将元素推入 queue 的动作称为 <em>push</em>，将元素推出 queue 的动作称为<em>pop</em>。</p>
<h3 id="queue-定义式完整列表"><a href="#queue-定义式完整列表" class="headerlink" title="queue 定义式完整列表"></a>queue 定义式完整列表</h3><p>SGI STL 依然以deque做为预设情况下的queue底部结构，因此queue也被归类为container adapter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; </span><br><span class="line"><span class="keyword">class</span> queue &#123; </span><br><span class="line"> <span class="comment">// 以下的 __STL_NULL_TMPL_ARGS 会开展为 &lt;&gt;</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y); </span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y); </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//底层容器</span></span><br><span class="line"><span class="comment">// 以下完全利用 Sequence c 的操作，完成 queue的操作。</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"><span class="comment">// deque是两头可进出，queue 是末端进，前端出（所以先进者先出）。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c == y.c; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c &lt; y.c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="queue-没有迭代器"><a href="#queue-没有迭代器" class="headerlink" title="queue 没有迭代器"></a>queue 没有迭代器</h3><p>queue 所有元素的进出都必须符合「先进先出」的条件，只有 queue 顶端的元素，才有机会被外界取用。queue不提供走访功能，也不提供迭代器。</p>
<h3 id="以-list做为queue-的底层容器"><a href="#以-list做为queue-的底层容器" class="headerlink" title="以 list做为queue 的底层容器"></a>以 list做为queue 的底层容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 4queue-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt; &gt; iqueue; </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">5</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4 </span></span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap-概述"><a href="#heap-概述" class="headerlink" title="heap 概述"></a>heap 概述</h3><p>heap并不归属于STL 容器组件，它是个幕后英雄，扮演priority queue （优先级队列）的推手。顾名思义，priority queue 允许使用者以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）之元素开始取。binary max heap正是具有这样的特性，适合做为 priority queue的底层机制。</p>
<h4 id="为何使用堆作为优先级队列的底层"><a href="#为何使用堆作为优先级队列的底层" class="headerlink" title="为何使用堆作为优先级队列的底层"></a>为何使用堆作为优先级队列的底层</h4><p>如果使用 list 做为 priority queue 的底层机制，元素安插动作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改个作法，让元素安插前先经过排序这一关，使得 list 的元素值总是由小到大（或由大到小），但这么一来，虽然取得极值以及元素删除动作达到最高效率，元素的安插却只有线性表现。</p>
<p>比较麻辣的作法是以binary search tree 做为priority queue的底层机制。这么一来元素的安插和极值的取得就有*O(logN)*的表现。但这样未免小题大作，一来binary search tree的输入需要足够的随机性， 二来binary search tree并不容易实作。priority queue的复杂度，最好介于queue和binary search tree之间，才算适得其所。binary heap便是这种条件下 的适当候选人。</p>
<h4 id="堆的一些细节"><a href="#堆的一些细节" class="headerlink" title="堆的一些细节"></a>堆的一些细节</h4><p>所谓binary heap就是一种complete binary tree（完全二叉树），也就是说，整棵binary tree除了最底层的叶节点(s)之外，是填满的，而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p>complete binary tree整棵树内没有任何节点漏洞，这带来一个极大好处：我们可以利用array来储存所有节点。假设动用一个小技巧，将array的**#0元素保留<strong>（或设为无限大值或无限小值），那么当complete binary tree中的某个节点位于array的 <strong>i</strong> 处，其左子节点必位于array 的 <strong>2i</strong> 处，其右子节点必位于 array的 <strong>2i+1 处</strong>，其父节点必位于「</strong>i&#x2F;2**」处（此处的「」权且代表高斯符号，取其整数）。通过这么简单的位置规则，array可以轻易实作出complete binary tree。这种以array表述tree的方式，我们称为隐式表述法（implicit representation）。</p>
<p>我们需要的工具就很简单了：一个array和一组heap算法（用来安插元素、删除元素、取极值、将某一整组数据排列成一个heap）。array的缺点是无法动态改变大小，而heap却需要这项功能，因此以vector代替 array是更好的选择。</p>
<p>根据元素排列方式，heap可分为<strong>max-heap</strong>和 <strong>min-heap</strong> （最大堆和最小堆）两种，前者每个节点的键值（<em>key</em>）都大于或等于其子节点键值，后者的每个节点键值（<em>key</em>）都小于或等于其子节点键值。因此，max-heap的最大值在根节点，并总是位于底层 array 或vector的起头处；min-heap的最小值在根节点，亦总是位于底层array或vector的起头处。STL 供应的是max-heap，因此以下说heap时，指的是max-heap。</p>
<h3 id="heap-算法"><a href="#heap-算法" class="headerlink" title="heap 算法"></a>heap 算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p>插入元素首先插入到<strong>最后端</strong>，然后<strong>向上过滤</strong>。为满足 max-heap 的条件（每个节点的键值都大于或等于其子节点键值），我们执行一个所谓的percolate up（上溯）程序：将新节点拿来与其父节点比较，如果其键值（<em>key</em>）比父节点大，就父子对换位置。如此一直上溯，直到不需对换或直到根节点为止。 </p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/push_heap.png" alt="image-20220707145259201"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 注意，此函式被呼叫时，新元素应已置于底部容器的最尾端。</span></span><br><span class="line">__push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) &#123; </span><br><span class="line">__push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>))); </span><br><span class="line"><span class="comment">// 以上系根据 implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line"><span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 push_back()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">void__push_heap</span>(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) &#123; </span><br><span class="line"> Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//找出父节点</span></span><br><span class="line"> <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent)&lt; value) &#123; </span><br><span class="line"> <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line"> <span class="comment">// 由于以上使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）。</span></span><br><span class="line"> *(first + holeIndex) = *(first + parent);<span class="comment">//令洞值为父值</span></span><br><span class="line"> holeIndex = parent;<span class="comment">//percolate up：调整洞号，向上提升至父节点。</span></span><br><span class="line"> parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//新洞的父节点</span></span><br><span class="line"> &#125; <span class="comment">// 持续至顶端，或满足 heap 的次序特性为止。</span></span><br><span class="line"> *(first + holeIndex) = value;<span class="comment">//令洞值为新值，完成安插动作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p>既然身为max-heap，最大值必然在根节点。pop动作取走根节点（其实是移至底部容器vector的最后一个元素）之后，为了满足 complete binary tree的条件，必须将最下一层最右边的叶节点拿掉，现在我们的任务是为这个被拿掉的节点找一个适当的位置。</p>
<p>为满足max-heap的条件（每个节点的键值都大于或等于其子节点键值），我们执行一个所谓的percolate down<strong>（向下过滤）</strong>程序：将根节点（最大值被取走后，形成一个<strong>「洞」</strong>）填入上述那个失去生存空间的叶节点值，再将它拿来和其两个子节点比较键值（<em>key</em>），并与较大子节点对调位置。如此一直下放，直到这个「洞」的键值大于左右两个子节点，或直到下放至叶节点为止。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/pop_heap.png" alt="image-20220707145736213"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line">__pop_heap_aux(first, last, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) &#123; </span><br><span class="line">__pop_heap(first, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)), <span class="built_in">distance_type</span>(first)); </span><br><span class="line"><span class="comment">// 以上，根据 implicit representation heap的次序特性，pop 动作的结果</span></span><br><span class="line"> <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line"> <span class="comment">// 尾节点（所以以上将迭代器 result 设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line"> <span class="comment">// 使之重新成一个合格的 heap。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 __pop_heap() 不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator result, T value, Distance*) &#123; </span><br><span class="line"> *result = *first;<span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line"> <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值。</span></span><br><span class="line"> __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value); </span><br><span class="line"><span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这个 __adjust_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">void__adjust_heap</span>(RandomAccessIterator first, Distance holeIndex, Distance len, T value) &#123; </span><br><span class="line"> Distance topIndex = holeIndex; </span><br><span class="line"> Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;<span class="comment">//洞节点之右子节点</span></span><br><span class="line"> <span class="keyword">while</span> (secondChild &lt; len) &#123; </span><br><span class="line"><span class="comment">// 比较洞节点之左右两个子值，然后以 secondChild代表较大子节点。</span></span><br><span class="line"> <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>))) </span><br><span class="line"> secondChild--; </span><br><span class="line"> <span class="comment">// Percolate down：令较大子值为洞值，再令洞号下移至较大子节点处。</span></span><br><span class="line"> *(first + holeIndex) = *(first + secondChild); </span><br><span class="line"> holeIndex = secondChild; </span><br><span class="line"><span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line"> secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (secondChild == len) &#123;<span class="comment">//没有右子节点，只有左子节点</span></span><br><span class="line"><span class="comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line"> *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>)); </span><br><span class="line"> holeIndex = secondChild - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性。</span></span><br><span class="line"> <span class="comment">// 依侯捷之见，下面直接改为 *(first + holeIndex) = value; 应该可以。</span></span><br><span class="line">__push_heap(first, holeIndex, topIndex, value); <span class="comment">//注：就是最后把原来last元素填好位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>既然每次pop_heap可获得 heap之中键值最大的元素，如果持续对整个 heap做pop_heap动作，每次将操作范围从后向前缩减一个元素（因为 pop_heap 会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下这个 sort_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 以下，每执行一次 pop_heap()，极值（在 STL heap 中为极大值）即被放在尾端。</span></span><br><span class="line"> <span class="comment">// 扣除尾端再执行一次 pop_heap()，次极值又被放在新尾端。一直下去，最后即得</span></span><br><span class="line"> <span class="comment">// 排序结果。</span></span><br><span class="line"> <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) </span><br><span class="line"> <span class="built_in">pop_heap</span>(first, last--);<span class="comment">//每执行 pop_heap() 一次，操作范围即退缩一格。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="make-heap-算法"><a href="#make-heap-算法" class="headerlink" title="make_heap 算法"></a>make_heap 算法</h4><p>这个算法用来将一段现有的数据转化为一个 heap。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 [first,last) 排列为一个 heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"> __make_heap(first, last,<span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 make_heap()不允许指定「大小比较标准」。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*) &#123; </span><br><span class="line"> <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;<span class="comment">//如果长度为 0或 1，不必重新排列。</span></span><br><span class="line"> Distance len = last - first; </span><br><span class="line"> <span class="comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶节点都不需执行</span></span><br><span class="line"> <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为 holeIndex更好。</span></span><br><span class="line"> Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>; </span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">  <span class="comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap()判断操作范围</span></span><br><span class="line">  __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent))); </span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//走完根节点，就结束。</span></span><br><span class="line">  parent--; <span class="comment">//（即将重排之子树的）头部向前一个节点</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="heap-没有迭代器"><a href="#heap-没有迭代器" class="headerlink" title="heap 没有迭代器"></a>heap 没有迭代器</h3><p>heap 的所有元素都必须遵循特别的（complete binary tree）排列规则，所以 heap不提供走访功能，也不提供迭代器。</p>
<h3 id="heap测试实例"><a href="#heap测试实例" class="headerlink" title="heap测试实例"></a>heap测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// heap algorithms </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// test heap (底层以 vector完成) </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia+<span class="number">9</span>)</span></span>; </span><br><span class="line"> <span class="built_in">make_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 5 8 3 4 0 2 3 1 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ivec.<span class="built_in">push_back</span>(<span class="number">7</span>); </span><br><span class="line"> <span class="built_in">push_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 7 8 3 5 0 2 3 1 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">pop_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> cout &lt;&lt; ivec.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 9.return but no remove. </span></span><br><span class="line"> ivec.<span class="built_in">pop_back</span>(); <span class="comment">// remove last elem and no return </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 8 7 4 3 5 0 2 3 1 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">sort_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 3 4 5 7 8 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// test heap (底层以 array 完成) </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="built_in">make_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="comment">// array 无法动态改变大小，因此不可以对满载的 array 做 push_heap() 动作。</span></span><br><span class="line"> <span class="comment">// 因为那得先在 array尾端增加一个元素。</span></span><br><span class="line"> <span class="built_in">sort_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i) </span><br><span class="line"> cout &lt;&lt; ia[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 3 4 5 8 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="comment">// 经过排序之后的 heap，不再是个合法的 heap </span></span><br><span class="line"> <span class="comment">// 重新再做一个 heap </span></span><br><span class="line"> <span class="built_in">make_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="built_in">pop_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> cout &lt;&lt; ia[<span class="number">8</span>] &lt;&lt; endl; <span class="comment">// 9 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue-概述"><a href="#priority-queue-概述" class="headerlink" title="priority_queue 概述"></a>priority_queue 概述</h3><p>priority_queue是一个拥有权值观念的 queue，它允许加入新元素、移除旧元素，审视元素值等功能。由于这是一个queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外别无其它存取元素的途径。</p>
<p>priority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列（通常权值以实值表示）。<strong>权值最高者，排在最前面</strong>。</p>
<p>预设情况下priority_queue系利用一个max-heap 完成，后者是一个以 vector 表现的 complete binary tree。max-heap 可以满足priority_queue所需要的「依权值高低自动递增排序」的特性。</p>
<h3 id="priority-queue-定义式完整列表"><a href="#priority-queue-定义式完整列表" class="headerlink" title="priority_queue 定义式完整列表"></a>priority_queue 定义式完整列表</h3><p>由于priority_queue完全以底部容器为根据，再加上heap处理规则，所以其实作非常简单。预设情况下是以vector为底部容器。源码很简短，此处完整列出。</p>
<p>STL priority_queue 也不被归类为container（容器），而被归类为container adapter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt; <span class="keyword">class</span> priority_queue &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; <span class="comment">//底层容器</span></span><br><span class="line"> Compare comp;<span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125; </span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125; </span><br><span class="line"><span class="comment">//以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line"><span class="comment">//注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap。</span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"> <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x) : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123;<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"> <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"><span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素</span></span><br><span class="line">c.<span class="built_in">push_back</span>(x); <span class="comment">// 推入末端，再重排 heap。</span></span><br><span class="line"><span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);<span class="comment">// push_heap是泛型算法</span></span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(c.<span class="built_in">clear</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> <span class="comment">// pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line"> <span class="comment">// 弹出，而是重排 heap，（首值被放在尾部）然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line"> <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); </span><br><span class="line"> c.<span class="built_in">pop_back</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(c.<span class="built_in">clear</span>()); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="priority-queue-没有迭代器"><a href="#priority-queue-没有迭代器" class="headerlink" title="priority_queue 没有迭代器"></a>priority_queue 没有迭代器</h3><p>priority_queue 的所有元素，进出都有一定的规则，只有 queue 顶端的元素（权值最高者），才有机会被外界取用。priority_queue不提供走访功能，也不提供迭代器。</p>
<h3 id="priority-queue-测试实例"><a href="#priority-queue-测试实例" class="headerlink" title="priority_queue 测试实例"></a>priority_queue 测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="comment">// test priority queue... </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">ipq</span><span class="params">(ia, ia+<span class="number">9</span>)</span></span>; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ipq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=9 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ipq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 9 9 9 9 9 9 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">while</span>(!ipq.<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 8 5 4 3 3 2 1 0 </span></span><br><span class="line"> ipq.<span class="built_in">pop</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>细致观察的话，我们会发现heap只提供了算法，而没有实际上作出容器。这与前面stack有不同：stack以deque为底层容器，封装deque的操作控制deque的元素。而heap没有元素，原因是优先级队列真正的底层容器是vector，所谓“heap”在这里只是概念，用来提供算法操作。为什么需要用vector而不是一个普通的array呢？因为优先级队列是可以动态扩展的，只有vector符合动态的理念，并且其迭代器是普通指针，满足随机访问的要求。而vector的元素删除、插入都是在尾部进行的，这也是为什么heap的pop算法把元素放到尾部就停止了（没有继续解构元素），就是为了能交给vector来pop。</p>
<p>最后，我们会发现所有容器的pop，均不返回值，原因是元素已真正解构了。</p>
<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><h3 id="slist-概述"><a href="#slist-概述" class="headerlink" title="slist 概述"></a>slist 概述</h3><p>STL list是个双向串行（double linked list）。SGI STL 另提供了一个单向串行（single linked list），名为slist。这个容器并不在标准规格之内，不过多做一 些剖析，多看多学一些实作技巧也不错。</p>
<p>slist和list的主要差别在于，前者的迭代器属于单向的 <em>Forward Iterator</em>，后者的迭代器属于双向的<em>Bidirectional Iterator</em>。为此，slist的功能自然也就受到许多限制。不过，单向串行所耗用的<strong>空间更小</strong>，<strong>某些动作更快</strong>，不失为另一种选择。</p>
<p>根据STL的习惯，安插动作会将新元素安插于指定位置之前，而非之后。然而做为一个单向串行，slist没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起。换句话说，除了slist起始处附近的区域之外，在其它位置上采用insert 或erase 操作函式，都是不智之举。这便是 slist 相较于 list 之下的大缺点。为此，slist特别提供了 insert_after()和erase_after()供弹性运用。</p>
<p>基于同样的（效率）考虑，slist不提供 push_back()，只提供 <strong>push_front()<strong>。因此 slist的元素次序会和元素安插进来的次序</strong>相反</strong>。</p>
<h3 id="slist-的节点"><a href="#slist-的节点" class="headerlink" title="slist 的节点"></a>slist 的节点</h3><p>slist节点和其迭代器的设计，架构上比list复杂许多，运用了继承关系，因此在型别转换上有复杂的表现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向串行的节点基本结构。注：只操作指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node_base</span></span><br><span class="line">&#123; </span><br><span class="line"> __slist_node_base* next; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//单向串行的节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node</span> : <span class="keyword">public</span> __slist_node_base </span><br><span class="line">&#123; </span><br><span class="line"> T data; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//全域函式：已知某一节点，安插新节点于其后。</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link( __slist_node_base* prev_node, __slist_node_base* new_node) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 令 new节点的下一节点为 prev节点的下一节点</span></span><br><span class="line"> new_node-&gt;next = prev_node-&gt;next; </span><br><span class="line"> prev_node-&gt;next = new_node;<span class="comment">//令 prev 节点的下一节点指向 new 节点</span></span><br><span class="line"> <span class="keyword">return</span> new_node; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//全域函式：单向串行的大小（元素个数）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __slist_size(__slist_node_base* node) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">size_t</span> result = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> ( ; node != <span class="number">0</span>; node = node-&gt;next) </span><br><span class="line"> ++result; <span class="comment">//一个一个累计</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/slist%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84.png" alt="image-20220707210631932"></p>
<h3 id="slist-的迭代器"><a href="#slist-的迭代器" class="headerlink" title="slist 的迭代器"></a>slist 的迭代器</h3><p>slist 迭代器可以下图表示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/slist%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt="image-20220707210714470"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向串行的迭代器基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> forward_iterator_tag iterator_category;<span class="comment">//注意，单向</span></span><br><span class="line"> __slist_node_base* node;<span class="comment">//指向节点基本结构</span></span><br><span class="line">__slist_iterator_base(__slist_node_base* x) :<span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123; node = node-&gt;next; &#125;<span class="comment">// 前进一个节点</span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> node == x.node; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> node != x.node; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//单向串行的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator</span> : <span class="keyword">public</span> __slist_iterator_base </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, Ref, Ptr&gt; self; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node; </span><br><span class="line">__slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125; </span><br><span class="line"> <span class="comment">// 呼叫 slist&lt;T&gt;::end() 时会造成 __slist_iterator(0)，于是唤起上述函式。</span></span><br><span class="line">__slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125; </span><br><span class="line">__slist_iterator(<span class="type">const</span> iterator&amp;x) : __slist_iterator_base(x.node) &#123;&#125; </span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((list_node*) node)-&gt;data; &#125; </span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line"> self&amp; <span class="keyword">operator</span>++() </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">incr</span>();<span class="comment">//前进一个节点</span></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> <span class="built_in">incr</span>();<span class="comment">//前进一个节点</span></span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//没有实作 operator--，因为这是一个 forward iterator </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="slist-的数据结构"><a href="#slist-的数据结构" class="headerlink" title="slist 的数据结构"></a>slist 的数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> value_type&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node_base list_node_base; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator_base iterator_base; </span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt;list_node_allocator; </span><br><span class="line"> <span class="function"><span class="type">static</span> list_node* <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> list_node* node =list_node_allocator::<span class="built_in">allocate</span>();<span class="comment">//配置空间</span></span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line">    <span class="built_in">construct</span>(&amp;node-&gt;data, x); <span class="comment">//建构元素</span></span><br><span class="line">	node-&gt;next = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(list_node_allocator::<span class="built_in">deallocate</span>(node)); </span><br><span class="line"> <span class="keyword">return</span> node; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span> </span>&#123; </span><br><span class="line"> <span class="built_in">destroy</span>(&amp;node-&gt;data); <span class="comment">//将元素解构</span></span><br><span class="line"> list_node_allocator::<span class="built_in">deallocate</span>(node); <span class="comment">//释还空间</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> list_node_base head; <span class="comment">// 头部。注意，它不是指标，是实物。</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">slist</span>() &#123; head.next = <span class="number">0</span>; &#125; </span><br><span class="line"> ~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next); &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __slist_size(head.next); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head.next == <span class="number">0</span>; &#125; </span><br><span class="line"> <span class="comment">// 两个 slist互换：只要将 head 交换互指即可。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> list_node_base* tmp = head.next; </span><br><span class="line"> head.next = L.head.next; </span><br><span class="line"> L.head.next = tmp; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// 取头部元素</span></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ((list_node*)head.next)-&gt;data; &#125; </span><br><span class="line"> <span class="comment">// 从头部安插元素（新元素成为 slist 的第一个元素）</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> __slist_make_link(&amp;head,<span class="built_in">create_node</span>(x)); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 注意，没有 push_back() </span></span><br><span class="line"> <span class="comment">// 从头部取走元素（删除之）。修改 head。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> list_node* node = (list_node*) head.next; </span><br><span class="line"> head.next = node-&gt;next; </span><br><span class="line"> <span class="built_in">destroy_node</span>(node); </span><br><span class="line"> &#125; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="slist-的元素操作"><a href="#slist-的元素操作" class="headerlink" title="slist 的元素操作"></a>slist 的元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;slist&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> slist&lt;<span class="type">int</span>&gt; islist; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0</span></span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">9</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">1</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">2</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">3</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> slist&lt;<span class="type">int</span>&gt;::iterator ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> slist&lt;<span class="type">int</span>&gt;::iterator ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 3 2 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> islist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); <span class="comment">//新元素会被安插在1的前面</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 3 2 99 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite = <span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> cout &lt;&lt; *(islist.<span class="built_in">erase</span>(ite)) &lt;&lt; endl; <span class="comment">// 2 </span></span><br><span class="line"> ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 2 99 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习程序中一再以循环巡访整个slist，并以迭代器是否等于slist.end() 做为循环结束条件，这其中有一些容易疏忽的地方。当我们呼叫end()企图做出一个指向尾端（下一位置）的迭代器，STL 源码是这么进行的：</p>
<p><code>iterator end() &#123; return iterator(0); &#125;</code></p>
<p>这会因为源码中如下的定义：</p>
<p><code>typedef __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </code></p>
<p>而形成这样的结果：</p>
<p><code> __slist_iterator&lt;T, T&amp;, T*&gt;(0);//产生一个暂时对象，引发 ctor</code></p>
<p>从而因为源码中如下的定义：</p>
<p><code>__slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125; </code></p>
<p>而导致基础类别的建构：</p>
<p><code>__slist_iterator_base(0); </code></p>
<p>并因为源码中这样的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span></span><br><span class="line">&#123; </span><br><span class="line"> __slist_node_base* node;<span class="comment">//指向节点基本结构</span></span><br><span class="line">__slist_iterator_base(__slist_node_base* x) :<span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而导致：</p>
<p><code>node(0);</code></p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这一章节探索容器（序列式），可以发现一块新大陆，这里挑一点来说。</p>
<ul>
<li>在构建一个容器之前，需要先想好基础结构，是连续的空间呢，还是一个一个的节点，这导致了内存配置的不同。</li>
<li>然后，需要继而构造迭代器，定义好走访的形式，是单向的还是双向的还是随机的，重载++、*、-&gt;等运算符。</li>
<li>然后实作容器类：<ul>
<li>首先定义好一系列type供萃取使用；</li>
<li>接着定义迭代器指针，以及迭代器相关的返回函数（如end()）；</li>
<li>然后定义一系列构造函数和析构函数，又紧接着可以作出内存配置（都使用simple_alloc）、清空，元素建构、解构（construct和deconstruc全域函数）的操作；</li>
<li>最后，作出容器动作函数，如插入、删除，以及一系列辅助操作。</li>
</ul>
</li>
</ul>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B51.png" alt="image-20220708212926619"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B52.png" alt="image-20220708213202176"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B53.png" alt="image-20220708213324148"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B54.png" alt="image-20220708213425662"></p>
<h2 id="树的导览"><a href="#树的导览" class="headerlink" title="树的导览"></a>树的导览</h2><p>这里只作简单介绍。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%A0%911.png" alt="image-20220708213538944"></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>首先需要是一棵二叉树：“任何节点最多只允许两个子节点。”</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%911.png" alt="image-20220708213849297"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912.png" alt="image-20220708213902871"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%913.png" alt="image-20220708213933983"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%914.png" alt="image-20220708214021195"></p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%911.png" alt="image-20220708214102679"></p>
<p><strong>这种不平衡状态会导致搜索的对数时间变为常数时间。</strong>尽量保持平衡能节省搜索时间。</p>
<p><strong>AVL树</strong>通过高度维护每个节点的平衡因子，以此来保持平衡。平衡破坏后具体的操作涉及<strong>RR、RL、LR、LL</strong>，即单旋转和双旋转，在数据结构已涉及，这里不详细展开了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%912.png" alt="image-20220708214715999"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%913.png" alt="image-20220708214804558"></p>
<h3 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%911.png" alt="image-20220708214854587"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%913.png" alt="image-20220708215232970"></p>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%914.png" alt="image-20220708215346578"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%915.png" alt="image-20220708215523697"></p>
<h5 id="状况1"><a href="#状况1" class="headerlink" title="状况1"></a>状况1</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B51.png" alt="image-20220708215740628"></p>
<h5 id="状况2"><a href="#状况2" class="headerlink" title="状况2"></a>状况2</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B52.png" alt="image-20220708215952231"></p>
<p>第二次旋转是为了满足规则4，本身G(10)的左子树在不考虑ABC时是没有黑节点的，因此要再旋转一次，把8这个黑节点转上去。实际上，第一次旋转就是把内侧插入变成了外侧插入，所以内侧插入总能用一次旋转变成外侧插入。</p>
<h5 id="状况3"><a href="#状况3" class="headerlink" title="状况3"></a>状况3</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B53.png" alt="image-20220708220601431"></p>
<h5 id="状况4"><a href="#状况4" class="headerlink" title="状况4"></a>状况4</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B54.png" alt="image-20220708220714966"></p>
<p>因为前面考虑状况123时，X这个新节点都是带着子树考虑的（从真正的叶节点递归上来），那么此时就可以把P看成新的节点，子树看成AB，然后继续向上考虑，就回到状况123了。</p>
<h4 id="由上而下的程序"><a href="#由上而下的程序" class="headerlink" title="由上而下的程序"></a>由上而下的程序</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B1.png" alt="image-20220708220955571"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B2.png" alt="image-20220708221107493"></p>
<p><strong>P是红色，说明G是黑色。由于路径自上而下检查，因此S不会是红色，否则G这个节点就已经需要修改了。所以可以保证S是黑色，归类到状态1和2。</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B3.png" alt="image-20220708221121614"></p>
<h4 id="节点设计"><a href="#节点设计" class="headerlink" title="节点设计"></a>节点设计</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B91.png" alt="image-20220708221455607"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A12.png" alt="image-20220708221727398"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A13.png" alt="image-20220708221742592"></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>关于双层结构</strong>：以后作补充。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A81.png" alt="image-20220708222113319"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A82.png" alt="image-20220708222145968"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A83.png" alt="image-20220708222335201"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A84.png" alt="image-20220708222354631"></p>
<p>header节点在后面图5-17。</p>
<p>注：对header节点的补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/sinat_41619762/article/details/115124653</span><br><span class="line"></span><br><span class="line">红黑树有一个特殊节点header。对于一棵空红黑树，header的left和right都指向自己，parent指向0。而红黑树不为空时，红黑树的根节点的parent指向header，header的parent指向根节点，header的left和right分别指向红黑树最左端和最右端的节点。于是可以方便地获得红黑树的根节点、最左节点和最右节点。</span><br><span class="line">header节点是红色的，root节点是黑色的，这用来对它们做出一定的区别。</span><br><span class="line">红黑树的begin()返回的迭代器指向的就是header的left节点，而end()返回的迭代器指向的是header自己。</span><br></pre></td></tr></table></figure>

<p>如果是根节点，则根节点（node&#x3D;&#x3D;root）的父节点是header（y），根据条件根节点右子节点是null，header的右子节点和父节点都是root，则执行一次while后：node会变为header，y会变为root。则此时不能直接把y返回，因为又回到root了，注意到此时node-&gt;right（header-&gt;right）==y，则可以用这个条件判断这个特殊状况，不加以判断的话得出的结果是有问题的。</p>
<p>decrement()也要结合header这一个节点理解。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A85.png" alt="image-20220708222409431"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A86.png" alt="image-20220708222453859"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A87.png" alt="image-20220708222512308"></p>
<p>这里的<strong>状况</strong>不是插入节点的状况。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A88.png" alt="image-20220708222524909"></p>
<h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841.png" alt="image-20220709202843598"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png" alt="image-20220709202912338"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843.png" alt="image-20220709202929089"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844.png" alt="image-20220709202951320"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845.png" alt="image-20220709203006027"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846.png" alt="image-20220709203022344"></p>
<h4 id="红黑树的构造与内存管理"><a href="#红黑树的构造与内存管理" class="headerlink" title="红黑树的构造与内存管理"></a>红黑树的构造与内存管理</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A01.png" alt="image-20220709204110637"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A02.png" alt="image-20220709204129927"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A03.png" alt="image-20220709204145642"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A04.png" alt="image-20220709204206488"></p>
<h4 id="红黑树元素操作"><a href="#红黑树元素操作" class="headerlink" title="红黑树元素操作"></a>红黑树元素操作</h4><h5 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C1.png" alt="image-20220709213914135"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C2.png" alt="image-20220709213927566"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C3.png" alt="image-20220709213956069"></p>
<p>对于insert_unique()，注意**j–**是找按大小顺序找前一个节点，下面是一些辅助理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/jmh1996/article/details/103466017</span><br><span class="line"></span><br><span class="line">while结束是，x为NULL也就是待插入点,而y为插入点的父节点。</span><br><span class="line">接下来初始化一个迭代器j.</span><br><span class="line">如果发现comp为true,这意味着x应该插入到y的左孩子，否则应该插入到右孩子。</span><br><span class="line"></span><br><span class="line">如果comp为true,而且刚好j又是整个树的最小值，这说明当前要插入的值比整个树的最小值还要小。于是就直接调用__insert(x, y, v) 函数进行插入。整个辅助函数，我们后面深入。</span><br><span class="line"></span><br><span class="line">如果comp为true,但是y不是指向最小值。那么就让 j 自减一下，此时 j 指向的元素,有关系：j.value&lt;y.value。 而且一定会有v&gt;=j.value。如果v&lt;j.value,那么在执行while循环的时候就应该找到是 j（或j的左子树，同时y不可能在j的左子树） 而不是 y。</span><br><span class="line"></span><br><span class="line">接下来：</span><br><span class="line">比较j.value和 v 之间那个大。</span><br><span class="line">如果条件为true,说明此时j.value&lt;v ,OK，说明v是一个全新的元素。执行正常的插入辅助程序。</span><br><span class="line">如果条件为false,意味着j.value&gt;=v，又因为v&gt;=j.value,联立这两个条件，必然有j.value==v，说明这个v就是一个重复的元素。</span><br><span class="line"></span><br><span class="line">如何在数学上证明x=y ？只需分别证明：x&gt;=y 且x&lt;=y 就可以了</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C4.png" alt="image-20220709215727673"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C5.png" alt="image-20220709215759005"></p>
<p>__insert操作中，对于x这个节点，经过while循环后一定是null。</p>
<h5 id="平衡调整"><a href="#平衡调整" class="headerlink" title="平衡调整"></a>平衡调整</h5><p>树形和颜色的调整，与前面插入节点的四个状况相符，进行一次或两次单一的旋转，并且调整节点的颜色。左旋转和右旋转与AVL树的旋转是一样的道理，不过红黑树的节点有父节点，指针的操作有所不同。</p>
<p>这里首先判断父节点关于祖父节点的左右关系，从而正确获得伯父节点。可以得知新节点、父节点都是红的（因为这样才需要处理）。</p>
<ul>
<li>如果伯父节点为红，对应状况3和4，则根据前面“自上而下的程序”，改变相应节点颜色，x本身直接插入，而后检查x的祖父节点（也即while继续检查）。</li>
<li>如果伯父节点为黑，则是状况1和2，也即新插入的节点位于内侧和外侧的问题。进行一次判断是否多做一次旋转即可。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C6.png" alt="image-20220709215947662"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C7.png" alt="image-20220709220008411"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C8.png" alt="image-20220709220109772"></p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C10.png" alt="image-20220709220150211" style="zoom:110%;" />

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C11.png" alt="image-20220709220251639"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C12.png" alt="image-20220709220318544"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C14.png" alt="image-20220709220450193"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C15.png" alt="image-20220709220520908"></p>
<h5 id="元素搜寻"><a href="#元素搜寻" class="headerlink" title="元素搜寻"></a>元素搜寻</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C13.png" alt="image-20220709220420450"></p>
<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2><h3 id="实作"><a href="#实作" class="headerlink" title="实作"></a>实作</h3><p>集合的键值就是实值，实值就是键值。不允许两个元素有相同的键值。集合能自动排序，以红黑树作为底层机制。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set1.png" alt="image-20220710214344791"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set2.png" alt="image-20220710214627910"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set3.png" alt="image-20220710214643208"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set4.png" alt="image-20220710214656094"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set5.png" alt="image-20220710214716430"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set6.png" alt="image-20220710214740470"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set7.png" alt="image-20220710214754310"></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set8.png" alt="image-20220710214813231"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/set9.png" alt="image-20220710214829559"></p>
<h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><h3 id="实作-1"><a href="#实作-1" class="headerlink" title="实作"></a>实作</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map1.png" alt="image-20220710220207679"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map2.png" alt="image-20220710220222302"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map3.png" alt="image-20220710220238807"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map4.png" alt="image-20220710220255655"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map5.png" alt="image-20220710220313214"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map6.png" alt="image-20220710220334105"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map7.png" alt="image-20220710220406454"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map8.png" alt="image-20220710220423703"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map9.png" alt="image-20220710220449046"></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map10.png" alt="image-20220710220507625"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map11.png" alt="image-20220710220526021"></p>
<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map12.png" alt="image-20220710220540190"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map13.png" alt="image-20220710220554639"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/map14.png" alt="image-20220710220609537"></p>
<h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>允许键值重复的set，底层使用红黑树的insert_equal()即可。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/multiset1.png" alt="image-20220710222720765"></p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>允许键值重复的map，底层使用红黑树的insert_equal()即可。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/multimap1.png" alt="image-20220710222118863"></p>
<h2 id="hashtable（哈希表）"><a href="#hashtable（哈希表）" class="headerlink" title="hashtable（哈希表）"></a>hashtable（哈希表）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A81.png" alt="image-20220711144731720"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A82.png" alt="image-20220711144908836"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A83.png" alt="image-20220711145042016"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A84.png" alt="image-20220711145057101"></p>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>平均插入成本太高了，平均情况下要线性寻访一半表格。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B1.png" alt="image-20220711145149421"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B2.png" alt="image-20220711145224861"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B3.png" alt="image-20220711145325523"></p>
<h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B2.png" alt="image-20220711145523339"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B1.png" alt="image-20220711145609963"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B3.png" alt="image-20220711145724005"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B4.png" alt="image-20220711145848868"></p>
<h4 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BC%80%E9%93%BE1.png" alt="image-20220711145946962"></p>
<h3 id="桶与节点"><a href="#桶与节点" class="headerlink" title="桶与节点"></a>桶与节点</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A1%B6%E4%B8%8E%E8%8A%82%E7%82%B91.png" alt="image-20220711150025546"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A1%B6%E4%B8%8E%E8%8A%82%E7%82%B92.png" alt="image-20220711150109251"></p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A81.png" alt="image-20220711150634444"></p>
<img src="C:\Users\14242\AppData\Roaming\Typora\typora-user-images\image-20220711150730477.png" alt="image-20220711150730477" style="zoom:110%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="image-20220711152331040"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841.png" alt="image-20220711152349896"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png" alt="image-20220711152604784"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843.png" alt="image-20220711152617353"></p>
<h3 id="构造与内存管理"><a href="#构造与内存管理" class="headerlink" title="构造与内存管理"></a>构造与内存管理</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%861.png" alt="image-20220711161536527"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A0%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%862.png" alt="image-20220711161554106"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A03.png" alt="image-20220711161625439"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A04.png" alt="image-20220711161640642"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A05.png" alt="image-20220711161653339"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A06.png" alt="image-20220711161705467"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A07.png" alt="image-20220711161719098"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A08.png" alt="image-20220711161730754"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A09.png" alt="image-20220711161743803"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A010.png" alt="image-20220711161755840"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A011.png" alt="image-20220711161809369"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A012.png" alt="image-20220711161821906"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9E%84%E9%80%A013.png" alt="image-20220711161836283"></p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B1.png" alt="image-20220711161911045"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B2.png" alt="image-20220711161928090"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B3.png" alt="image-20220711161947105"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B4.png" alt="image-20220711162006081"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B5.png" alt="image-20220711162017737"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B6.png" alt="image-20220711162032756"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B7.png" alt="image-20220711162043490"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E4%BE%8B8.png" alt="image-20220711162054903"></p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B01.png" alt="image-20220711162139133"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B02.png" alt="image-20220711162151600"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B03.png" alt="image-20220711162203492"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B04.png" alt="image-20220711162215439"></p>
<h2 id="hash-set"><a href="#hash-set" class="headerlink" title="hash set"></a>hash set</h2><p>两种集合的主要区别是，搜寻元素按什么方式。（红黑树是以二叉搜索的方式，哈希表是以哈希映射，因此哈希集合的元素不会被自动排序），源码就不放出来了，了解即可。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%881.png" alt="image-20220713200753990"></p>
<h2 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h2><p>与hash set一样的情况。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8Cmap1.png" alt="image-20220713201037384"></p>
<h2 id="hash-multiset-amp-hash-multimap"><a href="#hash-multiset-amp-hash-multimap" class="headerlink" title="hash multiset &amp; hash multimap"></a>hash multiset &amp; hash multimap</h2><p>与hash set 一样的情况。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8C%E5%A4%9A%E9%87%8D%E9%9B%861.png" alt="image-20220713201123939"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%93%88%E5%B8%8Cmultimap1.png" alt="image-20220713201227747"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h3 id="stl-算法总览"><a href="#stl-算法总览" class="headerlink" title="stl 算法总览"></a>stl 算法总览</h3><p>in-place操作，意思是所有的操作都是”就地“操作，不允许进行移动，或者称作<strong>原位操作</strong>，即<strong>不允许使用临时变量</strong>。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%881.png" alt="image-20220713201515538"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%882.png" alt="image-20220713201532118"></p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%883.png" alt="image-20220713201601573" style="zoom:150%;" />

<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%884.png" alt="image-20220713201624630" style="zoom:150%;" />

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%886.png" alt="image-20220713201644501"></p>
<h3 id="质变算法"><a href="#质变算法" class="headerlink" title="质变算法"></a>质变算法</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%B4%A8%E5%8F%98%E7%AE%97%E6%B3%951.png" alt="image-20220713202024949"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%B4%A8%E5%8F%98%E7%AE%97%E6%B3%952.png" alt="image-20220713202041673"></p>
<h3 id="非质变算法"><a href="#非质变算法" class="headerlink" title="非质变算法"></a>非质变算法</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9D%9E%E8%B4%A8%E5%8F%98%E7%AE%97%E6%B3%951.png" alt="image-20220713202302960"></p>
<h3 id="stl-算法一般形式"><a href="#stl-算法一般形式" class="headerlink" title="stl 算法一般形式"></a>stl 算法一般形式</h3><p>主要讲一些简单的规范</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F1.png" alt="image-20220713202705509"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F2.png" alt="image-20220713202723349"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F3.png" alt="image-20220713202736186"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F4.png" alt="image-20220713202747321"></p>
<h2 id="泛化过程"><a href="#泛化过程" class="headerlink" title="泛化过程"></a>泛化过程</h2><p>将算法独立于数据结构，即算法适用于不同类型的结构。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%961.png" alt="image-20220713210815481"></p>
<p>从int型泛化到任意类型</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%96.png" alt="image-20220713210914548"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%963.png" alt="image-20220713211111525"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%965.png" alt="image-20220713211303822"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%966.png" alt="image-20220713211523358"></p>
<p>从普通指针泛化到迭代器</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%967.png" alt="image-20220713211651828"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%968.png" alt="image-20220713211949549"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E6%B3%9B%E5%8C%969.png" alt="image-20220713212053777"></p>
<h2 id="数值算法-lt-stl-numeric-h-gt"><a href="#数值算法-lt-stl-numeric-h-gt" class="headerlink" title="数值算法 &lt;stl_numeric.h&gt;"></a>数值算法 &lt;stl_numeric.h&gt;</h2><p>使用数值算法，要包含头文件<code>&lt;numeric&gt;</code>，实现在<code> &lt;stl_numeric.h&gt;</code>。</p>
<h3 id="运用示例"><a href="#运用示例" class="headerlink" title="运用示例"></a>运用示例</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E8%BF%90%E7%94%A8%E7%A4%BA%E4%BE%8B1.png" alt="image-20220713212515585"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95%E8%BF%90%E7%94%A8%E7%A4%BA%E4%BE%8B2.png" alt="image-20220713212534684"></p>
<h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E7%B4%AF%E5%8A%A01.png" alt="image-20220713212843679"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E7%B4%AF%E5%8A%A02.png" alt="image-20220713212857578"></p>
<h3 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95adjacent1.png" alt="image-20220713213135915"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95adjacent2.png" alt="image-20220713213159492"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95adjacent3.png" alt="image-20220713213224780"></p>
<h3 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E5%86%85%E7%A7%AF1.png" alt="image-20220713213734522"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E5%86%85%E7%A7%AF2.png" alt="image-20220713213752876"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E5%86%85%E7%A7%AF3.png" alt="image-20220713213804662"></p>
<h3 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%E5%92%8C1.png" alt="image-20220713214139398"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%E5%92%8C2.png" alt="image-20220713214316624"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%E5%92%8C3.png" alt="image-20220713214328669"></p>
<h3 id="power"><a href="#power" class="headerlink" title="power"></a>power</h3><p>如果指数n是2的幂次方，则在第一个while就做完了，因为移位后低位一直是0，直到遇到唯一一个1变成最低位，期间x不断二次幂地执行op函数。记录算好的x，然后需要把n再右移一位（把前面说的那个‘1’扔掉，移除已经做完了的操作，即2的幂次方次操作）</p>
<p>此时如果n仍不为0，此时继续算：每次n右移一位代表x要再平方一次，如果右移的位是1，则result要加上；如果是0则忽略，继续向下迭代。</p>
<p>本质上直接用下面的while即可，但先用上面的while可以略去低位很多的连续0（如果有）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E5%B9%821.png" alt="image-20220713214514825"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95%E5%B9%822.png" alt="image-20220713214526809"></p>
<h3 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%B3%95itoa.png" alt="image-20220713215739972"></p>
<h2 id="基本算法-lt-stl-algobase-h-gt"><a href="#基本算法-lt-stl-algobase-h-gt" class="headerlink" title="基本算法&lt;stl_algobase.h&gt;"></a>基本算法&lt;stl_algobase.h&gt;</h2><h3 id="运用示例-1"><a href="#运用示例-1" class="headerlink" title="运用示例"></a>运用示例</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B1.png" alt="image-20220714095353452"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B2.png" alt="image-20220714095451416"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B3.png" alt="image-20220714095503217"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B4.png" alt="image-20220714095524252"></p>
<h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95equal1.png" alt="image-20220714100118987"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95equal2.png" alt="image-20220714100138700"></p>
<h3 id="fill-amp-fill-n"><a href="#fill-amp-fill-n" class="headerlink" title="fill &amp; fill_n"></a>fill &amp; fill_n</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95fill1.png" alt="image-20220714100404299"></p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95fill2.png" alt="image-20220714100419586" style="zoom:150%;" />

<h3 id="iter-swap"><a href="#iter-swap" class="headerlink" title="iter_swap"></a>iter_swap</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95swap1.png" alt="image-20220714100707144"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95swap2.png" alt="image-20220714100726524"></p>
<h3 id="lexicographical-compare"><a href="#lexicographical-compare" class="headerlink" title="lexicographical_compare"></a>lexicographical_compare</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%97%E5%85%B8%E5%BA%8F1.png" alt="image-20220714101349204"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%97%E5%85%B8%E5%BA%8F2.png" alt="image-20220714101406250"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%97%E5%85%B8%E5%BA%8F3.png" alt="image-20220714101419397"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AD%97%E5%85%B8%E5%BA%8F5.png" alt="image-20220714101433075"></p>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95max1.png" alt="image-20220714101926677"></p>
<h3 id="min"><a href="#min" class="headerlink" title="min"></a>min</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95min1.png" alt="image-20220714102002465"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95min2.png" alt="image-20220714102035256"></p>
<h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95mismatch1.png" alt="image-20220714102128380"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95mismatch2.png" alt="image-20220714102148154"></p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%AF%B9%E8%B1%A1%E4%BA%A4%E6%8D%A21.png" alt="image-20220714102312618"></p>
<h3 id="copy——极高的效率"><a href="#copy——极高的效率" class="headerlink" title="copy——极高的效率"></a>copy——极高的效率</h3><p>assignment operator是赋值运算符</p>
<p>trivial意思是平凡的（原生的），也就是在类里面的构造函数（ctor）、复制构造函数（copy）、赋值函数（assignment）、析构函数（dtor）这四个函数满足至少一条：</p>
<ul>
<li>显式(explict)定义了这四种函数。</li>
<li>类里有非静态非POD的数据成员。</li>
<li>有基类。</li>
</ul>
<p>则这些函数是non-trivial函数，否则就是trivial的。如果这个类都是trivial ctor&#x2F;dtor&#x2F;copy&#x2F;assignment函数，我们对这个类进行构造、析构、拷贝和赋值时可以采用最有效率的方法，不调用无所事事正真的那些ctor&#x2F;dtor等，而直接采用内存操作如malloc()、memcpy()等提高性能，这也是SGI STL内部干的事情。这里的copy，关键看类是否拥有<strong>trivial assignment</strong>。</p>
<ul>
<li>如果迭代器指向的序列是字符串，那么直接使用字符串拷贝，效率会提高。</li>
<li>如果迭代器本身是指针，那么它所指向的这个序列在内存上是连续存放的，所以可能可以使用memmove复制底层内存来加速。如果指针指向的类型拥有trivial operator&#x3D;（例如int类型），那么直接使用memmove复制底层内存是一种更快的方法。</li>
<li>如果迭代器本身就是迭代器，那么所指向的元素在内存上可能不是连续存放的，所以不能使用memmove。但是迭代器有分InputIterator和RandomAccessIterator，RandomAccessIterator可以加速复制过程。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy1.png" alt="image-20220714102441740"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy2.png" alt="image-20220714103237927"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy3.png" alt="image-20220714103636436"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy4.png" alt="image-20220714103721723"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy5.png" alt="image-20220714103734468"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy6.png" alt="image-20220714104030718"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy7.png" alt="image-20220714104101844"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy8.png" alt="image-20220714104122221"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy9.png" alt="image-20220714104232216"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy10.png" alt="image-20220714104600986"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">泛化版本会借助一个__copy_dispatch结构体来应对不同的迭代器类型，从而调用不同版本的底层实现函数。__copy_dispatch结构体本质上还是一个模板结构体，通过传入的模板参数获取迭代器的类型，并调用相应版本的函数。此外，__copy_dispatch结构体还是一个函数对象，重载了operator()运算符，所以可以像调用函数一样使用__copy_dispatch结构体。</span><br><span class="line"></span><br><span class="line">至于这里为啥要使用结构体来分发函数，而不是使用函数来分发函数，主要是因为结构体支持偏特化，而函数不支持偏特化，它只支持全特化。关于偏特化和全特化的区别，可以看这篇博客：https://harttle.land/2015/10/03/cpp-template.html。因为迭代器就算是指针，指针所指向的类型也是不确定的，而全特化不能拥有不确定的类型，它不仅需要确定迭代器类型是指针，而且还要确定指针所指向的类型，所以使用全特化不能够涵盖迭代器类型为指针的所有情况。而偏特化只是在模板的基础上进一步限定了模板参数的类型，但是它仍然可以拥有不确定的类型，所以只能用结构体偏特化。就像第一点中提到的对外接口，因为已经明确了参数必须是指向char或者wchar_t的指针，不存在不确定的类型，所以可以直接使用全特化版本。</span><br><span class="line"></span><br><span class="line">原文链接：https://blog.csdn.net/Johnsonjjj/article/details/107743872</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy11.png" alt="image-20220714104615587"></p>
<p>注：这两本版本的__copy（）根据最后一个参数iterator_tag区分。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy12.png" alt="image-20220714104637758"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy13.png" alt="image-20220714104651650"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy14.png" alt="image-20220714104706541"></p>
<p>如果对象定义了赋值操作，即具备non-trivial assignment operator，则必须循环而使用对象的”&#x3D;”赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* dst,<span class="type">const</span> <span class="type">void</span>* src,<span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span>* ret = dst;</span><br><span class="line">    <span class="comment">//dst &lt;= src表示，如果dst在src的前面，从前往后复制不会覆盖src中还没有复制的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dst &lt;= src || (<span class="type">char</span>*)dst &gt;= ((<span class="type">char</span>*)src + count))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从前往后复制，则不会出现覆盖src中没有复制的内容</span></span><br><span class="line">        <span class="keyword">while</span>(count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src; <span class="comment">//char类型指针，表示一个字节一个字节的复制</span></span><br><span class="line">            dst = (<span class="type">char</span>*)dst + <span class="number">1</span>; <span class="comment">//移动一个字节</span></span><br><span class="line">            src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从后往前复制，则不会出现覆盖src中没有复制的内容</span></span><br><span class="line">        dst = (<span class="type">char</span>*)dst + count - <span class="number">1</span>;<span class="comment">//移动到末尾</span></span><br><span class="line">        src = (<span class="type">char</span>*)src + count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count--)</span><br><span class="line">        &#123;</span><br><span class="line">            *(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">            dst = (<span class="type">char</span>*)dst - <span class="number">1</span>; <span class="comment">//移动一个字节</span></span><br><span class="line">            src = (<span class="type">char</span>*)src - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回dst的头指针，还方便左值操作。</span></span><br><span class="line">    <span class="comment">//如：ptstr = memmove(ptstr,src,count); cout &lt;&lt; memmove(ptstr,src,count);</span></span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="copy测试"><a href="#copy测试" class="headerlink" title="copy测试"></a>copy测试</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy15.png" alt="image-20220714104728497"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy16.png" alt="image-20220714104744428"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy17.png" alt="image-20220714104759964"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy18.png" alt="image-20220714104816163"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy19.png" alt="image-20220714104833740"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy20.png" alt="image-20220714104851661"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy21.png" alt="image-20220714104910005"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95copy22.png" alt="image-20220714104936585"></p>
<h3 id="copy-backward"><a href="#copy-backward" class="headerlink" title="copy_backward"></a>copy_backward</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%8D%E5%90%91copy1.png" alt="image-20220714115555737"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%8D%E5%90%91copy2.png" alt="image-20220714115614257"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%8D%E5%90%91copy3.png" alt="image-20220714115632463"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%8D%E5%90%91copy4.png" alt="image-20220714115647479"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%8F%8D%E5%90%91copy5.png" alt="image-20220714115701225"></p>
<h2 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%951.png" alt="image-20220714202741237"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%952.png" alt="image-20220714202816107"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%953.png" alt="image-20220714202853930"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%954.png" alt="image-20220714203000538"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%955.png" alt="image-20220714203020249"></p>
<h3 id="并集-set-union"><a href="#并集-set-union" class="headerlink" title="并集 set_union"></a>并集 set_union</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B6%E9%9B%86%E7%AE%97%E6%B3%951.png" alt="image-20220714203208465"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B6%E9%9B%86%E7%AE%97%E6%B3%952.png" alt="image-20220714203324899"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B6%E9%9B%86%E7%AE%97%E6%B3%953.png" alt="image-20220714203347384"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B6%E9%9B%86%E7%AE%97%E6%B3%954.png" alt="image-20220714203402900"></p>
<h3 id="交集-set-intersection"><a href="#交集-set-intersection" class="headerlink" title="交集 set_intersection"></a>交集 set_intersection</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%A4%E9%9B%86%E7%AE%97%E6%B3%951.png" alt="image-20220714203637985"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%A4%E9%9B%86%E7%AE%97%E6%B3%952.png" alt="image-20220714203738532"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%A4%E9%9B%86%E7%AE%97%E6%B3%953.png" alt="image-20220714203753218"></p>
<h3 id="差集-set-difference"><a href="#差集-set-difference" class="headerlink" title="差集 set_difference"></a>差集 set_difference</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B7%AE%E9%9B%861.png" alt="image-20220714203917427"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B7%AE%E9%9B%862.png" alt="image-20220714203932520"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B7%AE%E9%9B%863.png" alt="image-20220714203947129"></p>
<h3 id="对称差-set-symmetric-difference"><a href="#对称差-set-symmetric-difference" class="headerlink" title="对称差 set_symmetric_difference"></a>对称差 set_symmetric_difference</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%AF%B9%E7%A7%B0%E5%B7%AE1.png" alt="image-20220714204235115"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%AF%B9%E7%A7%B0%E5%B7%AE2.png" alt="image-20220714204359475"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%AF%B9%E7%A7%B0%E5%B7%AE3.png" alt="image-20220714204413278"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%AF%B9%E7%A7%B0%E5%B7%AE4.png" alt="image-20220714204433754"></p>
<h2 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A0%86%E7%AE%97%E6%B3%951.png" alt="image-20220714204635123"></p>
<h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B6%E4%BB%96%20%E7%AE%97%E6%B3%951.png" alt="image-20220714204706662"></p>
<h3 id="单纯数据处理算法"><a href="#单纯数据处理算法" class="headerlink" title="单纯数据处理算法"></a>单纯数据处理算法</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%951.png" alt="image-20220714204733064"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%952.png" alt="image-20220714204748664"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%953.png" alt="image-20220714204808323"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%954.png" alt="image-20220714204827113"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%955.png" alt="image-20220714204841122"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%956.png" alt="image-20220714204908691"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%957.png" alt="image-20220714204920647"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%958.png" alt="image-20220714204935019"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%9510.png" alt="image-20220714204949720"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8D%95%E7%BA%AF%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%9511.png" alt="image-20220714205003607"></p>
<h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/adjacent_find.png" alt="image-20220714210815066"></p>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/count%E7%AE%97%E6%B3%951.png" alt="image-20220714211135551"></p>
<h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/count_if%E7%AE%97%E6%B3%951.png" alt="image-20220714211155105"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/count_if%E7%AE%97%E6%B3%952.png" alt="image-20220714211209512"></p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find%E7%AE%97%E6%B3%951.png" alt="image-20220714211606347"></p>
<h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_if1.png" alt="image-20220714211646674"></p>
<h4 id="find-end"><a href="#find-end" class="headerlink" title="find_end"></a>find_end</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_end1.png" alt="image-20220714211720897"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_end2.png" alt="image-20220714211742806"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_end3.png" alt="image-20220714211759600"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_end4.png" alt="image-20220714211814419"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_end5.png" alt="image-20220714211829901"></p>
<h4 id="find-first-of"><a href="#find-first-of" class="headerlink" title="find_first_of"></a>find_first_of</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_first_of.png" alt="image-20220714212919217"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/find_first_of2.png" alt="image-20220714212936044"></p>
<h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/foreach1.png" alt="image-20220714213308180"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/foreach2.png" alt="image-20220714213331032"></p>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/generate1.png" alt="image-20220714220524077"></p>
<h4 id="generate-n"><a href="#generate-n" class="headerlink" title="generate_n"></a>generate_n</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/generate_n1.png" alt="image-20220714220606074"></p>
<h4 id="includes（有序区间）"><a href="#includes（有序区间）" class="headerlink" title="includes（有序区间）"></a>includes（有序区间）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/includes1.png" alt="image-20220714220958628"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/includes2.png" alt="image-20220714221456530"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/includes3.png" alt="image-20220714221524967"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/includes4.png" alt="image-20220714221720053"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/includes5.png" alt="image-20220714221751558"></p>
<h4 id="max-element"><a href="#max-element" class="headerlink" title="max_element"></a>max_element</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/maxelement1.png" alt="image-20220714222730578"></p>
<h4 id="merge（有序区间）"><a href="#merge（有序区间）" class="headerlink" title="merge（有序区间）"></a>merge（有序区间）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/merge1.png" alt="image-20220714222811138"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/merge2.png" alt="image-20220714222944765"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/merge3.png" alt="image-20220714223003871"></p>
<h4 id="min-element"><a href="#min-element" class="headerlink" title="min_element"></a>min_element</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/min_element1.png" alt="image-20220714223233423"></p>
<h4 id="partition（划分）"><a href="#partition（划分）" class="headerlink" title="partition（划分）"></a>partition（划分）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partition1.png" alt="image-20220714223316705"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partition2.png" alt="image-20220714223338951"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partition3.png" alt="image-20220714223357058"></p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/remove1.png" alt="image-20220716105046338"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/remove2.png" alt="image-20220716105123153"></p>
<h4 id="remove-copy"><a href="#remove-copy" class="headerlink" title="remove_copy"></a>remove_copy</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/removecopy1.png" alt="image-20220716105411061"></p>
<h4 id="remove-if"><a href="#remove-if" class="headerlink" title="remove_if"></a>remove_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/removeif1.png" alt="image-20220716105717210"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/removeif2.png" alt="image-20220716105731961"></p>
<h4 id="remove-copy-if"><a href="#remove-copy-if" class="headerlink" title="remove_copy_if"></a>remove_copy_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/removecopyif.png" alt="image-20220716105841970"></p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/replace1.png" alt="image-20220716110027436"></p>
<h4 id="replace-copy"><a href="#replace-copy" class="headerlink" title="replace_copy"></a>replace_copy</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/replace_copy1.png" alt="image-20220716110043024"></p>
<h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/replace_if1.png" alt="image-20220716110055607"></p>
<h4 id="replace-copy-if"><a href="#replace-copy-if" class="headerlink" title="replace_copy_if"></a>replace_copy_if</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/replace_copy_if1.png" alt="image-20220716110224638"></p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/reverse1.png" alt="image-20220716110326856"></p>
<h4 id="reverse-copy"><a href="#reverse-copy" class="headerlink" title="reverse_copy"></a>reverse_copy</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/reverse_copy1.png" alt="image-20220716110626384"></p>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p>forward版本的，交换元素然后不断调整指针位置；</p>
<p>bidirectional版本的解法很妙。</p>
<p>random的就不关注了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate1.png" alt="image-20220716110808262"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate2.png" alt="image-20220716110829579"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate3.png" alt="image-20220716110846069"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate4.png" alt="image-20220716110913182"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate5.png" alt="image-20220716110928287"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate6.png" alt="image-20220716110942128"></p>
<h4 id="rotate-copy"><a href="#rotate-copy" class="headerlink" title="rotate_copy"></a>rotate_copy</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rotate_copy1.png" alt="image-20220716112051491"></p>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>找的是连续的子序列</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search1.png" alt="image-20220716112247627"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search2.png" alt="image-20220716112302073"></p>
<h4 id="search-n"><a href="#search-n" class="headerlink" title="search_n"></a>search_n</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search_n1.png" alt="image-20220716112753477"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search_n2.png" alt="image-20220716112833894"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search_n.png" alt="image-20220716112855924"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search_n3.png" alt="image-20220716112934338"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/search_n4.png" alt="image-20220716112951504"></p>
<h4 id="swap-ranges"><a href="#swap-ranges" class="headerlink" title="swap_ranges"></a>swap_ranges</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/swap_ranges1.png" alt="image-20220716114006360"></p>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/transform1.png" alt="image-20220716114112746"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/transform2.png" alt="image-20220716114125644"></p>
<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/unique1.png" alt="image-20220716114413162"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/unique2.png" alt="image-20220716114536405"></p>
<h4 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/unique_copy1.png" alt="image-20220716114624383"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/unique_copy2.png" alt="image-20220716114644130"></p>
<h3 id="复杂数据算法"><a href="#复杂数据算法" class="headerlink" title="复杂数据算法"></a>复杂数据算法</h3><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B1.png" alt="image-20220716115501986"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B2.png" alt="image-20220716115524279"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B3.png" alt="image-20220716115542322"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B4.png" alt="image-20220716115557817"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B5.png" alt="image-20220716115619070"></p>
<h4 id="lower-bound（有序区间）"><a href="#lower-bound（有序区间）" class="headerlink" title="lower_bound（有序区间）"></a>lower_bound（有序区间）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/lower_bound1.png" alt="image-20220716210016874"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/lower_bound2.png" alt="image-20220716210108304"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/lower_bound3.png" alt="image-20220716210129359"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/lower_bound5.png" alt="image-20220716210152811"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/lower_bound6.png" alt="image-20220716210216423"></p>
<h4 id="upper-bound（有序区间）"><a href="#upper-bound（有序区间）" class="headerlink" title="upper_bound（有序区间）"></a>upper_bound（有序区间）</h4><p>也即迭代器前面的元素<strong>≤value</strong>，注意lower_bound是**&lt;**。一个是返回该元素第一次出现的位置，一个是返回最后一次出现的位置的下一个。如果没有value元素则返回的位置都相同。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/upper_bound1.png" alt="image-20220716210639673"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/upper_bound2.png" alt="image-20220716210659587"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/upper_bound3.png" alt="image-20220716210722306"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/upper_bound4.png" alt="image-20220716210742882"></p>
<h4 id="binary-search（有序区间）"><a href="#binary-search（有序区间）" class="headerlink" title="binary_search（有序区间）"></a>binary_search（有序区间）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/binary_search2.png" alt="image-20220716211550228"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/binary_search.png" alt="image-20220716211606176"></p>
<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/next_permutation1.png" alt="image-20220716212108470"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/next_permutation2.png" alt="image-20220716212318420"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/next_permutation3.png" alt="image-20220716212334221"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/next_permutation4.png" alt="image-20220716212602467"></p>
<h4 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/prev_permutation1.png" alt="image-20220716213159892"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/prev_permutation2.png" alt="image-20220716213221596"></p>
<h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/random_shuffle1.png" alt="image-20220716213419143"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/random_shuffle2.png" alt="image-20220716213507365"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/random_shuffle3.png" alt="image-20220716213719328"></p>
<h4 id="partial-sort-copy"><a href="#partial-sort-copy" class="headerlink" title="partial_sort(_copy)"></a>partial_sort(_copy)</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partial_sort(_copy)1.png" alt="image-20220716213827980"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partial_sort(_copy)2.png" alt="image-20220716214008716"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partial_sort(_copy)3.png" alt="image-20220716214031121"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partial_sort(_copy)4.png" alt="image-20220716214048928"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/partial_sort(_copy)5.png" alt="image-20220716214107696"></p>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/sort1.png" alt="image-20220716215312982"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/sort2.png" alt="image-20220716215341104"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/sort3.png" alt="image-20220716215407570"></p>
<h5 id="insertion-sort"><a href="#insertion-sort" class="headerlink" title="insertion sort"></a>insertion sort</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.png" alt="image-20220716215433434"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F2.png" alt="image-20220716215501735"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F3.png" alt="image-20220716215517323"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F4.png" alt="image-20220716215533099"></p>
<h5 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%921.png" alt="image-20220716220817021"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%922.png" alt="image-20220716220832651"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%923.png" alt="image-20220716220853155"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%924.png" alt="image-20220716220943850"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%925.png" alt="image-20220716221210031"></p>
<p>这个函数<strong>没有</strong>（while中）对first和last作边界检查，而是以两个指针交错作为中止条件，节约了比较运算的开支。可以这么做的理由是因为，选择是首尾中间位置三个值的中间值作为pivot，因此一定会在超出此有效区域之前中止指针的移动（这其中while使用小于判断而不是小于等于判断起到了作用）。过程比较简单就不放出来了。</p>
<h5 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BF%AB%E6%8E%926.png" alt="image-20220716221754812"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%98%88%E5%80%BC2.png" alt="image-20220716221834707"></p>
<h5 id="STL-sort"><a href="#STL-sort" class="headerlink" title="STL sort"></a>STL sort</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort.png" alt="image-20220716222842461"></p>
<p>这里层数<strong>乘2</strong>是因为代码的while一层只递归一半，可见后面源码。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort2.png" alt="image-20220716222035643"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort3.png" alt="image-20220716222108781"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort4.png" alt="image-20220716222136506"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort5.png" alt="image-20220716222205372"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort6.png" alt="image-20220716222220997"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/stlsort7.png" alt="image-20220716222236391"></p>
<p>如何理解<code>__final_insertion_sort</code>函数呢？</p>
<ul>
<li>首先，unguarded版本的插入算法更快，因为<strong>不用边界检测</strong>。与常规版本相比，这个版本的插入算法直接跳入<code>__unguarded_linear_insert</code>函数（常规版本进入<code>__linear_insert</code>，先看是否比当前最小值小）。</li>
<li>然后，注意到不用边界检测必然有一个前提条件，就是这个值不能比当前最小值小，即不能到最左边，所以必须保证全局最小值就在最左边的区间。</li>
<li>最后，这个函数是如何保证最小值就在最前面的阈值大小的区间中呢？答案源于前面进行的<code>__introsort_loop</code>，该函数只有两种情况下可能返回：<ul>
<li>一是区域小于等于阈值16；二是超过递归深度阈值。我们现在只考虑最左边的子序列：</li>
<li>先假设是由于第一种情况终止了这个函数，那么该子区域小于16。而根据快排原理，<strong>左边区间的所有数据一定比右边小</strong>，可以推断出最小值一定在该小于16的子区域内。</li>
<li>假设函数是第二种情况下终止，那么对于最左边的区间，由于递归深度过深，因此该区间会调用堆排序，所以这段区间的最小值一定位于最左端（这段区间大小不一定，但数据一定都比右区间小）。再加上前面的结论：左边区间所有的数据一定比右边小，那么该区间内最左边的数据一定是整个序列的最小值。</li>
<li>因此，不论是哪种情况，都可以保证起始的16个元素中一定有最小值。</li>
</ul>
</li>
<li>如若元素小于阈值，也即分支语句判断的那样，直接用常规的插入排序。</li>
</ul>
<p>对sort的理解可以参考博客：<code>https://feihu.me/blog/2014/sgi-std-sort/#为何__final_insertion_sort如此实现</code></p>
<h4 id="equal-range（有序区间）"><a href="#equal-range（有序区间）" class="headerlink" title="equal_range（有序区间）"></a>equal_range（有序区间）</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/equal_range1.png" alt="image-20220717101116777"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/equal_range2.png" alt="image-20220717101150696"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/equal_range3.png" alt="image-20220717101213233"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/equal_range4.png" alt="image-20220717101236524"></p>
<h4 id="inplace-merge（有序区间）"><a href="#inplace-merge（有序区间）" class="headerlink" title="inplace_merge（有序区间）"></a>inplace_merge（有序区间）</h4><p>常规的merge需要一个足够大的新区间，合并两个不一定连续的序列。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B61.png" alt="image-20220717102357897"></p>
<p>注意这里两个序列是连接在一起的，缓存空间只需要能安置任何一个序列，就能简单由merge（backward）完成，因为这个merge过程使用缓存先存好了一个序列，往原来容器排序合并的过程中破坏了的元素不被需要（从缓存拿）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B62.png" alt="image-20220717102412530"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B63.png" alt="image-20220717102435562"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B64.png" alt="image-20220717102451244"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B65.png" alt="image-20220717102506599"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B66.png" alt="image-20220717102519486"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B67.png" alt="image-20220717102531964"></p>
<p>针对case3：</p>
<ul>
<li>本质上是将两个序列先分成3个序列，其中中间的序列是从前面序列拿后部分元素，从后面序列拿前部分元素。然后再把中间序列分成两个序列，就有4个序列，对前两个、后两个做merge，就减少了长度；如果长度还是不够就继续减少，因为是递归调用。</li>
<li>接着我们看看中间序列是怎么形成的：将长的序列分两半（对照下面例子就是len2），然后另一个序列用<strong>lower_bound</strong>，这是至关重要的一点。因为两个序列都是递增序列，则middle-cut2的元素&lt;cut2指向的元素，这样序列一使用lower_bound得到的cut1指向的元素（包括到middle的元素）一定&gt;middle-cut2的元素，因为cut1元素&gt;&#x3D;cut2元素。并且first-cut1之间的元素&lt;cut2-last的元素（同样由lower_bound保证：cut1略过&lt;cut2的元素，而到&gt;&#x3D;cut2元素时停下）</li>
<li>紧接着用一个rotate旋转，将middle-cut2的元素与cut1-middle的元素互换位置，就能保证first-newmiddle之间的元素比newmiddle-last的元素都小。这样分别对两个区间递归merge（每个区间又包含两个小区间），就减少了长度，使得缓冲区能容纳。</li>
<li>真相呼之欲出。实质上为了缩小序列，把两个序列分成了四个小序列，不妨设为l1、l2、l3、l4，l1、l2由前半序列分成，l3、l4由后半序列分成。为了分别做merge，需要保证左半边的序列已经比右半边序列元素小，但直接划分的序列不能保证这个情况，因此使用了旋转。因为l1&lt;l2，l3&lt;l4，而使用了lower_bound，能保证l2&gt;l3，l4&gt;l1。在旋转后得到l1、l3，l2、l4，就保证了l1、l3都小于l2、l4，再递归对两个序列merge即可。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B68.png" alt="image-20220717102544559"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B69.png" alt="image-20220717102614400"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B610.png" alt="image-20220717102633097"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B611.png" alt="image-20220717102653956"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B0%B1%E5%9C%B0%E5%90%88%E5%B9%B612.png" alt="image-20220717102707307"></p>
<h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h4><p>这个不动点的保证是根据<code>左边区间&lt;nth&lt;右边区间</code>，nth即可得到与排序相同的值，不用管其他元素。</p>
<p>最后用插入排序是因为长度比较小，没必要再一点点分割了，直接排序完省事。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/nth_element1.png" alt="image-20220717110246499"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/nth_element2.png" alt="image-20220717110302510"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/nth_element3.png" alt="image-20220717110319387"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/nth_element4.png" alt="image-20220717110339228"></p>
<h4 id="merge-sort"><a href="#merge-sort" class="headerlink" title="merge sort"></a>merge sort</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png" alt="image-20220717111608636"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" alt="image-20220717111630333"></p>
<h1 id="仿函数（函数对象）"><a href="#仿函数（函数对象）" class="headerlink" title="仿函数（函数对象）"></a>仿函数（函数对象）</h1><h2 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h2><p>理解：仿函数实际上是一个类或结构体，重载了**()**运算符使得其可以像函数一样调用。而且对比一般的函数指针又具有更多的功能，比如能使用模板、拥有继承等类之间的关系，利于资源管理（如果不是暂时对象可以保存数据）、使用成员变量免去一些全局变量的维护。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E6%A6%82%E8%A7%821.png" alt="image-20220717212445635"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E6%A6%82%E8%A7%822.png" alt="image-20220717212620304"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E6%A6%82%E8%A7%823.png" alt="image-20220717212640627"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E6%A6%82%E8%A7%824.png" alt="image-20220717212701166"></p>
<h2 id="可配接（adaptable）的关键"><a href="#可配接（adaptable）的关键" class="headerlink" title="可配接（adaptable）的关键"></a>可配接（adaptable）的关键</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%AF%E9%85%8D%E6%8E%A51.png" alt="image-20220717214155110"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%AF%E9%85%8D%E6%8E%A52.png" alt="image-20220717214319801"></p>
<h3 id="unary-function"><a href="#unary-function" class="headerlink" title="unary_function"></a>unary_function</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/unary_function1.png" alt="image-20220717214420971"></p>
<h3 id="binary-function"><a href="#binary-function" class="headerlink" title="binary_function"></a>binary_function</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/binary_function1.png" alt="image-20220717214846421"></p>
<h2 id="算术运算类仿函数"><a href="#算术运算类仿函数" class="headerlink" title="算术运算类仿函数"></a>算术运算类仿函数</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B01.png" alt="image-20220717220011705"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B02.png" alt="image-20220717220027680"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B03.png" alt="image-20220717220356714"></p>
<p>第一种实例化创建方式，在main()函数栈中，第二种方式作为cout对象的”&lt;&lt;”运算符函数的临时对象参数（在这个运算符函数的栈中），在cout完就结束了生命周期。如果类里定义了构造函数，则在括号里加上数值就可以使用构造函数，如<code>plus&lt;int&gt;(123)(3,5)</code>，对应的不用临时对象的方式是<code>plus&lt;int&gt; plusobj(123)</code>（使用有参构造函数，否则使用无参构造函数或默认构造函数）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B04.png" alt="image-20220717221533861"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B05.png" alt="image-20220717221551371"></p>
<h2 id="关系运算类仿函数"><a href="#关系运算类仿函数" class="headerlink" title="关系运算类仿函数"></a>关系运算类仿函数</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B01.png" alt="image-20220717222058852"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B02.png" alt="image-20220717222126027"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B03.png" alt="image-20220717222140905"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B04.png" alt="image-20220717222155928"></p>
<h2 id="逻辑运算类仿函数"><a href="#逻辑运算类仿函数" class="headerlink" title="逻辑运算类仿函数"></a>逻辑运算类仿函数</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B01.png" alt="image-20220717222242442"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B02.png" alt="image-20220717222300935"></p>
<h2 id="证同、选择、投射"><a href="#证同、选择、投射" class="headerlink" title="证同、选择、投射"></a>证同、选择、投射</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%AF%81%E5%90%8C1.png" alt="image-20220717222336065"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%AF%81%E5%90%8C2.png" alt="image-20220717222352233"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%AF%81%E5%90%8C3.png" alt="image-20220717222407811"></p>
<h1 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h1><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718101755203"></p>
<h2 id="概观与分类"><a href="#概观与分类" class="headerlink" title="概观与分类"></a>概观与分类</h2><p>改变仿函数（functors）接口者，称为function adapter，改变容器（containers）接口者，称为container adapter，改变迭代器（iterators）接口者，称为iterator adapter。</p>
<h3 id="应用于容器，container-adapters"><a href="#应用于容器，container-adapters" class="headerlink" title="应用于容器，container adapters"></a>应用于容器，container adapters</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%AE%B9%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A8.png" alt="image-20220718102119349"></p>
<h3 id="应用于迭代器，iterator-adapters"><a href="#应用于迭代器，iterator-adapters" class="headerlink" title="应用于迭代器，iterator adapters"></a>应用于迭代器，iterator adapters</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718102217547"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718102233961"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718102249018"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718102307660"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%85%8D%E6%8E%A5%E5%99%A85.png" alt="image-20220718102410136"></p>
<h3 id="应用于仿函数，functor-adapters"><a href="#应用于仿函数，functor-adapters" class="headerlink" title="应用于仿函数，functor adapters"></a>应用于仿函数，functor adapters</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718103049962"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718103228312"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718103322494"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718103526544"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A85.png" alt="image-20220718103813947"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A86.png" alt="image-20220718103857300"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A87.png" alt="image-20220718104016271"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A88.png" alt="image-20220718104042713"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A89.png" alt="image-20220718104100211"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BB%BF%E5%87%BD%E6%95%B0%E9%85%8D%E6%8E%A5%E5%99%A810.png" alt="image-20220718104114616"></p>
<h2 id="container-adapters"><a href="#container-adapters" class="headerlink" title="container adapters"></a>container adapters</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/cont%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718105329217"></p>
<h2 id="iterator-adapters"><a href="#iterator-adapters" class="headerlink" title="iterator adapters"></a>iterator adapters</h2><h3 id="insert-iterators"><a href="#insert-iterators" class="headerlink" title="insert iterators"></a>insert iterators</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718145236565"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718145300655"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718145320497"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718145342558"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8F%92%E5%85%A5%E9%85%8D%E6%8E%A5%E5%99%A86.png" alt="image-20220718145402441"></p>
<h3 id="reverse-iterators"><a href="#reverse-iterators" class="headerlink" title="reverse iterators"></a>reverse iterators</h3><p>注意倒转后迭代器仍保持<strong>前闭后开</strong>！这使得逻辑位置改变（指向一个位置的正向、倒转迭代器取值不同，这是因为倒转迭代器先向前一步再取值），但只有这样才能保持正向迭代器的一切惯常行为。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718150323303"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718150343569"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718150434610"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718150453407"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A85.png" alt="image-20220718150510865"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A86.png" alt="image-20220718150536096"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A87.png" alt="image-20220718150552097"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A88.png" alt="image-20220718150616231"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A89.png" alt="image-20220718150632751"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%80%92%E8%BD%AC%E9%85%8D%E6%8E%A5%E5%99%A810.png" alt="image-20220718150646413"></p>
<h3 id="stream-iterators"><a href="#stream-iterators" class="headerlink" title="stream iterators"></a>stream iterators</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718152645229"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718152754751"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718152810584"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718152828514"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E9%85%8D%E6%8E%A5%E5%99%A85.png" alt="image-20220718152845572"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A86.png" alt="image-20220718155603786"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A87.png" alt="image-20220718155625952"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A88.png" alt="image-20220718155644000"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A89.png" alt="image-20220718155707414"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A810.png" alt="image-20220718155735301"></p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="输入流简单用法"><a href="#输入流简单用法" class="headerlink" title="输入流简单用法"></a>输入流简单用法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于接收输入流中的数据</span></span><br><span class="line">    <span class="type">double</span> value1, value2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入 2 个小数: &quot;</span>;</span><br><span class="line">    <span class="comment">//一般用两个流迭代器来从流中读取全部的值：指向要读入的第一个值的开始迭代器，指向流的末尾的结束迭代器。在输入流的文件结束状态(End-Of-File，EOF)被识别时，就可以确定结束迭代器。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建表示结束的输入流迭代器</span></span><br><span class="line">    istream_iterator&lt;<span class="type">double</span>&gt; eos;<span class="comment">//使用默认构造函数</span></span><br><span class="line">    <span class="comment">//创建一个可逐个读取输入流中数据的迭代器，同时这里会让用户输入数据</span></span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iit</span><span class="params">(cin)</span></span>;</span><br><span class="line">    <span class="comment">//判断输入流中是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> (iit != eos) &#123;</span><br><span class="line">        <span class="comment">//读取一个元素，并赋值给 value1</span></span><br><span class="line">        value1 = *iit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果输入流中此时没有数据，则用户要输入一个；反之，如果流中有数据，iit 迭代器后移一位，做读取下一个元素做准备</span></span><br><span class="line">    iit++;</span><br><span class="line">    <span class="keyword">if</span> (iit != eos) &#123;</span><br><span class="line">        <span class="comment">//读取第二个元素，赋值给 value2</span></span><br><span class="line">        value2 = *iit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出读取到的 2 个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value1 = &quot;</span> &lt;&lt; value1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value2 = &quot;</span> &lt;&lt; value2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入 2 个小数: 1.2 2.3</span><br><span class="line">value1 = 1.2</span><br><span class="line">value2 = 2.3</span><br></pre></td></tr></table></figure>

<p>注意，只有读取到 EOF 流结束符时，程序中的 iit 才会和 eos 相等。另外，Windows 平台上使用 Ctrl+Z 组合键输入 ^Z 表示 EOF 流结束符，此结束符需要单独输入，或者输入换行符之后再输入才有效。</p>
<h5 id="输出流简单用法"><a href="#输出流简单用法" class="headerlink" title="输出流简单用法"></a>输出流简单用法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个输出流迭代器</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;string&gt; <span class="title">out_it</span><span class="params">(cout)</span></span>;</span><br><span class="line">    <span class="comment">//向 cout 输出流写入 string 字符串</span></span><br><span class="line">    *out_it = <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个输出流迭代器，设置分隔符 ,</span></span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it1</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//向 cout 输出流依次写入 1、2、3</span></span><br><span class="line">    *out_it1 = <span class="number">1</span>;</span><br><span class="line">    *out_it1 = <span class="number">2</span>;</span><br><span class="line">    *out_it1 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://c.biancheng.net/stl/</span><br><span class="line">1,2,3,</span><br></pre></td></tr></table></figure>

<p>在实际场景中，输出流迭代器常和 copy() 函数连用，即作为该函数第 3 个参数。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::copy</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个 vector 容器</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myvector;</span><br><span class="line">    <span class="comment">//初始化 myvector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        myvector.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建输出流迭代器</span></span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout, <span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//将 myvector 容器中存储的元素写入到 cout 输出流中</span></span><br><span class="line">    std::<span class="built_in">copy</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), out_it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3, 4, 5, 6, 7, 8, 9,</span><br></pre></td></tr></table></figure>

<h2 id="function-adapters"><a href="#function-adapters" class="headerlink" title="function adapters"></a>function adapters</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/func%E9%85%8D%E6%8E%A5%E5%99%A81.png" alt="image-20220718204731386"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/func%E9%85%8D%E6%8E%A5%E5%99%A82.png" alt="image-20220718204821810"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/func%E9%85%8D%E6%8E%A5%E5%99%A83.png" alt="image-20220718205014836"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/func%E9%85%8D%E6%8E%A5%E5%99%A84.png" alt="image-20220718205041489"></p>
<h3 id="返回值逻辑否定-not1、not2"><a href="#返回值逻辑否定-not1、not2" class="headerlink" title="返回值逻辑否定 not1、not2"></a>返回值逻辑否定 not1、not2</h3><p>代码中常出现的<code>pred</code>一词，是<code>predicate</code>的缩写，意指这个函数会返回真假值（bool）的表达式。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%BB%E8%BE%91%E5%90%A6%E5%AE%9A1.png" alt="image-20220718205558167"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%BB%E8%BE%91%E5%90%A6%E5%AE%9A2.png" alt="image-20220718205615187"></p>
<h3 id="参数绑定-bind1st、bind2nd"><a href="#参数绑定-bind1st、bind2nd" class="headerlink" title="参数绑定 bind1st、bind2nd"></a>参数绑定 bind1st、bind2nd</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A1.png" alt="image-20220718210310958"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A2.png" alt="image-20220718210324882"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A3.png" alt="image-20220718210335848"></p>
<h3 id="函数合成-compose1、compose2"><a href="#函数合成-compose1、compose2" class="headerlink" title="函数合成 compose1、compose2"></a>函数合成 compose1、compose2</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E5%90%88%E6%88%901.png" alt="image-20220718211019187"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E5%90%88%E6%88%902.png" alt="image-20220718211033913"></p>
<h3 id="函数指针-ptr-fun"><a href="#函数指针-ptr-fun" class="headerlink" title="函数指针 ptr_fun"></a>函数指针 ptr_fun</h3><p>函数指针的前置知识可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvchaoshun/p/7806248.html">C&#x2F;C++ 函数指针使用总结 - 白菜菜白 - 博客园 (cnblogs.com)</a></p>
<p>使用配接器可以使用模板。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%881.png" alt="image-20220718211227501"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%882.png" alt="image-20220718212152451"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%883.png" alt="image-20220718212208413"></p>
<h3 id="成员函数指针-mem-fun、mem-fun-ref"><a href="#成员函数指针-mem-fun、mem-fun-ref" class="headerlink" title="成员函数指针 mem_fun、mem_fun_ref"></a>成员函数指针 mem_fun、mem_fun_ref</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%881.png" alt="image-20220718212612550"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%882.png" alt="image-20220718212738481"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%883.png" alt="image-20220718212755625"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%884.png" alt="image-20220718212812756"></p>
<p>这其中<strong>S</strong>是函数返回值，<strong>T</strong>是函数所属的class类型。把这个类的对象传进来，获取对应的成员函数。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%885.png" alt="image-20220718213446601"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%886.png" alt="image-20220718213505094"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%887.png" alt="image-20220718213546265"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%888.png" alt="image-20220718213559463"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%889.png" alt="image-20220718213632081"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="2022-x2F-7-x2F-18"><a href="#2022-x2F-7-x2F-18" class="headerlink" title="2022&#x2F;7&#x2F;18"></a>2022&#x2F;7&#x2F;18</h2><p>将这本书笼统地过了一遍，大概花了将近一个月的时间。因为挺久没接触c++了，（课设写的都是纯c风格、之前平时用的是python），导致很多语法都忘记了。实际上是一个边学习边复习的过程，以至于依然有许许多多地细节等待我去发现，因此我会再花五六天的时间（甚至更多）重头开始再过一遍，这次更加注重细节（作深一番追究），以及整个宏观层次的思考和总结。不过，这些都交给明天的我吧~~</p>
<h2 id="2022-x2F-7-x2F-28"><a href="#2022-x2F-7-x2F-28" class="headerlink" title="2022&#x2F;7&#x2F;28"></a>2022&#x2F;7&#x2F;28</h2><p>第二遍大概是过完了，补充了一些要点，并且之前没看懂的部分这次也能看懂了，有的部分作了总结。中间也有休息几天，大概用了七八天吧，其中也在学计网。当然很多东西是不用只根据看就能明白的，所以接下来打算做一个小型的STL，这个项目在github上：<a target="_blank" rel="noopener" href="https://github.com/Alinshans/MyTinySTL">Alinshans&#x2F;MyTinySTL: Achieve a tiny STL in C++11 (github.com)</a>，已经近7kstar了，如果要进阶STL，可以一起来学习这个项目并且自己动手实践。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/13/2022%E6%98%A5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B8%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/2022%E6%98%A5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B8%96/" class="post-title-link" itemprop="url">期末复习帖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-13 16:01:09" itemprop="dateCreated datePublished" datetime="2022-05-13T16:01:09+08:00">2022-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-26 20:26:26" itemprop="dateModified" datetime="2022-06-26T20:26:26+08:00">2022-06-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>总之就是非常痛苦 &gt;_&lt;</strong></p>
<p>这篇博客就当个帖，想记录一下复习期末考的过程，作为情绪抒发和进度整理等等（甚至类似于日记）。</p>
<h1 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h1><h2 id="Date-5-x2F-13"><a href="#Date-5-x2F-13" class="headerlink" title="Date 5&#x2F;13"></a>Date 5&#x2F;13</h2><p>这学期专业课学到了很多东西，但是很多知识点都不太深入，对考试不是很有信心，而且因为疫情估计要线上考试，也是很不方便不舒服的吧。剩下的还有20来天就考试周了，所以要现在开始复习了。首先是要规划一下，按考试的顺序应该是：</p>
<ul>
<li>操作系统（D类）</li>
<li>算法与复杂性</li>
<li>计算机组成</li>
<li>计算机科学中的数学基础</li>
<li>计算机系统结构（A类）</li>
<li>大学物理(A类）</li>
</ul>
<p>很庆幸把编译原理退了，实在折腾不起。其中毛概貌似改成了线上大作业的形式所以这里没有放出来，不过老师说还要等通知（虽然毛概这些课只是考前一天狂背）。我的习惯的从后往前复习，这样对第一门考试印象会清晰些。</p>
<ul>
<li>大学物理这学期是在上量子力学，老实说没学明白，老师的课件和讲解也比较混乱，猜想是应该不会考那么难。但是现在什么信息都不知道，甚至也没有教材，所以打算先不复习这个（感觉这门课没什么作用就是了）。</li>
<li>系统结构的话学得很烂，因为老师是选了几本书的内容来讲的，上课的时候没有结合书本来看，吸收得不是很到位。所以打算先再看看教材比较重点的章节，做做课后习题先。包括老师今天刚开放这学期的慕课，后面也可以看看慕课的视频讲得好不好（理论上慕课的成绩是课后题和模拟考试的成绩）。这门课的复习应该占的时间会比较多了。</li>
<li>数学基础讲的太难了，不过好在作业有认真做（当然是谷歌solution，因为太难了，据说作业对比考试是sss难度）。具体复习的话打算看看课件（也是没用教材来学习，全英的pdf太折磨了），把一些公式再好好看看推导再记一下（但是推导也太难了，不知道会考成啥样），然后复习做过的题目。</li>
<li>计组貌似期末是开卷（感觉开卷反而难一些），老师课讲得很好（太清晰明了了），知识点大都能理解，不过之前都没有复习导致都快忘了。所以一方面得再看看老师的ppt（老师上课很多手画的图没在ppt上，可能还得看视频了），一方面看看有没有题目做，感觉做起题目来还是很吃力。</li>
<li>算法课也难啊，图算法和几何算法讲了好几周了，属实是太难了。还没想好要咋复习，估计就看看写过的作业吧。笔记这些也没有，感觉有点难复习了，也是只能再看看ppt和书了，找不到对应能巩固的习题来做。</li>
<li>操作系统算是学得最明白的了，有一本中文教材太棒了。虽然课上用的是更新一版的英文版（中文版还没出），不过许多章节都能对应上。而且操作系统能出来考试的知识点比较明显吧，也做了相应的作业，感觉再看遍书，复习下作业题就好很多。当然还是希望能有题目做做巩固一下。</li>
</ul>
<p>时间方面的具体安排就还没想好，只能说学得不是很好，还没有<em>需要花多少时间复习</em>的自知。好在还有时间，走一步看一步先。</p>
<h2 id="Date-5-x2F-15"><a href="#Date-5-x2F-15" class="headerlink" title="Date 5&#x2F;15"></a>Date 5&#x2F;15</h2><p>现在是周日晚上十一点多，回顾一下这个周末，摸得多学得少。物理作业屯着先不打算做（做了怕又忘记了），所以周末都用来复习了。不过实际上复习的时间也就六七个小时，效率还是太低了。</p>
<p>也算是有个好的开端，两天复习了系统结构的处理器的章节和浮点数的章节。处理器部分比较多，浮点数讲的比较少，但是复习做了做题也巩固了不少，算是把薄弱的补了一些了。</p>
<p>之后打算每天看看慕课的ppt什么的，然后把课后习题做了（两天一篇吧，章节还挺多。）ppt不知道是不是和课上一样的，还没瞅瞅。然后就边复习数学基础了，看看公式什么的。</p>
<p>\ 周末都是在CIEL的歌下度过的，好听嘞 &#x2F;</p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/CIEL.png" alt="img"  />



<h2 id="Date-5-x2F-17"><a href="#Date-5-x2F-17" class="headerlink" title="Date 5&#x2F;17"></a>Date 5&#x2F;17</h2><p>跟预想的有些偏差，不知道是记错了还是怎么样，原来考试时间要倒着看的，下面是刚查到的考试信息，有点阴间，能堆的都堆了，中间又间隔挺久的。最后一周的周末貌似就用来线上考毛概，得重新计划一下复习节奏了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">大学物理：6-6   15：40——17：40</span><br><span class="line">系统结构：6-7   10：30——12：30</span><br><span class="line">数学基础：6-10  10：30——12：30</span><br><span class="line">计组    ：6-10  15：40——17：40</span><br><span class="line">算法    ：6-16  15：40——17：40</span><br><span class="line">操作系统：6-17  10：30——12：30</span><br></pre></td></tr></table></figure>

<p>至于这两天在干啥嘞，本来打算复习数学基础的，结果来了许多作业，算是最后为数不多的作业了。除了上课就是把 os 作业写了，然后补了物理作业（还差两题没写出来，这量子力学一点例题都没有，纯摸黑 ￣へ￣）。系统结构最后一次lab写了两个晚上了，现在还在等最后一题的程序出结果。</p>
<p>这两天在听re0的歌，下面两首强推（其他op和ed也都很好听）。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1832363905&auto=0&height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1475841363&auto=0&height=66"></iframe>

<h2 id="Date-5-x2F-19"><a href="#Date-5-x2F-19" class="headerlink" title="Date 5&#x2F;19"></a>Date 5&#x2F;19</h2><p>昨天肝了体育作业（该死的慕课），然后晚上写了算法课的作业就草草结束了。</p>
<p>今天复习了数学基础，先速通一遍，现在看了大概一半了。前面部分学的还是比较烂，所以看ppt的时候一边回放了视频，第二次看视频就觉得清晰多了，不过太难的证明还是不打算看了。明天打算把后面的部分也过完。</p>
<p>然后这几天看完了命运石之门，好看的嘞，胸针真男人。</p>
<h2 id="Date-5-x2F-26"><a href="#Date-5-x2F-26" class="headerlink" title="Date 5&#x2F;26"></a>Date 5&#x2F;26</h2><p>几天没更新了-。-</p>
<p>最近几天在复习完数学基础之后复习了操作系统的前面部分，本来周一是打算复习完后面部分的，结果计划了回家，买了票等等，就没心思复习下去了。</p>
<p>返乡要准备好多东西，不过一点点准备好也就可以了，回去还要先隔离14days，考试也要在酒店考，后面两门应该就能在家里了。会不会发生很麻烦的事情倒也还不知道，感觉一个人也能复习得下去一些。</p>
<p>周五的高铁，明天早上。心里不知道什么感觉，有种释放了吧。困了3个多月，从早晨起来就是对着电脑一直到晚上，不怎么出宿舍，也很久没有好好运动了……</p>
<p>倒不会很惨，学校各种措施和保障都做得很好，只是还是会有些压抑吧，虽然学业上的压力冲淡了这些压抑。</p>
<p>现在是周四的12点多一些，前两天把系统结构的慕课的测验做的差不多了，今天做完它，然后好好收拾一下行李（以及心情）。</p>
<p>回去最想做的一件事就是悠哉地吃点好的喝点好的</p>
<p>希望一切顺利，一路顺风</p>
<p>&#x2F; 最近喜欢听的歌，卡罗尔与星期二里的 After the fire</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1399996440&auto=0&height=66"></iframe>

<h2 id="Date-5-x2F-27"><a href="#Date-5-x2F-27" class="headerlink" title="Date 5&#x2F;27"></a>Date 5&#x2F;27</h2><p>跑路成功</p>
<p>5:00——22:00</p>
<p>好累- -</p>
<h2 id="Date-5-x2F-30"><a href="#Date-5-x2F-30" class="headerlink" title="Date 5&#x2F;30"></a>Date 5&#x2F;30</h2><p>最后的教学周了，今天在复习物理，好折磨嗷</p>
<p>越发感觉对知识的掌握程度并不足以应付考试</p>
<p>这周刚布置了形策的大作业，还没想好啥时候写。周末还有毛概的考试，复习时间好像不是很够…</p>
<p>在酒店隔离，条件还是很不错的，并且一个人可以开始自律生活</p>
<p>现在每天十二点睡，中午再午睡一下，慢慢变得早起些</p>
<p>然后每天保持半个小时左右的运动量，出出汗，毕竟之前在学校宿舍很久很久没有丝毫运动了，作为康复训练吧</p>
<p>压力还是很大，几门课程的平时分根据作业的打分情况看感觉也没有到预期，甚至还不知道错哪里了，答案也不公布…（唉）</p>
<p>不打算摆烂，但是也不打算太肝了。就像是在痛苦与快感中获得相对平衡</p>
<p>又也许只是，在虚无的快乐中寻求一些充实</p>
<h2 id="Date-6-x2F-1"><a href="#Date-6-x2F-1" class="headerlink" title="Date 6&#x2F;1"></a>Date 6&#x2F;1</h2><p>儿童节快乐</p>
<p>这两天一天整理+复习了计组，一天看了系统结构的题目，明天接着再看一遍系统结构的题目，以及把形策大作业over</p>
<p>然后是周五看os，因为周五晚上要os小测了</p>
<p>周六看大物，周天做毛概，下周一就开始考试了</p>
<p>选课遇到了点问题，选人工智能和要补修（因为转专业）的问求（问题求解与实践）时间冲突了，只能退选人工智能这门课，否则影响保研。实际上也不差人工智能这一门课，但是这又影响到后面学期的选方向，没选这门课就不能选AI的那个方向了，需要另修完一个方向的学分，我换了个计算机图形学，到时的方向应该是虚拟现实技术之类的。不过还是会继续学AI，因此那个方向是用来修学分的，AI方向的课还是可以选（据说），应该会继续选来上，就是课会比较多了……</p>
<p>不管怎么说，后面走一步算一步吧，加油</p>
<h2 id="Date-6-x2F-3"><a href="#Date-6-x2F-3" class="headerlink" title="Date 6&#x2F;3"></a>Date 6&#x2F;3</h2><p>端午节快乐</p>
<p>隔离酒店的早餐加了个粽子，挺开心的</p>
<p>晚上考了个os的小测，平均线之上吧，都是多选题，很难选</p>
<p>其他时间摆了挺久，期末考越来越近了</p>
<p>哈哈感觉期末考有些打boss的意思了</p>
<p>在酒店待了一个星期了，吃得挺好睡得挺好，都挺好的</p>
<p>日子很平淡，老实说就算放假了也没想着要干嘛——呃想得有些远了</p>
<p>最近喜欢听的歌，希望未来有一天</p>
<p>能明白许许多多的，非常遥远的，没有名字的，安静的孤单的，星星的愿望</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=437608325&auto=0&height=66"></iframe>



<h2 id="Date-6-x2F-5"><a href="#Date-6-x2F-5" class="headerlink" title="Date 6&#x2F;5"></a>Date 6&#x2F;5</h2><p>现在是下午，刚做完毛概的考试大作业，题目挺水的，逻辑搞对在书上找找，以及网上搜搜就能答。不过感觉大家的答案可能都一样了，官话都那个味道，不知道怎么批改。前天晚上刚做了os的小测，30道选择题，有95%的多选题，英文概念题，做起来挺恶心的，是题库的题目，但是老师有些都没有讲。不过还是老老实实自己做了，在平均分之上，换算下来平均分的话是平时分扣5分，我是平时分扣3分，这个结果对一门课程来说挺不应该的，不知道老师会不会调分，就算不调分我也能接受吧。</p>
<p>然后这个是最新的考试时间，为了不受早上做核酸的影响，教务把考试都安排到下午和晚上了，日期倒是没有变化，起码早上可以不用那么早起吧。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%80%83%E8%AF%95%E6%97%B6%E9%97%B41.png" alt="1d2b82fbcba30c43fa8a29a03c36d1f"></p>
<p>晚上接着复习物理，说实话已经看了几天物理了，感觉还不如前面花多点时间复习别的科目。但是明天就要考物理了也不能不继续复习，感觉自己的状态不是很好，复习起来也是有气无力的，没有前几个学期那么沉得住气，线上教学影响还是蛮大的。</p>
<p>这个学期考个正常分平均分就立大功了，不是很抱期望考高分，暑假再收拾收拾心情。</p>
<p>接下来就好好打boss了</p>
<h2 id="Date-6-x2F-12"><a href="#Date-6-x2F-12" class="headerlink" title="Date 6&#x2F;12"></a>Date 6&#x2F;12</h2><p>现在是周日，周五考完计组后周六好好放松了一天。</p>
<p>这几门科目的考试确实比较难，感觉发挥的也不是那么好吧，不过应该也不会那么差（希望吧）</p>
<p>后面还有两科今天要开始复习了，先花两天时间看操作系统，再花两天时间看算法，老实说算法还不知道会怎么考，后面有机会再了解了解</p>
<p>早上在阳台吹了很久的风，没有在思考，纯粹的放松。以后的职业选择估计也要变了，等考完试再理一理</p>
<p>最近看虫师被惊艳到的一首纯音乐，很惬意很飘渺</p>
<p>很理想</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=469933&auto=0&height=66"></iframe>

<h2 id="Date-6-x2F-18"><a href="#Date-6-x2F-18" class="headerlink" title="Date 6&#x2F;18"></a>Date 6&#x2F;18</h2><p>今天是周六，出去和朋友玩了。昨天考完os累坏啦，周末好好放松一下，然后下周又要开始小学期了。</p>
<p>明天再规划一下暑假安排，等分数出来再给这个贴子来一个终结啦。</p>
<h2 id="Date-6-x2F-26"><a href="#Date-6-x2F-26" class="headerlink" title="Date 6&#x2F;26"></a>Date 6&#x2F;26</h2><p> 今天成绩算是全部出来了，一般般比较正常。因为有很多同学缓考和重考，所以也不知道真实的排名，也就不说了。</p>
<p>整个过程算是很辛苦了，不过过去就好啦。</p>
<p>最近重新深入学c++，也感觉挺有意思的（虽然很难）。</p>
<p>这篇就到此为止啦，谢谢陪伴</p>
<p>（最后推一首歌</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1811129844&auto=0&height=66"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%993/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%993/" class="post-title-link" itemprop="url">自动登录学校网站（终：优化）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 15:56:47" itemprop="dateCreated datePublished" datetime="2022-05-12T15:56:47+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 08:27:27" itemprop="dateModified" datetime="2022-05-26T08:27:27+08:00">2022-05-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h1><p>对于原来的代码，尽管能够成功登录学校的网站，但依旧有很多地方可以优化。</p>
<ul>
<li><p>模型加载较慢，python加载本地训练好的模型还是太慢了，并且要打包成exe文件的话，torch这个库太大了，不可能再用自己的模型来完成项目。所以这里可以再用到之前的验证码识别库ddddocr来代替自己的识别模型。</p>
</li>
<li><p>考虑到项目迁移的方便，每次都下载一个chromedriver.exe文件是比较麻烦的，禁用谷歌浏览器自动升级是个好的选择，但是有更好的替代方法。可以使用<code>webdriver-manager</code>这个库，它会自动下载对应的driver到缓存里。具体的使用方式是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-logging&#x27;</span>])<span class="comment">#忽略dirver的信息打印</span></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install(),options=options)<span class="comment">#可以在缓存里下载最新的driver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面两个解决方式分别能够优化程序的<strong>运行速度</strong>和<strong>项目迁移性</strong>，但直接打包成.exe文件还是会产生其他的问题。</p>
</li>
</ul>
<h1 id="可执行文件优化"><a href="#可执行文件优化" class="headerlink" title="可执行文件优化"></a>可执行文件优化</h1><ul>
<li><p>程序正常运行的情况下会在结束时关闭浏览器，除非我们在程序末尾sleep一个很长的时间等待。然而我们希望程序进程在打开浏览器后就可以退出，而不必等待我们将浏览器关闭。可以使用<code>options.add_experimental_option(&quot;detach&quot;, True)</code>，这个语句使程序结束后浏览器不会关闭，不需要程序一直等待。</p>
</li>
<li><p>我们打包的文件会调用chromedriver.exe，尽管我们可以设置我们的可执行文件（.exe）运行时不出现cmd窗口，但chromedriver.exe依然会出现自己的窗口展示运行信息，而这会影响简结，我们希望这个窗口不出现。解决方法是修改<strong>selenium</strong>包中的<strong>service.py</strong>（selenium-&gt;webdriver-&gt;common-&gt;service.py）源码。如下图，注意数字必须相同。</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/selenium%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9.png" alt="image-20220512161629179" style="zoom:80%;" />
</li>
<li><p>最后的问题是，我们的程序自动退出了，因为不将浏览器关掉，所以chromedriver.exe这个进程会一直留在内存里。如果我们多次打开我们的.exe文件，就会有很多个chromedriver.exe进程，尽管占用的空间很小，我们也希望能在程序结束后终止掉这个进程，这并不会导致我们的网页关闭。</p>
<ul>
<li><p>我们可以用<code>&quot;taskkill /im chromedriver.exe /F&quot;</code>这个命令来杀死这个进程，一种容易想到的方式是用os.system(command)来执行这条命令，但是这个方式会在执行时闪现出cmd执行窗口，不是我们希望的方式。</p>
</li>
<li><p>更好的方式是使用python的另一个标准库<strong>subprocess</strong>的subprocess.call(command, creationflags&#x3D;0x08000000)。因此就可以写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.call(<span class="string">&quot;taskkill /im chromedriver.exe /F&quot;</span>, creationflags=<span class="number">0x08000000</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>以上就把代码优化完毕了，两个代码文件如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#captcha_fast.py</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_snap</span>(<span class="params">driver</span>):  <span class="comment"># 对目标网页进行截屏。这里截的是全屏</span></span><br><span class="line">    driver.save_screenshot(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    page_snap_obj=Image.<span class="built_in">open</span>(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> page_snap_obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">driver</span>): <span class="comment"># 对验证码所在位置进行定位，然后截取验证码图片</span></span><br><span class="line">    scaling_ratio=<span class="number">1</span><span class="comment">#系统显示的缩放比例</span></span><br><span class="line">    img = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;captcha-img&quot;]&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.10</span>)</span><br><span class="line">    location = img.location</span><br><span class="line">    size = img.size</span><br><span class="line">    left = location[<span class="string">&#x27;x&#x27;</span>]*scaling_ratio</span><br><span class="line">    top = location[<span class="string">&#x27;y&#x27;</span>]*scaling_ratio</span><br><span class="line">    right = left + size[<span class="string">&#x27;width&#x27;</span>]*scaling_ratio</span><br><span class="line">    bottom = top + size[<span class="string">&#x27;height&#x27;</span>]*scaling_ratio</span><br><span class="line">    page_snap_obj = get_snap(driver)</span><br><span class="line">    image_obj = page_snap_obj.crop((left, top, right, bottom))</span><br><span class="line">    image_obj.save(<span class="string">&#x27;captcha.png&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#login_oc.py</span></span><br><span class="line"><span class="keyword">from</span> captcha_fast <span class="keyword">import</span> get_image</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line"></span><br><span class="line">ocr = ddddocr.DdddOcr(use_gpu=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;detach&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-logging&#x27;</span>])</span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install(),options=options)</span><br><span class="line">driver.maximize_window()<span class="comment">#最大化</span></span><br><span class="line"></span><br><span class="line">captcha_path=<span class="string">&#x27;./captcha.png&#x27;</span></span><br><span class="line">snap_path=<span class="string">&#x27;./full_snap.png&#x27;</span></span><br><span class="line">url=<span class="string">&#x27;https://oc.sjtu.edu.cn/login/openid_connect&#x27;</span></span><br><span class="line"><span class="comment"># 构造请求头</span></span><br><span class="line"></span><br><span class="line">driver.get(url) <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line">cur_title=driver.title</span><br><span class="line"><span class="keyword">while</span>(driver.title==cur_title):<span class="comment">#失败则一直试</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)  <span class="comment"># 加载等待</span></span><br><span class="line">    get_image(driver)</span><br><span class="line">    <span class="comment">#print(&quot;推理验证码......&quot;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(captcha_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img_bytes = f.read()</span><br><span class="line">    captcha_res = ocr.classification(img_bytes)</span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;user&#x27;</span>).send_keys(<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 填入用户名</span></span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;pass&#x27;</span>).send_keys(<span class="string">&#x27;password&#x27;</span>)  <span class="comment"># 填入密码</span></span><br><span class="line">    driver.find_element(By.NAME,<span class="string">&#x27;captcha&#x27;</span>).send_keys(captcha_res)  <span class="comment"># 填入验证码</span></span><br><span class="line">    driver.find_element(By.ID,<span class="string">&quot;submit-button&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">os.remove(captcha_path)</span><br><span class="line">os.remove(snap_path)</span><br><span class="line">subprocess.call(<span class="string">&quot;taskkill /im chromedriver.exe /F&quot;</span>, creationflags=<span class="number">0x08000000</span>)<span class="comment">#杀死进程，用os.system会有黑窗口闪现</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ending......&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><p>最后进行项目的打包，我使用<strong>pyinstaller</strong>库来打包项目，用得比较习惯。首先在cmd窗口切换目录到python文件的目录，打包的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -w -i icon.ico login_oc.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-w</strong>表明取消程序执行的命令行窗口</li>
<li><strong>-i</strong> 表示添加打包文件的图标，后面的icon.ico就是我们使用的图标，要放在目录下，或者把路径写全。注意不能用其他后缀的图片，可以先去在线转换网站把图片转换成.ico格式，还需要注意的是，这个icon大小必须是<strong>16×16</strong>的。</li>
<li>最后想说这里不使用 <strong>-F</strong> 这个参数打包的原因。<ul>
<li>我们希望程序响应快一些，-F会把所有的项目依赖的文件打包在一起，获得一个比较大的.exe文件，这会导致文件的加载速度变慢。而不用 -F 会导出一个文件夹，放置项目依赖的文件。</li>
<li>ddddocr这个库在打包的过程中，没有被打包进去。因此不使用 -F 恰好能让我们手动把这个库添加到工作目录下（所有的库和我们的.exe文件都在这个文件夹中，还包括很多其他的.dll文件等）。</li>
<li>如果我们想做多个.exe文件登录不同的网站（我做了两个），程序使用的库基本都是一样的，仅仅是代码有一些修改，甚至只是url修改了以下。因此我们可以把多个.exe文件都放到一个工作目录下，共享这些项目依赖文件，这样就能很大地降低内存开销。</li>
</ul>
</li>
</ul>
<h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><p>在项目打包后，注意.exe文件不能移动到别的地方，要创建一个<strong>快捷方式</strong>，把这个快捷方式移动就可以在桌面或者其他地方使用了。</p>
<p>整个项目到此就结束了，有任何问题欢迎评论</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/头像.png" style="zoom: 15%;" />
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%992/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%992/" class="post-title-link" itemprop="url">自动登录学校网站（续）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 09:36:43" itemprop="dateCreated datePublished" datetime="2022-05-12T09:36:43+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 08:27:07" itemprop="dateModified" datetime="2022-05-26T08:27:07+08:00">2022-05-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="解析登录网址"><a href="#解析登录网址" class="headerlink" title="解析登录网址"></a>解析登录网址</h1><p>首先我们要定位到登录的网址以便driver访问。</p>
<p>将浏览器打开到登录页面，可以看到对应的网址为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://jaccount.sjtu.edu.cn/jaccount/jalogin?sid=jaoauth220160718&amp;client=CAzoSoajfvlBJKYW7q11rIlS5ucaE%2FIWcLi2eNuNEJDa&amp;returl=CPDcg4bZMUVfWbZWFi2BIAB%2BzZprZ2JnKxq%2Bd6MsjeS0nMw73qkvsCxG47FeRZmpnkzSb7Gf%2FCPIbwa%2BNH267zBN%2BexUD2RL%2BhgfQzpYNJ96UJUYoajLq%2Fqgx6g%2BL2Ol6i3p5RWYYIcKoV28CmbnNbPia3K1RfdgUgktPh4yNrgYsIciWlBvtMDF%2FLrJfK4rGV9Z%2BbdiXK6EFaQJId4mZXj45XlS2pmQtR5P6qOeSj3nvLDaxZ6bablX7cNO5IhPAmaj%2BMOH%2Fx5F7YpIbYoZg3R01iV6Rd7oO8pSmHFTFkvhJFWPTWI1C01nBDaKato1IDv%2BP0%2FF8C6e%2BTDf6MOGmge0SAXgweU0o4I2v06Xb5nDWAGGTAtyB2Vm0qxD7RB6C74n77jiGIGju4y13a%2Fi10RO4pmfPcik9st2unhTWfVMqDtYd%2BJ9jCjl8UOoel8G99qS7ET%2FVN%2FbP%2BfUkBJb7I8%3D&amp;se=CBZz3nk3K70uQiJvss5rVxhD4A5GYffm65sDqZ6Zh2PbEFVqISnzjU2JVjCO1VYIYuNZMv%2F8W6s3</span><br></pre></td></tr></table></figure>

<p>很明显这是拼接了随机数的网址而不是真正应该访问的，为了得到真正的登录页面的网址，需要动态解析。</p>
<p>打开一开始的登录选项，要点击校内用户登录才会加载出真正的登录页面，因此可以猜测这是一个动态加载的页面。所以我们打开页面控制台，点击<strong>Network</strong>选项，一开始是空白的，等待新加载的信息。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%901.png" alt="image-20220512114437557"></p>
<p>然后点击登录按钮，会跳转到登录页面。左边的控制台已经加载了许多信息，要在这些信息中找到加载网址的信息，一般来说我们查看第一条条目即可。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%902.png" alt="image-20220512114740458"></p>
<p>选中第一条，可以看到请求的url，这就是真正的登录页面的网址，这里可以复制这个地址打开看看是不是正确的，如果不是就继续找。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%903.png" alt="image-20220512114923472"></p>
<h1 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h1><p>得到网址后，可以进行登录。登录一般来说有两种方式，一种是用requests库的post请求，一种是用selenium的driver直接进行网页模拟登录。这里选择用driver的方式主要基于以下两个方面：</p>
<ul>
<li>目的上看，我们想要自动登录后还能够操纵我们的网页干其他事情，用driver的话刚刚好</li>
<li>从可行性的角度上看，登录过程我们需要验证码识别，如果用requests库抓取，前面提到抓取下来的验证码是不一样的，每次抓取都会改变内容。因此我能想到的解决方法就是用driver的页面进行静态的截图，实际上这符合我们人眼识别的过程。</li>
</ul>
<p>因此，我们对于验证码的识别就是根据截图来进行的。同样，这里使用我们之前训练的模型，因此要把模型先放到model.py里面。下面给出处理验证码的代码文件。首先定义验证码信息参数，如长度、大小等。然后我们要把模型初始化，加载参数的过程会比较慢（推理很快），我们不想浪费这段时间，由于用driver打开网页也需要一段时间，因此就可以开一个线程来加载参数，与此同时打开网页，可以节省一些时间。</p>
<p>然后定义了截图操作，先截全屏再截下验证码。这里验证码的位置信息通过网页源代码（html）的信息获取，用xpath、class、id定位都行，在webdriver都定义了相关的操作。需要注意的是<strong>scaling_ratio</strong>这一变量，要截下正确的验证码位置与我们屏幕的缩放比例有关。可以在桌面上右键点击显示设置，然后查看屏幕的缩放与布局，根据缩放的比例设置变量。</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE%E6%AF%94%E4%BE%8B.png" alt="image-20220512121304774" style="zoom:80%;" />

<p>最后还有一个验证码解码的方法，实际上这跟前面predict.py的操作类似。所有代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># captcha.py</span></span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> CNN_sjtu</span><br><span class="line"><span class="keyword">import</span> torch.nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> Compose, ToTensor, Resize,Normalize</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="comment">#pytorch版本关系，会有warning，实际上可以忽略</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码信息参数</span></span><br><span class="line">numchar = <span class="number">4</span></span><br><span class="line">alphabet = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">width = <span class="number">100</span></span><br><span class="line">height = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模型初始化</span></span><br><span class="line">model_net = CNN_sjtu(num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), width=width, height=height)</span><br><span class="line">model_net = model_net.cuda()</span><br><span class="line">model_net.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_net</span>():<span class="comment">#load参数 比较慢，用一个额外的线程先load</span></span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;load net......&quot;</span>)</span><br><span class="line">    model_net.load_state_dict(torch.load(<span class="string">r&#x27;C:\Users\14242\PycharmProjects&#x27;</span></span><br><span class="line">                                         <span class="string">r&#x27;\DL\Pytorch_project\captcha-CNN-验证码识别\weights/model_sjtu_4.path&#x27;</span>))<span class="comment">#参数位置</span></span><br><span class="line"></span><br><span class="line">thread_load= Thread(target=load_net)</span><br><span class="line">thread_load.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_captcha</span>(<span class="params">img_path</span>):</span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        img=Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        transforms = Compose([Resize((height, width)), ToTensor(), Normalize(<span class="number">0</span>, <span class="number">1</span>)])</span><br><span class="line">        img = transforms(img)</span><br><span class="line">        img = img.view(<span class="number">1</span>, <span class="number">3</span>, height, width).cuda()</span><br><span class="line">        output = model_net(img)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, <span class="built_in">len</span>(alphabet))</span><br><span class="line">        output = torch.nn.functional.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = torch.argmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, numchar)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([alphabet[i] <span class="keyword">for</span> i <span class="keyword">in</span> output.cpu().detach().numpy()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_snap</span>(<span class="params">driver</span>):  <span class="comment"># 对目标网页进行截屏。这里截的是全屏</span></span><br><span class="line">    driver.save_screenshot(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    page_snap_obj=Image.<span class="built_in">open</span>(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> page_snap_obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">driver</span>): <span class="comment"># 对验证码所在位置进行定位，然后截取验证码图片</span></span><br><span class="line">    scaling_ratio=<span class="number">1</span><span class="comment">#系统显示的缩放比例</span></span><br><span class="line">    img = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;captcha-img&quot;]&#x27;</span>)<span class="comment">#获取验证码在网页中的位置信息</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)<span class="comment">#等待一会</span></span><br><span class="line">    location = img.location<span class="comment">#位置</span></span><br><span class="line">    size = img.size<span class="comment">#大小</span></span><br><span class="line">    left = location[<span class="string">&#x27;x&#x27;</span>]*scaling_ratio</span><br><span class="line">    top = location[<span class="string">&#x27;y&#x27;</span>]*scaling_ratio</span><br><span class="line">    right = left + size[<span class="string">&#x27;width&#x27;</span>]*scaling_ratio</span><br><span class="line">    bottom = top + size[<span class="string">&#x27;height&#x27;</span>]*scaling_ratio</span><br><span class="line">    page_snap_obj = get_snap(driver)<span class="comment">#获取整个页面截图</span></span><br><span class="line">    image_obj = page_snap_obj.crop((left, top, right, bottom))<span class="comment">#截下验证码</span></span><br><span class="line">    image_obj.save(<span class="string">&#x27;captcha.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下面是我们登录的主程序，注意这种方式要先下载对应于谷歌浏览器版本号的chromedriver.exe放到当前的目录下。</p>
<p>通过<code>send_keys()</code>方法填入用户名、密码、验证码；接着通过<code>click()</code>方法自动点击登录按钮即可，注意操作网页的过程一定要适当地等待加载（sleep）。</p>
<p>由于验证码可能识别错误，因此要循环判断是否成功登录，直到成功再停止。我的方法是判断当前页面的<strong>title</strong>是否发生了改变，这是一个比较简单方便的方式。</p>
<p>最后，由于一开始我们生成了两个截图，可以用<code>os.remove()</code>将其删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># login.py</span></span><br><span class="line"><span class="keyword">from</span> captcha <span class="keyword">import</span> decode_captcha <span class="keyword">as</span> decode_c</span><br><span class="line"><span class="keyword">from</span> captcha <span class="keyword">import</span> get_image</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用谷歌driver的基本操作</span></span><br><span class="line">options = Options()</span><br><span class="line">driver = webdriver.Chrome(options=options)<span class="comment">#调用当前路径下的chromedriver.exe</span></span><br><span class="line">driver.maximize_window()<span class="comment">#最大化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截图的保存地址</span></span><br><span class="line">captcha_path=<span class="string">&#x27;./captcha.png&#x27;</span></span><br><span class="line">snap_path=<span class="string">&#x27;./full_snap.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#两个地址链接</span></span><br><span class="line">url = <span class="string">&#x27;https://i.sjtu.edu.cn/jaccountlogin&#x27;</span></span><br><span class="line">url =<span class="string">&#x27;https://oc.sjtu.edu.cn/login/openid_connect&#x27;</span></span><br><span class="line"></span><br><span class="line">driver.get(url) <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line">cur_title=driver.title</span><br><span class="line"><span class="keyword">while</span>(driver.title==cur_title):<span class="comment">#失败则一直试，因为验证码可能错误，两次应该就能成功</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)  <span class="comment"># 加载等待</span></span><br><span class="line">    get_image(driver)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;推理验证码......&quot;</span>)</span><br><span class="line">    captcha_res=decode_c(captcha_path)</span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;user&#x27;</span>).send_keys(<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 填入用户名</span></span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;pass&#x27;</span>).send_keys(<span class="string">&#x27;password&#x27;</span>)  <span class="comment"># 填入密码</span></span><br><span class="line">    driver.find_element(By.NAME,<span class="string">&#x27;captcha&#x27;</span>).send_keys(captcha_res)  <span class="comment"># 填入验证码</span></span><br><span class="line">    driver.find_element(By.ID,<span class="string">&quot;submit-button&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">os.remove(captcha_path)</span><br><span class="line">os.remove(snap_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ending......&quot;</span>)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">477k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
