<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Re：从零开始的写博客生活">
<meta property="og:type" content="website">
<meta property="og:title" content="JySama">
<meta property="og:url" content="https://jysama.cn/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="Re：从零开始的写博客生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/11/26/udp_hole_punching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/26/udp_hole_punching/" class="post-title-link" itemprop="url">UDP hole punching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-26 18:18:15 / 修改时间：11:31:45" itemprop="dateCreated datePublished" datetime="2022-11-26T18:18:15+08:00">2022-11-26</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p> 使用udp打洞实现内网穿透</p>
</blockquote>
<p>做项目的时候发现需要进行udp打洞，这里进行简单的验证</p>
<p>因为是测试，代码就先写在一个cpp文件里了，最后再封装。</p>
<hr>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>公网环境：ubuntu 20.04 LTS，g++</p>
<p>本地环境：win10，vs2022，网络利用nattypetest测是cone类型。</p>
<ul>
<li>首先进行udp收发测试</li>
<li>初次尝试udp打洞失败，思考可能与NAT类型有关，因为校园网和手机热点都是对称型，难以穿透；而如果两台内网机器连同一个wifi的话，可能会因为NAT回环而被丢弃，但是又没有其他网络可以连，错误的可能很多，先尝试逆向连接。</li>
<li>进行<strong>逆向连接</strong>测试，成功。</li>
<li>进行<strong>NAT回环测试</strong>（客户端A、B在同一个内网下，A向NAT发往B的包被丢弃），成功，并修改服务器逻辑，当双方在一个NAT内时，发的是主机ip（私有ip）和绑定的端口（不是NAT中的端口）。</li>
<li>逆向连接成功后进行tcp连接，失败，与conntrack连接跟踪有关，可能被防火墙根据协议号阻拦了。</li>
<li>根据连接跟踪，使用tcp打洞打穿NAT和防火墙，实现tcp的逆向连接。</li>
<li>tcp的内网穿透失败，防火墙有诸多限制。</li>
<li><strong>udp打洞测试成功，成功内网穿透了两个NAT。</strong></li>
<li><strong>整理代码与封装，并有使用示例。</strong></li>
</ul>
<h1 id="简单的收发测试"><a href="#简单的收发测试" class="headerlink" title="简单的收发测试"></a>简单的收发测试</h1><p>Linux服务器端server.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>,port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//端口复用，在bind前设置</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;socketaddr,<span class="built_in">sizeof</span>(socketaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(gateway);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;gateway, <span class="number">0</span>, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(listenfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;gateway, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching receive error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        string ip = <span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(gateway.sin_addr));</span><br><span class="line">        string port = <span class="built_in">to_string</span>(<span class="built_in">ntohs</span>(gateway.sin_port));</span><br><span class="line">        <span class="comment">//区分client1和client2</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recvbuf,<span class="string">&quot;client1&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching client1 ip: %s, port: %s\n&quot;</span>,ip.<span class="built_in">c_str</span>(),port.<span class="built_in">c_str</span>());</span><br><span class="line">        	<span class="keyword">return</span> ip+<span class="string">&quot; &quot;</span>+port;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recvbuf,<span class="string">&quot;client2&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching client2 ip: %s, port: %s\n&quot;</span>,ip.<span class="built_in">c_str</span>(),port.<span class="built_in">c_str</span>());</span><br><span class="line">        	<span class="keyword">return</span> ip+<span class="string">&quot; &quot;</span>+port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> listenudp;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(listenudp , port);</span><br><span class="line">    string ip_port1 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    string ip_port2 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    <span class="keyword">if</span>(ip_port1 == <span class="string">&quot;&quot;</span> || ip_port2 == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port1.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip1 = ip_port1.<span class="built_in">substr</span>(<span class="number">0</span>,pos1);</span><br><span class="line">    string port1 = ip_port1.<span class="built_in">substr</span>(pos1+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr1;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr1.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr1.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port1));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip1.<span class="built_in">c_str</span>(), &amp;socketaddr1.sin_addr);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> pos2 = ip_port2.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip2 = ip_port2.<span class="built_in">substr</span>(<span class="number">0</span>,pos2);</span><br><span class="line">    string port2 = ip_port2.<span class="built_in">substr</span>(pos2+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr2;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr2.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr2.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port2));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip2.<span class="built_in">c_str</span>(), &amp;socketaddr2.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对着发，ipport1发给addr2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(listenudp, ip_port1.<span class="built_in">c_str</span>(), </span><br><span class="line">                     ip_port1.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr2, <span class="built_in">sizeof</span>(socketaddr2));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    res = <span class="built_in">sendto</span>(listenudp, ip_port2.<span class="built_in">c_str</span>(), </span><br><span class="line">                     ip_port2.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr1, <span class="built_in">sizeof</span>(socketaddr1));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>windows客户端client.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，</span></span><br><span class="line"><span class="comment">    recvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;client1&quot;</span>;<span class="comment">//client1或client2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">10000</span>;<span class="comment">//同一台机器的话要改一下</span></span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, port);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 1 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();<span class="comment">//阻塞</span></span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>云服务器里运行server.cpp</p>
<p>本机使用vs2022，先release一份exe文件，然后改端口和client1还是client2的信息，在debug模式再运行一个程序，就可以做到两台主机了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/upd%E6%94%B6%E5%8F%91%E6%B5%8B%E8%AF%95.png" alt="image-20221030221930721"></p>
<p>使用另一台电脑运行程序，绑定端口10000，另一台电脑连不同的网，结果如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/udp%E6%94%B6%E5%8F%91%E6%B5%8B%E8%AF%952.png" alt="image-20221030223259010"></p>
<hr>
<p>现在产生p2p发送，发送端添加如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getchar</span>();<span class="comment">//阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面向对方发信息</span></span><br><span class="line"><span class="comment">//定义sockaddr_in</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line"><span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closesocket</span>(udpfd);</span><br></pre></td></tr></table></figure>

<p>接收端把getchar去掉，添加如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client2接收信息</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line"><span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"><span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line"><span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv: %s&quot;</span>, recvbuf);</span><br><span class="line"><span class="built_in">getchar</span>();<span class="comment">//阻塞</span></span><br></pre></td></tr></table></figure>

<p>结果是发不过去，接收端没有收到一直在阻塞。这需要进一步去思考。可能是NAT类型问题，也可能是NAT回环问题（注：经后面测试，发现是NAT回环问题）</p>
<h1 id="逆向连接-Connection-reversal"><a href="#逆向连接-Connection-reversal" class="headerlink" title="逆向连接-Connection reversal"></a>逆向连接-Connection reversal</h1><p>这种方法在两个端点中有一个不存在中间件（如NAT）的时候有效。例如，Client A在NAT之后而Client B拥有全局IP地址，如图所示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%86%E5%90%91%E8%BF%9E%E6%8E%A5.png" alt="img"></p>
<p>Client A内网地址为10.0.0.1，使用TCP，端口为1234。A和Server S建立了一个连接，Server的IP地址为18.181.0.31，监听1235端口。NAT A给Client A分配了TCP端口62000，地址为NAT的公网IP地址155.99.25.11，作为Client A对外当前会话的临时IP和端口。因此Server S认为Client A就是155.99.25.11:62000。而Client B由于有公网地址，所以对Server S来说Client B就是138.76.29.7:1234。</p>
<p>当Client B想要主动发起对Client A的P2P连接时，需要指定目的地址及端口为155.99.25.11:62000。由于NAT工作的原理问题，NAT A会拒绝将收到的对Client A的请求转发给Client A。拒绝该请求主要有如下原因：</p>
<ol>
<li><p>NAT A没有映射过62000端口，NAT A不知道该请求是给谁的</p>
</li>
<li><p>NAT A映射过62000端口，但是需要首先从Client A发起请求，然后才能转发应答（限制锥形NAT的保护）</p>
</li>
</ol>
<p>在直接连接Client A失败之后，Client B可以通过Server S向Client A中继一个连接请求，从而从Client A方向“逆向“地建立起Client A- Client B之间的点对点连接（因为Client A连接到了Server S）。</p>
<p>很多当前的P2P系统都实现了这种技术，但其局限性也是很明显的，只有当其中一方有公网IP时连接才能建立。越来越多的情况下，通信的双方都在NAT之后，因此就要用到打洞技术了。</p>
<hr>
<p>现在我们假设公网服务器有一个clientB，本地主机clientA在内网里，我们的目标是实现B发送udp请求能连接到A。</p>
<ul>
<li>首先通过服务器分发对方的IP和port</li>
<li>然后clientA向clientB发送信息（正常情况下能收到），此时NAT A已经建立了NAT A-&gt;clientB的映射，表示信任B</li>
<li>现在B可以先A发送信息了，NAT A会转发到A</li>
</ul>
<p>注意B是否接收A的消息是无关紧要，为了验证，这里本地客户端B接收并打印出来。实际上不需要接收，A发的这个包只是告诉NAT A：“我要发的目的ip和端口是被我信任的，它可以发包给我，不要丢弃这个ip和端口发来的信息”。</p>
<p>先写一个在公网云服务器运行的clientB，先接收然后发送：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span>&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;client2&quot;</span>;<span class="comment">//client1或client2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> udpfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">22222</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, port);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(udpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 2 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();//阻塞</span></span><br><span class="line">    <span class="comment">//先接收A发送的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>,recvbuf);</span><br><span class="line">    <span class="comment">//发送消息，一直发</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地客户端如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，r</span></span><br><span class="line"><span class="comment">    ecvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;client1&quot;</span>;<span class="comment">//client1或client2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">22222</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, port);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 1 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下面向对方发信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello!!&quot;</span>;</span><br><span class="line">    res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">        <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">        res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">        <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">            <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, recvbuf);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>如图，公网clientB成功发送udp包到内网clientA</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%86%E5%90%91%E8%BF%9E%E6%8E%A52.png" alt="image-20221031125624691"></p>
<hr>
<p>现在，我们不让A发送给B，B也不阻塞接收，而是一直发送信息给A。</p>
<p>注意，必须等NAT A中的映射自然删除（大概几分钟的存活时间），没删除前B仍然可以直接发给A。</p>
<p>删除后，B就无法发送给A了，A一直在阻塞，因为B发送的消息给NAT A丢弃了，即保护了A。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%86%E5%90%91%E8%BF%9E%E6%8E%A53.png" alt="image-20221031130440814"></p>
<h1 id="NAT回环-环回"><a href="#NAT回环-环回" class="headerlink" title="NAT回环(环回)"></a>NAT回环(环回)</h1><p>现在我们处理同一个局域网的问题，有些NAT对同一个局域网的信息会丢弃，这时服务器根据ip判断是否是一个局域网，是的话把客户端本机的ip和port发送回去即可。</p>
<p>客户端：</p>
<p>下面是一个获取本机ip的函数，一般取最后一个即可，然后把ip和端口发给服务器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//获取主机名</span></span><br><span class="line">    <span class="comment">//根据主机名获取主机信息列表，有多个ip（网卡）</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//需要禁用c4996警报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;<span class="comment">//转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; addr &lt;&lt; endl;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送包：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>];<span class="comment">//取最后一个</span></span><br><span class="line">    string myip_port = myip +<span class="string">&quot; &quot;</span>+<span class="built_in">to_string</span>(myport);</span><br><span class="line">    <span class="comment">//现在发送信息是本机ip</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(),myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>服务器端：</p>
<p>服务器不再接收”client1”或”client2”，而是接收客户端本机的ip和port，接收后判断NAT的ip是否相同，如果相同就是同一个局域网。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(gateway);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;gateway, <span class="number">0</span>, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(listenfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;gateway, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching receive error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        string ip = <span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(gateway.sin_addr));</span><br><span class="line">        string port = <span class="built_in">to_string</span>(<span class="built_in">ntohs</span>(gateway.sin_port));</span><br><span class="line">        </span><br><span class="line">        string host = <span class="built_in">string</span>(recvbuf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching  NAT ip: %s, port: %s; host:%s\n&quot;</span>,ip.<span class="built_in">c_str</span>(),port.<span class="built_in">c_str</span>(),host.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ip+<span class="string">&quot; &quot;</span>+port+<span class="string">&quot; &quot;</span>+host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于有空格分隔，这里用个解析函数解析两个ip-port</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">parse</span><span class="params">(string str)</span><span class="comment">//解析函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str = str + <span class="string">&quot; &quot;</span>;<span class="comment">//最后补个空格</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pos1;</span><br><span class="line">    <span class="keyword">while</span> ((pos1 = str.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(pos, pos1 - pos));</span><br><span class="line">        <span class="keyword">while</span> (str[pos1] == <span class="string">&#x27; &#x27;</span>)<span class="comment">//过滤空格</span></span><br><span class="line">            pos1++;</span><br><span class="line">        pos = pos1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//返回值是右值，外部vector会接收右值，调用移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在main里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">string ip_port1 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">string ip_port2 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line"><span class="keyword">if</span>(ip_port1 == <span class="string">&quot;&quot;</span> || ip_port2 == <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; host1 = <span class="built_in">parse</span>(ip_port1);</span><br><span class="line">vector&lt;string&gt; host2 = <span class="built_in">parse</span>(ip_port2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器发回去的还是使用NAT ip</span></span><br><span class="line">string ip1 = host1[<span class="number">0</span>];</span><br><span class="line">string port1 = host1[<span class="number">1</span>];</span><br><span class="line">string ip2 = host2[<span class="number">0</span>];</span><br><span class="line">string port2 = host2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义sockaddr_in</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr1;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">socketaddr1.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">socketaddr1.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port1));<span class="comment">//字节序转换</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip1.<span class="built_in">c_str</span>(), &amp;socketaddr1.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义sockaddr_in</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr2;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">socketaddr2.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">socketaddr2.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port2));<span class="comment">//字节序转换</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, ip2.<span class="built_in">c_str</span>(), &amp;socketaddr2.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是发送的数据不一样了</span></span><br><span class="line"><span class="comment">//对着发，ipport1发给addr2</span></span><br><span class="line"><span class="keyword">if</span>(ip1 != ip2)<span class="comment">//不同的内网</span></span><br><span class="line">&#123;</span><br><span class="line">    ip_port1 = ip1 + <span class="string">&quot; &quot;</span> + port1;</span><br><span class="line">    ip_port2 = ip2 + <span class="string">&quot; &quot;</span> + port2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//在同一个NAT里</span></span><br><span class="line">&#123;</span><br><span class="line">    ip_port1 = host1[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host1[<span class="number">3</span>];</span><br><span class="line">    ip_port2 = host2[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host2[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">sendto</span>(listenudp, ip_port1.<span class="built_in">c_str</span>(), </span><br><span class="line">              ip_port1.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr2, <span class="built_in">sizeof</span>(socketaddr2));</span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">sendto</span>(listenudp, ip_port2.<span class="built_in">c_str</span>(), </span><br><span class="line">                 ip_port2.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr1, <span class="built_in">sizeof</span>(socketaddr1));</span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p>在主机上跑两个程序，像逆向连接一样，A先B发送一个包，然后B就可以一直向A发包了。</p>
<p>当然这里服务器判断两个主机都在内网里，所以返回它们本地的ip和各自绑定的端口（这个端口不是NAT映射中的端口），此时这两个主机能互相发包。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/NAT%E5%9B%9E%E7%8E%AF.png" alt="image-20221031150918382"></p>
<p>下面修改服务器代码，不管怎么样都返回NAT的ip和port，这时客户端A发给NAT发现目标就是自己内网里的机器，就直接丢弃了，因此B不会收到A的hello!</p>
<p>这个例子就说明了有些NAT不支持回环。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/NAT%E5%9B%9E%E7%8E%AF3.png" alt="image-20221031151655791"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整的源码再放一下：</p>
<p>服务器端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>,port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//端口复用，在bind前设置，否则bind时出错就晚了</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;socketaddr,<span class="built_in">sizeof</span>(socketaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//完事了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(gateway);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;gateway, <span class="number">0</span>, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(listenfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;gateway, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching receive error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        string ip = <span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(gateway.sin_addr));</span><br><span class="line">        string port = <span class="built_in">to_string</span>(<span class="built_in">ntohs</span>(gateway.sin_port));</span><br><span class="line">        </span><br><span class="line">        string host = <span class="built_in">string</span>(recvbuf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching  NAT ip: %s, port: %s; host:%s\n&quot;</span>,ip.<span class="built_in">c_str</span>(),port.<span class="built_in">c_str</span>(),host.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ip+<span class="string">&quot; &quot;</span>+port+<span class="string">&quot; &quot;</span>+host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">parse</span><span class="params">(string str)</span><span class="comment">//解析函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str = str + <span class="string">&quot; &quot;</span>;<span class="comment">//最后补个空格</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pos1;</span><br><span class="line">    <span class="keyword">while</span> ((pos1 = str.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(pos, pos1 - pos));</span><br><span class="line">        <span class="keyword">while</span> (str[pos1] == <span class="string">&#x27; &#x27;</span>)<span class="comment">//过滤空格</span></span><br><span class="line">            pos1++;</span><br><span class="line">        pos = pos1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//返回值是右值，外部vector会接收右值，调用移动构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> listenudp;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(listenudp , port);</span><br><span class="line">    string ip_port1 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    string ip_port2 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    <span class="keyword">if</span>(ip_port1 == <span class="string">&quot;&quot;</span> || ip_port2 == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; host1 = <span class="built_in">parse</span>(ip_port1);</span><br><span class="line">    vector&lt;string&gt; host2 = <span class="built_in">parse</span>(ip_port2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器发回去的还是使用NAT ip</span></span><br><span class="line">    string ip1 = host1[<span class="number">0</span>];</span><br><span class="line">    string port1 = host1[<span class="number">1</span>];</span><br><span class="line">    string ip2 = host2[<span class="number">0</span>];</span><br><span class="line">    string port2 = host2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr1;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr1.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr1.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port1));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip1.<span class="built_in">c_str</span>(), &amp;socketaddr1.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr2;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr2.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr2.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port2));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip2.<span class="built_in">c_str</span>(), &amp;socketaddr2.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是发送的数据不一样了</span></span><br><span class="line">    <span class="comment">//对着发，ipport1发给addr2</span></span><br><span class="line">    <span class="keyword">if</span>(ip1 != ip2)<span class="comment">//不同的内网</span></span><br><span class="line">    &#123;</span><br><span class="line">        ip_port1 = ip1 + <span class="string">&quot; &quot;</span> + port1;</span><br><span class="line">        ip_port2 = ip2 + <span class="string">&quot; &quot;</span> + port2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//在同一个NAT里</span></span><br><span class="line">    &#123;</span><br><span class="line">        ip_port1 = host1[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host1[<span class="number">3</span>];</span><br><span class="line">        ip_port2 = host2[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host2[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(listenudp, ip_port1.<span class="built_in">c_str</span>(), </span><br><span class="line">                  ip_port1.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr2, <span class="built_in">sizeof</span>(socketaddr2));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">sendto</span>(listenudp, ip_port2.<span class="built_in">c_str</span>(), </span><br><span class="line">                     ip_port2.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr1, <span class="built_in">sizeof</span>(socketaddr1));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> myport = <span class="number">22222</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，r</span></span><br><span class="line"><span class="comment">    ecvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//获取主机名</span></span><br><span class="line">    <span class="comment">//根据主机名获取主机信息列表，有多个ip（网卡）</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//需要禁用c4996警报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;<span class="comment">//转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; addr &lt;&lt; endl;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>];<span class="comment">//取最后一个</span></span><br><span class="line">    string myip_port = myip +<span class="string">&quot; &quot;</span>+<span class="built_in">to_string</span>(myport);</span><br><span class="line">    <span class="comment">//现在发送信息是本机ip</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(),myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line">    </span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, myport);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 1 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下面向对方发信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello!!&quot;</span>;</span><br><span class="line">    res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">        <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">        res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">        <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">            <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">            <span class="built_in">WSACleanup</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, recvbuf);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端2，相对于客户端1只修改了绑定的port和接收发送的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> myport = <span class="number">11111</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，r</span></span><br><span class="line"><span class="comment">    ecvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//获取主机名</span></span><br><span class="line">    <span class="comment">//根据主机名获取主机信息列表，有多个ip（网卡）</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//需要禁用c4996警报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;<span class="comment">//转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; addr &lt;&lt; endl;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>];<span class="comment">//取最后一个</span></span><br><span class="line">    string myip_port = myip + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(myport);</span><br><span class="line">    <span class="comment">//现在发送信息是本机ip</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(), myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line"></span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, myport);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 2 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息，一直发</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="逆向连接后进行tcp连接"><a href="#逆向连接后进行tcp连接" class="headerlink" title="逆向连接后进行tcp连接"></a>逆向连接后进行tcp连接</h1><p>因为还没有找到合适的网络来测试udp的内网穿透（大多都是校园网，对称型无法处理），所以先等几天，然后开始测试如何逆向连接后，进行p2p的tcp连接。</p>
<p>目前的想法是，当逆向连接完成后，将原来的udp套接字关闭，创建tcp套接字，然后绑定相同的端口（因为NAT记录的端口）。</p>
<ul>
<li>首先公网客户端接收内网客户端的udp信息，逆向连接完成（可以不接收，内网客户端发送即可，为了验证这里还是接收）</li>
<li>公网客户端发个udp给内网客户端，作为验证</li>
<li>接着两个客户端创建tcp套接字并且都绑定原来的端口（udp套接字可以不关闭，tcp和udp可以共用端口，所以可同时初始化）</li>
<li>内网客户端进入listen状态，阻塞在accept</li>
<li>公网客户端connect内网客户端，tcp连接建立</li>
</ul>
<hr>
<p>公网客户端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span>&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;client2&quot;</span>;<span class="comment">//client1或client2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_tcp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//初始化一个端口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> udpfd;</span><br><span class="line">    <span class="type">int</span> tcpfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">22222</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, port);</span><br><span class="line">    <span class="built_in">init_tcp_Socket</span>(tcpfd,port);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(udpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 2 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();//阻塞</span></span><br><span class="line">    <span class="comment">//先接收A发送的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>,recvbuf);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect fail !\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;connect to server successfully!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(tcpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(udpfd);</span><br><span class="line">    <span class="built_in">close</span>(tcpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内网客户端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> myport = <span class="number">22222</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，r</span></span><br><span class="line"><span class="comment">    ecvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//获取主机名</span></span><br><span class="line">    <span class="comment">//根据主机名获取主机信息列表，有多个ip（网卡）</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//需要禁用c4996警报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;<span class="comment">//转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; addr &lt;&lt; endl;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>];<span class="comment">//取最后一个</span></span><br><span class="line">    string myip_port = myip + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(myport);</span><br><span class="line">    <span class="comment">//现在发送信息是本机ip</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(), myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_tcp_Socket</span><span class="params">(SOCKET&amp; tcpfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    tcpfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲.</span></span><br><span class="line">        <span class="comment">//也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(tcpfd, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line"></span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    SOCKET tcpfd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, myport);</span><br><span class="line">    <span class="built_in">init_tcp_Socket</span>(tcpfd, myport);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv from server...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 1 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面向对方发信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello!!&quot;</span>;</span><br><span class="line">    res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, recvbuf);</span><br><span class="line">    <span class="comment">//准备接收连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///客户端套接字</span></span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;<span class="comment">//获取客户的地址和端口号，连接后的不分配新端口</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);<span class="comment">//socklen_t 相当于 int，但使用int必须强制转型告知编译器</span></span><br><span class="line">    SOCKET conn = <span class="built_in">accept</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<span class="comment">//阻塞，等待连接，成功则创建连接套接字conn描述这个用户</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">closesocket</span>(tcpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nRecv = <span class="built_in">recv</span>(conn, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRecv == SOCKET_ERROR)<span class="comment">//copy出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connection to client has been failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">closesocket</span>(tcpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, recvbuf);</span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">closesocket</span>(tcpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><p>连接失败，双方阻塞在connect和accept处，connect的syn包根本到达不了内网机器（反向测试：内网可以connect外网）。为什么udp可以而tcp就不可以了呢？这两个协议的差异就是，我们在发udp之前，先用内网向外网发了udp；而tcp包是直接从外网发到内网的，这可能导致了问题。</p>
<h1 id="连接跟踪"><a href="#连接跟踪" class="headerlink" title="连接跟踪"></a>连接跟踪</h1><p>tcp连接失败也许是因为<strong>conntrack（连接跟踪）</strong>，在防火墙、内核（linux）中会跟踪连接，这个连接不是专门指tcp连接。连接跟踪可以让Netfilter（框架）知道某个特定连接的状态，运行连接跟踪的防火墙称作带有状态机制的防火墙，这种防火墙更安全。连接跟踪的信息一般是五元组，当然针对不同协议和特殊修改也有四元组和七元组：</p>
<ul>
<li>四元组：源IP地址、目的IP地址、源端口、目的端口</li>
<li>五元组：源IP地址、目的IP地址、<strong>协议号</strong>、源端口、目的端口</li>
<li>七元组：源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引</li>
</ul>
<p>可以看到，五元组中不仅有ip、端口，还有协议号这一内容，这标识了是tcp还是udp等等。在各种过滤机制下，连接跟踪会发挥作用。</p>
<p>当然我们的内网客户端是Windows下的，Windows下的防火墙是如何写的并不能知道（没开源），但我们可以大概看一下防火墙高级设置：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/Windows%E9%98%B2%E7%81%AB%E5%A2%99.png" alt="image-20221101084903251"></p>
<p>在入站规则中，可以看到除了地址端口，还有协议。借助连接跟踪的想法，我们猜测：</p>
<ul>
<li>假如通过udp打洞后，NAT不检测协议，而允许把tcp包转发到主机上，那么主机的防火墙就会把包丢弃。</li>
<li>因为NAT是基于地址端口的，从<strong>理论上</strong>说端口限制锥形只要报文源、目的地址端口匹配即可；但也只是理论，<strong>不排除NAT也会把tcp拦下来</strong>。</li>
</ul>
<p>因此可以得出简单的结论：内网穿透时，使用udp打洞后只能打出一条udp的隧道；要打出tcp隧道，就要让某个内网客户端先发tcp的包。也就是说：<strong>在基于NAT的情况下，内网穿透只要打穿地址和端口；而在基于防火墙的情况下，内网穿透还要打穿特定协议的隧道</strong>。</p>
<hr>
<h2 id="TCP打洞"><a href="#TCP打洞" class="headerlink" title="TCP打洞"></a>TCP打洞</h2><p>我们可以重新设计：</p>
<ul>
<li>首先服务器通知双方端口和ip</li>
<li>不进行udp打洞，直接发tcp包。这里的实现是：<strong>双方同时进行connect</strong>，利用connect在内核的重传机制（syn是会重传的），第一个tcp包会给对方NAT丢掉（因为没有udp打洞），因为有重传机制不会马上就返回错误。然后对方能进行connect过来（本地防火墙和NAT都允许入站了），本地发现在connect也就建立连接了。同时进行connect建立tcp连接可以参考我为此研究后写的博客：<a href="https://jysama.cn/2022/11/01/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80/">TCP同时打开-深度剖析 | JySama</a></li>
</ul>
<p>这里面：</p>
<ul>
<li><strong>服务器通知双方的NAT地址和端口是必要的</strong>，否则对方根本不知道网关的地址；其次，如果不通知端口，对方只能请求到预设端口，但是NAT中端口映射不一定相同，会给NAT丢弃</li>
<li><strong>udp、tcp套接字绑定端口也是必要的</strong>，这主要是为了<strong>udp和tcp端口同步</strong>。因为<ul>
<li>回环时，服务器发回去的是客户端通告的“我要绑定的端口”，然后双方根据这个通告的端口要连接。</li>
<li>没有回环时，使用的是NAT的端口，这只需要让udp套接字（与服务器交互）和tcp套接字（p2p交互）绑定在一个端口上即可，因为服务器发回的是NAT是建立了udp的端口，如果tcp套接字使用了不同的端口，那么在NAT上就重新建立了一条映射，这时请求udp端口的tcp连接肯定失败了，因为tcp的syn经过服务器发的端口到了udp的套接字。</li>
</ul>
</li>
<li>如果udp和tcp不绑定端口的话，当使用udp时，内核分配一个端口；使用tcp时connect时，又分配一个端口，可能就导致端口不一致了。</li>
</ul>
<p><strong>关于connect的建立机制，而不用listen-accept，这个还需要更详细地研究。</strong>（注：已研究透彻，为此写了一篇博客：<a href="https://jysama.cn/2022/11/01/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80/">TCP同时打开-深度剖析 | JySama</a>）</p>
<blockquote>
<ul>
<li>目前是1对1传输文件，不涉及1对多的p2p，互相connect即可。</li>
<li>如果是1对多，那么tcp的一个端口要connect多个对端，只用设置端口可重用即可<code>SO_REUSEADDR</code>，将多个套接字绑定到一个端口。这里不做研究</li>
</ul>
</blockquote>
<p>外网客户端：取消了udp打洞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span>&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;client2&quot;</span>;<span class="comment">//client1或client2</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_tcp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//初始化一个端口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> udpfd;</span><br><span class="line">    <span class="type">int</span> tcpfd;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">22222</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, port);</span><br><span class="line">    <span class="built_in">init_tcp_Socket</span>(tcpfd,port);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(udpfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 2 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();//阻塞</span></span><br><span class="line">    <span class="comment">//先接收A发送的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    <span class="comment">//res = recvfrom(udpfd, recvbuf, 128, 0, (struct sockaddr*)&amp;server, &amp;addr_len);</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;recv: %s\n&quot;,recvbuf);</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//res = sendto(udpfd, sendbuf, strlen(sendbuf), 0, (struct sockaddr*)&amp;gateway, sizeof(gateway));</span></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;send...\n&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect fail !\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;connect to server successfully!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send</span>(tcpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(udpfd);</span><br><span class="line">    <span class="built_in">close</span>(tcpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内网客户端：取消了udp打洞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton，inet_ntop（获取ip）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)<span class="comment">//链接dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;101.34.2.129&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> udpPORT3 = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> myport = <span class="number">22222</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//windows下有bug</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在 Windows 中，如果主机 A 使用 UDP 套接字并调用 sendto() 向主机 B 发送内容，</span></span><br><span class="line"><span class="comment">    但 B 没有绑定(bind)任何端口，因此 B 不会收到消息，并且然后宿主A调用recvfrom()接收一些消息，r</span></span><br><span class="line"><span class="comment">    ecvfrom()会失败，WSAGetLastError()会返回10054。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这是 Windows 的错误。如果UDP socket在发送消息后recv一个ICMP(port unreachable)消息，</span></span><br><span class="line"><span class="comment">    这个错误会被存储，下次调用recvfrom()会返回这个错误。</span></span><br><span class="line"><span class="comment">    可以使用下面代码禁用错误</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//获取主机名</span></span><br><span class="line">    <span class="comment">//根据主机名获取主机信息列表，有多个ip（网卡）</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//需要禁用c4996警报</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;<span class="comment">//转型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; addr &lt;&lt; endl;</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udp_hole_punching</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> port)</span><span class="comment">//向服务器发送udp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据，最后的len不用传地址，因为是告知，不用修改</span></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>];<span class="comment">//取最后一个</span></span><br><span class="line">    string myip_port = myip + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(myport);</span><br><span class="line">    <span class="comment">//现在发送信息是本机ip</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(), myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_tcp_Socket</span><span class="params">(SOCKET&amp; tcpfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    tcpfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲.</span></span><br><span class="line">        <span class="comment">//也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line"></span><br><span class="line">    SOCKET udpfd;</span><br><span class="line">    SOCKET tcpfd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(udpfd, myport);</span><br><span class="line">    <span class="built_in">init_tcp_Socket</span>(tcpfd, myport);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udp_hole_punching</span>(udpfd, SERVER_IP, udpPORT3))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发完就接收信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;<span class="comment">//表示网关</span></span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv from server...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string ip = ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string portx = ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client 1 recv: ip: %s, port: %s\n&quot;</span>, ip.<span class="built_in">c_str</span>(), portx.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面向对方发信息</span></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;<span class="comment">//告知要发送的目标ip及端口</span></span><br><span class="line">    gateway.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(portx));<span class="comment">//字节序转换</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip.<span class="built_in">c_str</span>(), &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello!!&quot;</span>;</span><br><span class="line">    <span class="comment">//res = sendto(udpfd, sendbuf, strlen(sendbuf), 0, (struct sockaddr*)&amp;gateway, sizeof(gateway));</span></span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;send...\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    <span class="comment">//len要传地址，因为要保存写入结构体的长度</span></span><br><span class="line">    <span class="comment">//res = recvfrom(udpfd, recvbuf, 128, 0, (struct sockaddr*)&amp;server, &amp;addr_len);</span></span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;recv: %s\n&quot;, recvbuf);</span></span><br><span class="line">    <span class="comment">//准备接收连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(tcpfd, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway)) == <span class="number">-1</span>)<span class="comment">//先发个tcp连接包</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect fail !\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">    <span class="comment">//if (listen(tcpfd, SOMAXCONN) == -1)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">     <span class="comment">//   printf(&quot;listen error %d!\n&quot;, WSAGetLastError());</span></span><br><span class="line">     <span class="comment">//   return 0;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">///客户端套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct sockaddr_in client_addr;//获取客户的地址和端口号，连接后的不分配新端口</span></span><br><span class="line"><span class="comment">    socklen_t len = sizeof(client_addr);//socklen_t 相当于 int，但使用int必须强制转型告知编译器</span></span><br><span class="line"><span class="comment">    SOCKET conn = accept(tcpfd, (struct sockaddr*)&amp;client_addr, &amp;len);//阻塞，等待连接，成功则创建连接套接字conn描述这个用户</span></span><br><span class="line"><span class="comment">    if (conn == -1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        std::cerr &lt;&lt; &quot;connect error&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">        closesocket(tcpfd);</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">    <span class="type">int</span> nRecv = <span class="built_in">recv</span>(tcpfd, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRecv == SOCKET_ERROR)<span class="comment">//copy出错</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connection to client has been failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">        <span class="built_in">closesocket</span>(tcpfd);</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, recvbuf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">    <span class="built_in">closesocket</span>(tcpfd);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有udp打洞的tcp连接：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%80%86%E5%90%91%E8%BF%9E%E6%8E%A5tcp%E8%BF%9E%E6%8E%A5.png" alt="image-20221101000011682"></p>
<p>无udp打洞的tcp连接：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%97%A0udp%E6%89%93%E6%B4%9Etcp%E8%BF%9E%E6%8E%A5.png" alt="image-20221101091010430"></p>
<h1 id="补充：已利用udp打洞成功穿透两个NAT"><a href="#补充：已利用udp打洞成功穿透两个NAT" class="headerlink" title="补充：已利用udp打洞成功穿透两个NAT"></a>补充：已利用udp打洞成功穿透两个NAT</h1><p>代码用NAT回环的代码即可。对方是另一个大学的寝室网络，接了路由器不是校园网，所以是圆锥型的NAT，可以成功。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/udp%E6%88%90%E5%8A%9F%E6%89%93%E6%B4%9E.png" alt="image-20221105114055816"></p>
<h1 id="代码整理（封装）"><a href="#代码整理（封装）" class="headerlink" title="代码整理（封装）"></a>代码整理（封装）</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>头文件<code>udp_hole_punch.h</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> UDP_HOLE_PUNCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UDP_HOLE_PUNCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Using UDP requires disabling errors</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIO_UDP_CONNRESET _WSAIOW(IOC_VENDOR, 12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span>; <span class="comment">//init WSA</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initUdpSocket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span>; <span class="comment">//init blocking socket</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span>; <span class="comment">//get host private ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//send udp segment to server</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">notifyServer</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort, <span class="type">const</span> <span class="type">int</span> myPort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//send one or more messages to the other party(punch a hole)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udpHolePunch</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* gateway_ip, <span class="type">const</span> <span class="type">int</span> gatewayPort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//active, receiver</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udpPunchSide</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort , <span class="type">const</span> <span class="type">int</span> myPort)</span></span>;</span><br><span class="line"><span class="comment">//passive, sender, return gateway ip and port</span></span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">udpPunchedSide</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort, <span class="type">const</span> <span class="type">int</span> myPort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp_hole_punch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//init WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//blocking socket</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initUdpSocket</span><span class="params">(SOCKET&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP); <span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind port</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind port-%d error !\n&quot;</span>, port);</span><br><span class="line">        <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Using UDP requires disabling errors</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If sending a datagram using the sendto function results in an &quot;ICMP port unreachable&quot; response and the select function is set for readfds,</span></span><br><span class="line"><span class="comment">    * the program returns 1 and the subsequent call to the recvfrom function does not work with a WSAECONNRESET (10054) error response.</span></span><br><span class="line"><span class="comment">    * In Microsoft Windows NT 4.0, this situation causes the select function to block or time out.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BOOL bEnalbeConnRestError = FALSE;</span><br><span class="line">    DWORD dwBytesReturned = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">WSAIoctl</span>(listenfd, SIO_UDP_CONNRESET, &amp;bEnalbeConnRestError, <span class="built_in">sizeof</span>(bEnalbeConnRestError), \</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwBytesReturned, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getIpList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> getNameRet = <span class="built_in">gethostname</span>(name, <span class="built_in">sizeof</span>(name));<span class="comment">//get host name</span></span><br><span class="line">    <span class="comment">//get private ip list</span></span><br><span class="line">    hostent* host = <span class="built_in">gethostbyname</span>(name);<span class="comment">//need to disable c4996 error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == host)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_addr* pAddr = (in_addr*)*host-&gt;h_addr_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; host-&gt;h_addr_list[i] != <span class="number">0</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> ip[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inet_ntop</span>(AF_INET, &amp;pAddr[i], ip, <span class="number">16</span>);</span><br><span class="line">        string addr = ip;</span><br><span class="line">        result.<span class="built_in">push_back</span>(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//send udp segment to server</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">notifyServer</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort , <span class="type">const</span> <span class="type">int</span> myPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(serverPort);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;socketaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; myipList = <span class="built_in">getIpList</span>();</span><br><span class="line">    string myip = myipList[myipList.<span class="built_in">size</span>() - <span class="number">1</span>]; <span class="comment">//send the last one </span></span><br><span class="line">    string myip_port = myip + <span class="string">&quot; &quot;</span> + <span class="built_in">to_string</span>(myPort);</span><br><span class="line">    <span class="comment">//send the private ip</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="built_in">sendto</span>(udpfd, myip_port.<span class="built_in">c_str</span>(), myip_port.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//send one or more messages to the other party(punch a hole)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udpHolePunch</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* gateway_ip, <span class="type">const</span> <span class="type">int</span> gatewayPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;</span><br><span class="line">    gateway.sin_family = AF_INET;</span><br><span class="line">    gateway.sin_port = <span class="built_in">htons</span>(gatewayPort);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, gateway_ip, &amp;gateway.sin_addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">10</span>] = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">    <span class="comment">//send two messages</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error1!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">sendto</span>(udpfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;gateway, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error2!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">udpPunchSide</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort, <span class="type">const</span> <span class="type">int</span> myPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initUdpSocket</span>(udpfd, myPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//send message to server</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">notifyServer</span>(udpfd, server_ip, serverPort, myPort))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//recvfrom server</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv from server error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string gateway_ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = gateway_ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string gateway_ip = gateway_ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string gateway_port = gateway_ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client recv: ip: %s, port: %s\n&quot;</span>, gateway_ip.<span class="built_in">c_str</span>(), gateway_port.<span class="built_in">c_str</span>()); <span class="comment">//debug</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">udpHolePunch</span>(udpfd, gateway_ip.<span class="built_in">c_str</span>(), <span class="built_in">stoi</span>(gateway_port)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punch error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">udpPunchedSide</span><span class="params">(SOCKET&amp; udpfd, <span class="type">const</span> <span class="type">char</span>* server_ip, <span class="type">const</span> <span class="type">int</span> serverPort, <span class="type">const</span> <span class="type">int</span> myPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">initUdpSocket</span>(udpfd, myPort);</span><br><span class="line">    pair&lt;string, <span class="type">int</span>&gt; pairRes;</span><br><span class="line">    pairRes.first = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    pairRes.second = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//send message to server</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">notifyServer</span>(udpfd, server_ip, serverPort, myPort))</span><br><span class="line">        <span class="keyword">return</span> pairRes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//recvfrom server</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(server);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> res = <span class="built_in">recvfrom</span>(udpfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (res == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv from server error %d!\n&quot;</span>, <span class="built_in">WSAGetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> pairRes;</span><br><span class="line">    &#125;</span><br><span class="line">    string gateway_ip_port = recvbuf;</span><br><span class="line">    <span class="type">size_t</span> pos1 = gateway_ip_port.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    string gateway_ip = gateway_ip_port.<span class="built_in">substr</span>(<span class="number">0</span>, pos1);</span><br><span class="line">    string gateway_port = gateway_ip_port.<span class="built_in">substr</span>(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client recv: ip: %s, port: %s\n&quot;</span>, gateway_ip.<span class="built_in">c_str</span>(), gateway_port.<span class="built_in">c_str</span>()); <span class="comment">//debug</span></span><br><span class="line">    pairRes.first = gateway_ip;</span><br><span class="line">    pairRes.second = <span class="built_in">stoi</span>(gateway_port);</span><br><span class="line">    <span class="keyword">return</span> pairRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端调用示例"><a href="#客户端调用示例" class="headerlink" title="客户端调用示例"></a>客户端调用示例</h2><p>main函数调用，接收方主动打洞，发送方不打洞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp_hole_punch.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;a.b.c.d&quot;</span>; <span class="comment">//your server</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SERVERUDPPORT = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MYPORT = <span class="number">22222</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SOCKET udpfd;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">udpPunchSide</span>(udpfd, SERVER_IP, SERVERUDPPORT, MYPORT))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//do other thing...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//end</span></span><br><span class="line">	<span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp_hole_punch.h&quot;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;a.b.c.d&quot;</span>; <span class="comment">//your server</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SERVERUDPPORT = <span class="number">10000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MYPORT = <span class="number">22222</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SOCKET udpfd;</span><br><span class="line">	pair&lt;string, <span class="type">int</span>&gt; gateway = <span class="built_in">udpPunchedSide</span>(udpfd, SERVER_IP, SERVERUDPPORT, MYPORT);</span><br><span class="line">	<span class="keyword">if</span> (gateway.first == <span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* gateway_ip = gateway.first.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> gateway_port = gateway.second;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//do other thing...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//end</span></span><br><span class="line">	<span class="built_in">closesocket</span>(udpfd);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_udp_Socket</span><span class="params">(<span class="type">int</span>&amp; listenfd, <span class="type">const</span> <span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_DGRAM,IPPROTO_UDP);<span class="comment">//UDP</span></span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create listen socket error, port-%d\n&quot;</span>,port);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Port reused</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;socketaddr,<span class="built_in">sizeof</span>(socketaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">udp_hole_punching</span><span class="params">(<span class="type">int</span> listenfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> gateway;</span><br><span class="line">    <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(gateway);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;gateway, <span class="number">0</span>, <span class="built_in">sizeof</span>(gateway));</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recvfrom</span>(listenfd, recvbuf, <span class="number">128</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;gateway, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching receive error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        string ip = <span class="built_in">string</span>(<span class="built_in">inet_ntoa</span>(gateway.sin_addr));</span><br><span class="line">        string port = <span class="built_in">to_string</span>(<span class="built_in">ntohs</span>(gateway.sin_port));</span><br><span class="line">        </span><br><span class="line">        string host = <span class="built_in">string</span>(recvbuf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp hole punching  NAT ip: %s, port: %s; host:%s\n&quot;</span>,ip.<span class="built_in">c_str</span>(),port.<span class="built_in">c_str</span>(),host.<span class="built_in">c_str</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ip+<span class="string">&quot; &quot;</span>+port+<span class="string">&quot; &quot;</span>+host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">parse</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str = str + <span class="string">&quot; &quot;</span>;<span class="comment">//add a space</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> pos1;</span><br><span class="line">    <span class="keyword">while</span> ((pos1 = str.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(pos, pos1 - pos));</span><br><span class="line">        <span class="keyword">while</span> (str[pos1] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            pos1++;</span><br><span class="line">        pos = pos1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//move rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> listenudp;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">init_udp_Socket</span>(listenudp , port);</span><br><span class="line">    string ip_port1 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    string ip_port2 = <span class="built_in">udp_hole_punching</span>(listenudp);</span><br><span class="line">    <span class="keyword">if</span>(ip_port1 == <span class="string">&quot;&quot;</span> || ip_port2 == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; host1 = <span class="built_in">parse</span>(ip_port1);</span><br><span class="line">    vector&lt;string&gt; host2 = <span class="built_in">parse</span>(ip_port2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The server sends back using a NAT ip</span></span><br><span class="line">    string ip1 = host1[<span class="number">0</span>];</span><br><span class="line">    string port1 = host1[<span class="number">1</span>];</span><br><span class="line">    string ip2 = host2[<span class="number">0</span>];</span><br><span class="line">    string port2 = host2[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr1;</span><br><span class="line">    socketaddr1.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr1.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port1));</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip1.<span class="built_in">c_str</span>(), &amp;socketaddr1.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr2;</span><br><span class="line">    socketaddr2.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr2.sin_port = <span class="built_in">htons</span>(<span class="built_in">stoi</span>(port2));</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip2.<span class="built_in">c_str</span>(), &amp;socketaddr2.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ip1 != ip2) <span class="comment">//Different intranets</span></span><br><span class="line">    &#123;</span><br><span class="line">        ip_port1 = ip1 + <span class="string">&quot; &quot;</span> + port1;</span><br><span class="line">        ip_port2 = ip2 + <span class="string">&quot; &quot;</span> + port2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//In the same NAT</span></span><br><span class="line">    &#123;</span><br><span class="line">        ip_port1 = host1[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host1[<span class="number">3</span>];</span><br><span class="line">        ip_port2 = host2[<span class="number">2</span>] + <span class="string">&quot; &quot;</span> + host2[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">sendto</span>(listenudp, ip_port1.<span class="built_in">c_str</span>(), </span><br><span class="line">                  ip_port1.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr2, <span class="built_in">sizeof</span>(socketaddr2));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = <span class="built_in">sendto</span>(listenudp, ip_port2.<span class="built_in">c_str</span>(), </span><br><span class="line">                     ip_port2.<span class="built_in">size</span>(), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr1, <span class="built_in">sizeof</span>(socketaddr1));</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;udp sendto error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/11/01/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/01/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80/" class="post-title-link" itemprop="url">TCP同时打开-深度剖析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-11-01 21:14:05 / 修改时间：23:09:56" itemprop="dateCreated datePublished" datetime="2022-11-01T21:14:05+08:00">2022-11-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在socket的编程中偶然发现了两端同时connect可以不经过listen-accept而建立tcp连接，然后去找了许多资料，发现这个现象叫<code>同时打开</code>，下面就来具体研究这个连接的建立情况。</p>
<p><strong>同时打开需要去连接对方的端口，因此客户在connect之前需要bind一个端口。</strong></p>
<p>参考资料：</p>
<ul>
<li>1）<a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/80518481">(33条消息) 关于TCP同时打开-无需Listener的TCP连接建立过程_dog250的博客-CSDN博客</a></li>
<li>2）<a target="_blank" rel="noopener" href="http://t.zoukankan.com/wanpengcoder-p-11751246.html">TCP连接建立 之 同时打开 - 走看看 (zoukankan.com)</a></li>
<li>3）<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011130578/article/details/44408713">(33条消息) 3.4 同时打开_Remy1119的博客-CSDN博客</a></li>
<li>4）<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/422385138">动图图解！没有accept，能建立TCP连接吗？ - 知乎 (zhihu.com)</a></li>
<li>5）<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/506042622">一道腾讯面试题目：没有listen，能否建立TCP连接 - 知乎 (zhihu.com)</a></li>
<li>6）<a target="_blank" rel="noopener" href="https://juejin.cn/post/6977340098287239198">TCP的握手（三次、同时）与挥手（四次、同时）理解 - 掘金 (juejin.cn)</a></li>
</ul>
<p>在参考资料的基础上，整理了整个逻辑，并补充了序列号确认的流程和能同步的原因，以及syn丢包时能成功建立的原因。</p>
<h1 id="connect与accept"><a href="#connect与accept" class="headerlink" title="connect与accept"></a>connect与accept</h1><p>我从tcp正常的建立说起。</p>
<p>在简单的服务器-客户端模型中，服务器在执行<code>listen()</code>方法之后还会执行一个<code>accept()</code>方法，并阻塞等待客户端连接。客户端在创建socket后可以调用<code>connect()</code>方法来连接服务器。这个过程中，TCP的三次握手究竟什么时候完成呢?</p>
<p>在<strong>参考资料4</strong>中，作者在执行accept前进行sleep等待，让客户端直接去connect并抓包。作者的抓包结果如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%801.jpg" alt="img"></p>
<p>从抓包结果看来，就算不执行accept()方法，三次握手照常进行，并顺利建立连接。</p>
<hr>
<p>从listen开始说起，在服务器执行listen方法后，就会进入监听（LISTEN)状态，内核会为每个处于监听状态的socket分配两个队列：半连接队列和全连接队列。相信这两个队列大家也不陌生了。</p>
<ul>
<li><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>socket</code>加入到这个队列中，队列内的<code>socket</code>都处于<code>SYN_RECV</code> 状态。然后发回syn+ack执行第二次握手。</li>
<li><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>socket</code>取出，放到全连接队列中。队列里的<code>socket</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></li>
</ul>
<p>这就是说，<strong>accept实际上只是从全连接队列取出一条连接</strong>，不参与TCP三次握手的过程。</p>
<p>这两个队列将详细点，<strong>全连接队列（icsk_accept_queue）是个链表</strong>，而<strong>半连接队列（syn_table）是个哈希表</strong>。</p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97.jpg" alt="img" style="zoom: 50%;" />

<p>这是因为全连接队列只需要把头部的连接给accept即可，维护一个线性结构就可以了。</p>
<p>而半连接队列中的连接都不是完整的连接，在等待第三次握手的到来。当第三次握手到来时，要根据IP端口来看是哪个socket，这就需要哈希表查找。这样，两个队列是时间复杂度都是O(1)。</p>
<p><strong>参考资料4</strong>还谈到了这两个队列满了会怎么样，不是本文重点，有兴趣的朋友可以去看看。</p>
<ul>
<li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</li>
<li>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</li>
</ul>
<h1 id="connect是如何保存socket信息的"><a href="#connect是如何保存socket信息的" class="headerlink" title="connect是如何保存socket信息的"></a>connect是如何保存socket信息的</h1><p>当服务端回复syn+ack时，客户端实际上也没有处于listen状态的套接字，<strong>没有半连接队列和全连接队列</strong>，但却可以完成三次握手。这意味着，客户端进行connect调用后，该<strong>套接字一定被加入到某个表</strong>中，并可以被匹配到。</p>
<p>跟踪内核源码可以看到当调用connect时，对应的套接字就被加入了全局的tcp已连接（established）的表中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_v4_connect</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sockaddr *uaddr, <span class="type">int</span> addr_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Socket identity is still unknown (sport may be zero).</span></span><br><span class="line"><span class="comment">     * However we set state to SYN-SENT and not releasing socket</span></span><br><span class="line"><span class="comment">     * lock select source port, enter ourselves into the hash tables and</span></span><br><span class="line"><span class="comment">     * complete initialization after this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">tcp_set_state</span>(sk, TCP_SYN_SENT);</span><br><span class="line">    err = <span class="built_in">inet_hash_connect</span>(&amp;tcp_death_row, sk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这句注释 <em>enter ourselves into the hash tables</em>，在<code>inet_hash_connect</code>函数中，<strong>socket在调用connect的时候就会把自己加入到establish hash表，虽然它此时连syn都还没有发送</strong>。确切的讲，应该是在它调用的<code>__inet_check_established</code>函数中。</p>
<p>当内核收到syn+ack报文时，内核是<strong>先在established表中查找，再进行listen表的查找</strong>。对于客户端来说，syn+ack报文必然可以在已连接表中匹配上对应的套接字。</p>
<h1 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h1><p>现在进入本文的重点</p>
<p>同时打开连接是指通信的双方在接收到对方的SYN包之前，都进行了主动打开的操作并发出了自己的SYN包。如之前所说一个四元组标识一个TCP连接，因此如果一个TCP连接要同时打开需要通信的双方知晓对方的IP和端口信息才行，这种场景在实际情况中很少发生(NAT穿透中可能会多一些)。同时打开的流程如下图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="image.png"></p>
<h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><p>套接字有以下三种状态：</p>
<ul>
<li>在发送syn之后状态处于SYN_SENT状态；</li>
<li>SYN_RECV状态；</li>
<li>ESTABLISHED状态。</li>
</ul>
<p>在正常的连接过程中，客户端向服务器在监听的端口发起connect，第一次握手发送syn后进入SYN_SENT状态，服务器发回syn+ack之后进入ESTABLISHED状态，服务器处的端口处于SYN_RECV状态，并在第三次握手中发回ack后进入ESTABLISHED状态。</p>
<p>SYN_RECV状态还可以是：处于SYN_SENT状态的套接字接收到syn后会进入的状态。这个过程中，客户发送syn并收到syn，就是一个同时打开的过程（双方同时connect）。</p>
<p>假设两台设备双方均发送syn给对端，理想情况下，<strong>在发送syn之后状态处于SYN_SENT状态，此时双方均收到对端的发来的syn，则立即进入SYN_RECV状态，并且都向对端回复syn+ack，在收到syn+ack之后，连接从SYN_RECV状态切换到ESTABLISHED状态。</strong></p>
<p>在发送syn进入SYN_SENT状态之后，收到对端发来的syn包处理流程如下。如果收到syn，进入SYN_RECV状态。如果收到的是ack（syn+ack和ack两种），会进入另外的处理流程，稍后再说。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">tcp_rcv_synsent_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">inet_connection_sock</span> *icsk = <span class="built_in">inet_csk</span>(sk);</span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">tcp_sock</span> *tp = <span class="built_in">tcp_sk</span>(sk);</span><br><span class="line">    	<span class="keyword">struct</span> <span class="title class_">tcp_fastopen_cookie</span> foc = &#123; .len = <span class="number">-1</span> &#125;;</span><br><span class="line">    	<span class="type">int</span> saved_clamp = tp-&gt;rx_opt.mss_clamp;</span><br><span class="line">	...</span><br><span class="line">   	<span class="keyword">if</span> (th-&gt;ack) &#123;  <span class="comment">//包中带ACK标记，走此路径</span></span><br><span class="line">   	...<span class="comment">//另外的处理流程</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">        <span class="comment">/* We see SYN without ACK. It is attempt of</span></span><br><span class="line"><span class="comment">         * simultaneous connect with crossed SYNs.</span></span><br><span class="line"><span class="comment">         * Particularly, it can be connect to self.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">tcp_set_state</span>(sk, TCP_SYN_RECV);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;rx_opt.saw_tstamp) &#123;</span><br><span class="line">            tp-&gt;rx_opt.tstamp_ok = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">tcp_store_ts_recent</span>(tp);</span><br><span class="line">            tp-&gt;tcp_header_len =</span><br><span class="line">                <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr) + TCPOLEN_TSTAMP_ALIGNED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tp-&gt;tcp_header_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tp-&gt;rcv_nxt = <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line">        tp-&gt;copied_seq = tp-&gt;rcv_nxt;</span><br><span class="line">        tp-&gt;rcv_wup = <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;seq + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments is</span></span><br><span class="line"><span class="comment">         * never scaled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tp-&gt;snd_wnd    = <span class="built_in">ntohs</span>(th-&gt;window);</span><br><span class="line">        tp-&gt;snd_wl1    = <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;seq;</span><br><span class="line">        tp-&gt;max_window = tp-&gt;snd_wnd;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">tcp_ecn_rcv_syn</span>(tp, th);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">tcp_mtup_init</span>(sk);</span><br><span class="line">        <span class="built_in">tcp_sync_mss</span>(sk, icsk-&gt;icsk_pmtu_cookie);</span><br><span class="line">        <span class="built_in">tcp_initialize_rcv_mss</span>(sk);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">tcp_send_synack</span>(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个负责发送SYN+ACK的函数tcp_send_synack有些特殊：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_send_synack</span><span class="params">(<span class="keyword">struct</span> sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line"></span><br><span class="line">    skb = <span class="built_in">tcp_write_queue_head</span>(sk);</span><br><span class="line">    <span class="keyword">if</span> (skb == <span class="literal">NULL</span> || !(<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;tcp_flags &amp; TCPHDR_SYN)) &#123;　<span class="comment">//包一定携带SYN标记</span></span><br><span class="line">        <span class="built_in">pr_debug</span>(<span class="string">&quot;%s: wrong queue state\n&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;tcp_flags &amp; TCPHDR_ACK)) &#123;　<span class="comment">//未携带ACK标记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">skb_cloned</span>(skb)) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *nskb = <span class="built_in">skb_copy</span>(skb, GFP_ATOMIC);</span><br><span class="line">            <span class="keyword">if</span> (nskb == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">            <span class="built_in">tcp_unlink_write_queue</span>(skb, sk);</span><br><span class="line">            <span class="built_in">skb_header_release</span>(nskb);</span><br><span class="line">            __tcp_add_write_queue_head(sk, nskb);</span><br><span class="line">            <span class="built_in">sk_wmem_free_skb</span>(sk, skb);</span><br><span class="line">            sk-&gt;sk_wmem_queued += nskb-&gt;truesize;</span><br><span class="line">            <span class="built_in">sk_mem_charge</span>(sk, nskb-&gt;truesize);</span><br><span class="line">            skb = nskb;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;tcp_flags |= TCPHDR_ACK;　<span class="comment">//加上ACK标记</span></span><br><span class="line">        <span class="built_in">TCP_ECN_send_synack</span>(<span class="built_in">tcp_sk</span>(sk), skb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;when = tcp_time_stamp;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tcp_transmit_skb</span>(sk, skb, <span class="number">1</span>, GFP_ATOMIC);　<span class="comment">//发送出去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在同时打开的情况下，发送队列中已经有一个SYN包等待确认。tcp_send_synack的基本功能是：将发送队列中的SYN包加上ACK标记位再发送。这样TCP收到SYN后发送的SYN+ACK的序列号与最开始发送的SYN包一致，ack的确认号是对方syn的序列号+1，连接就可以在收到对端的SYN+ACK后得以正常建立。</p>
<hr>
<p>在SYN_RECV状态收到对端发来的syn+ack包，则直接进入ESTABLISHED已连接状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">         <span class="comment">/* step 5: check the ACK field */</span></span><br><span class="line">     acceptable = <span class="built_in">tcp_ack</span>(sk, skb, FLAG_SLOWPATH |</span><br><span class="line">                       FLAG_UPDATE_TS_RECENT) &gt; <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line">     <span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* ack处理失败 */</span></span><br><span class="line">         <span class="keyword">if</span> (!acceptable)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* RTT */</span></span><br><span class="line">         <span class="keyword">if</span> (!tp-&gt;srtt_us)</span><br><span class="line">             <span class="built_in">tcp_synack_rtt_meas</span>(sk, req);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* Once we leave TCP_SYN_RECV, we no longer need req</span></span><br><span class="line"><span class="comment">          * so release it.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (req) &#123;</span><br><span class="line">             <span class="built_in">inet_csk</span>(sk)-&gt;icsk_retransmits = <span class="number">0</span>;</span><br><span class="line">             <span class="built_in">reqsk_fastopen_remove</span>(sk, req, <span class="literal">false</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">/* Make sure socket is routed, for correct metrics. */</span></span><br><span class="line">             <span class="comment">/* 检查重建路由 */</span></span><br><span class="line">             icsk-&gt;icsk_af_ops-&gt;<span class="built_in">rebuild_header</span>(sk);</span><br><span class="line">             <span class="comment">/* 初始化拥塞邋控制 */</span></span><br><span class="line">             <span class="built_in">tcp_init_congestion_control</span>(sk);</span><br><span class="line">             <span class="comment">/* 路径mtu发现初始化 */</span></span><br><span class="line">             <span class="built_in">tcp_mtup_init</span>(sk);</span><br><span class="line">             <span class="comment">/* 用户待读取数据初始化 */</span></span><br><span class="line">             tp-&gt;copied_seq = tp-&gt;rcv_nxt;</span><br><span class="line">             <span class="comment">/* 调整接收发送缓存以及窗口等 */</span></span><br><span class="line">             <span class="built_in">tcp_init_buffer_space</span>(sk);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">smp_mb</span>();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* 连接更新为已连接状态 */</span></span><br><span class="line">         <span class="built_in">tcp_set_state</span>(sk, TCP_ESTABLISHED);</span><br><span class="line">         sk-&gt;<span class="built_in">sk_state_change</span>(sk);</span><br><span class="line">                 <span class="comment">/* 省略了一些代码 */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列号确认"><a href="#序列号确认" class="headerlink" title="序列号确认"></a>序列号确认</h2><p>如流程图所示，假设客户端A的syn序列号为x，B的syn序列号为y。双方收到对方的syn时，发送的syn+ack序列号为，A：<code>syn-x+ack-y+1</code>；B：<code>syn-y+ack-x+1</code>。</p>
<p>这样，A收到B的syn+ack时，A知道这个是B过来的（syn还是y）；并且知道B收到的就是自己的syn（ack确认号是x+1），至此双方序列号就完成了同步。</p>
<p>在这个过程中，有三种情况被其他客户端干扰：</p>
<ul>
<li>如果客户端C<strong>只</strong>伪造syn-z发给A，A发给B的syn-ack确认号就是z+1，B就知道不对了；</li>
<li>如果客户端C<strong>只</strong>伪造<code>syn-z+ack-n</code>发给了A，A看到syn是z而不是B的y就直接丢弃了。</li>
<li>如果客户端C两个报文都发给A，这样A查看syn+ack时发现syn是z，还要进一步查看ack，发现ack不是自己的x+1，就知道是错误了。</li>
</ul>
<h2 id="syn丢包"><a href="#syn丢包" class="headerlink" title="syn丢包"></a>syn丢包</h2><p>在双方交换四个数据包的过程中，可能会发生丢包。有四种情况：</p>
<ul>
<li>客户AB向对方发送syn，进入SYN_SEND状态，两个包都丢了，超时重传。</li>
</ul>
<hr>
<ul>
<li>客户AB向对方发送syn，但B的syn包丢了。这时AB都在SYN_SENT状态，B收到A的syn后进入SYN_RECV状态，然后发送syn+ack。<ul>
<li>A收到syn+ack时还在SYN_SENT状态，注意到源码中有另一条“ack”的处理路径。</li>
<li>实际上客户A在发送syn后收到syn+ack是与listen中的服务器正常建立连接的过程（第二次握手），A并不知道对方是服务器还是客户端，B发的<code>syn-y+ack-x+1</code>中的y在A看来就是服务器的初始序列号。此时A会返回ack并进入ESTABLISHED状态。其中ack的序列号是y+1。</li>
<li>B收到ack后发现没有syn，检查ack序列号正确，就知道是自己的syn包丢了，进入ESTABLISHED状态，连接建立完成。</li>
</ul>
</li>
<li>这个过程由于B的syn包丢了，所以实际上变成了client-server模型，退化为正常的三次握手。</li>
</ul>
<hr>
<ul>
<li>客户AB向对方发送syn都收到了，AB都进入SYN_RECV状态，发送syn+ack，如果两个包都丢了，超时重传。</li>
</ul>
<hr>
<ul>
<li>客户AB向对方发送syn都收到了，AB都进入SYN_RECV状态，发送syn+ack。<ul>
<li>假设B发送的包丢了，这时B收到syn+ack直接进入ESTABLISHED状态。</li>
<li>A一直在等待syn+ack，当超时时，A会猜测是自己的syn丢了（且syn+ack也丢了，因为syn+ack没丢的话就是第二种情况client-server）或是对方的syn+ack丢了。</li>
<li>此时如上所述，A在SYN_RECV状态超时会重传syn+ack，对于A来说，B没发回syn+ack可能有两种情况：<ul>
<li>如果B在ESTABLISHED状态，知道自己syn+ack丢了，发回syn+ack让A进入ESTABLISHED状态。</li>
<li>如果B根本就没收到syn（B知道自己发了syn），此时退化为client-server模型，发回ack。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>至此，连接建立完成。</strong></p>
<h1 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h1><p>同时关闭的流程和四次挥手差不多</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD2.jpg" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>客户端在connect后在内核中会把套接字加入<code>已连接</code>哈希表，收到syn+ack报文先查<code>已连接哈希表</code>再查<code>listen半连接哈希表</code>。</li>
<li>客户端同时打开时，双方会进行syn、syn+ack四种报文的发送接收，在三种状态中转移：发送syn的SYN_SENT状态、接收syn发送syn+ack的SYN_RECV状态、接收syn+ack的ESTABLISHED状态。</li>
<li>序列号的同步中，syn发的序列号是随机初始序列号，syn+ack回复的序列号是syn的序列号（标识了该包是自己发的），确认号是对方syn序列号+1（标识了对方的包自己已经收到）。收到syn+ack后会检测序列号（该包是否是发syn的对方发来的）以及确认号（该包是否是自己想连接的发了syn过去的对方发来的）。</li>
<li>syn丢包中，如果有一个对方丢了syn包，就退化成client-server模型；如果有一个对方丢了syn+ack包，自己会重传syn+ack，对方要么重传syn+ack（对方的syn+ack丢了），要么重传ack（自己的syn丢了，退化为client-server模型）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/10/22/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/22/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">函数模板问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-22 19:46:32 / 修改时间：20:00:50" itemprop="dateCreated datePublished" datetime="2022-10-22T19:46:32+08:00">2022-10-22</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>757</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>函数模板的声明和定义写在一个头文件里，因为这样在别的cpp（假设是main）里调用（相当于这个cpp就有定义）才能实例化。</p>
<p>否则main-cpp（只有声明没有定义）调用生成的obj文件会去这个头文件（函数模板的声明）对应的obj文件找相应的实例化的函数的二进制代码，但是那个obj文件对应的cpp只有定义而没有调用！而没有调用就没有实例化，所以对应的obj文件也没有实例化函数的二进制代码，这样链接就出事了。</p>
<hr>
<p>不能在函数模板中打算使用不同的case针对不同的类型进行操作（比如0对int，1对string），因为对于一个类型的函数模板调用就实例化了整个函数，这些case也会被实例在这个类型上，就会出现类型不匹配的错误（错误可不管你case几，因为调用首先要实例化，实例化就发现出错了，没有管参数是多少）。</p>
<p>比如用case0，并且实例化一个int，但是case1中也要根据int生成二进制代码，但人家是string类型，就出错了</p>
<p>这对if也是一样的。</p>
<p>比如这样，这些map对应不同的类型，就会出错。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%981.png" alt="image-20221022195741403"></p>
<hr>
<p>上面说了case中采用不同的类型，实际上也不能在case中调用不同类型的模板函数。不要用函数模板（假设是1）调用多个函数模板（假设是2）。</p>
<p>比如一个函数模板1里switch调用不同的模板2，你只希望根据case和相应的参数来调用某个模板2，但是由于其他函数模板2也会根据这些参数的类型实例化，然而实例化很可能出错，因为你可能只考虑了某个case，而这些模板2是不同的实现。</p>
<p>比如这样，函数模板2根据map的参数和key的参数推导，但模板1只考虑了某个case和对应的key的类型，这会导致后面的case中出现map和key类型不匹配（因为map的类型1是和key类型共用的）</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%97%AE%E9%A2%982.png" alt="image-20221022195831467"></p>
<p>还是那个问题，实例化考虑参数的类型，执行才考虑参数的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/10/18/extern%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/18/extern%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">extern全局变量问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-18 23:35:46 / 修改时间：23:55:30" itemprop="dateCreated datePublished" datetime="2022-10-18T23:35:46+08:00">2022-10-18</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>645</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最好不要在头文件定义全局变量，很可能会出现重定义，即使使用了ifndef。</p>
<p>因为ifndef只是让预编译时头文件展开不包含重复的头文件，最后每个cpp文件的代码是包含了所有的include了的头文件的代码；</p>
<p>比如A.cpp包含了a.h，和b.h，a.h又包含了b.h，B.cpp包含了a.h；如果在b.h定义了一个全局变量，在编译时不会出错，在链接时就会出错了。</p>
<p>这是因为ifndef只是告诉A.cpp：a.h包含了b.h，不用再包含一次了；而B.cpp包含了ab两个头文件也可以编译成功，这样就cpp文件就生成了两个包含b.h的代码的obj文件，在链接时发现两个obj文件定义了同一个变量，就出现重定义错误了。</p>
<hr>
<p>因此<strong>头文件里最好只声明全局变量</strong>（可以成功是因为可能只被include一次），声明必须使用<code>extern T x;</code>，如果不用extern也视为定义只是没有初始化。</p>
<p>但需要在何处定义呢，只需要注意<strong>不能在其他头文件定义</strong>，这和前面说的是同样的道理。可以<strong>在任意的一个cpp文件里再定义一次</strong>，注意是定义不是赋值，定义要写上类型。但最好把**.h声明和.cpp定义关联起来**，因此不要随便找个cpp就定义。</p>
<p>其次，直接在cpp定义而不在.h文件声明是可行的，不过这会导致.h文件内依赖该变量的代码编译失败。但这些代码可以放到cpp内而解决这个错误，见仁见智了。</p>
<hr>
<p>总结：</p>
<ul>
<li>不要在头文件定义全局变量，声明必须使用extern</li>
<li>定义可以在任意一个cpp文件进行，但这个cpp文件最好和原来的.h文件关联起来，比较直观。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/10/14/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/14/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">windows10+ubuntu20.04LTS双系统安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-14 14:02:55 / 修改时间：16:27:17" itemprop="dateCreated datePublished" datetime="2022-10-14T14:02:55+08:00">2022-10-14</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>996</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>做虚拟化实验需要用物理机上的linux系统，用虚拟机会产生虚拟化嵌套的问题，而学校提供的服务器太烂了（唉(；′⌒&#96;)</p>
<p>因此要安装双系统，这里记录一下。</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li>要一个u盘</li>
<li>分区</li>
<li>制作系统盘</li>
</ul>
<p>先看bios模式cmd下msinfo32，可以看到是UEFI（可能会影响后续操作）</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/bios1.png" alt="image-20221014114454112"></p>
<p>首先，进入Windows，对于win10，直接在左下角的搜索栏里搜索<code>磁盘管理</code>(或者右键<code>此电脑</code>-&gt;<code>管理</code>-&gt;<code>磁盘管理</code>)，找到电脑的磁盘划分。开辟一块未分配的新分区：右键-&gt;<code>压缩卷</code>。我分了一块50GB的空闲磁盘。然后看一下磁盘的分区形式，这里是<strong>GPT</strong>。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%BD%A2%E5%BC%8F.png" alt="image-20221014133835613"></p>
<p>然后我们制作系统u盘，使用rufus软件（官网直接下载<a target="_blank" rel="noopener" href="https://rufus.ie/zh/">Rufus - 轻松创建USB启动盘</a>，界面很好看），选择镜像（先下载好）后注意根据磁盘分区格式选择类型。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/rufus1.png" alt="image-20221014134113266"></p>
<h1 id="启动安装"><a href="#启动安装" class="headerlink" title="启动安装"></a>启动安装</h1><p>关机，插入u盘，然后开机，按f9进入bios（我电脑是惠普的，不同电脑不一样）</p>
<p>如果检测到u盘设备可用，就进行下一步；否则，可能是微软的安全设置屏蔽了bios选择，这时按f10进入bios设置，找到安全启动设置（或安全引导等字眼），把它禁用，此时重启会出现提示，让你输验证码，禁用才奏效。然后再次重启基本上就可以检测到u盘设备了。</p>
<p>检测到u盘设备就选择该设备回车，会自动进行引导，等一会。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%8C%E7%B3%BB%E7%BB%9F1.png" alt="image-20221014134915951"></p>
<p>然后进入ubuntu界面后先选择语言（为了接下来的设置能看懂，可以选中文。如果follow别的教程可以选英文），接着会选择是try ubuntu还是直接install。最好选择try试试能否使用，如果可以使用就选择旁边的install，</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%8C%E7%B3%BB%E7%BB%9F2.png" alt="image-20221014135113368"></p>
<p>最重要的一步是选择磁盘，这里我忘记拍了就用一下别人的图，第一个是系统共存，选最后一个——自己选分区。</p>
<p><img src="https://colainlibrary.com/images/20200201/07.png" alt="img"></p>
<p>后面的操作都没拍照，具体参考博客：<a target="_blank" rel="noopener" href="https://colainlibrary.com//archives/292fe4d9.html">Windows下采用U盘安装Ubuntu双系统详细过程 | Cola In Library</a>的<strong>安装Ubuntu</strong>部分，主要是设置主分区和逻辑分区，无脑follow。设置完之后就安装就好了。</p>
<h1 id="默认启动设置"><a href="#默认启动设置" class="headerlink" title="默认启动设置"></a>默认启动设置</h1><p>我安装后开机是这样的：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8F%8C%E7%B3%BB%E7%BB%9F3.png" alt="image-20221014135723680"></p>
<p>默认是ubuntu，10s内不选择自动进ubuntu。这是可以修改的，进入ubuntu，然后修改grub文件。</p>
<p>刚刚启动页面是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu</span><br><span class="line">Advanced options for Ubuntu</span><br><span class="line">Windows 10</span><br></pre></td></tr></table></figure>

<p>那么对应的 GRUB_DEFAULT 顺序是0、1、2</p>
<p>打开文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># If you change this file, run &#x27;update-grub&#x27; afterwards to update</span><br><span class="line"># /boot/grub/grub.cfg.</span><br><span class="line"># For full documentation of the options in this file, see:</span><br><span class="line">#   info -f grub -n &#x27;Simple configuration&#x27;</span><br><span class="line"></span><br><span class="line">GRUB_DEFAULT=2</span><br><span class="line">GRUB_TIMEOUT_STYLE=hidden</span><br><span class="line">GRUB_TIMEOUT=10</span><br><span class="line">GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;text&quot;</span><br></pre></td></tr></table></figure>

<p>其中<code>GRUB_DEFAULT</code>的值设置的就是默认顺序，改成2就是windows。</p>
<p><code>GRUB_TIMEOUT</code>是等待时间，可以设置成5。</p>
<p><strong>这样就大功告成了！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/10/12/webserver%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/webserver%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA2/" class="post-title-link" itemprop="url">WebServer模块单元测试2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-12 14:02:16" itemprop="dateCreated datePublished" datetime="2022-10-12T14:02:16+08:00">2022-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-26 21:26:11" itemprop="dateModified" datetime="2022-10-26T21:26:11+08:00">2022-10-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>448</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接着上一篇博客<a href="https://jysama.cn/2022/09/28/websever%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA/">WebServer模块单元测试 | JySama</a>，写得太多了代码解析就很慢了，重新开一篇。</p>
<h1 id="epoll封装"><a href="#epoll封装" class="headerlink" title="epoll封装"></a>epoll封装</h1><p>上一篇末尾给出了epoll的实例，每次添加事件、修改事件、删除事件都是差不多的流程，可以封装一下，并且epollfd的create和close可以变成RAII的管理模式。</p>
<p>因为上层调用时，事件的类型是不一样的（读转读、读转写、写转写等），为了接口易用与通用，让上层传入events描述事件类型。events是一个uinit32_t，也即32位无符号整数类型。</p>
<p>封装很简单，只需要支持添加、修改、删除、调用epoll_wait、设置非阻塞（这个也让上层决定，默认非阻塞）即可。</p>
<h2 id="设置非阻塞"><a href="#设置非阻塞" class="headerlink" title="设置非阻塞"></a>设置非阻塞</h2><p>这个功能设置在这里是因为每个要添加进来的事件都可以顺便进行阻塞与非阻塞的设置（而且一般来说事件的模式都是一致的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为</span></span><br><span class="line"><span class="comment">的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，</span></span><br><span class="line"><span class="comment">或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span></span><br><span class="line"><span class="comment">//F_GETFL：获取文件打开方式的标志，标志值含义与open调用一致，然后或上非阻塞标志</span></span><br><span class="line"><span class="comment">//F_SETFL：设置文件打开方式标志为arg指定方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;<span class="comment">//不判断fd是否小于0，让上层判断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);<span class="comment">//出错返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">addFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果需要设置非阻塞，根据布尔运算就会调用SetFdNonblock函数，如果返回不是-1就成功，是-1就返回false</span></span><br><span class="line">    <span class="keyword">if</span>(nonBlock &amp;&amp; (<span class="built_in">setFdNonblock</span>(fd)==<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;<span class="comment">//关联fd</span></span><br><span class="line">    ev.events = events;<span class="comment">//上层设置好类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_ADD, fd, &amp;ev);<span class="comment">//add，成功返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">modFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_MOD, fd, &amp;ev);<span class="comment">//mod</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">delFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回就绪事件"><a href="#返回就绪事件" class="headerlink" title="返回就绪事件"></a>返回就绪事件</h2><p>这里上层创建一个events数组把地址传进来接收就绪事件，函数返回值是就绪事件个数。虽然c++定义一个结构体类型可以不写struct（c要），但还是写出来好些</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于timeout：-1：永远等待；0：不等待直接返回，执行下面的代码；其他：在超时时间内没有事件发生，返回0，如果有事件发生立即返回</span></span><br><span class="line"><span class="comment">//默认不等待</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(vector&lt;<span class="keyword">struct</span> epoll_event&gt; &amp;evlist, <span class="type">int</span> eventSize, <span class="type">int</span> timeoutMs = <span class="number">0</span>)</span> </span>&#123;<span class="comment">//成功返回多少事件就绪，超时返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span>* evs = ;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">epoll_wait</span>(epollFd, events, eventSize, timeoutMs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,i&lt;res;i++)</span><br><span class="line">        evlist.<span class="built_in">push_back</span>(events[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Epoller.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> eventSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> nonBlock;</span><br><span class="line">    <span class="type">int</span> epollFd;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Epoller</span>(<span class="type">const</span> <span class="type">int</span> eventsize = <span class="number">1024</span>, <span class="type">const</span> <span class="type">bool</span> ifNonBlock = <span class="literal">true</span>):</span><br><span class="line">    <span class="built_in">eventSize</span>(eventsize),<span class="built_in">nonBlock</span>(ifNonBlock),<span class="built_in">epollFd</span>(<span class="built_in">epoll_create</span>(<span class="number">5</span>)),<span class="built_in">events</span>(eventsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(epollFd&gt;=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Epoller</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(epollFd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);<span class="comment">//出错返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">addFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果需要设置非阻塞，根据布尔运算就会调用SetFdNonblock函数，如果返回不是-1就成功，是-1就返回false</span></span><br><span class="line">        <span class="keyword">if</span>(nonBlock &amp;&amp; (<span class="built_in">setFdNonblock</span>(fd)==<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        ev.data.fd = fd;<span class="comment">//关联fd</span></span><br><span class="line">        ev.events = events;<span class="comment">//上层设置好类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_ADD, fd, &amp;ev);<span class="comment">//add，成功返回0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">modFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        ev.data.fd = fd;</span><br><span class="line">        ev.events = events;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_MOD, fd, &amp;ev);<span class="comment">//mod</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">delFd</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对于timeout：-1：永远等待；0：不等待直接返回，执行下面的代码；其他：在超时时间内没有事件发生，返回0，如果有事件发生立即返回</span></span><br><span class="line">    <span class="comment">//默认不等待</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">0</span>)</span> <span class="comment">//成功返回多少事件就绪，超时返回0，出错返回-1</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd, &amp;events[<span class="number">0</span>], eventSize, timeoutMs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getEventFd</span><span class="params">(<span class="type">size_t</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events[i].data.fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getEvents</span><span class="params">(<span class="type">size_t</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> events[i].events;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/28/websever%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/28/websever%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">WebServer模块单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-28 19:49:06" itemprop="dateCreated datePublished" datetime="2022-09-28T19:49:06+08:00">2022-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-26 10:38:26" itemprop="dateModified" datetime="2022-10-26T10:38:26+08:00">2022-10-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看完了webserver的c++11（14）的写法并添加了大量注释后，也要开始自己手写一个了。整体的逻辑还没有研究透彻，虽然在写完注释后对思路已经挺清楚了，但是细节上还是很欠缺。</p>
<p>这一篇博客是为动手撸一个服务器而准备的，在这篇博客里，会动手写一些基本的模块，并进行正确性验证。</p>
<p>变量命名没有很规范，因为有时想随意一点，有时又觉得想认真点，(●’◡’●)</p>
<p>环境：ubuntu20.04，c++11及以上（14更好，c++11的话编译器会对lambda表达式按值捕获发出警告，尽管代码还是能正确运行）</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池是最简单的，就先从这入手。</p>
<p>考虑整体的思路：</p>
<ul>
<li>首先有一个池初始化若干个线程，每个线程配备一个运行的work函数，这个work函数要循环取任务去执行。</li>
<li>取任务就有个任务队列，在设计任务队列前，我们想一下任务的形式是什么，要传什么样的什么类型的任务进来。<ul>
<li>一种选择是传入一个类对象，然后调用类对象的一些工作处理函数，并且还能根据类对象的一些参数来进行不同的处理。</li>
<li>上面的方式也许是传统的c98的模式，它并不是那么的具有鲁棒性，因为尽管可以通过模板传入不同的类对象，但是类对象必须拥有一个处理函数。如果只是运行这些处理函数，为什么不直接传入一个函数进来呢，这样就可以执行任意的工作了。</li>
<li>c++11开始，std::function&lt;&gt;就提供了我们想要的功能，无论是函数指针还是函数对象等，都可以使用一个function对象保存然后传入。而那些细节处理交由上层，函数执行所需要的参数由std::bind来绑定给function对象，function本身不需要额外参数，更有灵活性。</li>
</ul>
</li>
<li>因此，我们的任务队列的元素就是std::function。然后，在取队列元素时和加入队列元素时，都需要互斥。队列是一个无界生产者，当队列大小为0时，一般用一个信号量阻塞即可，但我们也知道可以用条件变量来完成这件事，因此这里会用条件变量。<ul>
<li>在取任务时，首先互斥锁住（判断是否非空前就要锁），然后如果队列非空就取一个任务，解锁，执行任务。如果没有任务，就阻塞，这里用条件变量阻塞。因为要锁和解锁以及给条件变量使用，所以用unique_lock好，但unique_lock不要写在while内，这样会重复定义。</li>
</ul>
</li>
<li>这里先不考虑左值右值，因为本身项目中就不需要用到，从理论上讲考虑的话就更灵活，但没有实例还是不好理解，就先不用了。</li>
</ul>
<p>现在，我们可以开始写代码了，这里提一下头文件（注意标准库一般都是std命名空间）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mutex&gt;:互斥锁等</span><br><span class="line">&lt;thread&gt;:线程</span><br><span class="line">&lt;condition_variable&gt;:条件变量</span><br><span class="line">&lt;functional&gt;:std::function</span><br><span class="line">&lt;queue&gt;:队列</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">    std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([&amp;]&#123;<span class="comment">//lambda表达式，按引用捕获变量（确保同一地址），无参数无返回值</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面的版本基本上已经写好了一个线程池，但还有析构函数没有写。析构函数要析构什么呢，这里好像并没有要手动释放的东西——没有手动使用堆空间，不需要delete。但别忘了，我们的线程是分离的，这里没有去join回收，线程使用的全局变量会产生所谓的detch陷阱。</p>
<p>当进程要退出时，不会再添加任务了，我们更希望线程把这些已有任务都做完再退出，但是主进程退出了会把队列、互斥锁、条件变量都析构掉，使得线程调用这些资源会出错，这就是detch()带来的陷阱。在讨论解决方案前，我们再想想为什么要使用detch()：其实就是为了把已有的任务都做完。</p>
<p>为了做完这些任务，我们就得把线程访问的资源放在堆空间上，这样才不会在进程退出时析构掉资源。因为每个线程都访问这三个资源，因此再用一个结构体封装，线程捕获结构体指针就可以了。为了控制堆上的资源，我们还可以使用共享指针（共享很显然，因为这些线程用的是同一个）。</p>
<ul>
<li>创建共享指针的方式有两种，一种是用new，一种是用make_shared函数。尽量使用make_shared，因为new本质上会分配两次内存，一个是new的对象，一个是shared_ptr本身new的计数器（控制块）。而使用make_shared申请一个单独的内存块来存放对象和控制块，更高效，且因为没有顺序是同一时间开辟空间的，具有异常安全。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/03eea8262c11">C++11 make_shared - 简书 (jianshu.com)</a></li>
<li>使用make_shared函数要显式指出类型，因为返回值是<code>shared_ptr&lt;T&gt;</code>，返回值类型无法推导，要<code>make_shared&lt;T&gt;</code>指出。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改良版threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pool</span><span class="comment">//封装三个资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">        std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;pool&gt; pool_;<span class="comment">//共享指针，pool_是一个指针指向pool结构体，这个指针用于线程池操作资源</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>):<span class="built_in">pool_</span>(std::<span class="built_in">make_shared</span>&lt;pool&gt;())<span class="comment">//以make_shared的方式new一个对象给pool_指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([<span class="type">pool_t</span> = pool_]&#123;<span class="comment">//现在要按值捕获，相当于拷贝构造共享指针，计数+1，且指向相同内容</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(<span class="type">pool_t</span>-&gt;mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         <span class="type">pool_t</span>-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        pool_-&gt;taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在，我们已经解决了detch陷进，只要线程执行完任务，我们就退出线程，那么我们的析构函数只需要传递一个信号，让线程得知主进程已经退出了，线程根据信号作出反应即可。注意，因为线程要把工作做完再退出，所以优先级是!empty()，如果没有任务，我们是先看要不要退出，再进行等待，所以在if-else中插入一个else if判断即可。</p>
<p>注意，线程有可能卡在条件变量的wait处，所以析构函数还要唤醒所有的线程，让它们处理任务（如果有）并退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终版threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pool</span><span class="comment">//封装三个资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">        std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line">        <span class="type">bool</span> isclose = <span class="literal">false</span>;<span class="comment">//默认值是false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;pool&gt; pool_;<span class="comment">//共享指针，pool_是一个指针指向pool结构体，这个指针用于线程池操作资源</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>):<span class="built_in">pool_</span>(std::<span class="built_in">make_shared</span>&lt;pool&gt;())<span class="comment">//以make_shared的方式new一个对象给pool_指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([<span class="type">pool_t</span> = pool_]&#123;<span class="comment">//现在要按值捕获，相当于拷贝构造共享指针，计数+1，且指向相同内容</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(<span class="type">pool_t</span>-&gt;mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();<span class="comment">//抢占锁</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">pool_t</span>-&gt;isclose)</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         <span class="type">pool_t</span>-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        pool_-&gt;taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        pool_-&gt;isclose = <span class="literal">true</span>;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>以上基本就大功告成了，现在，我们来写一个test文件。</p>
<p>为了确认线程是否正确退出，我们在else if那打印退出信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">pool_t</span>-&gt;isclose)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;thread exit!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test_threadpool.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostraem&gt;</span><span class="comment">//cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//pthread_exit</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is [&quot;</span>&lt;&lt;id&lt;&lt;<span class="string">&quot;] task&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(id);<span class="comment">//睡眠id秒</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;id&lt;&lt;<span class="string">&quot;] task quit！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">threadpool <span class="title">threadp</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//十个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    	threadp.<span class="built_in">addTask</span>(<span class="built_in">bind</span>(task,i));<span class="comment">//bind 绑定task函数，并赋参数i，返回一个function对象</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//告知系统不用回收进程所有资源，等待子线程退出</span></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不能直接return！会把所有线程都回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意std::thread内部调用了pthread，linux不一定把pthread作为默认库，所以编译时候要链接，编译的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++14 -o test_threadpool test_threadpool.cpp -lpthread</span><br></pre></td></tr></table></figure>

<p>再者，当主进程return后，即使子线程是detch的，也会被系统回收资源。在 《UNIX 网络编程》卷一 第 537 页，有这么一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果进程的main函数返回或者任何线程调用了 exit， 整个进程就终止，其中包括它的任何线程。</span><br></pre></td></tr></table></figure>

<p>程序return，间接调用了exit()函数，因为一个线程调用exit函数，导致整个进程的退出。要想系统并不回收进程的所有资源，可以调用pthread_exit()；然后等其他线程终止退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果，数一下线程有没有正常退出</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test$ g++ -std=c++<span class="number">14</span> -o test_threadpool test_threadpool.cpp -lpthread</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test$ ./test_threadpool</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">5</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">6</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">7</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">8</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">9</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">10</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">11</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">12</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">13</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">14</span>] task</span><br><span class="line">[<span class="number">5</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">15</span>] task</span><br><span class="line">[<span class="number">6</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">16</span>] task</span><br><span class="line">[<span class="number">7</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">17</span>] task</span><br><span class="line">[<span class="number">8</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">18</span>] task</span><br><span class="line">[<span class="number">9</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">19</span>] task</span><br><span class="line">[<span class="number">10</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//1</span></span><br><span class="line">[<span class="number">11</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//2</span></span><br><span class="line">[<span class="number">12</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//3</span></span><br><span class="line">[<span class="number">13</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//4</span></span><br><span class="line">[<span class="number">14</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//5</span></span><br><span class="line">[<span class="number">15</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//6</span></span><br><span class="line">[<span class="number">16</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//7</span></span><br><span class="line">[<span class="number">17</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//8</span></span><br><span class="line">[<span class="number">18</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//9</span></span><br><span class="line">[<span class="number">19</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//10</span></span><br><span class="line"><span class="comment">//test成功</span></span><br></pre></td></tr></table></figure>

<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>这一块比较复杂，分解知识点，一点点细学。</p>
<h2 id="时间类chrono"><a href="#时间类chrono" class="headerlink" title="时间类chrono"></a>时间类chrono</h2><p>这个在日志系统用了一点，不过也可以用来输出时间，就在这里学习了。</p>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔，duration的原型是：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt; <span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">//第一个模板参数Rep是一个数值类型，表示时钟个数；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</span></span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Denom = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<p>ratio表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio&lt;2&gt;代表一个时钟周期是两秒，ratio&lt;60&gt;代表了一分钟，ratio&lt;60*60&gt;代表一个小时，ratio&lt;60*60*24&gt;代表一天。而ratio&lt;1, 1000&gt;代表的则是1&#x2F;1000秒即一毫秒，ratio&lt;1, 1000000&gt;代表一微秒，ratio&lt;1, 1000000000&gt;代表一纳秒。标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">3600</span>,<span class="number">1</span>&gt;&gt; hours;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt; minutes;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt; seconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000</span>&gt;&gt; milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000000</span>&gt;&gt; microseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000000000</span>&gt;&gt; nanoseconds;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠：</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">//休眠三秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono:: <span class="built_in">milliseconds</span> (<span class="number">100</span>)); <span class="comment">//休眠100毫秒</span></span><br></pre></td></tr></table></figure>

<p> chrono还提供了获取时间间隔的时钟周期个数的方法count() ，count()返回的间隔要向0取整，可以为负数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::milliseconds ms&#123;<span class="number">3</span>&#125;; <span class="comment">// 3 毫秒</span></span><br><span class="line">    <span class="comment">// 6000 microseconds constructed from 3 milliseconds</span></span><br><span class="line">    std::chrono::microseconds us = <span class="number">2</span>*ms; <span class="comment">//6000微秒</span></span><br><span class="line">    <span class="comment">// 30Hz clock using fractional ticks</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz30</span>(<span class="number">3.5</span>);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;3 ms duration has &quot;</span> &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span>&lt;&lt;  <span class="string">&quot;6000 us duration has &quot;</span> &lt;&lt; us.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> ms duration has <span class="number">3</span> ticks</span><br><span class="line"><span class="number">6000</span> us duration has <span class="number">6000</span> ticks</span><br></pre></td></tr></table></figure>

<p>时间间隔之间可以做运算，比如下面的例子中计算两端时间间隔的差值： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//都是duration类型</span></span><br><span class="line">std::<span class="function">chrono::minutes <span class="title">t1</span><span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">t2</span><span class="params">( <span class="number">60</span> )</span></span>;</span><br><span class="line">std::chrono::seconds t3 = t1 - t2;</span><br><span class="line">std::cout &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; second&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中，t1 是代表 10 分钟、t2 是代表 60 秒，t3 则是 t1 減去 t2，也就是 600 - 60 &#x3D; 540 秒。通过t1-t2的count输出差值为540个时钟周期即540秒（因为每个时钟周期为一秒）。</p>
<p>还可以通过**duration_cast&lt;&gt;()**来将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; chrono::<span class="built_in">duration_cast</span>&lt;chrono::minutes&gt;( t3 ).<span class="built_in">count</span>() &lt;&lt;” minutes”&lt;&lt; endl;</span><br><span class="line">将会输出:</span><br><span class="line"><span class="number">9</span> minutes</span><br></pre></td></tr></table></figure>

<p>使用转型后，数值就不一定是整数个tick()了，比如t2&#x3D;30s时，转型后就是9分半，这时使用count()会向下取整，只取到9。</p>
<h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p>谈到时间，总需要找一个时钟作为参照。clock就是这个时钟，在计算机中一般都会有一套或多套时钟系统供程序使用。在std::chrono库中，有3种时钟：</p>
<ul>
<li>system_clock</li>
<li>steady_clock</li>
<li>hight_definition_clock</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">system_clock</span></span><br><span class="line">&#123;	<span class="comment">// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> rep;</span><br><span class="line"><span class="keyword">typedef</span> ratio_multiply&lt;ratio&lt;_XTIME_NSECS_PER_TICK, <span class="number">1</span>&gt;, nano&gt; period;</span><br><span class="line"><span class="keyword">typedef</span> chrono::duration&lt;rep, period&gt; duration;</span><br><span class="line"><span class="keyword">typedef</span> chrono::time_point&lt;system_clock&gt; time_point;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">false</span>;<span class="comment">//steady_clock是true</span></span><br><span class="line"><span class="comment">//函数定义，注意都是静态成员函数，使用时用system_clock::func()调用</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，他们3个没有太大的区别，hight_definition_clock、steady_clock仅仅是system_clock的typedef，但是有为什么要区分呢，因为在有些情况下，他们是存在差异的。</p>
<ul>
<li>情况1：system_clock和steady_clock的差异<ul>
<li>比如windows系统可以提供时钟，如果认为时间不准，我们还可以进行调整。在没有调整时间前，system_clock和steady_clck是一样的，他们的读数都是单调匀速增加的；但是如果调整时间后，它们两者的读数就会出现差异，system_clock的读数就会出现跳变，而steady_clock依然保持线性单调递增，不受clock调整的影响，这个特点非常方便我们统计时间耗时（duration）。</li>
</ul>
</li>
<li>情况2：system_clock与hight_definition_clock的差异<ul>
<li>如果系统提供的时钟（clock）不止一种，有的时钟精度高（分辨率），有的精度低，hight_definition_clock使用时精度最高的clock，但是system_clock就不一定了。</li>
</ul>
</li>
</ul>
<p>clock主要用于获取当前的时间，通过now()方法获取，返回一个time_point，方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::system_clock::time_point current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>

<p>还有两个函数方法：to_time_t()：参数是time_point，转换到time_t；from_time_t()：从time_t转换过来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system_clock example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">int</span>, std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; <span class="built_in">one_day</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据时钟得到现在时间</span></span><br><span class="line">    std::chrono::system_clock::time_point today = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="type">time_t</span> time_t_today = std::chrono::system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;now time stamp is &quot;</span> &lt;&lt; time_t_today &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;now time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_today) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看明天的时间，time_point支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减</span></span><br><span class="line">    std::chrono::system_clock::time_point tomorrow = today + one_day;</span><br><span class="line">    std::<span class="type">time_t</span> time_t_tomorrow = std::chrono::system_clock::<span class="built_in">to_time_t</span>(tomorrow);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time stamp is &quot;</span> &lt;&lt; time_t_tomorrow &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_tomorrow) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下个小时时间</span></span><br><span class="line">    std::chrono::system_clock::time_point next_hour = today + std::chrono::<span class="built_in">hours</span>(<span class="number">1</span>);</span><br><span class="line">    std::<span class="type">time_t</span> time_t_next_hour = std::chrono::system_clock::<span class="built_in">to_time_t</span>(next_hour);</span><br><span class="line">    std::chrono::system_clock::time_point next_hour2 = std::chrono::system_clock::<span class="built_in">from_time_t</span>(time_t_next_hour);</span><br><span class="line"></span><br><span class="line">    std::<span class="type">time_t</span> time_t_next_hour2 = std::chrono::system_clock::<span class="built_in">to_time_t</span>(next_hour2);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time stamp is &quot;</span> &lt;&lt; time_t_next_hour2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_next_hour2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">now time stamp is <span class="number">1586662332</span></span><br><span class="line">now time is Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586748732</span></span><br><span class="line">tomorrow time is Mon Apr <span class="number">13</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586665932</span></span><br><span class="line">tomorrow time is Sun Apr <span class="number">12</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<h3 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h3><p>time_point是具体的时间，比如某年某月某日几点几分几秒，time_point依赖于clock的计时，可以用clock内部定义的time_point，也可以用自己定义的time_point。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个模板是时钟类型clock，一个是计时间隔duration</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;  <span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure>

<p>time_point有一个函数time_from_epoch()用来获得1970年1月1日到time_point时间经过的duration。举个例子，如果timepoint以天为单位，函数返回的duration就以天为单位。</p>
<p>由于各种time_point表示方式不同，chrono也提供了相应的转换函数 time_point_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">time_point&lt;Clock,ToDuration&gt; <span class="title">time_point_cast</span> <span class="params">(<span class="type">const</span> time_point&lt;Clock,Duration&gt;&amp; tp)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算当前时间距离1970年1月一日有多少天:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">  <span class="keyword">typedef</span> duration&lt;<span class="type">int</span>,std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; days_type;</span><br><span class="line">  <span class="comment">//now获取后返回的是system_clock类的timepoint类型，转型为天，给用户定义的timepoint</span></span><br><span class="line">  time_point&lt;system_clock,days_type&gt; today = <span class="built_in">time_point_cast</span>&lt;days_type&gt;(system_clock::<span class="built_in">now</span>());</span><br><span class="line">  <span class="comment">//调用epoch获得duration，调用count()计数</span></span><br><span class="line">  std::cout &lt;&lt; today.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; days since epoch&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这部分主要是三种类型穿插，让人比较迷糊。一般的用法就是：</p>
<ul>
<li>使用一个时钟的time_point，通过now()方法获取</li>
<li>要想直接输出就把获取的time_point通过to_time_t()转换后输出，这里还可以进一步用ctime函数格式化（返回char*）。注意time_point不能直接输出。</li>
<li>如果要继续处理，有两种运算方式<ul>
<li>定义duration，与time_point进行运算（一般是求和），运算后又是一个time_point，time_point之间本身可以大小比较</li>
<li>time_point之间作差，返回一个duration，可以用duration_cast转换类型，调用count()计算有多少tick。如果不转类型，system_clock的time_point一般是纳秒，用count的话很大。</li>
</ul>
</li>
</ul>
<h3 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h3><p>主要实现几个实例吧：</p>
<ul>
<li>实现时间格式化输出：<ul>
<li>当前时间</li>
<li>两小时后</li>
<li>两天后</li>
</ul>
</li>
<li>实现时间点大小比较</li>
<li>实现时间点运算count。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间类demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printft</span><span class="params">(chrono::system_clock::time_point time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> tt = chrono::system_clock::<span class="built_in">to_time_t</span>(time);</span><br><span class="line">    <span class="comment">//timepoint不能直接输出</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;timepoint&quot;&lt;&lt; time &lt;&lt;endl &lt;&lt; &quot;time:&quot; &lt;&lt; tt &lt;&lt;endl &lt;&lt; &quot;ctime:&quot;&lt;&lt;ctime(&amp;tt)&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;time:&quot;</span> &lt;&lt; tt &lt;&lt;endl &lt;&lt; <span class="string">&quot;ctime:&quot;</span>&lt;&lt;<span class="built_in">ctime</span>(&amp;tt)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//now</span></span><br><span class="line">    chrono::system_clock::time_point nowtime = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------now time----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(nowtime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义duration</span></span><br><span class="line">    <span class="function">chrono::hours <span class="title">twoh</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    chrono::time_point&lt;chrono::system_clock&gt; twohtime = nowtime+twoh;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------two hours after----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(twohtime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一天的间隔，一天的秒数是60*60*24</span></span><br><span class="line">    <span class="keyword">typedef</span> chrono::duration&lt;<span class="type">int</span>, std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; day;</span><br><span class="line">    <span class="function">day <span class="title">twod</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    chrono::time_point&lt;chrono::system_clock&gt; twodtime = nowtime+twod;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------two days after----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(twodtime);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------time_point之间比较大小----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = (twodtime&gt;nowtime)?<span class="string">&quot;大&quot;</span> : <span class="string">&quot;小&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;两天后时间比两天前要&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------timepoint之间作差转型查看时间点间隔tick----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;两天后和两天前间隔 &quot;</span>&lt;&lt;chrono::<span class="built_in">duration_cast</span>&lt;chrono::hours&gt;(twodtime-nowtime).<span class="built_in">count</span>()&lt;&lt;<span class="string">&quot; 小时&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;system_clock time_point不转换类型tick：&quot;</span>&lt;&lt;(twodtime-nowtime).<span class="built_in">count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">g++ -std=c++<span class="number">14</span> -o chrono_test chrono_test.cpp</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/chrono_test$ ./chrono_test</span><br><span class="line">--------------now time----------------------</span><br><span class="line">time:<span class="number">1664526100</span></span><br><span class="line">ctime:Fri Sep <span class="number">30</span> <span class="number">01</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------two hours after----------------------</span><br><span class="line">time:<span class="number">1664533300</span></span><br><span class="line">ctime:Fri Sep <span class="number">30</span> <span class="number">03</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------two days after----------------------</span><br><span class="line">time:<span class="number">1664698900</span></span><br><span class="line">ctime:Sun Oct  <span class="number">2</span> <span class="number">01</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------time_point之间比较大小----------------------</span><br><span class="line">两天后时间比两天前要大</span><br><span class="line">--------------timepoint之间作差转型查看时间点间隔tick----------------------</span><br><span class="line">两天后和两天前间隔 <span class="number">48</span> 小时</span><br><span class="line">system_clock time_point不转换类型tick：<span class="number">172800000000000</span><span class="comment">//这里可以看出是纳秒</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参宏va-list"><a href="#可变参宏va-list" class="headerlink" title="可变参宏va_list"></a>可变参宏va_list</h2><h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>在无法给出所有传递给函数的参数的类型和数目时，可以使用省略号（…）指定函数参数表。有如下几种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, ...)</span></span>; <span class="comment">//给出确定的几个参数，其他用省略号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a ...)</span></span>;            <span class="comment">//省略号前有或者没有逗号都是可以的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(...)</span></span>;                  <span class="comment">//也可以不确定任何参数，但和没有参数是不一样的</span></span><br></pre></td></tr></table></figure>

<p>最典型的应用就是printf函数，printf的声明和调用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format [,argument]... )</span></span>;    <span class="comment">//官方声明</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My name is %s, age %d.&quot;</span>, <span class="string">&quot;AnnieKim&quot;</span>, <span class="number">24</span>);   <span class="comment">//调用</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，第一个参数是必不可少的，因为它可以得到函数参数的地址入口，这样就可以取之后的参数。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可变参数是由宏实现的，但是由于硬件平台的不同，编译器的不同，宏的定义也不相同</span><br><span class="line">头文件&lt;stdarg.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * va_list;     <span class="comment">// TC中定义为void*</span></span><br><span class="line"><span class="comment">//为了满足需要内存对齐的系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n)    ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) - 1) ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ap指向第一个变参的位置，即将第一个变参的地址赋予ap</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v)    ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br><span class="line"><span class="comment">/*获取变参的具体内容，t为变参的类型，如有多个参数，则通过移动ap的指针来获得变参的地址，从而获得内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t)       ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )   </span></span><br><span class="line"><span class="comment">//清空va_list，即结束变参的获取</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) ( ap = (va_list)0 )   </span></span><br></pre></td></tr></table></figure>

<p>基本使用步骤：</p>
<ul>
<li>定义一个va_list类型的变量，变量是指向参数的指针。</li>
<li>va_start初始化刚定义的变量，第二个参数是<strong>最后一个</strong>显式声明的参数。</li>
<li>va_arg返回变长参数的值，第二个参数是该变长参数的<strong>类型</strong>。</li>
<li>va_end将第一步定义的va_list变量重置为NULL。</li>
</ul>
<p>注意问题：</p>
<p>（1）可变参数的类型和个数完全由程序代码控制,它并不能智能地识别不同参数的个数和类型；</p>
<p>（2）如果我们不需要一一详解每个参数，只需要将可变列表拷贝至某个缓冲，可用vsprintf函数；</p>
<p>（3）因为编译器对可变参数的函数的原型检查不够严格,对编程查错不利.不利于我们写出高质量的代码；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C 库函数 int vsprintf(char *str, const char *format, va_list arg) 使用参数列表发送格式化输出到字符串。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span></span><br><span class="line"><span class="function"><span class="comment">//即把参数列表中遍历到的一个一个参数，根据format格式写到str里。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">//例子</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">char</span> buffer[80]</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vspfunc</span><span class="params">(<span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   va_list aptr;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">va_start</span>(aptr, format);</span><br><span class="line">   ret = <span class="built_in">vsprintf</span>(buffer, format, aptr);</span><br><span class="line">   <span class="built_in">va_end</span>(aptr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">   <span class="type">float</span> f = <span class="number">27.0</span>;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">50</span>] = <span class="string">&quot;runoob.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">vspfunc</span>(<span class="string">&quot;%d %f %s&quot;</span>, i, f, str);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">5</span> <span class="number">27.000000</span> runoob.com</span><br></pre></td></tr></table></figure>

<p>还有vsnprintf，多了个size，size说明了str最多可写的字节，防止越界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="test-2"><a href="#test-2" class="headerlink" title="test"></a>test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试va_arg，va_arg不会自动结束，不会有=&quot;&quot;返回</span></span><br><span class="line"><span class="comment">/*错误代码，va_arg读完还读下去会内存错误</span></span><br><span class="line"><span class="comment">void valist(const char* str1,...)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    va_list vaList;</span></span><br><span class="line"><span class="comment">    va_start(vaList,str1);</span></span><br><span class="line"><span class="comment">    std::string str;</span></span><br><span class="line"><span class="comment">    while((str = va_arg(vaList,const char*))!=&quot;&quot;)</span></span><br><span class="line"><span class="comment">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">    va_end(vaList);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遵循古老的传统，要么加个结束元判断结束，要么让第一个参数指明参数个数手动结束</span></span><br><span class="line"><span class="comment">//加结束元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valist1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,str1);</span><br><span class="line">    std::string str = str1;<span class="comment">//va_arg从str1的下一个参数开始，str1这个参数自己获取</span></span><br><span class="line">    <span class="keyword">while</span>(str!=<span class="string">&quot;break&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">        str = <span class="built_in">va_arg</span>(vaList, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//获取下一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//结束     </span></span><br><span class="line">   <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valist2</span><span class="params">(<span class="type">int</span> arglen ,<span class="type">const</span> <span class="type">char</span>* str1,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,str1);</span><br><span class="line">    std::string str = str1;<span class="comment">//va_arg从str1的下一个参数开始，str1这个参数自己获取</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arglen;i++)<span class="comment">//i=1开始是因为第一个已经获取</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">        str = <span class="built_in">va_arg</span>(vaList, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//获取下一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;str&lt;&lt;std::endl;<span class="comment">//这里要多打印一次，因为最后一次取到参数没打印就退出了</span></span><br><span class="line">   <span class="comment">//结束     </span></span><br><span class="line">   <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">valist1</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;myfriend&quot;</span>,<span class="string">&quot;nihaoya&quot;</span>,<span class="string">&quot;break&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">valist2</span>(<span class="number">5</span>,<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;wish you&quot;</span>,<span class="string">&quot;happy&quot;</span>,<span class="string">&quot;health&quot;</span>,<span class="string">&quot;every day&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行情况</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ g++ -std=c++<span class="number">14</span> -o valist_test valist_test.cpp</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ ./valist_test</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">myfriend</span><br><span class="line">nihaoya</span><br><span class="line"></span><br><span class="line">hi</span><br><span class="line">wish you</span><br><span class="line">happy</span><br><span class="line">health</span><br><span class="line">every day</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vsprintf使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vsptest</span><span class="params">(<span class="type">char</span>* buffer,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="comment">//解析format这个格式，把后面的参数按照格式填入，格式中暗示了参数的类型</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(buffer,format,vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vsnptest</span><span class="params">(<span class="type">char</span>* buffer,<span class="type">size_t</span> size,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="comment">//解析format这个格式，把后面的参数按照格式填入，格式中暗示了参数的类型</span></span><br><span class="line">    <span class="built_in">vsnprintf</span>(buffer,size,format,vaList);<span class="comment">//测试一下这个size，看看会怎么样</span></span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsprintf-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *format1 = <span class="string">&quot;%s is %d years old, %s&quot;</span>;</span><br><span class="line">    <span class="built_in">vsptest</span>(buffer1,format1,<span class="string">&quot;jy&quot;</span>,<span class="number">20</span>,<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">    std::cout&lt;&lt;buffer1&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsnprintf-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer2[<span class="number">50</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *format2 = <span class="string">&quot;%s is %d years old, %s&quot;</span>;</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer2,<span class="number">10</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//只有10的size</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;只有10的buffer size： &quot;</span>&lt;&lt;buffer2&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer2,<span class="number">50</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//50</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;拥有50的buffer size： &quot;</span>&lt;&lt;buffer2&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size超出了buffer的大小会怎么样呢</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsnprintf，并且size超出了buffer的大小-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer3[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer3,<span class="number">50</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//有50的size</span></span><br><span class="line">    std::cout&lt;&lt;buffer3&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ g++ -std=c++<span class="number">14</span> -o vstest  vstest.cpp</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ ./vstest</span><br><span class="line">----------测试vsprintf-------------</span><br><span class="line">jy is <span class="number">20</span> years old, good!</span><br><span class="line"></span><br><span class="line">----------测试vsnprintf-------------</span><br><span class="line">只有<span class="number">10</span>的buffer size： xuepi is </span><br><span class="line">拥有<span class="number">50</span>的buffer size： xuepi is <span class="number">20</span> years old, nice!</span><br><span class="line"></span><br><span class="line">----------测试vsnprintf，并且size超出了buffer的大小-------------</span><br><span class="line">xuepi is <span class="number">20</span> years old, nice!</span><br><span class="line"><span class="comment">//可以看出即使超出了buffer的size也不会报错，而是继续向buffer拷贝，打印时因为首地址的关系会全打印出来</span></span><br><span class="line"><span class="comment">//这个size参数是给vsnprintf的，告诉它最多写多少进buffer，可以与buffer本身的大小无关，但一般会关联到buffer的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>四部曲，其中va_arg和vsprintf互相替换，看要哪个。va_arg就只能传一样的参数类型，可以做运算，vsprintf可以传不同的类型但是最后要写入一个char*的buffer。</p>
<p>也可以两个同时用，取完va_arg的参数，剩下的给vsprintf。</p>
<p>vsprintf和vsnprintf返回写入的字节数。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列本质上是在队列的基础上封装，添加阻塞的功能。主要就是一个普通的queue，然后用互斥锁和条件变量保护。条件变量是因为这个阻塞队列可以看成一个缓冲区，然后要生产者和消费者，因此条件变量替代信号量管理缓冲区。</p>
<p>当缓冲区已满时，生产者需要等待，由于是多个生产者竞争，所以要使用while-wait的等待方式。一旦push任务成功，就唤醒一个消费者线程。</p>
<p>当缓冲区已空时，消费者需要等待，和前面的方式一样。消费者还要支持超时处理，等待时间太长就不等待。</p>
<p>基本的操作都很简单，麻烦的地方在于关闭时的处理，要让在阻塞的线程退出，且不允许再操作，调用push和pop直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞队列version1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blockqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; que;</span><br><span class="line">    std::mutex mux;</span><br><span class="line">    std::condition_variable condprod;</span><br><span class="line">    std::condition_variable condcons;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">blockqueue</span>(<span class="type">int</span> maxsize = <span class="number">1024</span>):<span class="built_in">size</span>(maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(maxsize&gt;<span class="number">0</span>);<span class="comment">//初始化检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">blockqueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//queue没有clear操作，自己支持</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;task)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">(<span class="type">int</span> timeout)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">full</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">size</span>()&gt;=size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//插入元素，首先抢占互斥锁，但即使抢占了互斥锁也可能不能插入，队列可能是满的，这时要释放锁让消费者线程获得锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要用条件变量，用unique锁</span></span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;=size)<span class="comment">//避免虚假唤醒，notify_one一般不会导致虚假唤醒，但要随时最好准备。并且当要关闭时会notify_all</span></span><br><span class="line"> 		condprod.<span class="built_in">wait</span>(locker);<span class="comment">//等待唤醒</span></span><br><span class="line">    que.<span class="built_in">push</span>(task);<span class="comment">//插入元素</span></span><br><span class="line">    condcons.<span class="built_in">notify_one</span>();<span class="comment">//唤醒消费者</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T blockqueue&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>())</span><br><span class="line">        condcons.<span class="built_in">wait</span>(locker);</span><br><span class="line">    T task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T blockqueue&lt;T&gt;::<span class="built_in">pop</span>(<span class="type">int</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>())<span class="comment">//为空就等待，等待过程中如果超时就返回</span></span><br><span class="line">        <span class="keyword">if</span>(condcons.<span class="built_in">wait_for</span>(locker,std::chrono::<span class="built_in">seconds</span>(timeout)) == std::cv_status::timeout)<span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    T task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">close</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 当关闭时，我们的目标是要让所有的线程都退出，也就是不能被阻塞到push和pop里</span></span><br><span class="line"><span class="comment">    * 调用此函数的时机是，上层日志系统已经把任务都做完，然后关闭队列</span></span><br><span class="line"><span class="comment">    * 则调用这个函数后，所有想再次尝试push和pop的线程都不允许</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要锁住，然后clear队列</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">//做些事通知push和pop都不允许了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//close已经锁住了，不用锁了</span></span><br><span class="line">    <span class="comment">//高效的方式，swap一个空队列</span></span><br><span class="line">    std::queue&lt;T&gt; empty;</span><br><span class="line">    std::<span class="built_in">swap</span>(empty, que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面是一个较为完整的阻塞队列了，也是一般思考的形式，但还是有些没有完成的地方和不足。</p>
<p>首先我们思考一下，上层取任务的形式应该是循环pop，那么这个pop函数就需要返回一个成功或失败（在close后）的信息才能让上层线程结束循环，并且由于增加了超时处理，等待失败我们想什么都不返回，这和现在的代码不太相同。因此更好的方式是返回bool值，而取出的任务以引用参数形式传出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; task, <span class="type">int</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>())<span class="comment">//为空就等待，等待过程中如果超时就返回</span></span><br><span class="line">        <span class="keyword">if</span>(condcons.<span class="built_in">wait_for</span>(locker,std::chrono::<span class="built_in">seconds</span>(timeout)) == std::cv_status::timeout)<span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们思考一下怎么通知pop和push在close后直接退出，通常的方式是使用一个close信号，像线程池那样。最简单的方式就是在pop和push入口处设置判断，如果close就直接返回false(push直接return，不做任何事情)。然而：</p>
<ul>
<li>当上层一直调用完pop后，线程会卡在wait处，或者正在准备调用再次pop。</li>
<li>如果有生产者一直没抢夺到互斥锁，而被消费者占用，那么在上层pop结束后，很多的push可能会导致队列又满，从而push线程阻塞在wait处。</li>
</ul>
<p>我们先处理pop函数，我们必须唤醒所有在等待的消费者线程，然后让线程得知已close退出；对于没有在等待而是准备进入的线程，因为队列是空，不能让其进入while，否则会阻塞：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; task, <span class="type">int</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>() <span class="keyword">and</span> !isclose)<span class="comment">//为空就等待，等待过程中如果超时就返回。如果是关闭状态就不进入</span></span><br><span class="line">        <span class="keyword">if</span>(condcons.<span class="built_in">wait_for</span>(locker,std::chrono::<span class="built_in">seconds</span>(timeout)) == std::cv_status::timeout)<span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(isclose)<span class="comment">//关闭的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们处理push函数</p>
<ul>
<li>在关闭前，所有任务会被执行完然后消费者阻塞，这个操作由上层循环查看队列是否为空来做；注意这是日志系统析构时的操作，而消费者线程的循环是看pop的返回值，这样可以一直阻塞取任务直到超时或者close。在判断是否为空这个过程，既可以push也可以pop。</li>
<li>为空后在调用close前，有一段真空期可以push，同时也可以pop，这可能导致有些生产者阻塞了；</li>
<li>然后上层在执行完任务后调用close，close去抢占互斥锁，清空队列（那些真空期push的），设置信号，唤醒所有的消费者线程让它们退出。</li>
<li>由于队列清空了，此时while会被break，则唤醒阻塞的生产者并让其退出，且退出不写在while里，因为后来的生产者不会进入while，写外面让它们直接退出。这样维持队列是空，接下来的消费者线程因为进入while也退出了。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//插入元素，首先抢占互斥锁，但即使抢占了互斥锁也可能不能插入，队列可能是满的，这时要释放锁让消费者线程获得锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要用条件变量，用unique锁</span></span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;=size)<span class="comment">//避免虚假唤醒，notify_one一般不会导致虚假唤醒，但要随时最好准备。并且当要关闭时会notify_all</span></span><br><span class="line"> 		condprod.<span class="built_in">wait</span>(locker);<span class="comment">//等待唤醒</span></span><br><span class="line">    <span class="keyword">if</span>(isclose)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//不能插入元素</span></span><br><span class="line">    que.<span class="built_in">push</span>(task);<span class="comment">//插入元素</span></span><br><span class="line">    condcons.<span class="built_in">notify_one</span>();<span class="comment">//唤醒消费者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在close函数就出来了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">close</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 当关闭时，我们的目标是要让所有的线程都退出，也就是不能被阻塞到push和pop里</span></span><br><span class="line"><span class="comment">    * 调用此函数的时机是，上层日志系统已经把任务都做完，然后关闭队列</span></span><br><span class="line"><span class="comment">    * 则调用这个函数后，所有想再次尝试push和pop的线程都不允许</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要锁住，然后clear队列</span></span><br><span class="line">    que.<span class="built_in">clear</span>();</span><br><span class="line">    isclose = <span class="literal">true</span>;</span><br><span class="line">    condprod.<span class="built_in">notify_all</span>();</span><br><span class="line">    condcons.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在是最终版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blockqueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; que;</span><br><span class="line">    std::mutex mux;</span><br><span class="line">    std::condition_variable condprod;</span><br><span class="line">    std::condition_variable condcons;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">bool</span> isclose;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">blockqueue</span>(<span class="type">int</span> maxsize = <span class="number">1024</span>):<span class="built_in">size</span>(maxsize),<span class="built_in">isclose</span>(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(maxsize&gt;<span class="number">0</span>);<span class="comment">//初始化检查</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">blockqueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; task, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这是日志系统调用的函数，阻塞队列的pop不能调用，否则会死锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">full</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这是日志系统调用的函数，阻塞队列的push不能调用，否则会死锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> que.<span class="built_in">size</span>()&gt;=size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//插入元素，首先抢占互斥锁，但即使抢占了互斥锁也可能不能插入，队列可能是满的，这时要释放锁让消费者线程获得锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要用条件变量，用unique锁</span></span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">size</span>()&gt;=size)<span class="comment">//避免虚假唤醒，notify_one一般不会导致虚假唤醒，但要随时最好准备。并且当要关闭时会notify_all</span></span><br><span class="line"> 		condprod.<span class="built_in">wait</span>(locker);<span class="comment">//等待唤醒</span></span><br><span class="line">    <span class="keyword">if</span>(isclose)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//不能插入元素</span></span><br><span class="line">    que.<span class="built_in">push</span>(task);<span class="comment">//插入元素</span></span><br><span class="line">    condcons.<span class="built_in">notify_one</span>();<span class="comment">//唤醒消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>() <span class="keyword">and</span> !isclose)</span><br><span class="line">        condcons.<span class="built_in">wait</span>(locker);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isclose)<span class="comment">//关闭的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    </span><br><span class="line">    task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> blockqueue&lt;T&gt;::<span class="built_in">pop</span>(T&amp; task, <span class="type">int</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(que.<span class="built_in">empty</span>() <span class="keyword">and</span> !isclose)<span class="comment">//为空就等待，等待过程中如果超时就返回</span></span><br><span class="line">        <span class="keyword">if</span>(condcons.<span class="built_in">wait_for</span>(locker,std::chrono::<span class="built_in">seconds</span>(timeout)) == std::cv_status::timeout)<span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isclose)<span class="comment">//关闭的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    task = que.<span class="built_in">front</span>();</span><br><span class="line">    que.<span class="built_in">pop</span>();</span><br><span class="line">    condprod.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">close</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 当关闭时，我们的目标是要让所有的线程都退出，也就是不能被阻塞到push和pop里</span></span><br><span class="line"><span class="comment">    * 调用此函数的时机是，上层日志系统已经把任务都做完，然后关闭队列</span></span><br><span class="line"><span class="comment">    * 则调用这个函数后，所有想再次尝试push和pop的线程都不允许</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//要锁住，然后clear队列</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    isclose = <span class="literal">true</span>;<span class="comment">//修改信号</span></span><br><span class="line">	<span class="comment">//唤醒所有线程</span></span><br><span class="line">    condprod.<span class="built_in">notify_all</span>();</span><br><span class="line">    condcons.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> blockqueue&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//close已经锁住了，不用锁了</span></span><br><span class="line">    <span class="comment">//高效的方式，swap一个空队列</span></span><br><span class="line">    std::queue&lt;T&gt; empty;</span><br><span class="line">    std::<span class="built_in">swap</span>(empty, que);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="test-3"><a href="#test-3" class="headerlink" title="test"></a>test</h3><p>日志主要是写入字符串，这里就模拟字符串放入阻塞队列，然后取出打印</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;blockqueue&lt;string&gt;&gt; <span class="built_in">blockque</span>(<span class="keyword">new</span> <span class="built_in">blockqueue</span>&lt;string&gt;(<span class="number">1024</span>));<span class="comment">//主线程和消费者线程共享</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化消费者线程</span></span><br><span class="line">    <span class="built_in">thread</span>([blockque_ = blockque]&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">while</span>(blockque_-&gt;<span class="built_in">pop</span>(str))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread1 pop: &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">thread</span>([blockque_ = blockque]&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">while</span>(blockque_-&gt;<span class="built_in">pop</span>(str))</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread2 pop: &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化生产者线程</span></span><br><span class="line">    <span class="built_in">thread</span>([blockque_ = blockque]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        str = <span class="string">&quot;theard number[&quot;</span> + <span class="built_in">to_string</span>(i)+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        blockque_-&gt;<span class="built_in">push</span>(str);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;push: &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">thread</span>([blockque_ = blockque]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        str = <span class="string">&quot;theard number[&quot;</span> + <span class="built_in">to_string</span>(i)+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        blockque_-&gt;<span class="built_in">push</span>(str);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;push: &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//等一下生产者</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//调用close前，要等线程做完</span></span><br><span class="line">    <span class="keyword">while</span>(!blockque-&gt;<span class="built_in">empty</span>());</span><br><span class="line">    </span><br><span class="line">    blockque-&gt;<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试close后还能不能push</span></span><br><span class="line">    <span class="built_in">thread</span>([blockque_ = blockque]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string str;</span><br><span class="line">        str = <span class="string">&quot;theard number[&quot;</span> + <span class="built_in">to_string</span>(i)+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        blockque_-&gt;<span class="built_in">push</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    string s = (blockque-&gt;<span class="built_in">empty</span>())?<span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;close 之后 push，现在阻塞队列是否为空：&quot;</span>&lt;&lt; s &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">sun2@ubuntu:~/Desktop/websever_test/blockqueue$ g++ -std=c++<span class="number">14</span> -o blockque_test  blockque_test.cpp -lpthread<span class="comment">//编译</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/blockqueue$ ./blockque_test</span><br><span class="line">push: theard number[<span class="number">0</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">0</span>]</span><br><span class="line">push: theard number[<span class="number">20</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">20</span>]</span><br><span class="line">push: theard number[<span class="number">1</span>]</span><br><span class="line">push: theard number[<span class="number">21</span>]</span><br><span class="line">push: theard number[<span class="number">22</span>]</span><br><span class="line">push: theard number[<span class="number">2</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">1</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">21</span>]</span><br><span class="line">push: theard number[<span class="number">23</span>]</span><br><span class="line">push: theard number[<span class="number">3</span>]</span><br><span class="line">push: theard number[<span class="number">24</span>]</span><br><span class="line">push: theard number[<span class="number">4</span>]</span><br><span class="line">push: theard number[<span class="number">25</span>]</span><br><span class="line">push: theard number[<span class="number">5</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">22</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">2</span>]</span><br><span class="line">push: theard number[<span class="number">26</span>]</span><br><span class="line">push: theard number[<span class="number">6</span>]</span><br><span class="line">push: theard number[<span class="number">27</span>]</span><br><span class="line">push: theard number[<span class="number">7</span>]</span><br><span class="line">push: theard number[<span class="number">28</span>]</span><br><span class="line">push: theard number[<span class="number">8</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">23</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">3</span>]</span><br><span class="line">push: theard number[<span class="number">29</span>]</span><br><span class="line">push: theard number[<span class="number">9</span>]</span><br><span class="line">push: theard number[<span class="number">30</span>]</span><br><span class="line">push: theard number[<span class="number">10</span>]</span><br><span class="line">push: theard number[<span class="number">31</span>]</span><br><span class="line">push: theard number[<span class="number">11</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">24</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">4</span>]</span><br><span class="line">push: theard number[<span class="number">32</span>]</span><br><span class="line">push: theard number[<span class="number">12</span>]</span><br><span class="line">push: theard number[<span class="number">33</span>]</span><br><span class="line">push: theard number[<span class="number">13</span>]</span><br><span class="line">push: theard number[<span class="number">34</span>]</span><br><span class="line">push: theard number[<span class="number">14</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">25</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">5</span>]</span><br><span class="line">push: theard number[<span class="number">35</span>]</span><br><span class="line">push: theard number[<span class="number">15</span>]</span><br><span class="line">push: theard number[<span class="number">36</span>]</span><br><span class="line">push: theard number[<span class="number">16</span>]</span><br><span class="line">push: theard number[<span class="number">37</span>]</span><br><span class="line">push: theard number[<span class="number">17</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">26</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">6</span>]</span><br><span class="line">push: theard number[<span class="number">38</span>]</span><br><span class="line">push: theard number[<span class="number">18</span>]</span><br><span class="line">push: theard number[<span class="number">39</span>]</span><br><span class="line">push: theard number[<span class="number">19</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">27</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">7</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">28</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">8</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">29</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">9</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">30</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">10</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">31</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">11</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">32</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">12</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">33</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">13</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">34</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">14</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">35</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">15</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">36</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">16</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">37</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">17</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">38</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">18</span>]</span><br><span class="line">thread1 pop: theard number[<span class="number">39</span>]</span><br><span class="line">thread2 pop: theard number[<span class="number">19</span>]</span><br><span class="line">close 之后 push，现在阻塞队列是否为空：<span class="literal">true</span><span class="comment">//这说明close之后，所有的生产者都放不进去</span></span><br></pre></td></tr></table></figure>

<p>可以看到pop和push都顺利完成，且close之后进程能正常退出，且任务不会再push进去，效果还可以。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>我们再来梳理一下close部分：</p>
<ul>
<li>在调用close前，日志系统会使用循环判断empty()，必须要队列为空即任务做完才close。</li>
<li>当empty的时候，有的消费者线程会阻塞，有的消费者线程可能还没结束执行，准备重新进入。而生产者依旧可以放入任务，并且消费者也可以执行任务。</li>
<li>一旦close函数抢占到了互斥锁，接下来所有的push和pop都是禁止的：<ul>
<li>首先close会把队列清空，无论是原来已经执行完了，还是生产者在真空期放了些任务进去但没做的（关闭后放进来的不算）</li>
<li>然后唤醒所有在等待的消费者，清空后队列大小是0：<ul>
<li>对于生产者，在真空期可能会大量放入任务导致阻塞，这里要唤醒；也有的后来想push的，因为队列大小是0不会进入while，直接根据close信号退出。</li>
<li>对于消费者，把阻塞的线程唤醒退出，但注意有的消费者可能正准备从头进入，唤醒后由于队列是空不能在让其进入while阻塞，不然会死锁。因此while的判断要加入close信号，要退出就不进入等待，直接退出。</li>
</ul>
</li>
<li>这样阻塞队列就关闭了，遗留的任务会写完，在阻塞的线程会退出，想调用的线程也会直接退出。</li>
</ul>
</li>
</ul>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>write()函数是日志系统中最重要的函数，进行主要的业务处理。我们给日志系统几点要求：</p>
<ul>
<li>分级别，比如info、debug、warning、error，可以设定日志系统的等级，级别越低，能写入的越多。这要求write函数传入一个指示level的变量。</li>
<li>像printf一样支持各种形式的信息，比如float、char*、int，这可以使用可变参宏来实现，只需要向write函数传入一个format，然后传入一系列参数即可。</li>
<li>不把所有的日志都只写入一个文件：<ul>
<li>当换了一天时，关闭原来的文件，新建一个文件，这要求系统记录day信息；</li>
<li>当一天的日志行数（一个文件行数）过多时，换一个文件；</li>
<li>文件命名的一个实例为：2022-10-03_log0.txt；其中log0表示这是这一天的第一份文件</li>
</ul>
</li>
<li>一行日志信息的一个实例为：[info]2022-10-03_21:25:09：this is info</li>
</ul>
<p>首先要处理一下时间的格式化，前面使用的ctime函数可以获得我们想要的信息，但并不是这里提到的格式化，并且我们还需要单独的day的信息。一个想法是使用一个结构体，解析ctime的返回值，把年月日时分秒存在结构体里。实际上这个结构体在c++中已经有了，是time.h中的tm结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TM_DEFINED</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">          <span class="type">int</span> tm_sec;       <span class="comment">/* 秒 – 取值区间为[0,59] */</span></span><br><span class="line">          <span class="type">int</span> tm_min;       <span class="comment">/* 分 - 取值区间为[0,59] */</span></span><br><span class="line">          <span class="type">int</span> tm_hour;      <span class="comment">/* 时 - 取值区间为[0,23] */</span></span><br><span class="line">          <span class="type">int</span> tm_mday;      <span class="comment">/* 一个月中的日期 - 取值区间为[1,31] */</span></span><br><span class="line">          <span class="type">int</span> tm_mon;       <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span></span><br><span class="line">          <span class="type">int</span> tm_year;      <span class="comment">/* 年份，其值等于实际年份减去1900 */</span></span><br><span class="line">          <span class="type">int</span> tm_wday;      <span class="comment">/* 星期 – 取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span><br><span class="line">          <span class="type">int</span> tm_yday;      <span class="comment">/* 从每年的1月1日开始的天数 – 取值区间为[0,365]，其中0代表1月1日，1代表1月2日，以此类推 */</span></span><br><span class="line">          <span class="type">int</span> tm_isdst;     <span class="comment">/* 夏令时标识符，实行夏令时的时候，tm_isdst为正。不实行夏令时的进候，tm_isdst为0；不了解情况时，tm_isdst()为负。*/</span></span><br><span class="line">          &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TM_DEFINED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，年份是从1900年起至今多少年，而不是直接存储如2011年，月份从0开始的，0表示一月，星期也是从0开始的， 0表示星期日，1表示星期一。</p>
<p>一般有两个函数来支持tm结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> * <span class="built_in">gmtime</span>(<span class="type">const</span> <span class="type">time_t</span> *timer);                                          </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> * <span class="built_in">localtime</span>(<span class="type">const</span> <span class="type">time_t</span> * timer);</span><br></pre></td></tr></table></figure>

<ul>
<li>日历时间（Calendar Time）是通过time_t数据类型来表示的，用time_t表示的时间（日历时间）是从一个时间点（例如：1970年1月1日0时0分0秒）到此时的秒数。</li>
<li>gmtime()函数是将日历时间转化为世界标准时间（即格林尼治时间），并返回一个tm结构体来保存这个时间</li>
<li>localtime()函数是将日历时间转化为本地时间。比如现在用gmtime()函数获得的世界标准时间是2005年7月30日7点18分20秒，那么我用localtime()函数在中国地区获得的本地时间会比时间标准时间晚8个小时，即2005年7月30日15点18分20秒。</li>
</ul>
<p>则一般的使用方式就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃include <span class="string">&quot;time.h&quot;</span></span><br><span class="line">＃include <span class="string">&quot;stdio.h&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *local;<span class="comment">//初始化tm结构体，这里是指针，因为localtime返回的是指针</span></span><br><span class="line"><span class="type">time_t</span> t;<span class="comment">//初始化一个time_t</span></span><br><span class="line">t=<span class="built_in">time</span>(<span class="literal">NULL</span>);<span class="comment">//使用time()函数获取日历时间</span></span><br><span class="line">local = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//传入time_t的地址，获取当地时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Local hour is: %d\n&quot;</span>,local-&gt;tm_hour);</span><br></pre></td></tr></table></figure>

<p>现在开始写一个write函数，我们假设上层已经保存了day信息、定义了最大行数和当前行数，且打开了一个文件fp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//fopen、fclose</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *nowtime;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    nowtime = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在写之前看要不要创建新文件</span></span><br><span class="line">    <span class="comment">//如果当前日期变了，一般来说判断day就可以了；或是行数已满，就换一个文件</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来涉及行数的改写，以及文件的切换，要互斥。因为实际上一个线程切换文件即可，如果有线程在切换其他线程不可动</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    linecounts++;<span class="comment">//先++，因为行数是从0开始的，++后刚好判断是不是满了，这个操作要互斥</span></span><br><span class="line">    <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday || linecounts == maxlines)<span class="comment">//如果换了一天或行数满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> newname[<span class="number">36</span>];<span class="comment">//用snprintf，不能用string了</span></span><br><span class="line">        <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;</span><br><span class="line">            logday = nowtime-&gt;tm_mday;<span class="comment">//修改天</span></span><br><span class="line">            linecounts = <span class="number">0</span>;<span class="comment">//换文件了</span></span><br><span class="line">            filenum = <span class="number">0</span>;<span class="comment">//文件份数从0开始</span></span><br><span class="line">            <span class="comment">//为了格式化命名，要用format，这里用snprintf写入str</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_log%05d.txt&quot;</span>,nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//行数满了</span></span><br><span class="line">        &#123;</span><br><span class="line">            linecounts = <span class="number">0</span>;</span><br><span class="line">            filenum++;</span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_log%05d.txt&quot;</span>,nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fflush</span>(logfp);<span class="comment">//在关闭文件前要把文件缓存区的内容写完</span></span><br><span class="line">        <span class="built_in">fclose</span>(logfp);</span><br><span class="line">        logfp = <span class="built_in">fopen</span>(newname,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logfp != <span class="literal">nullptr</span>);<span class="comment">//创建失败报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    locker.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始写入，注意日志系统是单例的，如果还用到共享变量要锁，这里不用了</span></span><br><span class="line">    <span class="type">char</span> infobuffer[<span class="number">128</span>];<span class="comment">//一般一行日志没那么长，128足够了</span></span><br><span class="line">    <span class="type">char</span> timebuffer[<span class="number">36</span>];<span class="comment">//时间头</span></span><br><span class="line">    string allinfo;</span><br><span class="line">    <span class="comment">//分级</span></span><br><span class="line">    <span class="keyword">switch</span>(level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[debug]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[warning]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[error]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加时间信息</span></span><br><span class="line">    <span class="built_in">snprintf</span>(timebuffer,<span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_%02d:%02d:%02d：&quot;</span>,</span><br><span class="line">             nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday,</span><br><span class="line">            nowtime-&gt;tm_hour,nowtime-&gt;tm_min,nowtime-&gt;tm_sec);<span class="comment">//只精确到秒，更具体的信息交给内容体现</span></span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(timebuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(infobuffer,<span class="number">128</span>,format,vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(infobuffer)+<span class="string">&quot;\n&quot;</span>;<span class="comment">//注意换个行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分异步还是同步</span></span><br><span class="line">    <span class="comment">//异步由于异步线程还没有创建，先不管，但也可以知道形式</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(isAsync)</span></span><br><span class="line"><span class="comment">    	blockque.push(allinfo);</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">fputs</span>(allinfo.<span class="built_in">c_str</span>(),logfp);<span class="comment">//要互斥，这部分忘记了，日志系统处已发现并改正</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于异步线程的push，这里可以做一些思考：</p>
<ul>
<li>如果异步是像上面这种形式，那么工作线程可能会因为一个loginfo就阻塞，反倒不如直接写入；</li>
<li>但如果要阻塞时不阻塞直接写入，就会导致时间顺序不对；</li>
<li>一种解决方案是，直接再创建一个线程执行push，让线程阻塞；但这样的结果就是每个工作线程可能因为info又创建一个线程；</li>
<li>这样的结果就是资源相当浪费（不是不可行，前面的close的操作也支持了这样的push），或许不如就让时间顺序不一致。即当阻塞队列满了就执行同步写（不过这样前面对close里push讨论的很多就没意义辣）</li>
<li>或许最好的办法就是让阻塞队列长度和异步线程个数取得平衡，反正就是工作函数不要因为一个push阻塞了。</li>
</ul>
<h3 id="test-4"><a href="#test-4" class="headerlink" title="test"></a>test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span><span class="comment">//fopen、fclose</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一些上层变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxlines = <span class="number">256</span>;</span><br><span class="line"><span class="type">int</span> linecounts = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> logday = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> filenum = <span class="number">0</span>;</span><br><span class="line">mutex mux;</span><br><span class="line">FILE *logfp = <span class="built_in">fopen</span>(<span class="string">&quot;tmp.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *nowtime;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    nowtime = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在写之前看要不要创建新文件</span></span><br><span class="line">    <span class="comment">//如果当前日期变了，一般来说判断day就可以了；或是行数已满，就换一个文件</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来涉及行数的改写，以及文件的切换，要互斥。因为实际上一个线程切换文件即可，如果有线程在切换其他线程不可动</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    linecounts++;<span class="comment">//先++，因为行数是从0开始的，++后刚好判断是不是满了，这个操作要互斥</span></span><br><span class="line">    <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday || linecounts == maxlines)<span class="comment">//如果换了一天或行数满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> newname[<span class="number">36</span>];<span class="comment">//用snprintf，不能用string了</span></span><br><span class="line">        <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;</span><br><span class="line">            logday = nowtime-&gt;tm_mday;<span class="comment">//修改天</span></span><br><span class="line">            linecounts = <span class="number">0</span>;<span class="comment">//换文件了</span></span><br><span class="line">            filenum = <span class="number">0</span>;<span class="comment">//文件份数从0开始</span></span><br><span class="line">            <span class="comment">//为了格式化命名，要用format，这里用snprintf写入str</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_log%05d.txt&quot;</span>,nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//行数满了</span></span><br><span class="line">        &#123;</span><br><span class="line">            linecounts = <span class="number">0</span>;</span><br><span class="line">            filenum++;</span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_log%05d.txt&quot;</span>,nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fflush</span>(logfp);<span class="comment">//在关闭文件前要把文件缓存区的内容写完</span></span><br><span class="line">        <span class="built_in">fclose</span>(logfp);</span><br><span class="line">        logfp = <span class="built_in">fopen</span>(newname,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logfp != <span class="literal">nullptr</span>);<span class="comment">//创建失败报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    locker.<span class="built_in">unlock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始写入，注意日志系统是单例的，如果还用到共享变量要锁，这里不用了</span></span><br><span class="line">    <span class="type">char</span> infobuffer[<span class="number">128</span>];<span class="comment">//一般一行日志没那么长，128足够了</span></span><br><span class="line">    <span class="type">char</span> timebuffer[<span class="number">36</span>];<span class="comment">//时间头</span></span><br><span class="line">    string allinfo;</span><br><span class="line">    <span class="comment">//分级</span></span><br><span class="line">    <span class="keyword">switch</span>(level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[debug]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[warning]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[error]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加时间信息</span></span><br><span class="line">    <span class="built_in">snprintf</span>(timebuffer,<span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_%02d:%02d:%02d：&quot;</span>,</span><br><span class="line">             nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday,</span><br><span class="line">            nowtime-&gt;tm_hour,nowtime-&gt;tm_min,nowtime-&gt;tm_sec);<span class="comment">//只精确到秒，更具体的信息交给内容体现</span></span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(timebuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(infobuffer,<span class="number">128</span>,format,vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(infobuffer)+<span class="string">&quot;\n&quot;</span>;<span class="comment">//注意换个行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分异步还是同步</span></span><br><span class="line">    <span class="comment">//异步由于异步线程还没有创建，先不管，但也可以知道形式</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(isAsync)</span></span><br><span class="line"><span class="comment">    	blockque.push(allinfo);</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">fputs</span>(allinfo.<span class="built_in">c_str</span>(),logfp);<span class="comment">//要互斥，这部分忘记了，日志系统处已发现并改正</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1024</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        level = i%<span class="number">4</span>;</span><br><span class="line">        <span class="built_in">write</span>(level,<span class="string">&quot;hello, this is num [%d], for %s %d&quot;</span>,i,<span class="string">&quot;level&quot;</span>,level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(logfp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun2@ubuntu:~/Desktop/websever_test/logwrite$ g++ -std=c++<span class="number">14</span> -o write write_test.cpp<span class="comment">//编译</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/logwrite$ ./write</span><br><span class="line"><span class="comment">//结果就不放了，产生了刚好四个文件（tmp不算了），内容都是正确的，就不截图了</span></span><br></pre></td></tr></table></figure>

<h2 id="日志系统log"><a href="#日志系统log" class="headerlink" title="日志系统log"></a>日志系统log</h2><p>上面的write其实有些bug，就是当调用write时，先判断要不要切换文件，再看是写还是放入阻塞队列。这对于同步写是对的，但对于异步写，可能异步线程还没写完一个文件，就被write函数切换了文件，这实际上是不对的，因为放入阻塞队列不代表写进文件了，这里再把write操作解耦，分同步异步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span>		<span class="comment">//opendir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">//mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Log</span>();<span class="comment">//单例模式构造函数私有，成员函数才能调用构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Log</span>(Log <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Log&amp; <span class="keyword">operator</span>=(Log <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Log</span>();<span class="comment">//关闭...//析构函数实际上和构造函数一样，可以private，因为本质上是成员函数调用</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">instance</span><span class="params">()</span></span>;<span class="comment">//单例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数声明和定义，只能有一个使用默认参数，如果函数的声明和定义是分开的，那缺省函数不能在函数声明和定义中同时出现</span></span><br><span class="line">    <span class="comment">//默认参数在函数声明中提供，当又有声明又有定义时，定义中不允许默认参数（定义中的默认参数是无用的，必须传入参数才能找到匹配的函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level=<span class="number">1</span>, <span class="type">const</span> <span class="type">char</span>* fpath = <span class="string">&quot;./log&quot;</span>,<span class="type">int</span> maxqueue_size=<span class="number">1024</span>,<span class="type">int</span> threadnum=<span class="number">1</span>)</span></span>;<span class="comment">//不能用构造函数传参，使用一个init传参初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setlevel</span><span class="params">(<span class="type">int</span> level)</span></span>&#123;loglevel = level;&#125;<span class="comment">//修改level的接口，只允许主线程修改，因此不用互斥</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlevel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> loglevel;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isopen</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> logisopen;&#125;<span class="comment">//看是否打开日志的接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createthread</span><span class="params">(<span class="type">int</span> threadnum)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">logthread</span><span class="params">()</span></span>;<span class="comment">//异步线程的回调函数，需要是staic，没有this隐藏参数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span>;<span class="comment">//同步写，解耦</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">asyncwrite</span><span class="params">()</span></span>;<span class="comment">//互斥写，不用lambda表达式，因为要用到log类的变量，并修改它们</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changefile</span><span class="params">(<span class="keyword">struct</span> tm *nowtime)</span></span>;<span class="comment">//write函数的解耦</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* <span class="built_in">gettime</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> maxlines = <span class="number">52000</span>;</span><br><span class="line">    FILE *logfp;</span><br><span class="line">    <span class="type">int</span> linecounts;</span><br><span class="line">    <span class="type">int</span> filenum;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path;</span><br><span class="line">    <span class="type">int</span> logday;</span><br><span class="line">    <span class="type">bool</span> isasync;</span><br><span class="line">    <span class="type">bool</span> logisopen;</span><br><span class="line">    <span class="type">int</span> loglevel;</span><br><span class="line">    unique_ptr&lt;blockqueue&lt;string&gt;&gt; blockque;<span class="comment">//不用lambda表达式可以用uniqueptr，因为一个指针一起用。用指针是因为要根据队列长度动态构造</span></span><br><span class="line">    mutex mux;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们想用一个函数封装write函数，比如logoinfo调用level1的write，并且还要能判断loglevel支不支持</span></span><br><span class="line"><span class="comment">//但函数封装变参函数，为了传递可变参数，实际上还要修改write的实现，不如用宏来实现，使用##__VA_ARGS__传递可变参数，让编译器把宏替换为真实的函数</span></span><br><span class="line"><span class="comment">//##__VA_ARGS__的优点是，对于宏调用，如果format是一个字符串也即后面没有可变参数，## 操作将使预处理器（preprocessor）去除掉它前面的那个逗号。</span></span><br><span class="line"><span class="comment">//宏与类无关了，这里必须isopen了才能使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;isopen() &amp;&amp; log-&gt;getlevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>关于为什么要用do-while(0)使用宏，主要是希望多语句宏函数在大部分时刻正确展开执行：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoyilong2007101095/article/details/77067686">(29条消息) 宏定义为什么要使用do{……}while(0)形式_土豆爸爸的博客-CSDN博客</a>。宏的换行用\。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">Log* <span class="title">Log::instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Log instance;<span class="comment">//调用构造函数</span></span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span>* Log::<span class="built_in">gettime</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *nowtime;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    nowtime = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">return</span> nowtime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::changefile</span><span class="params">(<span class="keyword">struct</span> tm *nowtime)</span><span class="comment">//完成行数增加、判断文件切换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接下来涉及行数的改写，以及文件的切换，要互斥。因为实际上一个线程切换文件即可，如果有线程在切换其他线程不可动</span></span><br><span class="line">    <span class="comment">//unique_lock&lt;mutex&gt; locker(mux);互斥交给上层，因为fputs也要互斥</span></span><br><span class="line">    linecounts++;<span class="comment">//先++，因为行数是从0开始的，++后刚好判断是不是满了，这个操作要互斥</span></span><br><span class="line">    <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday || linecounts == maxlines)<span class="comment">//如果换了一天或行数满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> newname[<span class="number">48</span>];<span class="comment">//用snprintf，不能用string了</span></span><br><span class="line">        <span class="keyword">if</span>(logday != nowtime-&gt;tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;</span><br><span class="line">            logday = nowtime-&gt;tm_mday;<span class="comment">//修改天</span></span><br><span class="line">            linecounts = <span class="number">0</span>;<span class="comment">//换文件了</span></span><br><span class="line">            filenum = <span class="number">0</span>;<span class="comment">//文件份数从0开始</span></span><br><span class="line">            <span class="comment">//为了格式化命名，要用format，这里用snprintf写入str</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">48</span>, <span class="string">&quot;%s/%d-%02d-%02d_log%05d.txt&quot;</span>,<span class="comment">//补充一个前缀-文件夹</span></span><br><span class="line">                     path, nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//行数满了</span></span><br><span class="line">        &#123;</span><br><span class="line">            linecounts = <span class="number">0</span>;</span><br><span class="line">            filenum++;</span><br><span class="line">            <span class="built_in">snprintf</span>(newname, <span class="number">48</span>, <span class="string">&quot;%s/%d-%02d-%02d_log%05d.txt&quot;</span>,</span><br><span class="line">                     path, nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">fflush</span>(logfp);<span class="comment">//在关闭文件前要把文件缓存区的内容写完</span></span><br><span class="line">        <span class="built_in">fclose</span>(logfp);</span><br><span class="line">        logfp = <span class="built_in">fopen</span>(newname,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="built_in">assert</span>(logfp != <span class="literal">nullptr</span>);<span class="comment">//创建失败报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//locker.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *nowtime = <span class="built_in">gettime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-----------------根据传入的信息整理成一行日志-------------------------</span></span><br><span class="line">    <span class="type">char</span> infobuffer[<span class="number">128</span>];<span class="comment">//一般一行日志没那么长，128足够了</span></span><br><span class="line">    <span class="type">char</span> timebuffer[<span class="number">36</span>];<span class="comment">//时间头</span></span><br><span class="line">    string allinfo;</span><br><span class="line">    <span class="comment">//分级</span></span><br><span class="line">    <span class="keyword">switch</span>(level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[debug]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[warning]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[error]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            allinfo += <span class="string">&quot;[info]&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加时间信息</span></span><br><span class="line">    <span class="built_in">snprintf</span>(timebuffer,<span class="number">36</span>, <span class="string">&quot;%d-%02d-%02d_%02d:%02d:%02d：&quot;</span>,</span><br><span class="line">             nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday,</span><br><span class="line">            nowtime-&gt;tm_hour,nowtime-&gt;tm_min,nowtime-&gt;tm_sec);<span class="comment">//只精确到秒，更具体的信息交给内容体现</span></span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(timebuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//写内容</span></span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(infobuffer,<span class="number">128</span>,format,vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">    </span><br><span class="line">    allinfo += <span class="built_in">string</span>(infobuffer)+<span class="string">&quot;\n&quot;</span>;<span class="comment">//注意换个行</span></span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分异步还是同步，要不要切换文件交给异步线程判断 </span></span><br><span class="line">    <span class="keyword">if</span>(isasync &amp;&amp; !blockque-&gt;<span class="built_in">full</span>())</span><br><span class="line">    	blockque-&gt;<span class="built_in">push</span>(allinfo);<span class="comment">//异步直接插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在写之前看要不要创建新文件</span></span><br><span class="line">    	<span class="comment">//如果当前日期变了，一般来说判断day就可以了；或是行数已满，就换一个文件</span></span><br><span class="line">        </span><br><span class="line">        lock_guard&lt;mutex&gt; <span class="built_in">locker</span>(mux);<span class="comment">//互斥</span></span><br><span class="line">        <span class="built_in">changefile</span>(nowtime);<span class="comment">//直接交给该函数完成</span></span><br><span class="line">        <span class="built_in">fputs</span>(allinfo.<span class="built_in">c_str</span>(),logfp);<span class="comment">//操作文件缓冲区，也要互斥</span></span><br><span class="line">        <span class="built_in">fflush</span>(logfp);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>()<span class="comment">//初始化一部分变量</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始行数为-1，因为是先++然后判断再写入，初始为0的话，第一份文件会少一行，</span></span><br><span class="line">    <span class="comment">//比如最大行为2，初始为0；则++，写入；++就换文件了，只写了一行，所以初始要是-1。换文件后置为0</span></span><br><span class="line">    <span class="comment">//因为换文件后没++了，写了一行，就是正确的</span></span><br><span class="line">    linecounts = <span class="number">-1</span>;</span><br><span class="line">    filenum = <span class="number">0</span>;</span><br><span class="line">    isasync = <span class="literal">false</span>;</span><br><span class="line">    blockque = <span class="literal">nullptr</span>;</span><br><span class="line">    logday = <span class="number">0</span>;</span><br><span class="line">    logfp = <span class="literal">nullptr</span>;</span><br><span class="line">    logisopen = <span class="literal">false</span>;<span class="comment">//init才算打开</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    logisopen = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(isasync)<span class="comment">//异步的话要让线程退出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!blockque-&gt;<span class="built_in">empty</span>());<span class="comment">//等待工作完成</span></span><br><span class="line">        </span><br><span class="line">        blockque-&gt;<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(logfp)<span class="comment">//如果打开了文件要关闭</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于其他线程可能正在使用，因此要等待互斥锁</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">        <span class="built_in">fflush</span>(logfp);<span class="comment">//刷新缓冲区</span></span><br><span class="line">        <span class="built_in">fclose</span>(logfp);</span><br><span class="line">        logfp = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::logthread</span><span class="params">()</span><span class="comment">//异步线程回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">asyncwrite</span>();<span class="comment">//调用类成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* fpath,<span class="type">int</span> maxqueue_size,<span class="type">int</span> threadnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(logisopen == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//只允许init一次</span></span><br><span class="line">    logisopen = <span class="literal">true</span>;</span><br><span class="line">    loglevel = level;</span><br><span class="line">    <span class="keyword">if</span>(maxqueue_size&gt;<span class="number">0</span>)<span class="comment">//有阻塞队列则异步</span></span><br><span class="line">    &#123;</span><br><span class="line">        isasync = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//创建阻塞队列</span></span><br><span class="line">        unique_ptr&lt;blockqueue&lt;string&gt;&gt; <span class="built_in">que</span>(<span class="keyword">new</span> <span class="built_in">blockqueue</span>&lt;string&gt;(maxqueue_size));</span><br><span class="line">        blockque = <span class="built_in">move</span>(que);<span class="comment">//移动赋值</span></span><br><span class="line">        <span class="built_in">createthread</span>(threadnum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        isasync = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *nowtime;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    nowtime = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    </span><br><span class="line">    logday = nowtime-&gt;tm_mday;</span><br><span class="line">    path = fpath;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> filename[<span class="number">48</span>];<span class="comment">//用snprintf，不能用string了</span></span><br><span class="line">    <span class="built_in">snprintf</span>(filename, <span class="number">48</span>, <span class="string">&quot;%s/%d-%02d-%02d_log%05d.txt&quot;</span>,<span class="comment">//补充一个前缀-文件夹</span></span><br><span class="line">             path, nowtime-&gt;tm_year+<span class="number">1900</span>, nowtime-&gt;tm_mon+<span class="number">1</span>, nowtime-&gt;tm_mday, filenum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初步打开文件，没有文件夹就创建文件夹</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">opendir</span>(path) == <span class="literal">NULL</span>)<span class="comment">//如果文件夹不存在</span></span><br><span class="line">        <span class="built_in">mkdir</span>(path,<span class="number">0777</span>);<span class="comment">//0777是最大的访问权</span></span><br><span class="line"></span><br><span class="line">    logfp = <span class="built_in">fopen</span>(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="built_in">assert</span>(logfp!=<span class="literal">nullptr</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::asyncwrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(blockque-&gt;<span class="built_in">pop</span>(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* nowtime = <span class="built_in">gettime</span>();</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//互斥</span></span><br><span class="line">        <span class="built_in">changefile</span>(nowtime);<span class="comment">//每写一行判断要不要换文件</span></span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(),logfp);</span><br><span class="line">        <span class="built_in">fflush</span>(logfp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::createthread</span><span class="params">(<span class="type">int</span> threadnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">thread</span>(logthread).<span class="built_in">detach</span>();<span class="comment">//因为内部函数采用单例调用，logthread不用传入this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="test-5"><a href="#test-5" class="headerlink" title="test"></a>test</h2><p>所有的都准备完成了，这里分同步和异步测试一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------同步测试------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">init</span>(<span class="number">0</span>,<span class="string">&quot;./同步log&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试时先把日志最大行数改成100</span></span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;num %d debug&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">thread</span>([]&#123;</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_INFO</span>(<span class="string">&quot;num %d info&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;num %d ERROR&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_WARN</span>(<span class="string">&quot;num %d warn&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------主线程退出---------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，编译时要把log.cpp手动链接进来，它们是独立的文件</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/log$ g++ -std=c++<span class="number">14</span> -o test test.cpp log.cpp  -lpthread</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/log$ ./test</span><br><span class="line">----------同步测试------------------</span><br><span class="line">------主线程退出---------</span><br><span class="line"><span class="comment">//结果很ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------异步测试------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">init</span>(<span class="number">0</span>,<span class="string">&quot;./异步log&quot;</span>,<span class="number">100</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试时先把日志最大行数改成100</span></span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;num %d debug&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">thread</span>([]&#123;</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_INFO</span>(<span class="string">&quot;num %d info&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;num %d ERROR&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_WARN</span>(<span class="string">&quot;num %d warn&quot;</span>,i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------主线程退出---------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更有测试效果，我们在asyncwrite函数里加一个打印</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::asyncwrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(blockque-&gt;<span class="built_in">pop</span>(str))</span><br><span class="line">    &#123;</span><br><span class="line">    	cout&lt;&lt;<span class="string">&quot;async doing: &quot;</span>&lt;&lt;str&lt;&lt;endl;<span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* nowtime = <span class="built_in">gettime</span>();</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;<span class="comment">//互斥</span></span><br><span class="line">        <span class="built_in">changefile</span>(nowtime);<span class="comment">//每写一行判断要不要换文件</span></span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(),logfp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sun2@ubuntu:~/Desktop/websever_test/log$ g++ -std=c++<span class="number">14</span> -o test2 test2.cpp log.cpp  -lpthread</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/log$ ./test2</span><br><span class="line">----------异步测试------------------</span><br><span class="line">------主线程退出---------</span><br><span class="line">async doing: [debug]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">07</span>：num <span class="number">0</span> debug</span><br><span class="line"></span><br><span class="line">async doing: [info]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">07</span>：num <span class="number">0</span> info</span><br><span class="line"></span><br><span class="line">async doing: [warning]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">07</span>：num <span class="number">0</span> warn</span><br><span class="line"></span><br><span class="line">async doing: [error]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">07</span>：num <span class="number">0</span> ERROR</span><br><span class="line"></span><br><span class="line">async doing: [debug]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">08</span>：num <span class="number">1</span> debug</span><br><span class="line"></span><br><span class="line">async doing: [info]<span class="number">2022</span><span class="number">-10</span><span class="number">-04</span>_06:<span class="number">41</span>:<span class="number">08</span>：num <span class="number">1</span> info</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>异步测试效果还是不错的，但是最后一个文件因为日志系统没有析构，导致缓冲区没有flush，所以最后一个文件没有写入，并且异步线程也不会自动退出。现在我们再修改一下test文件。<strong>注：现在已经改为每写一行fflush一次，因为当logerror时上层往往随后会终止程序，要记录必须刷新。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------异步测试------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">init</span>(<span class="number">0</span>,<span class="string">&quot;./异步log&quot;</span>,<span class="number">100</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试时先把日志最大行数改成100</span></span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;num %d debug&quot;</span>,i);</span><br><span class="line">         <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">thread</span>([]&#123;</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_INFO</span>(<span class="string">&quot;num %d info&quot;</span>,i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;num %d ERROR&quot;</span>,i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">thread</span>([]&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">70000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">LOG_WARN</span>(<span class="string">&quot;num %d warn&quot;</span>,i);</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).<span class="built_in">detach</span>();</span><br><span class="line">	<span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">close</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;------主线程退出---------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里让生产者线程快速产生大量的任务，让异步线程工作，然后等一段时间（主要是让生产者线程产生完工作，不至于调用时阻塞队列还是空的），再手动调用close。现在，所有的文件都写成功，并且异步线程退出成功。</p>
<p>如果让每个异步线程写一行都停一会（sleep(1)），使得在调用close后任务还没写完，可以发现close会等待异步线程把任务做完，说明关闭日志系统很成功。</p>
<h1 id="关于close和析构"><a href="#关于close和析构" class="headerlink" title="关于close和析构"></a>关于close和析构</h1><p>对于阻塞队列和日志系统，都使用了析构函数调用close，实际上日志系统的close函数是我新增的，因为我需要手动在程序里close，没办法让主线程退出时而异步线程还存在时析构而调用close。这是因为：</p>
<p><code>日志系统的static变量，只有当程序全部退出才会析构。</code></p>
<p>这会导致一些问题，就是手动close之后，主线程和异步线程都退出了会导致析构再调用一次close。在阻塞队列里，两次close不会导致什么问题，但在日志系统会有问题：<code>free(): double free detected in tcache 2</code>，即释放已释放的资源。在close函数中，原本没有这一行：<code>logfp = nullptr;</code>，而fclose并不会把fp置为nullptr，那么第二次close函数的if(logfp)就成立，又调用一次fclose，导致报错。</p>
<p>这里引起了一些思考：在服务器运行的时候，没有什么办法让服务器主动退出调用析构函数，ctrl+c会直接终止进程。在最初版本的tinywebsever中是捕获了ctrl+c的信号，处理成stop的一个flag通知服务器结束，c++11的版本直接不能通知服务器停下，必须强行终止。</p>
<p>因此，不如都手动close，而析构函数不做处理。可以使用一个线程接收终止输入，需要终止时就让这个线程调用一系列的close函数，让其他线程退出，之后调用析构函数就不会产生二次close的冲突。</p>
<p><strong>这是否会浪费RAII带来的作用呢？</strong></p>
<p>注意，我们手动调用close只是为了让线程不会阻塞，因为线程存在时又不会析构，不析构就没办法close然后就矛盾了。对于不会引起阻塞的类，还是可以放在析构函数里的。比如日志系统就需要手动调用close，这可能会导致一些其他资源需要在日志系统前关闭，那就导致这些资源也需要在日志系统close前手动close。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>头文件<code>#include &lt;mysql/mysql.h&gt;</code></p>
<p>数据库的一个连接句柄的初始化有三步</p>
<ul>
<li>定义一个sql指针：<code>MYSQL *sql = nullptr;</code></li>
<li>用这个指针初始化一个sql结构体，返回一个指向这个结构体的指针：<code>sql = mysql_init(sql);</code></li>
<li>init后就connect，连接数据库，返回一个可用连接<code>sql = mysql_real_connect(sql, host,user, pwd,dbName, port, unix_socket, client_flag);</code><ul>
<li>host是主机名或IP，如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。</li>
<li>如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。</li>
<li>client_flag的值通常为0，其他标志可以实现特定的功能</li>
</ul>
</li>
</ul>
<p>然后这个sql句柄就可以用来执行语句了，最后在不使用的时候还需要调用<code>mysql_close(sql);</code>释放连接。并且，为了避免在使用库完成应用程序后发生内存泄漏(例如，在关闭与服务器的连接之后)，可以显式调用mysql_library_end()。这样可以执行内存 Management 以清理和释放库使用的资源。</p>
<p>上面就是一个连接的建立，对于多个连接，我们可以把多个连接初始化后放入一个队列里，这样就构成了一个连接池。对于这样一个共享的连接池，就需要互斥操作。而这一个队列又和阻塞队列不同，队列是可能空的但不可能会因为满而阻塞——可用的连接是一定的，push回去不会多。在阻塞队列中使用了两个条件变量管理了空&#x2F;满缓冲区的阻塞，这里只需要管理空，也即pop操作的阻塞。可以用一个条件变量，也可以用一个信号量。两种方法都比较简单，不过为了熟悉一下条件变量，还是使用条件变量（信号量就使用<code>sem_post(&amp;semId_)、sem_wait(&amp;semId_)、sem_init(&amp;semId_, 0, MAX_CONN_)</code>）。</p>
<p>当上层需要登录或注册时，会尝试获取一个连接，然后使用完后释放连接。这里的问题是，当没有连接可用时，是阻塞等待还是直接返回错误。或许使用折中会好一点，即用cond.wait_for()阻塞一段时间。当释放一个连接后就尝试唤醒一个阻塞的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sqlconnpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex mux;</span><br><span class="line">    condition_variable cond;</span><br><span class="line">    queue&lt;MYSQL*&gt; connque;</span><br><span class="line">    <span class="type">int</span> maxconn;</span><br><span class="line">    <span class="type">int</span> freecount;</span><br><span class="line">    <span class="built_in">Sqlconnpool</span>();</span><br><span class="line">    ~<span class="built_in">Sqlconnpool</span>()&#123;&#125;<span class="comment">//析构函数实际上和构造函数一样，可以private，因为本质上是成员函数调用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sqlconnpool</span>(<span class="type">const</span> Sqlconnpool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sqlconnpool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sqlconnpool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> Sqlconnpool*  <span class="title">instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MYSQL* <span class="title">getconn</span><span class="params">(<span class="type">int</span> timeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">freeconn</span><span class="params">(MYSQL* conn)</span></span>;</span><br><span class="line">    <span class="comment">//无法使用构造函数传参，用init，默认参数写声明中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host,<span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd,<span class="type">const</span> <span class="type">char</span>* dbname,<span class="type">int</span> connsize=<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">conncount</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Sqlconnpool::<span class="built_in">Sqlconnpool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    maxconn = <span class="number">0</span>;</span><br><span class="line">    freecount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sqlconnpool* <span class="title">Sqlconnpool::instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Sqlconnpool instance;</span><br><span class="line">    <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL* <span class="title">Sqlconnpool::getconn</span><span class="params">(<span class="type">int</span> timeout = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(timeout&gt;=<span class="number">0</span>);<span class="comment">//</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(connque.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">if</span>(cond.<span class="built_in">wait_for</span>(locker, chrono::<span class="built_in">seconds</span>(timeout)) == std::cv_status::timeout)<span class="comment">//超时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Sqlconnpool busy&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    MYSQL* sql = connque.<span class="built_in">front</span>();</span><br><span class="line">    connque.<span class="built_in">pop</span>();</span><br><span class="line">    freecount--;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sqlconnpool::freeconn</span><span class="params">(MYSQL* conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(conn);<span class="comment">//防止放入nullptr</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    connque.<span class="built_in">push</span>(conn);</span><br><span class="line">    freecount++;</span><br><span class="line">    cond.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个get线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sqlconnpool::conncount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> maxconn-freecount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sqlconnpool::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host,<span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd,<span class="type">const</span> <span class="type">char</span>* dbname,<span class="type">int</span> connsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(connsize&gt;<span class="number">0</span>);</span><br><span class="line">    maxconn = connsize;</span><br><span class="line">    freecount = connsize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxconn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//三步初始化</span></span><br><span class="line">        MYSQL* sql = <span class="literal">nullptr</span>;</span><br><span class="line">        sql = <span class="built_in">mysql_init</span>(sql);</span><br><span class="line">        <span class="keyword">if</span>(!sql)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sql number %d init error&quot;</span>,i);</span><br><span class="line">            <span class="built_in">assert</span>(sql);<span class="comment">//终止报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        sql = <span class="built_in">mysql_real_connect</span>(sql,host,user,pwd,dbname,port,<span class="literal">nullptr</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sql)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sql number %d connect error&quot;</span>,i);</span><br><span class="line">            <span class="built_in">assert</span>(sql);<span class="comment">//终止报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        connque.<span class="built_in">push</span>(sql);<span class="comment">//放入的一定不是nullptr</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sqlconnpool::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mux)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(freecount != maxconn)<span class="comment">//必须要等待所有连接都放回来，直接close再执行查询程序会崩溃</span></span><br><span class="line">        cond.<span class="built_in">wait</span>(locker);<span class="comment">//每放回一个连接唤醒一次，然后判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!connque.<span class="built_in">empty</span>())<span class="comment">//逐个关闭连接</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mysql_close</span>(connque.<span class="built_in">front</span>());</span><br><span class="line">        connque.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_library_end</span>();<span class="comment">//释放库的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLRAII_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlRAII</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL* conn;<span class="comment">//保存连接好的sql</span></span><br><span class="line">    Sqlconnpool* connpool;<span class="comment">//保存连接池</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlRAII</span>(MYSQL** sql,Sqlconnpool* sqlpool,<span class="type">int</span> timeout = <span class="number">0</span>)<span class="comment">//传入sql指针的地址，即&amp;sql，获取连接后传出去</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(sqlpool);<span class="comment">//必须先建好连接池</span></span><br><span class="line">        </span><br><span class="line">        *sql = sqlpool-&gt;<span class="built_in">getconn</span>(timeout);<span class="comment">//可能会超时</span></span><br><span class="line">        <span class="comment">//为了用户自行getconn和使用sqlraii的统一，这里统一让用户在上层处理sql为nullptr的情况</span></span><br><span class="line">        conn = *sql;</span><br><span class="line">        connpool = sqlpool;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SqlRAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn)<span class="comment">//有连接就释放</span></span><br><span class="line">        	connpool-&gt;<span class="built_in">freeconn</span>(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="test-6"><a href="#test-6" class="headerlink" title="test"></a>test</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlraii.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">( Sqlconnpool* sqlpool,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            MYSQL* sql;</span><br><span class="line">            <span class="comment">//SqlRAII(&amp;sql,sqlpool,0);这个会出错，下面介绍</span></span><br><span class="line">    		<span class="function">SqlRAII <span class="title">myconn</span><span class="params">(&amp;sql,sqlpool,<span class="number">0</span>)</span></span>;<span class="comment">//这样才行</span></span><br><span class="line">            <span class="keyword">if</span>(sql==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;haha, thread &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; can&#x27;t get the connection\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;haha, thread &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; gets the connection\n&quot;</span>;</span><br><span class="line">                 <span class="built_in">sleep</span>(i);</span><br><span class="line">                 MYSQL_FIELD *fields = <span class="literal">nullptr</span>;</span><br><span class="line">    		    MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span>* order = <span class="string">&quot;SELECT username, passwd FROM user&quot;</span>;<span class="comment">//命令不用加分号</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql,order))</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;query error\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">mysql_store_result</span>(sql);<span class="comment">//存储完整的结果集</span></span><br><span class="line">                <span class="type">int</span> j = <span class="built_in">mysql_num_fields</span>(res);<span class="comment">//获取列数</span></span><br><span class="line">                fields = <span class="built_in">mysql_fetch_fields</span>(res);<span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;thread &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;：&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                   	cout&lt;&lt;fields[k].name&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//输出列名</span></span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">while</span>(MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)</span><br><span class="line">                        cout&lt;&lt;row[k]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    cout&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">mysql_free_result</span>(res);<span class="comment">//释放结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sqlconnpool* sqlpool = Sqlconnpool::<span class="built_in">instance</span>();</span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">init</span>(<span class="number">0</span>,<span class="string">&quot;./log&quot;</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    sqlpool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">3306</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;Qq1424277869!&quot;</span>,<span class="string">&quot;myWebSever&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sqlconnpool init successfully!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//调线程池</span></span><br><span class="line">    <span class="function">threadpool <span class="title">threadp</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;<span class="number">23</span>;i++)</span><br><span class="line">    	threadp.<span class="built_in">addTask</span>(<span class="built_in">bind</span>(task,sqlpool,i));<span class="comment">//按序放入，其实就前十个能取得连接</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;add task successfully!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//老样子，在调用close前等一下线程的工作初始化</span></span><br><span class="line">    <span class="comment">//手动调用close</span></span><br><span class="line">    threadp.<span class="built_in">close</span>();<span class="comment">//通知任务做完自己退出，不会阻塞，注意封装了一层close。</span></span><br><span class="line">    sqlpool-&gt;<span class="built_in">close</span>();<span class="comment">//等待所有连接放回，因为要逐个关闭连接，会阻塞</span></span><br><span class="line">    Log::<span class="built_in">instance</span>()-&gt;<span class="built_in">close</span>();<span class="comment">//日志一般最后关闭</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;quit----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//线程池的析构函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用到了线程池的close，重写一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终版threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pool</span><span class="comment">//封装三个资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">        std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line">        <span class="type">bool</span> isclose = <span class="literal">false</span>;<span class="comment">//默认值是false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;pool&gt; pool_;<span class="comment">//共享指针，pool_是一个指针指向pool结构体，这个指针用于线程池操作资源</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>):<span class="built_in">pool_</span>(std::<span class="built_in">make_shared</span>&lt;pool&gt;())<span class="comment">//以make_shared的方式new一个对象给pool_指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([<span class="type">pool_t</span> = pool_]&#123;<span class="comment">//现在要按值捕获，相当于拷贝构造共享指针，计数+1，且指向相同内容</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(<span class="type">pool_t</span>-&gt;mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();<span class="comment">//抢占锁</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">pool_t</span>-&gt;isclose)</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         <span class="type">pool_t</span>-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        pool_-&gt;taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pool_-&gt;isclose = <span class="literal">true</span>;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>为什么说<code>SqlRAII(&amp;sql,sqlpool,0);</code>会出错呢，主要是临时变量作用域的问题，这条语句会给sql赋值，但是临时变量只存活于这条语句里，然后就析构了，会把sql再放回连接池，其他的线程无论多少都能再拿到这个sql连接句柄。</li>
<li>这样，多个用户可能同时操作一个句柄，可能会引发问题；并且当调用连接池的close函数时，总是会发现连接池是满了，直接把所有的连接都关闭，这样在关闭后执行查询等操作就会出错，直接导致程序崩溃。因此要用一个有名变量，作用于线程的存活空间中。</li>
</ul>
<p>编译一下，执行发现挺正常的，日志系统也正常，有一半能获取连接，一半不能获取连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++<span class="number">14</span> -o test test.cpp log.cpp sqlconnpool.cpp -lpthread `mysql_config --cflags --libs`<span class="comment">//要链接mysql库</span></span><br></pre></td></tr></table></figure>

<p>我们改变一下，现在设置成可以超时10秒，可以发现这十秒钟内，在前面线程执行完放回连接后，剩下的线程又可以获取连接了。只有3个线程不能获取连接。则超时的设置也测试成功。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SqlRAII <span class="title">myconn</span><span class="params">(&amp;sql,sqlpool,<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sun2@ubuntu:~/Desktop/websever_test/sqlpool$ g++ -std=c++<span class="number">14</span> -o test test.cpp log.cpp sqlconnpool.cpp -lpthread `mysql_config --cflags --libs`</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/sqlpool$ ./test</span><br><span class="line">sqlconnpool init successfully!</span><br><span class="line">add task successfully!</span><br><span class="line">haha, thread <span class="number">3</span> gets the connection</span><br><span class="line">haha, thread <span class="number">4</span> gets the connection</span><br><span class="line">haha, thread <span class="number">6</span> gets the connection</span><br><span class="line">haha, thread <span class="number">5</span> gets the connection</span><br><span class="line">haha, thread <span class="number">7</span> gets the connection</span><br><span class="line">haha, thread <span class="number">8</span> gets the connection</span><br><span class="line">haha, thread <span class="number">9</span> gets the connection</span><br><span class="line">haha, thread <span class="number">10</span> gets the connection</span><br><span class="line">haha, thread <span class="number">11</span> gets the connection</span><br><span class="line">haha, thread <span class="number">12</span> gets the connection</span><br><span class="line">thread <span class="number">3</span>：username passwd </span><br><span class="line">name passwd </span><br><span class="line">jysama jysama </span><br><span class="line">woshinidie cjy </span><br><span class="line">haha, thread <span class="number">13</span> gets the connection</span><br><span class="line">thread <span class="number">4</span>：username passwd </span><br><span class="line">name passwd </span><br><span class="line">jysama jysama </span><br><span class="line">woshinidie cjy </span><br><span class="line">haha, thread <span class="number">14</span> gets the connection</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h2 id="socket-Linux"><a href="#socket-Linux" class="headerlink" title="socket-Linux"></a>socket-Linux</h2><h3 id="ping测试"><a href="#ping测试" class="headerlink" title="ping测试"></a>ping测试</h3><p><strong>测试终端之间的网络有没有联通。</strong></p>
<p>这里先测试一下两台机器能不能互相ping通，首先是两台虚拟机之间：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/ping%E8%99%9A%E6%8B%9F%E6%9C%BA1.png" alt="image-20221008161104460"></p>
<p>如果图片加载失败可以看文字描述：具体的，使用ifconfig查看虚拟机ip，除了本地host还有一块网卡，另一块网卡<code>ens33</code>内容的<code>inet 192.168.248.131</code>就是ip。然后两个虚拟机互相ping ip就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sun2@ubuntu:~/Desktop$ ifconfig</span><br><span class="line">ens33: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.248</span><span class="number">.131</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.248</span><span class="number">.255</span><span class="comment">//inet 后是ip</span></span><br><span class="line">        inet6 fe80::e754:<span class="number">7748</span>:<span class="number">53</span>d4:<span class="number">6f</span>8e  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:<span class="number">1</span>a:ab:<span class="number">67</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">154</span>  bytes <span class="number">24552</span> (<span class="number">24.5</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">156</span>  bytes <span class="number">16227</span> (<span class="number">16.2</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span><span class="comment">//本地local</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">175</span>  bytes <span class="number">14698</span> (<span class="number">14.6</span> KB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">175</span>  bytes <span class="number">14698</span> (<span class="number">14.6</span> KB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于lo网卡:</span></span><br><span class="line"><span class="comment">是一个虚拟的网络接口，并没有对应的物理网卡，我们知道它的地址是 127.0.0.1 ，主要作为本地地址使用。 在程序开发中，我们常常把服务启动在这个地址上，通过浏览器来访问 127.0.0.1 或其解析的 localhost 来访问本地的服务进行调试。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>至于这里的ip，实际上使用了NAT转换共享了host主机的ip。虚拟机的网络设置有三种模式，可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/systemnet123/articles/2640883.html">VMware Network Adapter VMnet1&#x2F;8详解 - larryle - 博客园 (cnblogs.com)</a></p>
<p>其中NAT转换使用了vmnet8，在host主机的cmd中输入ipconfig，可以看到vmnet8的网段，以及本机的ip：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示部分内容</span></span><br><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">21</span>ea:<span class="number">6</span>a23:d725:a9b7%<span class="number">16</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span><span class="number">.248</span><span class="number">.1</span><span class="comment">//vmnet8，使用NAT转换的虚拟机的网关</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line"></span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::b835:<span class="number">29</span>a:<span class="number">672</span>:<span class="number">3928</span>%<span class="number">12</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span><span class="number">.31</span><span class="number">.213</span><span class="comment">//本机ip</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . : <span class="number">192.168</span><span class="number">.31</span><span class="number">.1</span><span class="comment">//网关</span></span><br></pre></td></tr></table></figure>

<p>现在我们试一下host主机和虚拟机的ping。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/ping%E8%99%9A%E6%8B%9F%E6%9C%BA2.png" alt="image-20221008162027010"></p>
<p>也没什么问题。</p>
<h3 id="Linux下套接字api简单介绍"><a href="#Linux下套接字api简单介绍" class="headerlink" title="Linux下套接字api简单介绍"></a>Linux下套接字api简单介绍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用头文件</span></span><br><span class="line">&lt;sys/types.h&gt;                    <span class="comment">//primitive system data types(包含很多类型重定义，如pid_t、int8_t等)  </span></span><br><span class="line">&lt;sys/socket.h&gt;         <span class="comment">//与套接字相关的函数声明和结构体定义，如socket()、bind()、connect()及struct sockaddr的定义等</span></span><br><span class="line">&lt;sys/ioctl.h&gt;             <span class="comment">//I/O控制操作相关的函数声明，如ioctl()</span></span><br><span class="line">&lt;stdlib.h&gt;                   <span class="comment">//某些结构体定义和宏定义，如EXIT_FAILURE、EXIT_SUCCESS等</span></span><br><span class="line">&lt;netdb.h&gt;                  <span class="comment">//某些结构体定义、宏定义和函数声明，如struct hostent、struct servent、gethostbyname()、gethostbyaddr()、herror()等</span></span><br><span class="line">&lt;netinet/in.h&gt;          <span class="comment">//某些结构体声明、宏定义，如struct sockaddr_in、PROTO_ICMP、INADDR_ANY等</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用函数</span></span><br><span class="line"><span class="built_in">socket</span>()</span><br><span class="line">       头文件：</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">       函数原型：</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function">          domain: 协议类型，一般为AF_INET</span></span><br><span class="line"><span class="function">          type: socket类型</span></span><br><span class="line"><span class="function">          protocol:用来指定socket所使用的传输协议编号，通常设为<span class="number">0</span>即可</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bind()</span></span><br><span class="line"><span class="function">       头文件：</span></span><br><span class="line"><span class="function">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="function">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function">       函数原型：</span></span><br><span class="line"><span class="function">       int bind(int sockfd, struct sockaddr *my_addr, int addrlen)</span></span><br><span class="line"><span class="function">          sockfd: socket描述符</span></span><br><span class="line"><span class="function">          my_addr:是一个指向包含有本机ip地址和端口号等信息的sockaddr类型的指针</span></span><br><span class="line"><span class="function">          addrlen:常被设为sizeof(struct sockaddr)</span></span><br><span class="line"><span class="function">          返回值：若成功则为<span class="number">0</span>，若出错则为<span class="number">-1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">connect()</span></span><br><span class="line"><span class="function">       头文件：</span></span><br><span class="line"><span class="function">       #include &lt;sys/types.h&gt; </span></span><br><span class="line"><span class="function">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function">       函数原型：</span></span><br><span class="line"><span class="function">       int connect(int sockfd, struct sockaddr *serv_addr, int addrlen)</span></span><br><span class="line"><span class="function">           sockfd: 目的服务器的socket描述符</span></span><br><span class="line"><span class="function">           serv_addr:包含目的机器ip地址和端口号的指针</span></span><br><span class="line"><span class="function">           addrlen:sizeof(struct sockaddr)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">listen()</span></span><br><span class="line"><span class="function">       头文件：</span></span><br><span class="line"><span class="function">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function">       函数原型：</span></span><br><span class="line"><span class="function">       int listen(int sockfd, int backlog);</span></span><br><span class="line">           sockfd:<span class="built_in">socket</span>()系统调用返回的socket描述符</span><br><span class="line">           backlog:指定在请求队列中的最大请求数，进入的连接请求将在队列中等待<span class="built_in">accept</span>()它们。</span><br><span class="line"></span><br><span class="line"><span class="built_in">accept</span>()</span><br><span class="line">       头文件：  </span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#inlcude <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">       函数原型：</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span> </span></span><br><span class="line"><span class="function">           sockfd:是被监听的socket描述符</span></span><br><span class="line"><span class="function">           addr:通常是一个指向sockaddr_in变量的指针，该变量用来存放提出连接请求服务的主机的信息</span></span><br><span class="line"><span class="function">           addrlen:sizeof(struct sockaddr_in)</span></span><br><span class="line"><span class="function">      成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－<span class="number">1</span>，相应地设定全局变量errno。</span></span><br><span class="line"><span class="function">               </span></span><br><span class="line"><span class="function">send()</span></span><br><span class="line"><span class="function">        头文件：</span></span><br><span class="line"><span class="function">        #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function">        函数原型：</span></span><br><span class="line"><span class="function">        int send(int sockfd, const void *msg, int len, int flags);</span></span><br><span class="line">           sockfd:用来传输数据的socket描述符</span><br><span class="line">           msg:要发送数据的指针</span><br><span class="line">           flags: <span class="number">0</span></span><br><span class="line">     </span><br><span class="line"><span class="built_in">recv</span>()</span><br><span class="line">        头文件：</span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">        函数原型:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function">          sockfd：接收数据的socket描述符</span></span><br><span class="line"><span class="function">          buf:存放数据的缓冲区</span></span><br><span class="line"><span class="function">          len:缓冲的长度</span></span><br><span class="line"><span class="function">          flags:<span class="number">0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sendto()</span></span><br><span class="line"><span class="function">       头文件：</span></span><br><span class="line"><span class="function">       #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="function">       #include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="function">       函数原型：</span></span><br><span class="line"><span class="function">       int sendto(int sockfd, const void *msg, int len, unsigned int flags, const struct sockaddr *to, int tolen);</span></span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line"><span class="built_in">recvfrom</span>()</span><br><span class="line">       头文件：</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line">       函数原型：</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">int</span> fromlen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       头文件：</span></span><br><span class="line"><span class="function">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span></span><br><span class="line"><span class="function">       <span class="type">int</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">       <span class="type">int</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">关闭已连接的套接字只是导致相应描述符的引用计数减<span class="number">1</span>，如果引用计数扔大于<span class="number">0</span>，这个close调用并不会让TCP连接上发送一个FIN。</span><br><span class="line">如果确实想发送一个FIN，可以用shutdown函数。</span><br><span class="line">    </span><br><span class="line"><span class="built_in">shutdown</span>()</span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span></span><br><span class="line"><span class="function">该函数的行为依赖howto参数的值：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SHUT_RD</span></span><br><span class="line"><span class="function">套接字中不再有数据可接收，而且套接字接收缓冲区中的现有数据都被丢弃。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SHUT_WR</span></span><br><span class="line"><span class="function">对于TCP套接字，称为半关闭（half-close）。当前在套接字发送缓冲区中的数据将被发送掉，后跟TCP的正常连接终止序列。（不管套接字的引用计数是否等于0）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SHUT_RDWR</span></span><br><span class="line"><span class="function">等于调用shutdown函数两次，连接的读半部和写半部都关闭。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。</li>
<li>bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</li>
<li>通过 listen() 函数可以让套接字进入被动监听状态，所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。<code>所以，执行accept的是被动套接字，执行connect的是主动套接字。</code></li>
<li>作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</li>
<li>当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。<code>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。</code>后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</li>
<li>两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</li>
<li>recv函数和send函数提供了read和write函数一样的功能，不同的是他们提供了四个参数。前面的三个参数和read、write函数是一样的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="comment">//sockaddr在头文件#include &lt;sys/socket.h&gt;中定义，sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;  </span><br><span class="line">     <span class="type">sa_family_t</span> sin_family;<span class="comment">//地址族</span></span><br><span class="line">　　  <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//14字节，包含套接字中的目标地址和端口信息               </span></span><br><span class="line">　　 &#125;; </span><br><span class="line"><span class="comment">//sockaddr_in在头文件#include&lt;netinet/in.h&gt;或#include &lt;arpa/inet.h&gt;中定义，该结构体解决了sockaddr的缺陷，把port和addr 分开储存在两个变量中</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line"><span class="type">__uint8_t</span> sin_len;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">in_port_t</span> sin_port;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;</span><br><span class="line"><span class="type">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line">addr.sin_len=<span class="built_in">sizeof</span>(addr);<span class="comment">//socket字节长度</span></span><br><span class="line">sin_family指代协议族，在socket编程中一般是AF_INET</span><br><span class="line">sin_port存储端口号（使用网络字节顺序）</span><br><span class="line">sin_addr存储IP地址，使用in_addr这个数据结构</span><br><span class="line">sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define AF_UNIX 1 //local to host (pipes, portals) </span></span><br><span class="line"><span class="comment">#define AF_INET 2  //internetwork: UDP, TCP, etc. </span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">#define AF_ATM 22 // Native ATM Services</span></span><br><span class="line"><span class="comment">#define AF_INET6 23 // Internetwork Version 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//in_addr，头文件#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line">结构体in_addr 用来表示一个<span class="number">32</span>位的IPv4地址</span><br><span class="line"><span class="type">in_addr_t</span> 一般为 <span class="number">32</span>位的<span class="type">unsigned</span> <span class="type">int</span>，其字节顺序为网络顺序（network byte ordered)，即该无符号整数采用大端字节序</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>　</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;　<span class="comment">//n指network</span></span><br><span class="line"><span class="comment">//将一个无符号短整型数值转换为网络字节序，即大端模式(big-endian)</span></span><br><span class="line">htons 是把你机器上的整数转换成“网络字节序”， 网络字节序是 big-endian，也就是整数的高位字节存放在内存的低地址处。 </span><br><span class="line">而我们常用的 <span class="function">x86 <span class="title">CPU</span> <span class="params">(intel, AMD)</span> 电脑是 little-endian,也就是整数的低位字节放在内存的低字节处。</span></span><br><span class="line"><span class="function">举个例子：</span></span><br><span class="line"><span class="function">假定你的port是0x1234,在网络字节序里，这个port放到内存中就应该显示成　　</span></span><br><span class="line"><span class="function">addr 	0x12	<span class="comment">//12字节是高位，放低地址</span></span></span><br><span class="line"><span class="function">addr+1　 0x34　　</span></span><br><span class="line"><span class="function">而在x86电脑上，0x1234放到内存中实际是：　　</span></span><br><span class="line"><span class="function">addr 	0x34</span></span><br><span class="line"><span class="function">addr+1　0x12　</span></span><br><span class="line"><span class="function">htons 的用处就是把实际内存中的整数存放方式调整成“网络字节序”的方式。</span></span><br><span class="line"><span class="function"><span class="comment">//为了程序可扩展性，不管电脑是何种方式对齐，都使用这个函数</span></span></span><br><span class="line"><span class="function">ntohs相反</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>　　</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;　</span><br><span class="line"><span class="comment">//同htons，本函数将一个32位数从主机字节顺序转换成网络字节顺序。</span></span><br><span class="line">ntohl相反</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>　　</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line">将一个点分十进制的IP转换成一个长整数型数（u_long类型），也即in_addr结构体中s_addr的类型（大端排列）</span><br><span class="line"></span><br><span class="line">inet_addr的参数是字符串，返回值是网络字节序，htonl的参数是<span class="number">32b</span>it的ip，并且是主机字节序</span><br><span class="line">    </span><br><span class="line"><span class="comment">//n指network</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *strptr, <span class="keyword">struct</span> in_addr *addrptr)</span></span>; <span class="comment">//将字符串ip转换成无符号长整型,并转换成网络字节序</span></span><br><span class="line"><span class="built_in">inet_addr</span>(<span class="string">&quot;*.*.*.*&quot;</span>) <span class="comment">//将字符串ip转换成无符号长整型(unsigned long int)，并转换成网络字节序。</span></span><br><span class="line"></span><br><span class="line">inet_addr与inet_aton不同在于，他的返回值为转换后的<span class="number">32</span>位网络字节序二进制值，而不是作为出参返回，这样存在一个问题，他的返回值返回的有效IP地址为<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>到<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span>，如果函数出错，返回常量值INADDR_NONE（这个值一般为一个<span class="number">32</span>位均为<span class="number">1</span>的值），这意味着点分二进制数串<span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span>（IPv4的有限广播地址）不能由此函数进行处理。   </span><br><span class="line">    </span><br><span class="line">inet_ntoa是inet_aton和（几乎和）inet_addr相反的函数</span><br><span class="line"><span class="function"><span class="type">char</span> FAR* <span class="title">inet_ntoa</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">struct</span> in_addr in</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">inet_pton <span class="comment">//将点分十进制数ip地址转换陈32位二进制网络地址</span></span><br><span class="line">inet_ntop <span class="comment">//将32位二进制ip地址转换为点分十进制ip地址</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">socketfd 描述了一个 socket结构体 socket  结构体的定义如下：   </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">socket</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    socket_state              state;   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>             flags;   </span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">proto_ops</span>    *ops;   </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fasync_struct</span>      *fasync_list;   </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span>               *file;   </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock</span>               *sk;   </span><br><span class="line">    <span class="type">wait_queue_head_t</span>         wait;   </span><br><span class="line">    <span class="type">short</span>                     type;   </span><br><span class="line">&#125;;   </span><br><span class="line">其中，<span class="keyword">struct</span> <span class="title class_">sock</span> 包含有一个 sock_common 结构体，而sock_common结构体又包含有<span class="keyword">struct</span> <span class="title class_">inet_sock</span> 结构体，而<span class="keyword">struct</span> <span class="title class_">inet_sock</span> 结构体的部分定义如下：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inet_sock</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock</span>     sk;   </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)   </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ipv6_pinfo</span>   *pinet6;   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>   </span></span><br><span class="line">    __u32           daddr;          <span class="comment">//IPv4的目的地址。   </span></span><br><span class="line">    __u32           rcv_saddr;      <span class="comment">//IPv4的本地接收地址。   </span></span><br><span class="line">    __u16           dport;          <span class="comment">//目的端口。   </span></span><br><span class="line">    __u16           num;            <span class="comment">//本地端口（主机字节序）。  </span></span><br><span class="line">    </span><br><span class="line">    …………      </span><br><span class="line">&#125;     </span><br><span class="line">由此，我们清楚了，socket结构体不仅仅记录了本地的IP和端口号，还记录了目的IP和端口（四元组）。</span><br><span class="line">这样，通过一个socket描述符，就能accept和connect了。</span><br><span class="line">而服务器一般只需要一个端口，即使accept也不会新开端口：</span><br><span class="line">    由于TCP/IP协议栈是维护着一个接收和发送缓冲区的。在接收到来自客户端的数据包后，服务器端的TCP/IP协议栈应该会做如下处理：如果收到的是请求连接的数据包（connect），则传给监听着连接请求端口的socetfd套接字，进行accept处理；</span><br><span class="line">    如果是已经建立过连接后的客户端数据包，则将数据放入接收缓冲区。这样，当服务器端需要读取指定客户端的数据时，则可以利用socketfd_new 套接字通过recv或者read函数到缓冲区里面去取指定的数据（因为socketfd_new代表的socket对象记录了客户端IP和端口，因此可以鉴别）。</span><br><span class="line">    本质上因为客户端的ip和端口不同，accept创建新的socketfd，可以通过socket区分用户</span><br></pre></td></tr></table></figure>

<h3 id="api详解"><a href="#api详解" class="headerlink" title="api详解"></a>api详解</h3><ul>
<li><p>int <strong>socket</strong>(int domain, int type, int protocol);</p>
<ul>
<li><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
</li>
<li><p>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET（IPv4)、AF_INET6(IPv6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p>
</li>
<li><p>type：指定socket类型。常用的socket类型有，SOCK_STREAM（流式套接字，TCP）、SOCK_DGRAM（数据报式套接字，UDP）、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等</p>
</li>
<li><p>protocol：就是指定协议。常用的协议有，IPPROTO_TCP、PPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p>
<ul>
<li>&#96;&#96;&#96;c++<br>#define IPPROTO_IP 0 &#x2F;* dummy for IP <em>&#x2F;<br>#define IPPROTO_ICMP 1 &#x2F;</em> control message protocol <em>&#x2F;<br>#define IPPROTO_IGMP 2 &#x2F;</em> internet group management protocol <em>&#x2F;<br>#define IPPROTO_GGP 3 &#x2F;</em> gateway^2 (deprecated) <em>&#x2F;<br>#define IPPROTO_TCP 6 &#x2F;</em> tcp <em>&#x2F;<br>#define IPPROTO_PUP 12 &#x2F;</em> pup <em>&#x2F;<br>#define IPPROTO_UDP 17 &#x2F;</em> user datagram protocol <em>&#x2F;<br>#define IPPROTO_IDP 22 &#x2F;</em> xns idp <em>&#x2F;<br>#define IPPROTO_ND 77 &#x2F;</em> UNOFFICIAL net disk proto <em>&#x2F;<br>#define IPPROTO_RAW 255 &#x2F;</em> raw IP packet *&#x2F;<br>#define IPPROTO_MAX 256<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * 有的程序protocol参数填的是0，有些填写的是IPPROTO_UDP或IPPROTO_TCP。如果type已经指明SOCK_STREAM或SOCK_DGRAM，protocol可以是0。type=SOCK_STREAM时，默认protocol就是IPPROTO_TCP；type=SOCK_DGRAM时，默认protocol就是IPPROTO_UDP。参数0即表示了默认传输。但是，最好还是指明使用哪种传输，因为types对应多种类型，比如数据流类型的有：atm,tcp等协议。</span><br><span class="line"></span><br><span class="line">* int **listen**(int fd, int backlog);</span><br><span class="line"></span><br><span class="line">  * **sockfd** 一个已绑定未被连接的套接字描述符</span><br><span class="line">  * **backlog** 连接请求队列的最大长度（一般由2到4）。用SOMAXCONN则为系统给出的最大值</span><br><span class="line">  * 返回：若成功则为0，若出错则为-1</span><br><span class="line">  * 执行listen 之后套接字进入被动模式。队列满了以后，将拒绝新的连接请求。客户端将出现连接错误WSAECONNREFUSED。</span><br><span class="line"></span><br><span class="line">* int **recv**(SOCKET s, charFAR*buf, int len, int flags);</span><br><span class="line"></span><br><span class="line">  * 第一个参数指定接收端套接字描述符；</span><br><span class="line">  * 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span><br><span class="line">  * 第三个参数指明buf的长度；</span><br><span class="line">  * 第四个参数一般置0。</span><br><span class="line">  * recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。</span><br><span class="line">  * 同步Socket的recv函数的执行流程。当应用程序调用recv函数时：</span><br><span class="line">    * （1）recv先**等待**s的发送缓冲中的数据被协议**传送完毕**，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR，</span><br><span class="line">    * （2）如果s的发送缓冲中**没有数据或者数据被协议成功发送完毕**后，recv先**检查**套接字s的接收缓冲区，如果s接收缓冲区中**没有数据或者协议正在接收数据**，那么recv就一直**等待**，直到协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的）</span><br><span class="line"></span><br><span class="line">* int **send**( SOCKET s, const char FAR *buf, int len, int flags );</span><br><span class="line"></span><br><span class="line">  * （1）第一个参数指定发送端套接字描述符；</span><br><span class="line">  * （2）第二个参数指明一个存放应用程序要发送数据的缓冲区；</span><br><span class="line">  * （3）第三个参数指明实际要发送的数据的字节数；</span><br><span class="line">  * （4）第四个参数一般置0。</span><br><span class="line">  * 同步Socket的send函数的执行流程。当调用该函数时：</span><br><span class="line">    * send先比较待发送数据的长度len和套接字s的发送缓冲的长度， 如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR</span><br><span class="line">    * 如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据</span><br><span class="line">      * 如果是就**等待**协议把数据发送完，</span><br><span class="line">      * 如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的**剩余空间**和len，如果len大于剩余空间大小send就一直**等待**协议把s的发送缓冲中的数据发送完，如果len小于剩余空间大小send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）</span><br><span class="line">    * 如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。</span><br><span class="line">    * 注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个Socket函数就会返回SOCKET_ERROR。</span><br><span class="line">    * 在Unix系统下，如果send在等待协议传送数据时网络断开的话，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</span><br><span class="line"></span><br><span class="line">* **int** accept(**int** sockfd, struct sockaddr *addr, socklen_t *addrlen) </span><br><span class="line"></span><br><span class="line">  * 大部分资料对于accept函数第三个参数的描述如下：连线成功时，参数addr所指的结构会被系统填入远程主机的地址数据，参数addrlen为scokaddr的结构长度。</span><br><span class="line">  * 如果将addrlen指针所指向的值中的数据不初始化或初始化为一个小于sizeof(struct sockaddr)的值时，所获取的客户机地址就会出现错误。</span><br><span class="line">  * 官方关于accept的*addrlen参数解释如下：这里的addrlen所指向的值，是必须初始化的，而且要初始化为一个大于等于实际获取socket的数据长度的值，而accept函数在执行后，会将实际值赋给addrlen所指向的值，故如果期望值小于实际值，所获取的数据在存储时就会发生溢出，读取时所得值便产生了错误。</span><br><span class="line">  * 与connect函数不同的就在于addrlen是要被赋值的，因为addr要被赋值，因此要传入一个初始化了的指针的地址。而connect只需要告知addr的大小，因此传入一个值</span><br><span class="line"></span><br><span class="line">### 简单代码实现</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">//server</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;//sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;//in_addr</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;//cerr</span><br><span class="line">#include &lt;unistd.h&gt;//close</span><br><span class="line">#define myport 8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //定义socketfd，它要绑定监听的网卡地址和端口</span><br><span class="line">    int listenfd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);//第三个参数写0也可以，这里表示创建tcp套接字</span><br><span class="line">    </span><br><span class="line">    //定义sockaddr_in</span><br><span class="line">    struct sockaddr_in socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;//ipv4</span><br><span class="line">    socketaddr.sin_port = htons(myport);//字节序转换</span><br><span class="line">    socketaddr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span><br><span class="line">    			//因为路由的关系，从客户端来的IP包只可能到达其中一个网卡。指定了网卡地址的话，必须从相应的地址进入才能连接到port</span><br><span class="line">    			//#define    INADDR_ANY        ((in_addr_t) 0x00000000)</span><br><span class="line">    </span><br><span class="line">    //绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span><br><span class="line">    if(bind(listenfd,(struct sockaddr *)&amp;socketaddr,sizeof(socketaddr))==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;&quot;bind&quot;&lt;&lt;std::endl;</span><br><span class="line">        exit(1);</span><br><span class="line">        //cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲.</span><br><span class="line">        //也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;&quot;listen socket port: &quot;&lt;&lt;myport&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    //开始监听</span><br><span class="line">     if(listen(listenfd,SOMAXCONN) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;&quot;listen&quot;&lt;&lt;std::endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ///客户端套接字</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    struct sockaddr_in client_addr;//获取客户的地址和端口号，连接后的不分配新端口</span><br><span class="line">    socklen_t len = sizeof(client_addr);//socklen_t 相当于 int，但使用int必须强制转型告知编译器</span><br><span class="line">    std::cout&lt;&lt;&quot;wating for conn...&quot;&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    int conn = accept(listenfd, (struct sockaddr*)&amp;client_addr, &amp;len);//阻塞，等待连接，成功则创建连接套接字conn描述这个用户</span><br><span class="line">    if(conn==-1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;&quot;connect&quot;&lt;&lt;std::endl;</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；</span><br><span class="line">    如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK。</span><br><span class="line">    */</span><br><span class="line">    std::cout&lt;&lt;&quot;conn successfully: port-&quot;&lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;&quot; ip-&quot;&lt;&lt;inet_ntoa(client_addr.sin_addr)&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    std::string str = &quot;receive successfully&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buffer,sizeof(buffer));//每次都将buffer清空，防止被上次写入的结果影响，和memset(buffer,0,sizeof(buffer));等价</span><br><span class="line">        int len = recv(conn, buffer, sizeof(buffer),0);//同步接收，是阻塞的</span><br><span class="line">        //客户端发送exit或者异常结束时，退出</span><br><span class="line">        if(strcmp(buffer,&quot;exit\n&quot;)==0 || len&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;&quot;break!&quot;&lt;&lt;std::endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        std::cout&lt;&lt;&quot;receive: &quot;&lt;&lt;buffer;//fgets本身不会去掉\n，这里不用endl</span><br><span class="line">        send(conn, str.c_str(), str.size(), 0);//发回成功信息</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(conn);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//cerr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myport 8000</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//或&quot;192.168.248.131&quot;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义connect socket</span></span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(myport);<span class="comment">//服务器端口，自己连接后的端口是os分配的，由进程选择一个端口去连服务器</span></span><br><span class="line">    <span class="comment">//socketaddr.sin_addr.s_addr = inet_addr(SERVER_IP);  ///服务器ip</span></span><br><span class="line">    <span class="comment">//inet_addr最好换成inet_aton()，不会冤枉0.0.0.0和255.255.255.255</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> inaddr;</span><br><span class="line">    <span class="built_in">inet_aton</span>(SERVER_IP,&amp;inaddr);</span><br><span class="line">    socketaddr.sin_addr = inaddr;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;connect to &quot;</span>&lt;&lt;SERVER_IP&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;myport&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///连接服务器，成功返回0，错误返回-1。返回的描述符connfd，该socket包含了服务器ip、port，自己ip、port，可用于发送和接收数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr *)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;connect error&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;connect to server successfully&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> sendbuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> recvbuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//gets:从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时停止</span></span><br><span class="line">    <span class="comment">//如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</span></span><br><span class="line">    <span class="comment">//等价于fgets(sendbuf, sizeof(sendbuf), stdin)</span></span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;send&gt; &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(sendbuf, <span class="built_in">sizeof</span>(sendbuf), stdin) != <span class="literal">NULL</span>)<span class="comment">//gets已不被编译器支持，不太安全</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;send to server: &quot;</span>&lt;&lt;sendbuf;<span class="comment">//不用换行fgets包含了\n</span></span><br><span class="line">        <span class="built_in">send</span>(connfd, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">///发送</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf,<span class="string">&quot;exit\n&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">recv</span>(connfd, recvbuf, <span class="built_in">sizeof</span>(recvbuf),<span class="number">0</span>); <span class="comment">///接收</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;receive from server: &quot;</span>&lt;&lt;recvbuf&lt;&lt;std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">bzero</span>(sendbuf,<span class="built_in">sizeof</span>(sendbuf));</span><br><span class="line">        <span class="built_in">bzero</span>(recvbuf,<span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;send&gt; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译就正常g++编译</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%A5%97%E6%8E%A5%E5%AD%971.png" alt="image-20221008231532602"></p>
<h2 id="socket-Windows"><a href="#socket-Windows" class="headerlink" title="socket-Windows"></a>socket-Windows</h2><p>基本的socket操作在<code>&lt;WinSock2.h&gt;</code>这个头文件，包括许多使用到的网络相关的结构体和函数。</p>
<ul>
<li><p>加载&#x2F;释放Winsock库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化WSA</span></span><br><span class="line">	WORD sockVersion=<span class="built_in">MAKEWORD</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> MAKEWORD 语法如下：</span></span><br><span class="line"><span class="comment">WORD MAKEWORD（</span></span><br><span class="line"><span class="comment">    BYTE below;  //指定一个低位的新值</span></span><br><span class="line"><span class="comment">	BYTE high;  //指定一个高位的新值</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">先将两个参数转换为二进制，将第一个参数放在低位，第二个参数放在高位，</span></span><br><span class="line"><span class="comment">高位字节指明副版本、低位字节指明主版本,最后转换为十进制,赋给 sockVersion。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这一步是为了声明调用不同的WinSock版本。例如MAKEWORD(2,2)就是调用2.2版本，MAKEWORD(1,1) 就是调用1.1版。</span></span><br><span class="line"><span class="comment">不同版本是有区别的，例如1.1版只支持TCP/IP协议，而2.0版可以支持多协议。</span></span><br><span class="line"><span class="comment">2.0版有良好的向后兼容性，任何使用1.1版的源代码、二进制文件、应用程序都可以不加修改地在2.0规范下使用。此外 WinSock 2.0 支持异步,1.1不支持异步。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">WSADATA 是一个结构体，用于存放 socket 的初始化信息。wsaData 用于存放结构体变量的地址值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化socket资源</span></span><br><span class="line"><span class="comment">// 当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库，</span></span><br><span class="line"><span class="comment">// 然后绑定找到的Socket库到该应用程序中。以后应用程序就可以调用所请求的Socket库中的其它Socket函数了</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData)!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//代表失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WSAStartup()的原型如下： int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line"><span class="comment">如果WSA初始化成功，函数会返回0，失败时会返回非零的错误代码值。所以如果函数返回值不等于0，则打印错误信息，程序终止。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">WSACleanup() 与开头的 WSAStartup() 函数是成对使用的，用于解除与 Socket 库的绑定并且释放 Socket 库所占用的系统资源。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在 Windows 下，Socket 是以 DLL 的形式实现的。在 DLL 内部维持着一个计数器，</span></span><br><span class="line"><span class="comment">只有第一次调用 WSAStartup 才真正装载DLL，以后的 调用只是简单的增加计数器，</span></span><br><span class="line"><span class="comment">而WSACleanup 函数的功能则刚好相反，每调用一次使计数器减1，当计数器减到0时，DLL 就从内存中被卸载！</span></span><br><span class="line"><span class="comment">因此，你调用了多少次 WSAStartup ，就应相应的调用多少次的WSACleanup。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建socket使用<code>SOCKET</code>这一关键字；关闭socket使用closesocket()函数。</p>
</li>
<li><p>没有bzero函数，使用memset</p>
</li>
<li><p>没有inet_aton()，需要使用inet_pton()，头文件是<code>&lt;WS2tcpip.h&gt;</code>，多了第一个参数，AF_INET或AF_INET6，指定ipv4或ipv6。</p>
</li>
<li><p>INVALID_SOCKET值为int的-1</p>
</li>
<li><p>#pragma comment(lib,”ws2_32.lib”)表示链接 Ws2_32.lib 这个库，加载dll。</p>
<ul>
<li>这种方式和在工程设置_链接库里面添加 Ws2_32.lib 的效果一样，不过这种方法写的程序,别人在使用你的代码的时候就不用再设置工程了。使用 DLL 之前必须把 DLL 加载到当前程序，这里在程序运行时加载，表示加载了ws2_32.dll</li>
</ul>
</li>
<li><p>比较新的操作是：初始化WSA资源，从而根据设置在dll文件中找到对应的库；释放WSA资源，解除库占用。其他都和linux差不多。而这几步不同的操作基本都是复制粘贴不需要变的。</p>
</li>
<li><p>关于lib和dll</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lib库有两种：</span><br><span class="line"></span><br><span class="line">1、静态链接库（Static Link Library）</span><br><span class="line">	这种 lib 中有函数的实现代码，它是将 lib 中的代码加入目标模块(.exe 或者 .dll)文件中，所以链接好了之后，lib 文件就没有用了。</span><br><span class="line">	这种 lib文件实际上是任意个 obj 文件的集合。obj 文件则是 cpp 文件编译生成的，</span><br><span class="line">如果有多个 cpp 文件则会编译生成多个 obj 文件，从而生成的 lib 文件中也包含了多个 obj。</span><br><span class="line"></span><br><span class="line">2、动态链接库（Dynamic Link Library）的导入库（Import Library）</span><br><span class="line">这种 lib 是和 dll 配合使用的，里面没有代码，代码在 dll 中，这种 lib 是用在静态调用 dll 上的，所以起的作用也是链接作用，</span><br><span class="line">链接完成了， lib 也没用了。至于动态调用 dll 的话，根本用不上 lib 文件。目标模块（exe 或者 dll）文件生成之后，就用不着 lib 文件了。</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*	1、加载套接字库，创建套接字（WSAStartup()/socket()）;</span></span><br><span class="line"><span class="comment">*	2、关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup());</span></span><br><span class="line"><span class="comment">*****************************************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> <span class="comment">//相当于string.h，使用strlen、memset函数。string头文件拥有string类，也可以使用string.h的函数，但是在std名称空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myport 8000</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;192.168.248.131&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化WSA</span></span><br><span class="line">	WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">	<span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	SOCKET connfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (connfd == INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;socket error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义sockaddr_in</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">	socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">	socketaddr.sin_port = <span class="built_in">htons</span>(myport);<span class="comment">//服务器端口，自己连接后的端口是os分配的，由进程选择一个端口去连服务器</span></span><br><span class="line">	<span class="comment">//socketaddr.sin_addr.s_addr = inet_addr(SERVER_IP);  ///服务器ip</span></span><br><span class="line">	<span class="comment">//inet_addr最好换成inet_aton()，不会冤枉0.0.0.0和255.255.255.255</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> inaddr;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;inaddr);<span class="comment">//windows下相当于inet_aton的函数，多了第一个参数表明是ipv4还是ipv6</span></span><br><span class="line">	socketaddr.sin_addr = inaddr;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;connect to &quot;</span> &lt;&lt; SERVER_IP &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myport &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">///连接服务器，成功返回0，错误返回-1。返回的描述符connfd，该socket包含了服务器ip、port，自己ip、port，可用于发送和接收数据</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)<span class="comment">//</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;connect to server successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">char</span> sendbuf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> recvbuf[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">//windows下初始化好像有些奇怪，这里先手动清0</span></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendbuf));</span><br><span class="line">	<span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">	<span class="comment">//gets:从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时停止</span></span><br><span class="line">	<span class="comment">//如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</span></span><br><span class="line">	<span class="comment">//等价于fgets(sendbuf, sizeof(sendbuf), stdin)</span></span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;send&gt; &quot;</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fgets</span>(sendbuf, <span class="built_in">sizeof</span>(sendbuf), stdin) != <span class="literal">NULL</span>)<span class="comment">//gets已不被编译器支持，不太安全</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;send to server: &quot;</span> &lt;&lt; sendbuf;<span class="comment">//不用换行fgets包含了\n</span></span><br><span class="line">		<span class="built_in">send</span>(connfd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>); <span class="comment">///发送</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;exit\n&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">recv</span>(connfd, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>); <span class="comment">///接收</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;receive from server: &quot;</span> &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//windows下不支持bzero</span></span><br><span class="line">		<span class="comment">//bzero(sendbuf, sizeof(sendbuf));</span></span><br><span class="line">		<span class="comment">//bzero(recvbuf, sizeof(recvbuf));</span></span><br><span class="line">		<span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendbuf));</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(recvbuf));</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;send&gt; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">closesocket</span>(connfd);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\14242\AppData\Roaming\Typora\typora-user-images\image-20221009150801980.png" alt="image-20221009150801980"></p>
<p>使用vs2022跑程序，可以跑通，虚拟机的网卡并没有设置其他的东西，使用了默认的NAT模式就行，不过有可能要配置端口转发，好在我的机器不用-。-</p>
<h3 id="exe生成发布"><a href="#exe生成发布" class="headerlink" title="exe生成发布"></a>exe生成发布</h3><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/hunk954/article/details/100339913">(29条消息) 在VisualStudio上生成代码的exe可执行文件_hunk954的博客-CSDN博客_visualstudio怎么生成exe</a></p>
<p>其中关于多线程MT和多线程MD，可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mod109/p/3762604.html">多线程MT和多线程MD的区别 - 繁星jemini - 博客园 (cnblogs.com)</a>，使用MD较多，小项目就没啥差别了。</p>
<h2 id="socket-文件传输"><a href="#socket-文件传输" class="headerlink" title="socket-文件传输"></a>socket-文件传输</h2><p>服务器接收文件，客户端发送文件</p>
<p>客户端：主要是打开文件，然后读到缓冲区，不断发送</p>
<ul>
<li><p>FILE *fopen(const char *filename, const char *mode)</p>
<ul>
<li><strong>filename</strong> – 字符串，表示要打开的文件名称。</li>
<li><strong>mode</strong> – 字符串，表示文件的访问模式，可以是以下的值：<ul>
<li>r 以只读方式打开文件，该文件必须存在。</li>
<li>r+ 以可读写方式打开文件，该文件必须存在。</li>
<li>rb+ 读写打开一个二进制文件，允许读数据。</li>
<li>rw+ 读写打开一个文本文件，允许读和写。</li>
<li>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</li>
<li>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</li>
<li>wb 只写打开或新建一个二进制文件；只允许写数据。</li>
<li>wb+ 读写打开或建立一个二进制文件，允许读和写。</li>
<li>ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>vs已不支持fopen，使用fopen_s（linux下还是用fopen）：errno_t fopen_s( FILE** pFile, const char *filename, const char *mode );</p>
<ul>
<li>err &#x3D; fopen_s(&amp;fp,“filename”,“w”)；</li>
<li>打开文件成功返回0，失败返回非0。</li>
</ul>
</li>
<li><p>int ferror(FILE *stream)</p>
<ul>
<li>测试给定流 stream 的错误标识符。如果出错返回一个非零值，否则返回0。</li>
</ul>
</li>
<li><p>int feof(FILE *stream)</p>
<ul>
<li>测试给定流 stream 的文件结束标识符。如果fread后文件读完了（指针到文件末尾），返回非零值，否则返回0</li>
</ul>
</li>
<li><p>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</p>
<ul>
<li><strong>ptr</strong> – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针。</li>
<li><strong>size</strong> – 这是要读取的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li>
<li>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************************************************************</span></span><br><span class="line"><span class="comment">*	1、加载套接字库，创建套接字（WSAStartup()/socket()）;</span></span><br><span class="line"><span class="comment">*	2、关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup());</span></span><br><span class="line"><span class="comment">*****************************************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> <span class="comment">//相当于string.h，使用strlen、memset函数。string头文件拥有string类，也可以使用string.h的函数，但是在std名称空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//FILE等操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myport 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buffSize  102400</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* SERVER_IP = <span class="string">&quot;192.168.248.131&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化WSA</span></span><br><span class="line">	WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">	<span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建套接字</span></span><br><span class="line">	SOCKET connfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (connfd == INVALID_SOCKET)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;socket error !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义sockaddr_in</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">	socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">	socketaddr.sin_port = <span class="built_in">htons</span>(myport);<span class="comment">//服务器端口，自己连接后的端口是os分配的，由进程选择一个端口去连服务器</span></span><br><span class="line">	<span class="comment">//socketaddr.sin_addr.s_addr = inet_addr(SERVER_IP);  ///服务器ip</span></span><br><span class="line">	<span class="comment">//inet_addr最好换成inet_aton()，不会冤枉0.0.0.0和255.255.255.255</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">in_addr</span> inaddr;</span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;inaddr);<span class="comment">//windows下相当于inet_aton的函数，多了第一个参数表明是ipv4还是ipv6</span></span><br><span class="line">	socketaddr.sin_addr = inaddr;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;connect to &quot;</span> &lt;&lt; SERVER_IP &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; myport &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">///连接服务器，成功返回0，错误返回-1。返回的描述符connfd，该socket包含了服务器ip、port，自己ip、port，可用于发送和接收数据</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(connfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)<span class="comment">//</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;connect to server successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> sendbuf[buffSize];</span><br><span class="line">	<span class="comment">//windows下初始化好像有些奇怪，这里先手动清0</span></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in">sizeof</span>(sendbuf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----------------------打开文件------------------------------------------------------</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;test.pdf&quot;</span>;</span><br><span class="line">	FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fopen_s</span>(&amp;fp,filename, <span class="string">&quot;rb&quot;</span>) != <span class="number">0</span>)<span class="comment">//要以二进制形式读写，这样兼容文件格式</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;cannot open file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	std::chrono::system_clock::time_point time1 = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">	<span class="type">int</span> nSend = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> totalSend = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nRead = <span class="built_in">fread</span>(sendbuf, <span class="number">1</span>, buffSize, fp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">ferror</span>(fp) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;failed to read file &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nSend = <span class="built_in">send</span>(connfd, sendbuf, nRead, <span class="number">0</span>);<span class="comment">//发送nRead个字节</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nSend == SOCKET_ERROR)<span class="comment">//网络断开或copy出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;the connection to server has been failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		totalSend += nSend;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;success to send %d bytes\n&quot;</span>, nSend);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">feof</span>(fp))<span class="comment">//读了，发完，再判断是否到达末尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;success to transmit file to server\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    std::chrono::system_clock::time_point time2 = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success to send %d bytes totally\n&quot;</span>, totalSend);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;spend &quot;</span>&lt;&lt;std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(time2-time1).<span class="built_in">count</span>()&lt;&lt;<span class="string">&quot; ms&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	<span class="built_in">closesocket</span>(connfd);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端：</p>
<ul>
<li><p>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</p>
<ul>
<li><strong>ptr</strong> – 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> – 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
<li>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span><span class="comment">//in_addr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="comment">//cerr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myport 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buffSize  102400</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(myport);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line">    			<span class="comment">//因为路由的关系，从客户端来的IP包只可能到达其中一个网卡。指定了网卡地址的话，必须从相应的地址进入才能连接到port</span></span><br><span class="line">    			<span class="comment">//#define    INADDR_ANY        ((in_addr_t) 0x00000000)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;socketaddr,<span class="built_in">sizeof</span>(socketaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;bind&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲.</span></span><br><span class="line">        <span class="comment">//也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;listen socket port: &quot;</span>&lt;&lt;myport&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">listen</span>(listenfd,SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;listen&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///客户端套接字</span></span><br><span class="line">    <span class="type">char</span> recvbuf[buffSize];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;<span class="comment">//获取客户的地址和端口号，连接后的不分配新端口</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);<span class="comment">//socklen_t 相当于 int，但使用int必须强制转型告知编译器</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;wating for conn...&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> conn = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<span class="comment">//阻塞，等待连接，成功则创建连接套接字conn描述这个用户</span></span><br><span class="line">    <span class="keyword">if</span>(conn==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr&lt;&lt;<span class="string">&quot;connect&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；</span></span><br><span class="line"><span class="comment">    如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;conn successfully: port-&quot;</span>&lt;&lt;<span class="built_in">ntohs</span>(client_addr.sin_port)&lt;&lt;<span class="string">&quot; ip-&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(client_addr.sin_addr)&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    std::string str = <span class="string">&quot;receive successfully&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//----------------------打开文件------------------------------------------------------</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;test.pdf&quot;</span>;</span><br><span class="line">    FILE *fp=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fp=<span class="built_in">fopen</span>(filename,<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)<span class="comment">//要以二进制形式读写，这样兼容文件格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cannot open file &quot;</span>&lt;&lt;filename&lt;&lt;std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> nRecv = <span class="built_in">recv</span>( conn, recvbuf, buffSize, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>( nRecv == SO_ERROR )<span class="comment">//copy出错，linux下为SO_ERROR</span></span><br><span class="line">		&#123;</span><br><span class="line">             std::cerr &lt;&lt; <span class="string">&quot;connection to client has been failed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        	 <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>( nRecv == <span class="number">0</span> )<span class="comment">//这种情况是对端close了，此时返回0。可能是意外close，也可能是发送完毕了</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>( <span class="string">&quot;client close, maybe the file transmit successfully\n&quot;</span> );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> nWrite=<span class="built_in">fwrite</span>(recvbuf,<span class="number">1</span>,nRecv,fp);<span class="comment">//写文件</span></span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(nWrite!=nRecv || <span class="built_in">ferror</span>(fp)!=<span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			std::cerr &lt;&lt;<span class="string">&quot;failed to write file&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(conn);</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>使用102400的buffer大小（比10240快），发送10M的文件耗时100多ms</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/socketfile1.png" alt="image-20221009230059734"></p>
<p>栈空间默认只有1M大小，所以buffer不能太大。可以试一下用堆空间</p>
<p>开一个1M的buffer空间，结果和栈差不多。因为访问栈会比访问堆快，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。 </p>
<p>发一个300M的pdf需要5s。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server-windows</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> <span class="comment">//相当于string.h，使用strlen、memset函数。string头文件拥有string类，也可以使用string.h的函数，但是在std名称空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span><span class="comment">//除了inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span><span class="comment">//inet_pton</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//FILE等操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> myport 8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> buffSize  102400</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化WSA</span></span><br><span class="line">    WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    WSADATA wsaData;<span class="comment">//WSADATA结构体变量的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);</span></span><br><span class="line">    <span class="comment">//成功时会返回0，失败时返回非零的错误代码值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WSAStartup() error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义socketfd，它要绑定监听的网卡地址和端口</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<span class="comment">//第三个参数写0也可以，这里表示创建tcp套接字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> socketaddr;</span><br><span class="line">    socketaddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    socketaddr.sin_port = <span class="built_in">htons</span>(myport);<span class="comment">//字节序转换</span></span><br><span class="line">    socketaddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//INADDR_ANY表示监听所有网卡地址，0.0.0.0；</span></span><br><span class="line">    <span class="comment">//因为路由的关系，从客户端来的IP包只可能到达其中一个网卡。指定了网卡地址的话，必须从相应的地址进入才能连接到port</span></span><br><span class="line">    <span class="comment">//#define    INADDR_ANY        ((in_addr_t) 0x00000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定套接字和地址端口信息，sockaddr_in转成sockaddr</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;socketaddr, <span class="built_in">sizeof</span>(socketaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;bind&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲.</span></span><br><span class="line">        <span class="comment">//也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;listen socket port: &quot;</span> &lt;&lt; myport &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, SOMAXCONN) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;listen&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///客户端套接字</span></span><br><span class="line">    <span class="type">char</span> recvbuf[buffSize];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;<span class="comment">//获取客户的地址和端口号，连接后的不分配新端口</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(client_addr);<span class="comment">//socklen_t 相当于 int，但使用int必须强制转型告知编译器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wating for conn...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> conn = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<span class="comment">//阻塞，等待连接，成功则创建连接套接字conn描述这个用户</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;connect&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果队列中没有等待的连接，套接字也没有被标记为Non-blocking，accept()会阻塞调用函数直到连接出现；</span></span><br><span class="line"><span class="comment">    如果套接字被标记为Non-blocking，队列中也没有等待的连接，accept()返回错误EAGAIN或EWOULDBLOCK。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::string str = <span class="string">&quot;receive successfully&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------打开文件------------------------------------------------------</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;test.zip&quot;</span>;</span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fopen_s</span>(&amp;fp, filename, <span class="string">&quot;wb&quot;</span>) != <span class="number">0</span>)<span class="comment">//要以二进制形式读写，这样兼容文件格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;cannot open file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nRecv = <span class="built_in">recv</span>(conn, recvbuf, buffSize, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRecv == SO_ERROR)<span class="comment">//copy出错，linux下为SO_ERROR</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;connection to client has been failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nRecv == <span class="number">0</span>)<span class="comment">//这种情况是对端close了，此时返回0。可能是意外close，也可能是发送完毕了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client close, maybe the file transmit successfully\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> nWrite = <span class="built_in">fwrite</span>(recvbuf, <span class="number">1</span>, nRecv, fp);<span class="comment">//写文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nWrite != nRecv || <span class="built_in">ferror</span>(fp) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;failed to write file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(listenfd);</span><br><span class="line">    <span class="built_in">closesocket</span>(conn);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll是对于服务器端来说的，可以用前面的客户端来连接验证。我们来简单看看epoll的底层。</p>
<h2 id="select和epoll的区别-面试常考"><a href="#select和epoll的区别-面试常考" class="headerlink" title="select和epoll的区别(面试常考)"></a>select和epoll的区别(面试常考)</h2><ul>
<li>首先select是posix支持的，而epoll是linux特定的系统调用，因此，epoll的可移植性就没有select好，但是考虑到epoll和select一般用作服务器的比较多，而服务器中大多又是linux，所以这个可移植性的影响应该不会很大。</li>
<li>其次，select可以监听的文件描述符有限，最大值为1024，而epoll可以监听的文件描述符则是系统对整个进程限制的最大文件描述符。</li>
<li>接下来就要谈epoll和select的性能比较了，这个一般情况下应该是epoll表现好一些，否则linux也不会去特定实现epoll函数了，那么epoll为什么比select更高效呢？原因有很多，第一点，epoll通过每次有就绪事件时都将其插入到一个就绪队列中，使得epoll_wait的返回结果中只存储了已经就绪的事件，而select则返回了所有被监听的事件，事件是否就绪需要应用程序去检测，那么如果已被监听但未就绪的事件较多的话，对性能的影响就比较大了。第二点，每一次调用select获得就绪事件时都要将需要监听的事件重复传递给操作系统内核，而epoll对监听文件描述符的处理则和获得就绪事件的调用分开，这样获得就绪事件的调用epoll_wait就不需要重新传递需要监听的事件列表，这种重复的传递需要监听的事件也是性能低下的原因之一。除此之外，epoll的实现中使用了mmap调用使得内核空间和用户空间共享内存，从而避免了过多的内核和用户空间的切换引起的开销。</li>
<li>然后就是epoll提供了两种工作模式，一种是水平触发模式，这种模式和select的触发方式是一样的，要只要文件描述符的缓冲区中有数据，就永远通知用户这个描述符是可读的，这种模式对block和noblock的描述符都支持，编程的难度也比较小；而另一种更高效且只有epoll提供的模式是边缘触发模式，只支持nonblock的文件描述符，他只有在文件描述符有新的监听事件发生的时候（例如有新的数据包到达）才会通知应用程序，在没有新的监听时间发生时，即使缓冲区有数据（即上一次没有读完，或者甚至没有读），epoll也不会继续通知应用程序，使用这种模式一般要求应用程序收到文件描述符读就绪通知时，要一直读数据直到收到EWOULDBLOCK&#x2F;EAGAIN错误，使用边缘触发就必须要将缓冲区中的内容读完，否则有可能引起死等,尤其是当一个listen_fd需要监听到达连接的时候，如果多个连接同时到达，如果每次只是调用accept一次，就会导致多个连接在内核缓冲区中滞留，处理的办法是用while循环抱住accept，直到其出现EAGAIN。这种模式虽然容易出错，但是性能要比前面的模式更高效，因为只需要监听是否有事件发生，发生了就直接将描述符加入就绪队列即可。</li>
</ul>
<h2 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h2><p>select的缺点：</p>
<ol>
<li>单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，当然可以更改数量，但由于select采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差；(在linux内核头文件中，有这样的定义：#define __FD_SETSIZE  1024)</li>
<li>内核 &#x2F; 用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；</li>
<li>（不是返回就绪数组）select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li>
<li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li>
</ol>
<p>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</p>
<p>拿select模型为例，假设我们的服务器需要支持100万的并发连接，则在__FD_SETSIZE 为1024的情况下，则我们至少需要开辟1k个进程才能实现100万的并发连接。除了进程间上下文切换的时间消耗外，从内核&#x2F;用户空间大量的无脑内存拷贝、数组轮询等，是系统难以承受的。因此，基于select模型的服务器程序，要达到10万级别的并发访问，是一个很难完成的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通俗版本可能是这样的：</span><br><span class="line">应用程序拿着一张纸：内核哥，我想知道这张纸上面三个表格中画1的地方对应的文件描述符，有没有发生啥事件。</span><br><span class="line">内核说：程序弟，稍等。。。，我给你把没有事件的地方画上0，有事件的地方保留1.</span><br><span class="line">内核在纸上一顿涂改操作，把没事件发生的地方改成了0，有事件的地方保留1,然后把纸交给程序。</span><br><span class="line">然后，程序拿着纸，看着有1的地方就知道这地方发生了事件，他要去处理了。</span><br></pre></td></tr></table></figure>

<p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select&#x2F;poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select&#x2F;poll一般只能处理几千的并发连接。</p>
<h2 id="epoll底层"><a href="#epoll底层" class="headerlink" title="epoll底层"></a>epoll底层</h2><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">eventpoll</span>&#123;<span class="comment">//置于缓存中，很快</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_root</span>  rbr;</span><br><span class="line">    <span class="comment">/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> rdlist;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当事件到来或结束时，会用到红黑树的插入删除</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有的人误以为 epoll 高效的全部因为这棵红黑树，这就有点夸大红黑树的作用了。</span><br><span class="line">其实红黑树的作用是仅仅是在管理大量连接的情况下，添加和删除 socket 非常的高效。</span><br><span class="line">如果 epoll 管理的 socket 固定的话，在数据收发的事件管理过程中其实红黑树是没有起作用的。</span><br><span class="line">内核在socket上收到数据包以后，可以直接找到 epitem(epoll item)，并把它插入到就绪队列里，然后等用户进程把事件取走。</span><br><span class="line">这个过程中，红黑树的作用并不会得到体现。</span><br></pre></td></tr></table></figure>

<p>所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback，它会将发生的事件添加到rdlist双链表中。也是通过这个回调关系（更具体来说是一个指针），根据socket能直接找到epitem（我们创建记录的fd只是为了能找到socket），epitem中又包含了fd供用户使用。那为什么又要红黑树呢？因为要管理这些事件，当事件要关闭时还要找得到事件来关闭。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epitem</span>&#123;<span class="comment">//事件对应一个fd</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rb_node</span>  rbn;<span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span>    rdllink;<span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_filefd</span>  ffd;  <span class="comment">//事件句柄信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">eventpoll</span> *ep;    <span class="comment">//指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event; <span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/epoll.jpg" alt="epoll.jpg"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/epoll2.png" alt="img"></p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul>
<li><p>int epoll_create(int size)</p>
<ul>
<li>创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。(从Linux 2.6.8开始，max_size参数将被忽略，但必须大于零。)</li>
<li>成功时，返回一个非负文件描述符。发生错误时，返回-1，并且将errno设置为指示错误</li>
</ul>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p>
<ul>
<li><p>该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
</li>
<li><p>epfd：为epoll_creat的句柄</p>
</li>
<li><p>op：表示动作，用3个宏来表示：</p>
</li>
<li><ul>
<li>EPOLL_CTL_ADD (注册新的fd到epfd)，相当于把fd加到epfd这棵红黑树上</li>
<li>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</li>
<li>EPOLL_CTL_DEL (从epfd删除一个fd)；</li>
</ul>
</li>
<li><p>fd：文件描述符</p>
</li>
<li><p>event：告诉内核需要监听的事件，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events，是一串比特，设置类型时把类型或起来 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>events描述事件类型，其中epoll事件类型有以下几种</p>
</li>
<li><ul>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</p>
<ul>
<li><p>该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</p>
<ul>
<li><p>events：用来存内核得到事件的集合，</p>
</li>
<li><p>maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</p>
</li>
<li><p>timeout：是超时时间</p>
</li>
<li><ul>
<li>-1：阻塞</li>
<li>0：立即返回，非阻塞</li>
<li>&gt;0：指定毫秒，没有事件触发会等待，但有事件触发就立即返回</li>
</ul>
</li>
<li><p>返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发模式：</p>
<ul>
<li><p>LT水平触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll还会再次向应用程序通知此事件，直到该事件被处理完毕。</li>
</ul>
</li>
<li><p>ET边缘触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</li>
<li>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain</li>
</ul>
</li>
<li><p>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，故效率要比LT模式高。LT模式是epoll的默认工作模式</p>
</li>
<li><p>EPOLLONESHOT</p>
</li>
<li><ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>只看epoll部分，其他先不考虑。是很简单的接收响应，不涉及对写事件的响应。这里是同步的代码，主要还是了解一下代码流程。</p>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>几乎所有的epoll程序都使用下面的框架：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                n = <span class="built_in">read</span>(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">                ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">                sockfd = md-&gt;fd;</span><br><span class="line">                <span class="built_in">send</span>( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="type">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csy777777/article/details/117529589">(29条消息) epoll 的LT与ET实例_five丶的博客-CSDN博客</a>代码参考的博客，有修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置地址可重用</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setReuseAddr</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>( fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">8000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_EVENT = <span class="number">20</span>;<span class="comment">//最多有20个就绪事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ev用来设置事件状态，event数组接收就绪事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev, event[MAX_EVENT];</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> local_addr = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//0表示根据type默认</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listenfd) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create listenfd failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setReuseAddr</span>(listenfd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;set reuse addr failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span> (server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind port failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, SOMAXCONN) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == epfd) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create epoll failed&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加listenfd 到epoll事件，事件绑定读事件</span></span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    ev.events = EPOLLIN <span class="comment">/* 默认为水平触发。 */</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;epoll add failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">close</span>(epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">        <span class="type">int</span> nfds;</span><br><span class="line">        <span class="comment">//等待io事件</span></span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd, event, MAX_EVENT, <span class="number">-1</span>);<span class="comment">//-1是阻塞</span></span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;epoll_wait return&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++)&#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = event[i].events;</span><br><span class="line">            <span class="comment">//处理epoll出错和对端关闭情况</span></span><br><span class="line">            <span class="keyword">if</span> (events &amp; EPOLLERR || events &amp; EPOLLHUP) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;epoll has error&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span> (event[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (event[i].data.fd == listenfd)&#123;</span><br><span class="line">                <span class="comment">//LT模式下，每次触发只处理一次</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr in_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="type">socklen_t</span> in_addr_len = <span class="built_in">sizeof</span> (in_addr);</span><br><span class="line">                <span class="type">int</span> client_sock = <span class="built_in">accept</span>(listenfd, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);<span class="comment">//nullptr表示不保存客户端信息</span></span><br><span class="line">                <span class="keyword">if</span> (client_sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;accept client&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                ev.events = EPOLLIN;<span class="comment">//添加事件读</span></span><br><span class="line">                ev.data.fd = client_sock;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>( epfd, EPOLL_CTL_ADD, client_sock, &amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    std::cout &lt;&lt; client_sock &lt;&lt;<span class="string">&quot; epoll_ctl falied: &quot;</span> &lt;&lt; std::endl; </span><br><span class="line">                    <span class="built_in">close</span>(client_sock);</span><br><span class="line">                    <span class="built_in">close</span>(listenfd);</span><br><span class="line">                    <span class="built_in">close</span>(epfd);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">ssize_t</span> result_len;</span><br><span class="line">                <span class="comment">//为了测试LT模式如何处理大量数据，将buf容量设置为10</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;  </span><br><span class="line">                result_len = <span class="built_in">read</span>(event[i].data.fd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//处理对端关闭情况</span></span><br><span class="line">                <span class="keyword">if</span>(result_len == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">close</span>(event[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!result_len)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive message:&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">send</span>(event[i].data.fd, <span class="string">&quot;receive!&quot;</span>, <span class="number">9</span>, <span class="number">0</span>);<span class="comment">//发回成功信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LT模式下对端ctrl+c关闭会导致服务器epoll_wait不阻塞一直循环。原因是产生了一个事件一直得不到解决，可以用EPOLLONESHOT（亲测可用），不过要重新设置文件描述符。这里可以先不管，测试和参考博客一样，且可以连接多台客户端。</p>
<h3 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h3><ul>
<li>ET模式下每次write或read需要循环write或read直到返回EAGAIN错误。以读操作为例，这是因为ET模式只在socket描述符状态发生变化时才触发事件，如果不一次把socket内核缓冲区的数据读完，会导致socket内核缓冲区中即使还有一部分数据，该socket的可读事件也不会被触发</li>
<li>根据上面的讨论，若ET模式下使用阻塞IO，则程序一定会阻塞在最后一次write或read操作，因此说<strong>ET模式下一定要使用非阻塞IO</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文件描述符非阻塞</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setNonblock</span> <span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flags &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置地址可重用</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">setReuseAddr</span><span class="params">(<span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>( fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = <span class="number">8000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_EVENT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev, event[MAX_EVENT];</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> local_addr = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//初始化socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listenfd) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create listenfd failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setReuseAddr</span>(listenfd) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;set reuse addr failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(listenfd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="built_in">sizeof</span> (server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind port failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setNonblock</span>(listenfd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;set listenfd nonblock failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(listenfd, <span class="number">200</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == epfd) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create epoll failed&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加listenfd 到epoll事件</span></span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET <span class="comment">/* 边缘触发选项。 */</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;epoll add failed:&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(listenfd);</span><br><span class="line">        <span class="built_in">close</span>(epfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">        <span class="type">int</span> nfds;</span><br><span class="line">        <span class="comment">//等待io事件</span></span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd, event, MAX_EVENT, <span class="number">-1</span>);</span><br><span class="line">        std:: cout &lt;&lt; <span class="string">&quot;epoll_wait return&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++)&#123;</span><br><span class="line">            <span class="type">uint32_t</span> events = event[i].events;</span><br><span class="line">            <span class="comment">//处理epoll出错和对端关闭情况</span></span><br><span class="line">            <span class="keyword">if</span> (events &amp; EPOLLERR || events &amp; EPOLLHUP) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;epoll has error&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">close</span> (event[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event[i].data.fd == listenfd)&#123;</span><br><span class="line">                <span class="comment">//ET模式下，需要一次把所有数据读完，使用循环读取</span></span><br><span class="line">                <span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr in_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">socklen_t</span> in_addr_len = <span class="built_in">sizeof</span> (in_addr);</span><br><span class="line">                    <span class="type">int</span> client_sock = <span class="built_in">accept</span>(listenfd, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">                    <span class="keyword">if</span> (client_sock &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;accept client&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">setNonblock</span>(client_sock) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        std::cout &lt;&lt; client_sock &lt;&lt;<span class="string">&quot; set non_block falied: &quot;</span> &lt;&lt; std::endl; </span><br><span class="line">                        <span class="built_in">close</span>(client_sock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    ev.data.fd = client_sock;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>( epfd, EPOLL_CTL_ADD, client_sock, &amp;ev) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        std::cout &lt;&lt; client_sock &lt;&lt;<span class="string">&quot; epoll_ctl falied: &quot;</span> &lt;&lt; std::endl; </span><br><span class="line">                        <span class="built_in">close</span>(client_sock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">                    <span class="type">ssize_t</span> result_len;</span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    result_len = <span class="built_in">read</span>(event[i].data.fd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">                       </span><br><span class="line">                    <span class="keyword">if</span>(result_len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK)&#123;</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line">                            <span class="built_in">epoll_ctl</span>( epfd, EPOLL_CTL_DEL, event[i].data.fd, <span class="literal">nullptr</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(!result_len)&#123;</span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;receive message:&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">send</span>(event[i].data.fd, <span class="string">&quot;receive!&quot;</span>, <span class="number">9</span>, <span class="number">0</span>);<span class="comment">//发回成功信息</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(done)&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;close connection&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">close</span>(event[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果和博客一样，如果把ET模式下代码改成不一次读完，那么冗余的数据会在下次客户端send后接收。</p>
<h3 id="EPOLLONESHOT"><a href="#EPOLLONESHOT" class="headerlink" title="EPOLLONESHOT"></a>EPOLLONESHOT</h3><p>客户端ctrl+c不会出现像LT模式下那样有某个事件然后一直处理不了不断循环，因为ET模式只触发一次相同事件或者说只在从非触发到触发两个状态转换的时候儿才触发。</p>
<p>因此EPOLLONESHOT在ET模式下，主要是为了防止多线程操作同一个socket：socket接收到数据交给一个线程处理数据，在数据没有处理完之前又有新数据达到触发了事件，另一个线程被激活获得该socket，从而产生多个线程操作同一socket，即使在ET模式下也有可能出现这种情况。采用EPOLLONETSHOT事件的文件描述符上的注册事件只触发一次，要想重新注册事件则需要调用epoll_ctl重置文件描述符上的事件，这样前面的socket就不会出现竞态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/21/websever-c++11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/websever-c++11/" class="post-title-link" itemprop="url">TinyWebServer-C++11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-21 09:56:36" itemprop="dateCreated datePublished" datetime="2022-09-21T09:56:36+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-26 16:26:37" itemprop="dateModified" datetime="2022-10-26T16:26:37+08:00">2022-10-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天follow完了tinywebsever的项目，分析了很多代码，最后也能跑起来。不过感觉整体的代码框架有些杂乱，代码也有冗余、不清晰的地方，比如互斥锁在c++11已经有专门的实现，不需要自己实现了。</p>
<p>作者也推荐了另一个c++11写的更简洁更优雅的项目实现：<a target="_blank" rel="noopener" href="https://github.com/markparticle/WebServer">markparticle&#x2F;WebServer: C++ Linux WebServer服务器 (github.com)</a></p>
<p>上一个项目最大的好处是作者专门写了一系列分析的文章，而这个项目没有教程也没什么注释，因此打算再写篇博客分析一下代码，写下注释，更重要的是把代码框架、逻辑理清楚，以及看看c++11实现的方便之处。</p>
<hr>
<p>另外，在这里说一下size_t，很多c系的程序员对这个类型用的比较少，但这个项目里经常出现。</p>
<p>可以参考下：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24773728">(24 封私信 &#x2F; 80 条消息) size_t 这个类型的意义是什么？ - 知乎 (zhihu.com)</a>。</p>
<p>主要还是为了可移植性，不同平台对于size_t的大小不同，64位系统是8字节，32位系统是4字节。为了方便移植，许多库函数的参数、返回值都是size_t。当换了个平台时，可以不改动代码而传入、接收更大或更小的值；并且系统不会使用更大的类型，从而加快速度。注意这些都是相对只用int、unsigned int、unsigned long作为类型对比的结果，用size_t有弹性。</p>
<p>但是，一个size_t类型的参数的用途却是用户定义的，比如可以把size_t就当int用，用来数组寻址等等，也可以用它来接收函数返回的参数然后作为一些长度，这些长度表示字节、还是两个字节都是用户决定的，它本身的值是多少就是多少。</p>
<p>一般用于作索引和表示单字节长度：</p>
<ul>
<li>size_t传达了语义：您立即知道它表示一个以字节为单位的大小或一个索引，而不仅仅是另一个整数。</li>
<li>std::size_t是任何sizeof表达式的类型，并且保证能够表达C ++中任何对象(包括任何数组)的最大大小。通过扩展，它也保证对任何数组索引都足够大，因此它是数组上逐个索引循环的自然类型。</li>
</ul>
<hr>
<p>C++11可以将{}初始化器用于任何类型（可以使用等号，也可以不使用），这是一种通用的初始化语法。</p>
<p>在C++11中，集合（列表）的初始化已经成为C++的一个基本功能，被称为“初始化列表（initializer list）”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;            <span class="comment">//C++98支持，C++11支持</span></span><br><span class="line"><span class="type">int</span> b[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;        <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; d = &#123;&#123; <span class="number">1</span>, <span class="number">1.0f</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2.0f</span> &#125;, &#123; <span class="number">3</span>, <span class="number">3.0f</span> &#125; &#125;;<span class="comment">//C++98不支持，C++11支持</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>应用了很多新特性，比较难理解，要耐心一点。</p>
<p>右值引用可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">C++11右值引用（一看即懂） (biancheng.net)</a></p>
<p>std::move()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7863.html">C++11 move()函数：将左值强制转换为右值 (biancheng.net)</a></p>
<p>std::forward()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7868.html">C++11完美转发及实现方法详解 (biancheng.net)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;<span class="comment">//线程创建后就开始运行，顶层只用往线程池插入任务即可</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span><span class="comment">//初始化一个pool</span></span><br><span class="line">            <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;<span class="comment">//创建count个线程，每个线程绑定工作函数并detach分离</span></span><br><span class="line">                <span class="comment">//lambda匿名函数，按值捕获pool_，本身是个指针，指向同一个实例。没有参数，省略“（）”</span></span><br><span class="line">                std::<span class="built_in">thread</span>([pool = pool_] &#123;<span class="comment">//接下来是函数体</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);<span class="comment">//灵活锁，因为要取一个元素。不放while可以避免重复定义</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//有元素就取，这里一定要先锁再判断</span></span><br><span class="line">                            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());<span class="comment">//左值转右值，转移task内存的所有权，把function取出来，调用移动构造函数</span></span><br><span class="line">                            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                            locker.<span class="built_in">unlock</span>();<span class="comment">//取完可以解锁了</span></span><br><span class="line">                            <span class="built_in">task</span>();<span class="comment">//工作</span></span><br><span class="line">                            locker.<span class="built_in">lock</span>();<span class="comment">//工作完因为是while，再锁，接下来再取元素。</span></span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;<span class="comment">//结束线程</span></span><br><span class="line">                        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//没有元素，解锁并等待唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();<span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;<span class="comment">//强制转型，pool_有指向的话就是true，那么就准备让线程退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">                pool_-&gt;isClosed = <span class="literal">true</span>;<span class="comment">//退出标识</span></span><br><span class="line">            &#125;</span><br><span class="line">            pool_-&gt;cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有线程，要把工作都做完才退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;<span class="comment">//以模板定义的&amp;&amp;既能接受左值也能接受右值，但注意，task作为参数，有名且能寻址，成为了左值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;<span class="comment">//添加一个task，右值传入，使得传入的对象的所有权被task获取，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            <span class="comment">//c++11新特性，emplace使对象在内存中调用构造函数，push会先构造再拷贝构造</span></span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));<span class="comment">//完美转发，保留传入的左右值属性，</span></span><br><span class="line">            	<span class="comment">//直接传task是个左值，如果F是一个function&lt;&gt;类型，这会导致移动构造和拷贝构造的区别。如果F是一个普通函数或指针等，一律调用普通构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//唤醒等待队列中的第一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;<span class="comment">//线程池结构体，相当于在类里再封装一层</span></span><br><span class="line">        std::mutex mtx;</span><br><span class="line">        std::condition_variable cond;</span><br><span class="line">        <span class="type">bool</span> isClosed;</span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列，元素是一个函数，执行任务，没有返回值。没有参数是因为bind绑定好了参数，不需要外部传</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_;<span class="comment">//使用共享指针，能自动销毁pool实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>先介绍下std::mutex：头文件<code>&lt;mutex&gt; </code>，实际上跟linux中pthread的互斥锁差不多，手动上锁和解锁。</p>
<ul>
<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
<li>unlock()， 解锁，释放对互斥量的所有权。</li>
<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
<p>真正好用的是std::lock_guard：头文件<code>&lt;mutex&gt; </code>，使用RAII机制，退出作用域就解锁。</p>
<ul>
<li><pre><code class="c++">template &lt;class _Mutex&gt;
class lock_guard &#123; // class with destructor that unlocks a mutex
public:
    using mutex_type = _Mutex;
    //无adopt_lock参数，构造时加锁
    explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123; // construct and lock
        _MyMutex.lock();
    &#125;
    //有adopt_lock参数，构造时不加锁
    lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123;&#125; // construct but don&#39;t lock
    //析构解锁
    ~lock_guard() noexcept &#123;
        _MyMutex.unlock();
    &#125;
    //屏蔽拷贝构造
    lock_guard(const lock_guard&amp;) = delete; 
    lock_guard&amp; operator=(const lock_guard&amp;) = delete; 

private:
    _Mutex&amp; _MyMutex;
&#125;;
</code></pre>
</li>
<li><p>lock_guard具有两种构造方法：</p>
<ol>
<li><code>lock_guard(mutex&amp; m)</code></li>
<li><code>lock_guard(mutex&amp; m, adopt_lock)</code>其中<code>mutex&amp; m</code>是互斥量，参数<code>adopt_lock</code>表示假定调用线程已经获得互斥体所有权并对其进行管理了。</li>
</ol>
</li>
</ul>
<p>再说下std::unique_lock：头文件<code>&lt;mutex&gt;</code>，也是使用RAII机制，定义和lock_guard相同。</p>
<p>主要还是说下二者的对比：</p>
<ul>
<li>std::unique_lock 与std::lock_guard都能实现自动加锁与解锁功能，但是std::unique_lock要比std::lock_guard更灵活，但是更灵活的代价是占用空间相对更大一点且相对更慢一点。</li>
<li>它提供了<code>lock()</code>和<code>unlock()</code>接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁。而lock_guard一锁就锁住一个作用域，直到退出才解锁，没有lock和unlock接口，有时只想锁住一段代码，用unique_lock就更灵活。</li>
<li><code>unique_lock</code>和<code>lock_guard</code>都不能复制，<code>lock_guard</code>不能移动，但是<code>unique_lock</code>可以</li>
<li>可以参考[<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/34d219380d90">c++11]多线程编程(五)——unique_lock - 简书 (jianshu.com)</a></li>
</ul>
<hr>
<p>条件变量std::condition_variable：头文件<code> &lt;condition_variable&gt;</code>，和linux的差不多了，可以看下<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38210354/article/details/107168532">(29条消息) C++11多线程条件变量std::condition_variable详解（转 ）_山城盛夏的博客-CSDN博客_std::condition_variable 详解</a>，当然不看也可以，无非是等待和唤醒。</p>
<hr>
<p>关于std::function，主要是用来包装函数的，像函数一样调用，具体可以参考之前的博客：<a href="https://jysama.cn/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">lambda表达式 | JySama</a></p>
<p>std::function是一个函数包装器，该函数包装器模板能包装任何类型的可调用实体，如普通函数，函数对象，lamda表达式等。包装器可拷贝，移动等，并且包装器类型仅仅依赖于调用特征，而不依赖于可调用元素自身的类型。std::function是C++11的新特性，包含在头文件<code>&lt;functional&gt;</code>中。</p>
<p>一个std::function类型对象实例可以包装下列这几种可调用实体：函数、函数指针、成员函数、静态函数、lamda表达式和函数对象。std::function对象实例可被拷贝和移动，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象实例未包含任何实际可调用实体时，调用该std::function对象实例将抛出std::bad_function_call异常。</p>
<hr>
<p>std::forward()：完美转发 </p>
<p>当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个<strong>左值</strong>。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。</p>
<p>std::forward必须配合T&amp;&amp;来使用。例如T&amp;&amp;接受左值int&amp;时，T会被推断为int&amp;，而T&amp;&amp;接受右值int&amp;&amp;时，T被推断为int。</p>
<hr>
<p>std::thread：头文件<code>&lt;thread&gt;</code>，可移动不可复制</p>
<ul>
<li>默认构造函数，创建一个空的 <code>std::thread</code> 执行对象： thread() noexcept;</li>
<li>初始化构造函数，创建一个 <code>std::thread</code> 对象，该 <code>std::thread</code> 对象可被 <code>joinable</code>，新产生的线程会调用 <code>fn</code> 函数，该函数的参数由 <code>args</code> 给出。<ul>
<li>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args);</li>
</ul>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库如出一辙，很好理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span> &#123;<span class="comment">//创建全局唯一的数据库连接池，维护多个与数据库的连接</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SqlConnPool *<span class="title">Instance</span><span class="params">()</span></span>;<span class="comment">//单例，静态成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MYSQL *<span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL * conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SqlConnPool</span>();</span><br><span class="line">    ~<span class="built_in">SqlConnPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_CONN_;</span><br><span class="line">    <span class="type">int</span> useCount_;</span><br><span class="line">    <span class="type">int</span> freeCount_;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;MYSQL *&gt; connQue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="type">sem_t</span> semId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SQLCONNPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">SqlConnPool::<span class="built_in">SqlConnPool</span>() &#123;<span class="comment">//放init也行，或者init放这</span></span><br><span class="line">    useCount_ = <span class="number">0</span>;</span><br><span class="line">    freeCount_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例模式</span></span><br><span class="line">    <span class="type">static</span> SqlConnPool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, <span class="type">const</span> <span class="type">char</span>* dbName,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>);<span class="comment">//条件判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connSize; i++) &#123;</span><br><span class="line">        MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//定义一个sql指针</span></span><br><span class="line">        sql = <span class="built_in">mysql_init</span>(sql);<span class="comment">//用这个指针初始化一个sql结构体，返回一个指向这个结构体的指针</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;<span class="comment">//错误判断，写日志</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);</span><br><span class="line">            <span class="built_in">assert</span>(sql);<span class="comment">//报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        sql = <span class="built_in">mysql_real_connect</span>(sql, host,</span><br><span class="line">                                 user, pwd,</span><br><span class="line">                                 dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);<span class="comment">//init后就connect，连接数据库，返回一个可用连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connQue_.<span class="built_in">push</span>(sql);<span class="comment">//放入队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    MAX_CONN_ = connSize;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);<span class="comment">//初始化信号量的值，这个0表示只能在当前进程的所有线程之间共享</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取一个可用连接</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//句柄</span></span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为什么前面判断了空这里还要用信号量呢？原因是线程可能在队列非空时纷涌而至，但实际上没有那么多连接可用，因此还是要信号量阻塞buffer</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);</span><br><span class="line">    &#123;<span class="comment">//lock的作用域</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//如果能取，要互斥</span></span><br><span class="line">        sql = connQue_.<span class="built_in">front</span>();</span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放一个连接，放回队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* sql)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sql);<span class="comment">//判空，不能放回虚假的连接</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//互斥放回</span></span><br><span class="line">    connQue_.<span class="built_in">push</span>(sql);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);<span class="comment">//post</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//锁住先，避免在close时被使用</span></span><br><span class="line">    <span class="keyword">while</span>(!connQue_.<span class="built_in">empty</span>()) &#123;<span class="comment">//循环取</span></span><br><span class="line">        <span class="keyword">auto</span> item = connQue_.<span class="built_in">front</span>();<span class="comment">//auto真给力...</span></span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">mysql_close</span>(item);<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免在使用库完成应用程序后发生内存泄漏(例如，在关闭与服务器的连接之后)，</span></span><br><span class="line">    <span class="comment">//可以显式调用mysql_library_end()。这样可以执行内存 Management 以清理和释放库使用的资源。</span></span><br><span class="line">    <span class="built_in">mysql_library_end</span>();        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前可用连接大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">SqlConnPool::~<span class="built_in">SqlConnPool</span>() &#123;</span><br><span class="line">    <span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-19</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源在对象构造初始化 资源在对象析构时释放*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span> &#123;<span class="comment">//以参数形式获取一个数据库连接</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool *connpool) &#123;<span class="comment">//双指针修改sql，为了获取连接，传入connpool</span></span><br><span class="line">        <span class="built_in">assert</span>(connpool);</span><br><span class="line">        *sql = connpool-&gt;<span class="built_in">GetConn</span>();<span class="comment">//获取连接</span></span><br><span class="line">        sql_ = *sql;<span class="comment">//记录</span></span><br><span class="line">        connpool_ = connpool;<span class="comment">//为了释放，需要记录sql和connpool</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(sql_) &#123; connpool_-&gt;<span class="built_in">FreeConn</span>(sql_); &#125;<span class="comment">//析构释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *sql_;</span><br><span class="line">    SqlConnPool* connpool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SQLCONNRAII_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>阻塞队列，用互斥锁再封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockDeque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockDeque</span><span class="params">(<span class="type">size_t</span> MaxCapacity = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BlockDeque</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; deq_;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity_;     </span><br><span class="line"></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condConsumer_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condProducer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::<span class="built_in">BlockDeque</span>(<span class="type">size_t</span> MaxCapacity) :<span class="built_in">capacity_</span>(MaxCapacity) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(MaxCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::~<span class="built_in">BlockDeque</span>() &#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">Close</span>() &#123;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        deq_.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">        isClose_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者，准备退出</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者，准备退出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//刷新，唤醒一个线程，准备工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有问题，前面close唤醒了线程，这里没有根据isclose变量直接退出，在pop那是退出了的，这里可能会卡住，一旦wait的太多，就可能一直写然后一直while。</span></span><br><span class="line"><span class="comment">//除非线程数严格小于容量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;<span class="comment">//条件变量的等待方式</span></span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);<span class="comment">//阻塞，等待唤醒，但唤醒后还是需要while看条件，因为有多个生产者在竞争</span></span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">full</span>()&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//如果close了就return了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个生产者线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout) &#123;<span class="comment">//增加了超时处理，push没有超时处理</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout)) </span><br><span class="line">                == std::cv_status::timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻塞超时就结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//关了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BLOCKQUEUE_H</span></span></span><br></pre></td></tr></table></figure>

<p>std::chrono::seconds：一个类，获取多少时间，这里以临时变量的形式传给wait_for，持续…seconds，超时结果就是timeout，和cv_status的timeout相等，借此判断是否超时。</p>
<p>std::cv_status：定义于头文件 <code>&lt;condition_variable&gt;</code>，带作用域枚举 <code>std::cv_status</code> 描述定时等待是否因时限返回。成员：</p>
<ul>
<li><code>no_timeout</code>：条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒</li>
<li><code>timeout</code>：条件变量因时限耗尽被唤醒</li>
</ul>
<p>wait_for：</p>
<p>返回值：若经过 <code>rel_time</code> 所指定的关联时限则为 std::cv_status::timeout，否则为 std::cv_status::no_timeout 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>           <span class="comment">// vastart va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">//mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* suffix =<span class="string">&quot;.log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;<span class="comment">//单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>;<span class="comment">//异步线程的回调函数，需要是staic，没有this隐藏参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isOpen_; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;<span class="comment">//互斥写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineCount_;</span><br><span class="line">    <span class="type">int</span> toDay_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isOpen_;</span><br><span class="line"> </span><br><span class="line">    Buffer buff_;<span class="comment">//一个日志仅有一个buffer，因为write被互斥锁锁住了</span></span><br><span class="line">    <span class="type">int</span> level_;</span><br><span class="line">    <span class="type">bool</span> isAsync_;</span><br><span class="line"></span><br><span class="line">    FILE* fp_;</span><br><span class="line">    std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_; <span class="comment">//智能指针，还没有实例</span></span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;<span class="comment">//指向一个thread，还没有实例</span></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以宏的形式，感觉写个string形式也行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>() &#123;</span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line">    isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    writeThread_ = <span class="literal">nullptr</span>;</span><br><span class="line">    deque_ = <span class="literal">nullptr</span>;</span><br><span class="line">    toDay_ = <span class="number">0</span>;</span><br><span class="line">    fp_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>()) &#123;<span class="comment">//如果写线程存在且需要join，就需要join</span></span><br><span class="line">        <span class="keyword">while</span>(!deque_-&gt;<span class="built_in">empty</span>()) &#123;<span class="comment">//不断唤醒消费者线程，把日志写完</span></span><br><span class="line">            deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        deque_-&gt;<span class="built_in">Close</span>();<span class="comment">//关掉</span></span><br><span class="line">        writeThread_-&gt;<span class="built_in">join</span>();<span class="comment">//join</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp_) &#123;<span class="comment">//如果文件打开了</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">flush</span>();<span class="comment">//刷新fp的缓冲区，还有唤醒线程的功能，这里没用</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);<span class="comment">//关掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;<span class="comment">//日志系统级别，越高级能写的类型越多，日志系统没到对应级别不能写</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level = <span class="number">1</span>, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    isOpen_ = <span class="literal">true</span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">    <span class="keyword">if</span>(maxQueueSize &gt; <span class="number">0</span>) &#123;<span class="comment">//如果设置了阻塞队列大小，就是异步</span></span><br><span class="line">        isAsync_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!deque_) &#123;</span><br><span class="line">            unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; <span class="built_in">newDeque</span>(<span class="keyword">new</span> BlockDeque&lt;std::string&gt;);<span class="comment">//创建一个实例</span></span><br><span class="line">            deque_ = <span class="built_in">move</span>(newDeque);<span class="comment">//unique指针只能移动构造</span></span><br><span class="line">            </span><br><span class="line">            <span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">NewThread</span><span class="params">(<span class="keyword">new</span> thread(FlushLogThread))</span></span>;<span class="comment">//异步同时要实例化一个写线程</span></span><br><span class="line">            writeThread_ = <span class="built_in">move</span>(NewThread);<span class="comment">//因为是单独线程，所以用unique指针，转移所有权用move</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    path_ = path;</span><br><span class="line">    suffix_ = suffix;</span><br><span class="line">    <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, </span><br><span class="line">            path_, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);<span class="comment">//日志文件名写到名称缓冲区</span></span><br><span class="line">    toDay_ = t.tm_mday;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">//互斥锁作用域，感觉没必要，init就主线程调用</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">        <span class="keyword">if</span>(fp_) &#123; <span class="comment">//如果文本打开了，就关了重新开</span></span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">            <span class="built_in">fclose</span>(fp_); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据名称创建or打开</span></span><br><span class="line">        <span class="keyword">if</span>(fp_ == <span class="literal">nullptr</span>) &#123;<span class="comment">//打开失败，没有目标文件夹，要先创建</span></span><br><span class="line">            <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);<span class="comment">//0777是最大的访问权</span></span><br><span class="line">            fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    <span class="comment">//宏参数初始化</span></span><br><span class="line">    va_list vaList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志日期 日志行数 */</span></span><br><span class="line">    <span class="keyword">if</span> (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_  %  MAX_LINES == <span class="number">0</span>)))<span class="comment">//如果日志行数太多写满了，或着换了一天，要重新创建一个文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//这个锁感觉放if外好一点，因为让一个线程进来创建好新文件更新day喝line就可以了，这样就会很多线程一起进这个if</span></span><br><span class="line">        locker.<span class="built_in">unlock</span>();<span class="comment">//等下要用一个锁，先创建好，解锁。这对于同步写有用，因为同步的话有很多线程会调用</span></span><br><span class="line">        <span class="comment">//把lock锁if外，然后处理完，更新day和line，打开新文件，再解锁，其他线程就不会进if了</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toDay_ != t.tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;<span class="comment">//-72是什么鬼，不需要那么长吗？</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);</span><br><span class="line">            toDay_ = t.tm_mday;<span class="comment">//给天赋值</span></span><br><span class="line">            lineCount_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_  / MAX_LINES), suffix_);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        locker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">flush</span>();</span><br><span class="line">        <span class="built_in">fclose</span>(fp_);</span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(newFile, <span class="string">&quot;a&quot;</span>);<span class="comment">//重新打开</span></span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后正常写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        lineCount_++;<span class="comment">//写一行</span></span><br><span class="line">        <span class="comment">//buffer不只是为日志系统写的，而且感觉这里不用buffer更好</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">                    t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">                    t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);<span class="comment">//向buffer写时间信息，n是写入的长度</span></span><br><span class="line">                    </span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(n);<span class="comment">//移动指针，前n个写时间信息</span></span><br><span class="line">        <span class="built_in">AppendLogLevelTitle_</span>(level);<span class="comment">//然后添加等级</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">va_start</span>(vaList, format);<span class="comment">//遍历参数</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);<span class="comment">//不断向buffer写，返回写入长度</span></span><br><span class="line">        <span class="built_in">va_end</span>(vaList);<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(m);<span class="comment">//移动指针</span></span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);<span class="comment">//加换行和终止</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>()) &#123;<span class="comment">//如果是异步的，放阻塞队列</span></span><br><span class="line">            deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果是同步的，开写</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);</span><br><span class="line">        &#125;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;<span class="comment">//添加信息头</span></span><br><span class="line">    <span class="keyword">switch</span>(level) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span> </span>&#123;<span class="comment">//刷新缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(isAsync_) &#123; </span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(fp_);<span class="comment">//刷新文本的缓冲区，强制写完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数的运行函数</span></span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//这里只用了非超时的，如果有大量任务突然到来，可以创建多个线程使用超时pop</span></span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">pop</span>(str)) &#123;<span class="comment">//不断取str，写进文本</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Log* <span class="title">Log::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例函数</span></span><br><span class="line">    <span class="type">static</span> Log inst;</span><br><span class="line">    <span class="keyword">return</span> &amp;inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数，调用运行函数</span></span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize = <span class="number">1024</span>);</span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;       </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;<span class="comment">//buffer是一个vector...new一个得了，取地址比较简明</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_;<span class="comment">//原子类型，感觉还是用个互斥锁吧...资料太少了，查不到。不过操作buffer在顶层是被互斥锁锁住的，也许不用互斥</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BUFFER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize) : <span class="built_in">buffer_</span>(initBuffSize), <span class="built_in">readPos_</span>(<span class="number">0</span>), <span class="built_in">writePos_</span>(<span class="number">0</span>) &#123;&#125;<span class="comment">//初始化列表，使用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//准备好的字节数</span></span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;<span class="comment">//原子地相减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//可写入的字节数</span></span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//已读字节数</span></span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回readpos之后的字符串/位置，即准备好但没有取出的数据的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + readPos_;<span class="comment">//定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//buffer被取出了多少字节</span></span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    readPos_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span> </span>&#123;<span class="comment">//过滤到end之后</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end );<span class="comment">//已读的记录比已取出的小，地址的比较</span></span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>());<span class="comment">//被出去了这么多字节（地址）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出，清空</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());</span><br><span class="line">    readPos_ = <span class="number">0</span>;</span><br><span class="line">    writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出并转字string</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(), ReadableBytes())</span></span>;</span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回写到的位置之后的字符串，有何意义？后面不是没写到吗</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个能写的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//已写入多少个字节</span></span><br><span class="line">    writePos_ += len;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;<span class="comment">//重载函数</span></span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//任何指针类型data</span></span><br><span class="line">    <span class="built_in">assert</span>(data);</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);<span class="comment">//其他类型，就强制转型为char*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//char*优先匹配</span></span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);<span class="comment">//确保空间足够</span></span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());</span><br><span class="line">    <span class="built_in">HasWritten</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加另一个buff的数据</span></span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//确保这么大的长度能写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() &lt; len) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">WritableBytes</span>() &gt;= len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//接收</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];<span class="comment">//如果第一个缓冲区填不满，就用到这个缓冲区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">WritableBytes</span>();</span><br><span class="line">    <span class="comment">/* 分散读， 保证数据全部读完 */</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginPtr_</span>() + writePos_;<span class="comment">//定位可写的地方，不就是beginwrite()吗</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);<span class="comment">//2是指iovec结构的个数，返回值是有符号整型</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writable) &#123;<span class="comment">//转为无符号整型，长度是一样的</span></span><br><span class="line">        writePos_ += len;<span class="comment">//小于可写的地方就更新当前的buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//写的超出了buffer可写的空间</span></span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>();<span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">Append</span>(buff, len - writable);<span class="comment">//添加buff的数据，会扩大buffer的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//写出</span></span><br><span class="line">    <span class="type">size_t</span> readSize = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd, <span class="built_in">Peek</span>(), readSize);<span class="comment">//从当前开始（peek），写入准备好的数据</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125; </span><br><span class="line">    readPos_ += len;<span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char* 返回指向的字符串的首地址、也可以返回第一个字符、也可以返回整个字符串</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个char的地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();<span class="comment">//*begin()取第一个字符，&amp;取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//区别是返回值要不要当常量处理</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//扩容函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len) &#123;<span class="comment">//如果可写和已读都小于len，就必须重新开辟空间</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>);<span class="comment">//resize</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//否则，可以把已读的覆盖</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();<span class="comment">//准备好的数据大小</span></span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>());<span class="comment">//把中间未读的，从头开始覆盖</span></span><br><span class="line">        readPos_ = <span class="number">0</span>;<span class="comment">//已读为0</span></span><br><span class="line">        writePos_ = readPos_ + readable;<span class="comment">//写的位置是准备好的数据的位置</span></span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>注意：这里没有加锁，上层的调用要加锁</p>
<p>chrono可以稍微参考下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oncealong/article/details/28599655">(29条消息) C++11的chrono库，可实现毫秒微秒级定时_oncealong的博客-CSDN博客_chrono sleep</a>。里面提了三种类型，虽然不详细。</p>
<ul>
<li>std::chrono::high_resolution_clock：high_resolution_clock只不过是system_clock或者steady_clock的typedef。用于获取时间点。<ul>
<li>std::chrono::system_clock 它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</li>
<li>std::chrono::steady_clock 为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大。用在需要得到时间间隔，并且这个时间间隔不会因为修改系统时间而受影响的场景；它是单调的时钟，相当于教练手中的秒表；只会增长，适合用于记录程序耗时，他表示的时钟是不能设置的。</li>
<li>可以使用now()方法取得时间，是一个纳秒，相对系统启动的时间多少。一般用time_point：<code>std::chrono::high_resolution_clock::time_point t1=std::chrono::high_resolution_clock::now()</code>;或者<code>auto t1=std::chrono::high_resolution_clock::now();</code></li>
</ul>
</li>
<li>std::chrono::milliseconds：表示毫秒，是一个时间间隔。</li>
<li>在代码里面，now()+MS(timeout)被赋值到high_resolution_clock的time_point上，毫秒会转换为纳秒加上去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;<span class="comment">//时钟</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;<span class="comment">//时间间隔</span></span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;<span class="comment">//时钟内的时间点，获取now()方法结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;<span class="comment">//时间结构</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//这个id用来给哈希表映射，这样查找时间是O(1)，通过id映射到位置。</span></span><br><span class="line">    TimeStamp expires;<span class="comment">//时间点</span></span><br><span class="line">    TimeoutCallBack cb;<span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;</span><br><span class="line">        <span class="keyword">return</span> expires &lt; t.expires;<span class="comment">//比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;<span class="comment">//先指定vector有64个空间，其他情况下会两倍两倍的扩容</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//用size_t作为索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;TimerNode&gt; heap_;<span class="comment">//用vector实现堆，是一个小顶堆</span></span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;<span class="comment">//哈希表，i-&gt;size_t</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAP_TIMER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;<span class="comment">//向上过滤，用于插入节点</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[j] &lt; heap_[i]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;<span class="comment">//交换节点的辅助函数</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">swap</span>(heap_[i], heap_[j]);<span class="comment">//交换vector元素</span></span><br><span class="line">    ref_[heap_[i].id] = i;<span class="comment">//更改哈希表的映射</span></span><br><span class="line">    ref_[heap_[j].id] = j;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span> </span>&#123;<span class="comment">//向下过滤，用于建堆和删除顶点。这里是左闭右开的，n是取不到的右边界</span></span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; heap_[j + <span class="number">1</span>] &lt; heap_[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(heap_[i] &lt; heap_[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt; index;<span class="comment">//如果向下过滤了就返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;<span class="comment">//插入节点，关联回调函数</span></span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 新节点：堆尾插入，调整堆 */</span></span><br><span class="line">        i = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = i;<span class="comment">//先放i处</span></span><br><span class="line">        <span class="comment">//结构体可以struct A = &#123;...&#125;，调用默认构造函数，但必须把所有成员都赋值。常见的是struct A; A.x = ...逐个赋值</span></span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout), cb&#125;);<span class="comment">//放i处，调用默认构造函数</span></span><br><span class="line">        <span class="built_in">siftup_</span>(i);<span class="comment">//向上过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果原来就有这个节点，说明没到时，重设时间，调整一下即可</span></span><br><span class="line">        <span class="comment">/* 已有结点：调整堆 */</span></span><br><span class="line">        i = ref_[id];<span class="comment">//获得位置</span></span><br><span class="line">        heap_[i].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);<span class="comment">//调整</span></span><br><span class="line">        heap_[i].cb = cb;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>())) &#123;<span class="comment">//调整之后看看向上还是向下，如果不用向下过滤，那就向上过滤；如果向下过滤了，就不用向上了</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定id结点，并触发回调函数 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    TimerNode node = heap_[i];<span class="comment">//拷贝节点，如果是串行的话，是不是不需要拷贝，反正是调用完再删除</span></span><br><span class="line">    node.<span class="built_in">cb</span>();<span class="comment">//调用回调函数</span></span><br><span class="line">    <span class="built_in">del_</span>(i);<span class="comment">//删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定位置的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">/* 将要删除的结点换到队尾，然后调整堆 */</span></span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//下标=大小-1</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt;= n);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;<span class="comment">//删的不是最后一个元素就交换</span></span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, n);<span class="comment">//把目前最后的元素换到前面去，此时要删的元素放到了最后</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, n)) &#123;<span class="comment">//然后要调整这个元素的位置，先试一下向下过滤</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);<span class="comment">//不向下过滤的话就向上过滤。这里为什么要向上过滤呢？因为堆的兄弟之间没有关系，大堆有两个子堆，如果交换到另一个子堆就可能要向上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 队尾元素删除 */</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 调整指定id的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id) &gt; <span class="number">0</span>);</span><br><span class="line">    heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);</span><br><span class="line">    <span class="built_in">siftdown_</span>(ref_[id], heap_.<span class="built_in">size</span>());<span class="comment">//调整只可能更大，向下过滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;<span class="comment">//这里的tick()时间复杂度要比链表形式的高</span></span><br><span class="line">    <span class="comment">/* 清除超时结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();<span class="comment">//取顶</span></span><br><span class="line">        <span class="comment">//这里先用预设时间-当前时间，结果是一个纳秒级的时间间隔，用间隔转换转到毫秒级，调用count()，它的作用是返回当前级别还有多少ticks（单位时间）</span></span><br><span class="line">        <span class="comment">//比如3ms就有3ticks（在毫秒级下），因此这里是忽略毫秒级以下的数，只有剩余1毫秒及以上才不算超时。这是因为设定的超时时间是毫秒的，当然只看毫秒</span></span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123; <span class="comment">//等于0或小于0都超时</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="built_in">cb</span>();<span class="comment">//超时，调用回调函数</span></span><br><span class="line">        <span class="built_in">pop</span>();<span class="comment">//删除顶部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);<span class="comment">//删除0号位置的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清除</span></span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;<span class="comment">//看未超时的顶点剩下多少ticks</span></span><br><span class="line">    <span class="built_in">tick</span>();<span class="comment">//处理完超时的节点</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果非空</span></span><br><span class="line">        res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();<span class="comment">//看顶点还剩多少ticks（毫秒级别下）</span></span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; res = <span class="number">0</span>; &#125;<span class="comment">//负数说明预设时间小于当前时间，也就是时间间隔是负的，说明超时了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//-1说明空了，0说明超时了，大于0说明剩下的ticks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h2><p>涉及到一个string.data()，看到比较好的文章里面提到了一点：</p>
<p>为什么C语言风格的字符串要以’\0’结尾，C++（string）可以不要？</p>
<p>c语言用char*指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而c++语言则是面向对象的（string），长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。</p>
<hr>
<ul>
<li>首先会尝试把文件信息写入stat结构体，根据文件找不找得到、文件权限，得到对应的状态码。stat结构体主要是获得文件size</li>
<li>如果状态码是404那些，就把路径和stat结构体修改为404那些html文件的路径，如果是200OK，就再不修改。</li>
<li>然后添加状态行、头部信息</li>
<li>最后添加文件内容信息：<ul>
<li>先根据文件路径打开文件，可能是404那些html，也可能是真的文件。如果打开失败，会返回一个file not found的html</li>
<li>打开成功的话会尝试去内存映射，stat结构体的size在这有用。如果映射失败，也会返回一个file not found的html</li>
<li>如果打开成功，会添加文件的长度信息，把内存地址指针保存，可通过接口调用。因为不会真正写入文件内容</li>
<li>在添加文件长度信息后，顺便添加一个空行。</li>
</ul>
</li>
<li>没有写入内容，等待外部写入。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-25</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// mmap, munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();</span><br><span class="line">    ~<span class="built_in">HttpResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code_;<span class="comment">//响应状态码</span></span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;</span><br><span class="line"></span><br><span class="line">    std::string path_;<span class="comment">//资源路径</span></span><br><span class="line">    std::string srcDir_;<span class="comment">//资源文件夹路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* mmFile_; <span class="comment">//指向内存映射后的文件的内存空间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;<span class="comment">//存储文件信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的且不允许修改</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;<span class="comment">//把后缀类型映射到http的文件类型</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;<span class="comment">//把响应码映射到响应字符串</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;<span class="comment">//把响应码映射到响应需要发送的html文件的路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_RESPONSE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-27</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员定义，用&#123;&#125;构造整体，用&#123;key,value&#125;构造元素</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123; <span class="number">200</span>, <span class="string">&quot;OK&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    code_ = <span class="number">-1</span>;</span><br><span class="line">    path_ = srcDir_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();<span class="comment">//解除内存映射，不用参数，用mmFile_指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> string&amp; srcDir, string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123; <span class="built_in">UnmapFile</span>(); &#125;<span class="comment">//一个上层实例由一个线程控制，那么一个类实例可以多次init，多次的话就要把原来的映射解除</span></span><br><span class="line">    code_ = code;<span class="comment">//传入的状态，会根据之后的文件打开/访问成功与否改变</span></span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    <span class="comment">//访问的文件路径</span></span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向buff写入响应信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//传入一个buff，没有真正写入文件内容（file not found除外，自定义返回了一个html）</span></span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="comment">//stat函数，向stat结构体中写入path指定的文件信息，成功返回0，失败返回-1</span></span><br><span class="line">    <span class="comment">//S_ISDIR()函数的作用是判断一个路径是不是目录，st_mode表示了文件对应的模式：文件，目录等。函数返回0表示是文件，返回1是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;<span class="comment">//如果请求的文件不存在或者是文件夹，就404not found</span></span><br><span class="line">        code_ = <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//st_mode是个32位的整型变量，不过现在的linux操作系统只用了低16位（估计是鉴于以后拓展的考虑）</span></span><br><span class="line">    <span class="comment">//最低9位代表了文件的许可权限，它标识了文件所有者（owner）、组用户（group）、其他用户（other）的读（r）、写（w）、执行（x）权限。</span></span><br><span class="line">    <span class="comment">//S_IROTH：00004（无符号八进制数）：others have read permission</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;<span class="comment">//也即，如果其他用户没有读权限的话就返回403forbidden</span></span><br><span class="line">        code_ = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>) &#123; <span class="comment">//如果上面都没有，且没有被init为400，那就是初始值-1，表示ok</span></span><br><span class="line">        code_ = <span class="number">200</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();<span class="comment">//如果是error状态，会把对应的html页面文件信息添加到stat结构体中，把路径改了，成功就不做任何事情</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);<span class="comment">//添加状态行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);<span class="comment">//添加头部信息</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);<span class="comment">//返回文件内容，会尝试真正地打开文件，映射到内存，但是没有写入buff，会把内存指针放到mmFile_，File()接口调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;<span class="comment">//返回文件映射到内存的位置</span></span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回文件的大小</span></span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;<span class="comment">//如果是200OK，就不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span>(CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有响应码对应的html文件，count找到返回1，否则0</span></span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//find返回一个迭代器，first是key，second是value。</span></span><br><span class="line">        <span class="comment">//感觉可以用CODE_PATH[code_]，因为前面已经找到了才执行，虽说内部也会遍历去find。另外，如果直接用[]，没有这个元素会插入</span></span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);<span class="comment">//把这个错误页面文件信息保存到stat中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//向buff添加状态头部</span></span><br><span class="line">    string status;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有code_对应的状态</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//获取状态字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//上面处理了200，404，403，如果code_不知道被赋值成什么了，就400</span></span><br><span class="line">        code_ = <span class="number">400</span>;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(<span class="number">400</span>)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + <span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加头部信息</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(isKeepAlive_) &#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加返回内容</span></span><br><span class="line">    <span class="comment">//打开文件，string.data()返回c式字符串指针，c++11后与c_str()等价，结尾加&#x27;\0&#x27;。</span></span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);<span class="comment">//O_RDONLY表示只读</span></span><br><span class="line">    <span class="keyword">if</span>(srcFd &lt; <span class="number">0</span>) &#123; <span class="comment">//打开失败</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射到内存提高文件的访问速度 </span></span><br><span class="line"><span class="comment">        MAP_PRIVATE 建立一个写入时拷贝的私有映射*/</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成功返回创建的映射区的首地址；失败返回宏MAP_FAILED，这个宏就是-1。mmap返回一个void*</span></span><br><span class="line">    <span class="comment">//返回值用mmret指向，表示指向一个int类型，解指针时以int类型解析，找4个字节</span></span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*mmRet == <span class="number">-1</span>) &#123;<span class="comment">//取int，如果是-1表示失败了</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);<span class="comment">//这里的notfound，实际上打开了文件了，但是写进内存出错了</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取地址，修改指向的类型，两个指针指向的地址起始相同，但现在解指针按照char的解析类型解析，找一个字节。</span></span><br><span class="line">    <span class="comment">//多少个字节都无妨，因为munmap传入的地址参数类型是void*指针，只要首地址正确就好</span></span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;</span><br><span class="line">    <span class="built_in">close</span>(srcFd);<span class="comment">//关闭文件</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//只添加内容长度，两个\r\n，后面那个表示空行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size);<span class="comment">//解除映射</span></span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 判断文件类型 */</span></span><br><span class="line">    <span class="comment">//find_last_of返回最后一个.的位置，就是后缀类型前面那个.。逆向查找，返回的是下标</span></span><br><span class="line">    <span class="comment">//size_type是string的长度表示方式，不同的机器大小不同，为了匹配机器上string的最大长度。因此找位置、长度这些要用size_type</span></span><br><span class="line">    string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);<span class="comment">//找不到返回string::npos，表示不存在位置，值是-1</span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string suffix = path_.<span class="built_in">substr</span>(idx);<span class="comment">//从.开始返回后缀</span></span><br><span class="line">    <span class="keyword">if</span>(SUFFIX_TYPE.<span class="built_in">count</span>(suffix) == <span class="number">1</span>) &#123;<span class="comment">//有相应的类型就返回</span></span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;<span class="comment">//没有相应类型就返回这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, string message)</span> <span class="comment">//自定义错误信息，在添加内容时遇到错误就返回这个html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string body;</span><br><span class="line">    string status;</span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    body += <span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status  + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>用到正则，语法：<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 – 语法 | 菜鸟教程 (runoob.com)</a></p>
<p>几种用法：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sgdd123/p/7778599.html">C++ regex库的三种正则表达式操作 - 上官栋 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-25</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_REQUEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_REQUEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span>  <span class="comment">//mysql</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PARSE_STATE</span> &#123;<span class="comment">//解析状态</span></span><br><span class="line">        REQUEST_LINE,</span><br><span class="line">        HEADERS,</span><br><span class="line">        BODY,</span><br><span class="line">        FINISH,        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">HTTP_CODE</span> &#123;</span><br><span class="line">        NO_REQUEST = <span class="number">0</span>,</span><br><span class="line">        GET_REQUEST,</span><br><span class="line">        BAD_REQUEST,</span><br><span class="line">        NO_RESOURSE,</span><br><span class="line">        FORBIDDENT_REQUEST,</span><br><span class="line">        FILE_REQUEST,</span><br><span class="line">        INTERNAL_ERROR,</span><br><span class="line">        CLOSED_CONNECTION,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HttpRequest</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">path</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">version</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    todo </span></span><br><span class="line"><span class="comment">    void HttpConn::ParseFormData() &#123;&#125;</span></span><br><span class="line"><span class="comment">    void HttpConn::ParseJson() &#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd, <span class="type">bool</span> isLogin)</span></span>;</span><br><span class="line"></span><br><span class="line">    PARSE_STATE state_;<span class="comment">//描述目前的解析状态</span></span><br><span class="line">    std::string method_, path_, version_, body_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; header_;<span class="comment">//保存信息，描述-&gt;参数</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; post_;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DEFAULT_HTML;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFAULT_HTML_TAG;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ConverHex</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_REQUEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_set&lt;string&gt; HttpRequest::DEFAULT_HTML&#123;</span><br><span class="line">            <span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">             <span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;/video&quot;</span>, <span class="string">&quot;/picture&quot;</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, <span class="type">int</span>&gt; HttpRequest::DEFAULT_HTML_TAG &#123;</span><br><span class="line">            &#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;,  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method_ = path_ = version_ = body_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    state_ = REQUEST_LINE;</span><br><span class="line">    header_.<span class="built_in">clear</span>();</span><br><span class="line">    post_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>) &#123;<span class="comment">//如果有头部有这个参数，就去找要不要keep</span></span><br><span class="line">        <span class="keyword">return</span> header_.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>)-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp; version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> CRLF[] = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != FINISH) &#123;</span><br><span class="line">        <span class="comment">//search：查找 [first1, last1) 范围内第一个 [first2, last2) 子序列，返回指向first2的首地址。未找到就返回last1，请求数据就没/r/n</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineEnd = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);<span class="comment">//每次获取一行</span></span><br><span class="line">        <span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;<span class="comment">//拷贝一行，左闭右开</span></span><br><span class="line">        <span class="keyword">switch</span>(state_)<span class="comment">//看看现在是在解析什么</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_LINE:<span class="comment">//请求行</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">ParseRequestLine_</span>(line)) &#123;<span class="comment">//会根据要访问什么资源把path弄好</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有数据但是请求行都没准备好</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ParsePath_</span>();<span class="comment">//解析path</span></span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> HEADERS:</span><br><span class="line">            <span class="built_in">ParseHeader_</span>(line);<span class="comment">//不断解析头部</span></span><br><span class="line">            <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;<span class="comment">//解析完一个头部后会判断是不是/r/n，两个字节就是空行，没有请求数据，就结束</span></span><br><span class="line">                state_ = FINISH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BODY:</span><br><span class="line">            <span class="built_in">ParseBody_</span>(line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lineEnd == buff.<span class="built_in">BeginWrite</span>()) &#123; <span class="keyword">break</span>; &#125;<span class="comment">//空了，提前结束，避免buff出错，因为请求数据可能没有/r/n</span></span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>);<span class="comment">//过滤/r/n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求文件路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path_ == <span class="string">&quot;/&quot;</span>) &#123;<span class="comment">//输入ip地址最后只有一个/，返回的就是主页面</span></span><br><span class="line">        path_ = <span class="string">&quot;/index.html&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item: DEFAULT_HTML) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item == path_) &#123;<span class="comment">//遍历集合</span></span><br><span class="line">                path_ += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看一个请求行的实例：GET /562f25980001b1b106000338.jpg HTTP/1.1</span></span><br><span class="line"><span class="comment">//第一个^表示开始，匹配的字符串开始必须是[^ ]*，这个表示匹配除了空格的所有，遇到空格结束。然后会跟一个空格，再匹配下一个连续的串，遇到空格为止</span></span><br><span class="line"><span class="comment">//然后匹配一个空格，匹配HTTP/，再匹配除了空格的内容，如果有/r/n，也会匹配。最后$表示结束，后面不再匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParseRequestLine_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^ ]*) ([^ ]*) HTTP/([^ ]*)$&quot;</span>)</span></span>;<span class="comment">//匹配模式</span></span><br><span class="line">    smatch subMatch;<span class="comment">//存储结果，每个()中是一个子表达式，第0个参数是完整结果，1-n是()中的结果</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;<span class="comment">//严格要求各参数之间只有一个空格</span></span><br><span class="line">        method_ = subMatch[<span class="number">1</span>];</span><br><span class="line">        path_ = subMatch[<span class="number">2</span>];</span><br><span class="line">        version_ = subMatch[<span class="number">3</span>];<span class="comment">//说明传进来的line的/r/n被去掉了</span></span><br><span class="line">        state_ = HEADERS;<span class="comment">//接下来解析请求头</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求头，比如host: ... 或者host:...</span></span><br><span class="line"><span class="comment">//首先匹配冒号前面的，到冒号停下，然后匹配冒号，然后是一个空格，问号表示这个空格可以匹配0次或1次，因为报文中空格可以0次或多次</span></span><br><span class="line"><span class="comment">//然后匹配剩下的除换行符之外的所有字符，.相当于[^\n\r]。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^:]*): ?(.*)$&quot;</span>)</span></span>;</span><br><span class="line">    smatch subMatch;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;<span class="comment">//匹配成功</span></span><br><span class="line">        header_[subMatch[<span class="number">1</span>]] = subMatch[<span class="number">2</span>];<span class="comment">//添加头部信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//失败就是到空行了，准备解析请求体。上层会判断是否有请求体，没有就结束</span></span><br><span class="line">        state_ = BODY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求体，就是post的请求数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    body_ = line;<span class="comment">//拷贝</span></span><br><span class="line">    <span class="built_in">ParsePost_</span>();<span class="comment">//调用解析post</span></span><br><span class="line">    state_ = FINISH;<span class="comment">//结束咯</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpRequest::ConverHex</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;<span class="comment">//把一个十六进制的字符转为int数字</span></span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>) <span class="keyword">return</span> ch -<span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;<span class="comment">//+10是因为A本身在十六进制代表10</span></span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;f&#x27;</span>) <span class="keyword">return</span> ch -<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;<span class="comment">//是不是忘了-&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//application/x-www-form-urlencoded是最常见的 POST 提交数据方式。这里只解析这种格式</span></span><br><span class="line">    <span class="comment">//请求数据实例：name=Professional%20Ajax&amp;publisher=Wiley</span></span><br><span class="line">    <span class="keyword">if</span>(method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp; header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">ParseFromUrlencoded_</span>();<span class="comment">//把body解码</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML_TAG.<span class="built_in">count</span>(path_)) &#123;<span class="comment">//login的话，post的url就是当前请求的页面，就能解析到是/login.html，得到对应tag</span></span><br><span class="line">            <span class="type">int</span> tag = DEFAULT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;</span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Tag:%d&quot;</span>, tag);</span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span> || tag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);<span class="comment">//看是登录还是注册</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin)) &#123;<span class="comment">//处理登录和处理注册</span></span><br><span class="line">                    path_ = <span class="string">&quot;/welcome.html&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/error.html&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name1=value1&amp;name2=value2&amp;name3=value3&amp;.....&amp;nameN=valueN</span></span><br><span class="line"><span class="comment">//用&quot;+&quot;取代空字符</span></span><br><span class="line"><span class="comment">//非数字, 字母用%HH格式进行替换, 其中HH是两位16进制数字, 表示被替换字符的ASCII码(例如&quot;?&quot;会被替换成&quot;%3F&quot;, 对应十进制数是63,也就是问号对应的ASCII值)</span></span><br><span class="line"><span class="comment">//换行符用CR LF字符对表示, 对应的值是&quot;%0D%0A&quot;;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(body_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    string key, value;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;<span class="comment">//逐个解析</span></span><br><span class="line">        <span class="type">char</span> ch = body_[i];</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:<span class="comment">//如果是等号，key就是j-i-1这一段，</span></span><br><span class="line">            key = body_.<span class="built_in">substr</span>(j, i - j);<span class="comment">//长度是i-j</span></span><br><span class="line">            j = i + <span class="number">1</span>;<span class="comment">//下一个str起始</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//如果是+，换回空格</span></span><br><span class="line">            body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:<span class="comment">//后面跟两个十六进制的字符</span></span><br><span class="line">            num = <span class="built_in">ConverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">ConverHex</span>(body_[i + <span class="number">2</span>]);<span class="comment">//转化为对应的ascii码</span></span><br><span class="line">            body_[i + <span class="number">2</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            body_[i + <span class="number">1</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;<span class="comment">//并不是转换为ascii对应的符号，转换为数字对应的字符形式而已，就是16进制转十进制</span></span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:<span class="comment">//如果是&amp;，就得到value</span></span><br><span class="line">            value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            post_[key] = value;<span class="comment">//存储</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(j &lt;= i);<span class="comment">//处理最后一个value，它没有&amp;</span></span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">        post_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;pwd, <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;<span class="comment">//空的话返回错误</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());<span class="comment">//否则就记录</span></span><br><span class="line">    MYSQL* sql;</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(&amp;sql,  SqlConnPool::<span class="built_in">Instance</span>());<span class="comment">//初始化连接数据库，返回全局的静态的连接池</span></span><br><span class="line">    <span class="built_in">assert</span>(sql);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> order[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MYSQL_FIELD *fields = <span class="literal">nullptr</span>;</span><br><span class="line">    MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!isLogin) &#123; flag = <span class="literal">true</span>; &#125;<span class="comment">//如果是注册</span></span><br><span class="line">    <span class="comment">/* 查询用户及密码 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;SELECT username, password FROM user WHERE username=&#x27;%s&#x27; LIMIT 1&quot;</span>, name.<span class="built_in">c_str</span>());<span class="comment">//sql语句，查一个</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; <span class="comment">//执行语句，成功返回0，错误返回非0</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);<span class="comment">//错误的话释放结果集并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">mysql_store_result</span>(sql);<span class="comment">//完整的结果集</span></span><br><span class="line">    j = <span class="built_in">mysql_num_fields</span>(res); <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    fields = <span class="built_in">mysql_fetch_fields</span>(res);<span class="comment">//返回所有字段结构的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res)) &#123;<span class="comment">//遍历行，实际上只有一行，但这样可以取出行</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        <span class="comment">// 能select到说明又对应的username，看是登录还是注册</span></span><br><span class="line">        <span class="keyword">if</span>(isLogin) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwd == password) &#123; flag = <span class="literal">true</span>; &#125;<span class="comment">//标记成功，可以直接return的</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;pwd error!&quot;</span>);</span><br><span class="line">                <span class="comment">//可以直接return的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//如果是注册，注意能进到这个while说明取出了row，就说明前面res select到了一个username，重名了</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;user used!&quot;</span>);</span><br><span class="line">            <span class="comment">//可以直接return的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_free_result</span>(res);<span class="comment">//释放结果集使用的内存，store后要释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册行为 且 用户名未被使用*/</span></span><br><span class="line">    <span class="keyword">if</span>(!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;regirster!&quot;</span>);</span><br><span class="line">        <span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(order, <span class="number">256</span>,<span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());<span class="comment">//插入表</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;Insert error!&quot;</span>);</span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">FreeConn</span>(sql);<span class="comment">//这行不用，使用了RAII机制了</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;UserVerify success!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">HttpRequest::path</span><span class="params">()</span></span>&#123;<span class="comment">//外部可修改path_</span></span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> version_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口函数，供外部使用，用于获取解析请求体后获得的参数</span></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上层调用"><a href="#上层调用" class="headerlink" title="上层调用"></a>上层调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>      </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;<span class="comment">//是否是ET触发模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> fd_;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">sockaddr_in</span> addr_;<span class="comment">//internet环境下套接字的地址形式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> iovCnt_;<span class="comment">//根据有没有文件要传，有的话就是两个。打开文件失败的话，会返回自定义的html，这个html是写到buff的，此时没有文件要传</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];<span class="comment">//0发送响应报文，1发送响应文件</span></span><br><span class="line">    </span><br><span class="line">    Buffer readBuff_; <span class="comment">// 读缓冲区</span></span><br><span class="line">    Buffer writeBuff_; <span class="comment">// 写缓冲区</span></span><br><span class="line"></span><br><span class="line">    HttpRequest request_;</span><br><span class="line">    HttpResponse response_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount;</span><br><span class="line"><span class="type">bool</span> HttpConn::isET;</span><br><span class="line"></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;</span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();</span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>; </span><br><span class="line">        userCount--;</span><br><span class="line">        <span class="built_in">close</span>(fd_);</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ntoa：network to ascii，将网络地址转换成“.”点隔的字符串格式</span></span><br><span class="line"><span class="comment">//&lt;arpa/inet.h&gt;，char *inet_ntoa (struct in_addr);参数是结构体</span></span><br><span class="line"><span class="comment">//相反的函数是inet_addr，讲ip转换为长整型，参数是ip字符串，如addr_.sin_addr.s_addr = inet_addr(&quot;132.241.5.10&quot;);</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;<span class="comment">//sin_port存储端口号（使用网络字节顺序）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//读数据到自己的缓冲区</span></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);<span class="comment">//调用读缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isET);<span class="comment">//如果是ET模式就一直读取直到len==0，LT模式就读一次就结束</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//iov里的数据写出去</span></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_, iov_, iovCnt_);<span class="comment">//写多个非连续缓冲区（聚集写），成功返回字节数，失败返回-1，因此用ssize_t，是signed的</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125; <span class="comment">/* 传输结束 */</span><span class="comment">//也就是TuWriteBytes()==0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len) &#123;<span class="comment">//第一个缓冲区以写完</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len);<span class="comment">//更新第二个缓冲区剩下的</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;<span class="comment">//然后更新第一个缓冲区为0</span></span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>();<span class="comment">//写缓冲区已经发送完毕</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//c++中指针相互赋值要显式转换，void*可接受任意类型的赋值（不必转换）；反过来不行，void*要给其他变量赋值要显示转换</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len;<span class="comment">//typedef unsigned char  uint8_t;</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len);<span class="comment">//已经发送了len长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>);<span class="comment">//ET模式一直写，或者有太多字节要写了，就多写几次</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;<span class="comment">//解析请求数据，并把响应数据放到iovec结构体</span></span><br><span class="line">    request_.<span class="built_in">Init</span>();<span class="comment">//处理请求初始化</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;<span class="comment">//如果一点数据都没接收到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_)) &#123;<span class="comment">//有数据就处理，如果解析请求行错误就false</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());<span class="comment">//解析请求行成功，后面数据有无无所谓。get的话请求行就有路径，post的话会检查请求体，没有就返回error</span></span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);<span class="comment">//然后初始化响应</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);<span class="comment">//请求错误，返回400 bad request</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_);<span class="comment">//响应数据写到缓冲区</span></span><br><span class="line">    <span class="comment">/* 响应头 */</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());<span class="comment">//赋予内存起始地址，用const_cast消去const</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();<span class="comment">//大小</span></span><br><span class="line">    iovCnt_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;<span class="comment">//文件不写到缓冲区，直接返回文件内存映射的指针，给iov1</span></span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器顶层"><a href="#服务器顶层" class="headerlink" title="服务器顶层"></a>服务器顶层</h1><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;<span class="comment">//存放监听到的事件 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-19</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;<span class="comment">//构造内核事件表描述符，以及事件集合</span></span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);<span class="comment">//关闭句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;<span class="comment">//创建一个epoll_event，前面的vector存放事件，这里是为了描述事件的类型，关联fd。不初始化也可以：epoll_event ev;</span></span><br><span class="line">    ev.data.fd = fd;<span class="comment">//关联fd</span></span><br><span class="line">    ev.events = events;<span class="comment">//上层设置好类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);<span class="comment">//add，成功返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;<span class="comment">//和add差不多</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);<span class="comment">//mod</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;<span class="comment">//可以不创建，epoll_ctl(epollFd_, EPOLL_CTL_DEL, fd, 0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于timeout：-1：永远等待；0：不等待直接返回，执行下面的代码；其他：在超时时间内没有事件发生，返回0，如果有事件发生立即返回</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;<span class="comment">//成功返回多少事件就绪，超时返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;<span class="comment">//&amp;events_[0]等价于events；vector.size()返回类型是size_t，unsigned int转int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;<span class="comment">//调用wait后，从events事件集合中取出对应的可io的文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;<span class="comment">//调用wait后，从events事件集合中取出对应的事件的类型描述</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顶层调用"><a href="#顶层调用" class="headerlink" title="顶层调用"></a>顶层调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../timer/heaptimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/httpconn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>(</span><br><span class="line">        <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger, </span><br><span class="line">        <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span>  <span class="type">char</span>* sqlPwd, </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">        <span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitSocket_</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealListen_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>*info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtentTime_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseConn_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnProcess</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">    <span class="type">bool</span> openLinger_;</span><br><span class="line">    <span class="type">int</span> timeoutMS_;  <span class="comment">/* 毫秒MS */</span></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    <span class="type">int</span> listenFd_;<span class="comment">//fd是socket</span></span><br><span class="line">    <span class="type">char</span>* srcDir_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听是接受tcp连接，所谓的连接是指维护客户与服务器之间的数据交换</span></span><br><span class="line">    <span class="type">uint32_t</span> listenEvent_;<span class="comment">//监听模式，维护服务器的监听事件的类型</span></span><br><span class="line">    <span class="type">uint32_t</span> connEvent_;<span class="comment">//连接模式，维护客户端与服务器之间的连接事件的类型</span></span><br><span class="line">   <span class="comment">//动态创建的，都用智能指针</span></span><br><span class="line">    std::unique_ptr&lt;HeapTimer&gt; timer_;</span><br><span class="line">    std::unique_ptr&lt;ThreadPool&gt; threadpool_;</span><br><span class="line">    std::unique_ptr&lt;Epoller&gt; epoller_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, HttpConn&gt; users_;<span class="comment">//一个用户的socket匹配一个连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WEBSERVER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>(</span><br><span class="line">            <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">            <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span>  <span class="type">char</span>* sqlPwd,</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">            <span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize):</span><br><span class="line">            <span class="built_in">port_</span>(port), <span class="built_in">openLinger_</span>(OptLinger), <span class="built_in">timeoutMS_</span>(timeoutMS), <span class="built_in">isClose_</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="built_in">timer_</span>(<span class="keyword">new</span> <span class="built_in">HeapTimer</span>()), <span class="built_in">threadpool_</span>(<span class="keyword">new</span> <span class="built_in">ThreadPool</span>(threadNum)), <span class="built_in">epoller_</span>(<span class="keyword">new</span> <span class="built_in">Epoller</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    srcDir_ = <span class="built_in">getcwd</span>(<span class="literal">nullptr</span>, <span class="number">256</span>);<span class="comment">//获取当前路径</span></span><br><span class="line">    <span class="built_in">assert</span>(srcDir_);</span><br><span class="line">    <span class="built_in">strncat</span>(srcDir_, <span class="string">&quot;/resources/&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    HttpConn::userCount = <span class="number">0</span>;</span><br><span class="line">    HttpConn::srcDir = srcDir_;</span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">Init</span>(<span class="string">&quot;localhost&quot;</span>, sqlPort, sqlUser, sqlPwd, dbName, connPoolNum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitEventMode_</span>(trigMode);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">InitSocket_</span>()) &#123; isClose_ = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(openLog) &#123;</span><br><span class="line">        Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">init</span>(logLevel, <span class="string">&quot;./log&quot;</span>, <span class="string">&quot;.log&quot;</span>, logQueSize);</span><br><span class="line">        <span class="keyword">if</span>(isClose_) &#123; <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;========== Server init error!==========&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server init ==========&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Port:%d, OpenLinger: %s&quot;</span>, port_, OptLinger? <span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Listen Mode: %s, OpenConn Mode: %s&quot;</span>,</span><br><span class="line">                            (listenEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span>: <span class="string">&quot;LT&quot;</span>),</span><br><span class="line">                            (connEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span>: <span class="string">&quot;LT&quot;</span>));</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;LogSys level: %d&quot;</span>, logLevel);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;srcDir: %s&quot;</span>, HttpConn::srcDir);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;SqlConnPool num: %d, ThreadPool num: %d&quot;</span>, connPoolNum, threadNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">free</span>(srcDir_);</span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件，EPOLLRDHUP监听挂断事件，在底层完成</span></span><br><span class="line">    <span class="comment">//EPOLLRDHUP：https://blog.csdn.net/midion9/article/details/49883063</span></span><br><span class="line">    <span class="comment">//EPOLLHUP：https://blog.csdn.net/voidccc/article/details/8619632</span></span><br><span class="line">    listenEvent_ = EPOLLRDHUP;<span class="comment">//说明要监听对端是否挂断</span></span><br><span class="line">    connEvent_ = EPOLLONESHOT | EPOLLRDHUP;<span class="comment">//连接事务每次响应后要重新设置</span></span><br><span class="line">    <span class="keyword">switch</span> (trigMode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HttpConn::isET = (connEvent_ &amp; EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timeMS = <span class="number">-1</span>;  <span class="comment">/* epoll wait timeout == -1 无事件将阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(!isClose_) &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server start ==========&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(!isClose_) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;<span class="comment">//设置了超时处理的话，每轮都处理超时的事件</span></span><br><span class="line">            timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();<span class="comment">//获取下一个定时器超时的剩余时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);<span class="comment">//等待事件触发，有事件触发立即返回，没有会等timeMS的时间</span></span><br><span class="line">        <span class="comment">//等待的事件包括监听事件和读写事件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; i++) &#123;</span><br><span class="line">            <span class="comment">/* 处理事件 */</span></span><br><span class="line">            <span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);<span class="comment">//获取fd描述符</span></span><br><span class="line">            <span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);<span class="comment">//获取时间的类型</span></span><br><span class="line">            <span class="keyword">if</span>(fd == listenFd_) &#123;<span class="comment">//如果监听到一个新连接</span></span><br><span class="line">                <span class="built_in">DealListen_</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是触发的事件是对端断开或者对端异常（ERR通常是服务器读写（自身采取行动）发现对方异常触发）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;<span class="comment">//异常事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);<span class="comment">//确定user内保存了这个描述符</span></span><br><span class="line">                <span class="built_in">CloseConn_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLIN) &#123;<span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">DealRead_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLOUT) &#123;<span class="comment">//如果是写事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">DealWrite_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//非预期事件</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>*info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);<span class="comment">//向某个socket发生信息，送到对方的socket由对方处理这个信息</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;send error to client[%d] error!&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::CloseConn_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//关闭连接</span></span><br><span class="line">    <span class="built_in">assert</span>(client);<span class="comment">//首先会有一个连接类维护这个连接</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] quit!&quot;</span>, client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">    epoller_-&gt;<span class="built_in">DelFd</span>(client-&gt;<span class="built_in">GetFd</span>());<span class="comment">//获取连接类维护的socket并从事件表中删除，并不关闭</span></span><br><span class="line">    client-&gt;<span class="built_in">Close</span>();<span class="comment">//关闭连接，这个会关闭fd。实际上连接类的析构也会close()，但在使用过程中要手动释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建http连接</span></span><br><span class="line">    users_[fd].<span class="built_in">init</span>(fd, addr);<span class="comment">//不指定value的写法，会讲value以0初始化，然后这里再调用init</span></span><br><span class="line">    <span class="comment">//创建计时器关联http连接</span></span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;<span class="comment">//有超时处理的话，就绑定一个定时器，回调函数用来关闭连接。这种形式的回调函数不再需要是static</span></span><br><span class="line">        timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_, std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;users_[fd]));<span class="comment">//绑定参数，this是第一个参数，client是</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向内核事件表注册</span></span><br><span class="line">    epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);<span class="comment">//尝试通过listen socket连接，获取地址</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span>;&#125;<span class="comment">//连接失败，即没有数据了，返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HttpConn::userCount &gt;= MAX_FD) &#123;<span class="comment">//请求过多，无法连接</span></span><br><span class="line">            <span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);<span class="comment">//向socket发送错误信息</span></span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AddClient_</span>(fd, addr);<span class="comment">//添加连接</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(listenEvent_ &amp; EPOLLET);<span class="comment">//ET模式要把事件全部处理，应该就是把socket缓冲区的地址全部读完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//处理读事件</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);<span class="comment">//有响应就刷新时间</span></span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));<span class="comment">//唤醒一个线程处理读事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//处理写事件</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::ExtentTime_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//重新设置时间</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123; timer_-&gt;<span class="built_in">adjust</span>(client-&gt;<span class="built_in">GetFd</span>(), timeoutMS_); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//调用读</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">read</span>(&amp;readErrno);<span class="comment">//读取数据，把数据读到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;<span class="comment">//如果读不到数据且不是因为缓冲区空了，那么就异常，关闭连接</span></span><br><span class="line">        <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OnProcess</span>(client);<span class="comment">//读完了就解析请求数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//解析数据</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">process</span>()) &#123;<span class="comment">//如果解析成功了，无论是正常请求还是bad请求，通知内核事件输出，即修改成out</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//缓冲区一点数据都没收到，，继续读</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//调用写</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">write</span>(&amp;writeErrno);<span class="comment">//传输数据</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 传输完成 */</span></span><br><span class="line">        <span class="keyword">if</span>(client-&gt;<span class="built_in">IsKeepAlive</span>()) &#123;<span class="comment">//如果是keep</span></span><br><span class="line">            <span class="built_in">OnProcess</span>(client);<span class="comment">//改成in</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;<span class="comment">//传输数据小于0</span></span><br><span class="line">        <span class="keyword">if</span>(writeErrno == EAGAIN) &#123;<span class="comment">//如果是socket的发送缓存被占满，要继续写</span></span><br><span class="line">            <span class="comment">/* 继续传输 */</span></span><br><span class="line">            epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);<span class="comment">//总是告知继续写，除非写完</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseConn_</span>(client);<span class="comment">//成功且不keep就关掉连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create listenFd */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::InitSocket_</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化监听窗口，注入内核事件表</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="keyword">if</span>(port_ &gt; <span class="number">65535</span> || port_ &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Port:%d error!&quot;</span>,  port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//AF_INET 表示 IPv4 地址</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//本函数将一个32位数从主机字节顺序转换成网络字节顺序，ANY泛指本机，监听所有网卡</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(port_);<span class="comment">////将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linger</span> optLinger = &#123; <span class="number">0</span> &#125;;<span class="comment">//设置tcp连接断开方式，默认是优雅退出即全0</span></span><br><span class="line">    <span class="keyword">if</span>(openLinger_) &#123;</span><br><span class="line">        <span class="comment">/* 优雅关闭: 直到所剩数据发送完毕或超时 */</span></span><br><span class="line">        optLinger.l_onoff = <span class="number">1</span>;</span><br><span class="line">        optLinger.l_linger = <span class="number">1</span>;<span class="comment">//在close前延迟linger的时间，这段时间是优雅退出时间，超时则返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenFd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//开启一个连接，返回描述符，SOCK_STREAM基于TCP</span></span><br><span class="line">    <span class="keyword">if</span>(listenFd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create socket error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, <span class="built_in">sizeof</span>(optLinger));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Init linger error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 端口复用 */</span></span><br><span class="line">    <span class="comment">/* 只有最后一个套接字会正常接收数据。 */</span></span><br><span class="line">    <span class="comment">//打开地址复用功能，允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</span></span><br><span class="line">    <span class="comment">//optval=true：如果在已经处于 ESTABLISHED状态下的socket调用closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket</span></span><br><span class="line">    <span class="comment">//参考：https://blog.csdn.net/c_base_jin/article/details/94353956</span></span><br><span class="line">    <span class="comment">//https://blog.csdn.net/u010144805/article/details/78579528</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;set socket setsockopt error !&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));<span class="comment">//设置完就可以bind一个地址了，监听所有网卡</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Bind Port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。</span></span><br><span class="line">    <span class="comment">//socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenFd_, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Listen port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = epoller_-&gt;<span class="built_in">AddFd</span>(listenFd_,  listenEvent_ | EPOLLIN);<span class="comment">//添加事件</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Add listen error!&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当 listenfd 设置成阻塞模式（默认行为，无需额外设置）时，如果连接 pending 队列中有需要处理的连接，accept 函数会立即返回，</span></span><br><span class="line"><span class="comment">    	否则会一直阻塞下去，直到有新的连接到来。</span></span><br><span class="line"><span class="comment">	当 listenfd 设置成非阻塞模式，无论连接 pending 队列中是否有需要处理的连接，accept 都会立即返回，不会阻塞。</span></span><br><span class="line"><span class="comment">		如果有连接，则 accept 返回一个大于 0 的值，这个返回值即是我们上文所说的 clientfd；如果没有连接，accept 返回值小于 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(listenFd_);<span class="comment">//设置为非阻塞</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Server port:%d&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为</span></span><br><span class="line"><span class="comment">的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，</span></span><br><span class="line"><span class="comment">或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span></span><br><span class="line"><span class="comment">//F_GETFL：获取文件打开方式的标志，标志值含义与open调用一致，然后或上非阻塞标志</span></span><br><span class="line"><span class="comment">//F_SETFL：设置文件打开方式标志为arg指定方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WebServer::SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);<span class="comment">//这里感觉是F_GETFL不是F_GETFD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>config里啥东西没有，主要也没啥好配的，就直接main里面启动。服务器顶层的isclose没作用，ctrl+c终止进程，资源由操作系统自动回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-18</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server/webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 守护进程 后台运行 */</span></span><br><span class="line">    <span class="comment">//daemon(1, 0); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端口1316，监听和连接事件都是ET模式，连接1分钟无动作就关闭，linger全0是优雅退出</span></span><br><span class="line">    <span class="comment">//mysql端口3306，用户名、密码、数据库名称</span></span><br><span class="line">    <span class="comment">//连接池数量（同时维持连接的个数）、...</span></span><br><span class="line">    <span class="function">WebServer <span class="title">server</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">1316</span>, <span class="number">3</span>, <span class="number">60000</span>, <span class="literal">false</span>,             <span class="comment">/* 端口 ET模式 timeoutMs 优雅退出  */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">3306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;webserver&quot;</span>, <span class="comment">/* Mysql配置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">12</span>, <span class="number">6</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="number">1024</span>)</span></span>;             <span class="comment">/* 连接池数量 线程池数量 日志开关 日志等级 日志异步队列容量 */</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="压力测试截图"><a href="#压力测试截图" class="headerlink" title="压力测试截图"></a>压力测试截图</h1><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%953.png" alt="image-20220925220717478"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/09/TinyWebServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/09/TinyWebServer/" class="post-title-link" itemprop="url">Follow-TinyWebServer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-09 10:00:04" itemprop="dateCreated datePublished" datetime="2022-09-09T10:00:04+08:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-23 16:18:49" itemprop="dateModified" datetime="2022-09-23T16:18:49+08:00">2022-09-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GitHub上的项目：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)</a>，这篇博客记录一下follow的日程和更详细的注解和逻辑思考。整个工程作者没有透露完成顺序，我就根据自己的理解从一个部分开始逐步往下。</p>
<h1 id="第一站"><a href="#第一站" class="headerlink" title="第一站"></a>第一站</h1><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>服务器需要一些互斥操作，因为一些共享资源（如数据库连接池、线程池）被同时访问时会出现错误，需要互斥访问。因此互斥作为一个小的辅助功能，在前面这里先进行分析。</p>
<p>locker.h代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//for mutex</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span><span class="comment">//for sem</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem</span>(<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//阻塞等待资源，资源获取后往下执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//执行完毕，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;<span class="comment">//信号量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span><span class="comment">//取类私有成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁对象，注意它本身不是指针，当参数时要用引用传入地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pthread_mutex_destroy(&amp;m_mutex);</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">timewait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex, <span class="keyword">struct</span> timespec t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//static pthread_mutex_t m_mutex;</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;<span class="comment">//条件变量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h3><p>互斥锁主要是让一个资源锁起来，同一时间只能有一个活动在使用这个资源，其他的请求全部被卡住。项目中具体的实现不是用零散的mutex类的函数操作，而是用一个locker类封装好，构造和析构函数分别执行初始化和注销，这使得用户不需要手动去做（RAII思想，同时可以简化API较长的函数名，其他两个类也是这样的思想）。</p>
<ul>
<li>int pthread_mutex_init(<strong>pthread_mutex_t</strong> *restrict mutex,const <strong>pthread_mutexattr_t</strong> *restrict attr);<ul>
<li><strong>pthread_mutex_init</strong>() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空(<strong>NULL</strong>)，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</li>
<li><strong>pthread_mutexattr_init</strong>() 函数成功完成之后会返回零，其他任何返回值都表示出现了错误。函数成功执行后，互斥锁被初始化为未锁住态。</li>
</ul>
</li>
<li>*<em>pthread_mutex_destroy()*<em>用于注销一个互斥锁，API定义如下：int <strong>pthread_mutex_destroy(pthread_mutex_t</strong> *<em>mute</em>x*</em>)*</em><ul>
<li>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。</li>
</ul>
</li>
<li>int pthread_mutex_lock(pthread_mutex_t *mutex)：锁住，返回值为0成功；</li>
<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)：解锁，返回值为0成功；</li>
</ul>
<p>简单来说：</p>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
<h3 id="信号量sem"><a href="#信号量sem" class="headerlink" title="信号量sem"></a>信号量sem</h3><p>信号量有数值大小，主要用来管理一个buffer，写入和读出都要满足buffer的边界，同样的取用资源也要在资源池满足的情况下进行。</p>
<ul>
<li>int sem_init(sem_t *sem, int pshared, unsigned int value);<ul>
<li>该函数初始化由 sem 指向的信号对象，并给它一个初始的整数值 value。pshared 控制信号量的类型，值为 0 代表该信号量用于多线程间的同步，值如果大于 0 表示可以共享，用于多个相关进程间的同步：参数 pshared &gt; 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量</li>
</ul>
</li>
<li>int sem_destroy(sem_t *sem);<ul>
<li>该函数用于对用完的信号量的清理。</li>
</ul>
</li>
<li>int sem_wait(sem_t *sem); <ul>
<li>sem_wait 是一个阻塞的函数，测试所指定信号量的值，它的操作是原子的。若 sem value &gt; 0，则该信号量值减去 1 并立即返回。若sem value &#x3D; 0，则阻塞直到 sem value &gt; 0，此时立即减去 1，然后返回。函数成功返回0，错误的话信号量的值不改动，返回-1。</li>
<li>还有另一个函数：sem_trywait 函数是非阻塞的函数，它会尝试获取获取 sem value 值，如果 sem value &#x3D; 0，不是阻塞住，而是直接返回一个错误 EAGAIN。</li>
</ul>
</li>
<li>int sem_post(sem_t *sem);<ul>
<li>把指定的信号量 sem 的值加 1，唤醒正在等待该信号量的任意线程。成功时返回 0；错误时，信号量的值没有更改，-1 被返回。</li>
</ul>
</li>
</ul>
<p>简单来说:</p>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
<h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><ul>
<li><p>int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。</li>
</ul>
</li>
<li><p>int pthread_cond_destroy(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。释放条件变量。需要注意的是只有在没有线程在该条件变量上等待时，才可以注销条件变量，否则会返回EBUSY。同时Linux在实现条件变量时，并没有为条件变量分配资源，所以在销毁一个条件变量时，只要注意该变量是否仍有等待线程即可。</li>
</ul>
</li>
<li><p>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);</p>
<ul>
<li><p>返回值：函数成功返回0；任何其他返回值都表示错误。</p>
</li>
<li><p>为什么要关联一个mutex呢？无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。</p>
<ul>
<li>pthread_cond_wait(cond, mutex)的功能有3个：<ul>
<li>调用者线程首先释放mutex</li>
<li>然后阻塞，等待被别的线程唤醒</li>
<li>当调用者线程被唤醒后，调用者线程会再次获取mutex</li>
</ul>
</li>
<li>pthread_cond_wait(cond)的功能只有1个：<ul>
<li>调用者线程阻塞，等待被别的线程唤醒。</li>
</ul>
</li>
</ul>
<p>这里首先给一个简洁的回答：</p>
<ul>
<li><strong>通常的应用场景下，当前线程执行pthread_cond_wait时，处于临界区访问共享资源，存在一个mutex与该临界区相关联，这是理解pthread_cond_wait带有mutex参数的关键</strong></li>
<li>当前线程执行pthread_cond_wait前，已经获得了和临界区相关联的mutex；<strong>因为缺少其他条件</strong>，执行pthread_cond_wait会阻塞，但是在进入阻塞状态前，必须释放已经获得的mutex，让其它线程能够进入临界区</li>
<li>当前线程执行pthread_cond_wait后，阻塞等待的条件满足，条件满足时会被唤醒；被唤醒后，仍然处于临界区，因此被唤醒后必须再次获得和临界区相关联的mutex</li>
</ul>
<p>综上，调用pthread_cond_wait时，线程总是位于某个临界区，该临界区与mutex相关，pthread_cond_wait需要带有一个参数mutex，用于释放和再次获取mutex。</p>
</li>
</ul>
</li>
<li><p>int pthread_cond_timedwait(pthread_cond_t *cv,pthread_mutex_t *mp, const struct timespec * abstime);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>pthread_cond_timedwait()用于等待一个条件变量，等待条件变量的同时可以设置等待超时。这是一个非常有用的功能，如果不想一直等待某一条件变量，就可以使用这个函数。函数到了一定的时间，即使条件未发生也会解除阻塞。</li>
<li>条件变量默认使用的时间是CLOCK_REALTIME。通过clock_gettime()接口获取时间。</li>
</ul>
</li>
<li><p>int pthread_cond_signal(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态，继续执行。如果没有线程处在阻塞等待状态，pthread_cond_signal也会成功返回。</li>
</ul>
</li>
<li><p>int pthread_cond_broadcast(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cv被用来指定这个条件变量。当没有线程阻塞在这个条件变量上时，pthread_cond_broadcast函数无效。</li>
</ul>
</li>
</ul>
<h2 id="线程池threadpool"><a href="#线程池threadpool" class="headerlink" title="线程池threadpool"></a>线程池threadpool</h2><p>使用线程有动态方法和静态方法，动态方法是当一个工作需要完成时创建一个线程，当工作做完后释放线程。这种方式对资源的利用率高一些，但是耗费时间，因为要新创建、销毁线程。静态方法是使用线程池先创建好一系列等待请求的线程，当一个工作到来时直接分配空闲线程，工作完成后放回线程池。</p>
<p>线程池的代码放在threadpool.h中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../CGImysql/sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T *request, <span class="type">int</span> state)</span></span>;<span class="comment">//两种append，应该对应了不同的T的操作，实际上感觉重载就可以了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append_p</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;<span class="comment">//静态成员函数，是一个回调函数，后面会说明为什么要设置成静态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number;        <span class="comment">//线程池中的线程数，即可同时工作的数量</span></span><br><span class="line">    <span class="type">int</span> m_max_requests;         <span class="comment">//请求队列中允许的最大请求数，即最多同时等待的数量</span></span><br><span class="line">    <span class="type">pthread_t</span> *m_threads;       <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">    std::list&lt;T *&gt; m_workqueue; <span class="comment">//请求队列</span></span><br><span class="line">    locker m_queuelocker;       <span class="comment">//保护请求队列的互斥锁</span></span><br><span class="line">    sem m_queuestat;            <span class="comment">//是否有任务需要处理</span></span><br><span class="line">    connection_pool *m_connPool;  <span class="comment">//数据库</span></span><br><span class="line">    <span class="type">int</span> m_actor_model;          <span class="comment">//模型切换</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( <span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : <span class="built_in">m_actor_model</span>(actor_model),<span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>),<span class="built_in">m_connPool</span>(connPool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_number &lt;= <span class="number">0</span> || max_requests &lt;= <span class="number">0</span>)    <span class="comment">//一些不合理请求的判断</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];	<span class="comment">//线程池的实作是一个线程数组</span></span><br><span class="line">    <span class="keyword">if</span> (!m_threads)	<span class="comment">//请求失败则m_threads是一个nullptr</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i)</span><br><span class="line">    &#123;	<span class="comment">//初始化线程池里的线程，返回值不为0说明失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>)<span class="comment">//m_threads+i与m_threads[i]没区别</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源，具体在后面有写</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(m_threads[i]))<span class="comment">//感觉这个if和上面那个if的风格好不一样...</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>()<span class="comment">//析构，new出来的delete掉</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向请求队列添加请求</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T *request, <span class="type">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//多线程状态下工作，要互斥，否则request和list的修改会出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)<span class="comment">//超出最大请求，非阻塞返回。如果要阻塞的话，可以用一个full信号量控制</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    request-&gt;m_state = state;<span class="comment">//赋予状态，指读还是写</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);<span class="comment">//添加队列</span></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();<span class="comment">//信号量加一，告知线程池有任务在等待处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和上面一样</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append_p</span>(T *request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//worker函数，传递参数给线程，然后调用真正的run函数工作。静态成员类外定义不用static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> *threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span> *arg)<span class="comment">//void 指针可以指向任意类型的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    threadpool *pool = (threadpool *)arg;<span class="comment">//arg = this，将参数强转为线程池类，调用成员方法</span></span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();<span class="comment">//调用实例的run函数</span></span><br><span class="line">    <span class="keyword">return</span> pool;<span class="comment">//实际上run一直运行，估计不会return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//为什么是while呢？因为每个线程其实在不断的运行，如果有任务就取出来做，没有就wait阻塞</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();<span class="comment">//阻塞，要等有任务即前面post信号量了，才往下做</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//取出任务，要对list操作，那么要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_workqueue.<span class="built_in">empty</span>())<span class="comment">//感觉没必要，前面用wait其实已经判断了工作池buffer了，有任务才会往下</span></span><br><span class="line">        &#123;<span class="comment">//m_workqueue的大小应该和m_queuestat信号量的大小绑定了（根据append函数来看）</span></span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T *request = m_workqueue.<span class="built_in">front</span>();<span class="comment">//取第一个请求</span></span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();<span class="comment">//pop</span></span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁，让下一个线程可以操作list</span></span><br><span class="line">        <span class="keyword">if</span> (!request)<span class="comment">//如果请求实际上是null</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//切换模式，reactor==1，proactor==0</span></span><br><span class="line">        <span class="comment">//非阻塞同步工作模式，读写均需要在线程里工作，调用read和write，并且进行最后的process业务逻辑处理。</span></span><br><span class="line">        <span class="comment">//非阻塞是指有数据才进行，但数据处理过程仍在线程里执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_actor_model)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == request-&gt;m_state)<span class="comment">//读</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">read_once</span>())<span class="comment">//如果成功则不关闭定时器，不用关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;request-&gt;mysql, m_connPool)</span></span>;</span><br><span class="line">                    request-&gt;<span class="built_in">process</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//不成功要关闭连接和定时器</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//写</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">write</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//模拟proactor模式的IO在主循环处理（是同步的），线程只需要处理业务逻辑即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            connectionRAII <span class="built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);</span><br><span class="line">            request-&gt;<span class="built_in">process</span>();<span class="comment">//处理业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>线程池类使用模板，目前还没看出作用，猜测是后面会用于多种不同资源的分配使用，如处理http连接、处理数据库请求等等。</li>
<li>int<code> </code>pthread_create(pthread_t *tidp,<code> </code>const<code> </code>pthread_attr_t *attr,(<code> </code>void<code> </code>*)(*start_rtn)(<code> </code>void<code> </code>*),<code> </code>void<code> </code>*arg);<ul>
<li>第一个参数为指向线程 标识符的指针。</li>
<li>第二个参数用来设置线程属性。</li>
<li>第三个参数是线程运行函数的起始地址（函数指针）。</li>
<li>最后一个参数是运行函数的参数。</li>
<li>若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</li>
</ul>
</li>
<li>int pthread_detach(pthread_t thread);  成功：0；失败：错误号<ul>
<li>使用pthread_create创建的线程有两种状态：joinable和unjoinable。默认是joinable 状态。</li>
<li>线程创建后在线程中调用 pthread_detach, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。</li>
<li>pthread_detach()和pthread_join()就是控制子线程回收资源的两种不同的方式。同一进程间的线程具有共享和独立的资源，其中共享的资源有堆、全局变量、静态变量、文件等公用资源。而独享的资源有栈和寄存器，这两种方式就是决定子线程结束时如何回收独享的资源。<ul>
<li>如果是joinable状态，则该线程结束后（通过pthread_exit结束或者线程执行体任务执行完毕）不会释放线程所占用堆栈和线程描述符（总计8K多）等资源，除非在主线程调用了pthread_join函数之后才会释放。pthread_join函数一般应用在主线程需要等待子线程结束后才继续执行的场景。(pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。 )</li>
<li>如果是unjoinable状态，则该线程结束后会自动释放占用资源。实现方式是在创建时指定属性，或者在线程执行体的最开始处添加一行：pthread_detach(pthread_self())；不会阻塞，调用它后，线程运行结束后会自动释放资源,后者非常方便。</li>
</ul>
</li>
<li>总结<ul>
<li>pthread_detach()即主线程与子线程分离，两者相互不干涉，子线程结束同时子线程的资源自动回收。</li>
<li>pthread_join()即是子线程合入主线程，主线程会一直阻塞，直到子线程执行结束，然后回收子线程资源，并继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作流程</strong>：<ul>
<li>构造函数初始化线程池：创建线程和分离线程状态</li>
<li>析构函数销毁线程池</li>
<li>append函数互斥地向list添加请求，并post信号量</li>
<li>一个线程对应一个worker，worker函数调用run。</li>
<li>run函数从list互斥地获得请求并工作，不断循环</li>
</ul>
</li>
<li>worker函数是一个成员函数，那么必须是一个静态的。它是一个回调函数，回调函数是通过指针调用的函数，最常使用的回调函数就是在创建线程时（pthread_create），以一个函数指针以及传递给这个函数多个参数来调用线程函数来创建线程。那么一般的类成员函数是不能用作回调函数的，因为在使用回调函数时，会传递指定的符合回调函数声明的的参数给回调函数，而类成员函数隐式包含一个this指针参数，所以把类成员函数当作回调函数编译时会因为参数不匹配会出错（回调后多了个this，与声明不一致）。<ul>
<li>静态成员函数就没有这个问题，里面没有this指针。</li>
</ul>
</li>
<li>那么为什么要用worker间接调用run函数呢？run设计成静态的直接调用不行吗？<ul>
<li>答案是不太方便，因为静态成员函数只能访问静态成员数据、其他静态成员和类外部的函数，因为没有this指针。不过我们这里手动传入了this指针使得它可以调用run成员函数。</li>
<li>this指针只能在类内部使用而不能在外部使用。可以访问类中所有public、private、protect的成员函数和变量。this指针是指向对象的实例，所以只有当对象被创建时this指针才有效。</li>
<li>同一个模板类的不同实例共享静态成员函数，不同实例有不同的资源，这导致静态成员函数不能访问那些实例各有的资源，因为不知道要访问哪个。而run要操作不同实例的list等等资源，通过共享的worker使用从线程传入的this指针操作各个实例的run函数，run就能操作自己这个实例的资源了。但如果run是静态的，即使通过手动传入this参数，run里面所有的资源都要this-&gt;一下，太不方便了。</li>
<li>因此，最好的方式就是静态成员函数通过this指针调用成员函数，这个成员函数就可以很方便地访问类实例的资源了（说白了就是使用资源不用this-&gt;了）。</li>
</ul>
</li>
</ul>
<h1 id="第二站"><a href="#第二站" class="headerlink" title="第二站"></a>第二站</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>后面会用到单例模式，这里先详解一下，参考了许多文章。</p>
<h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式。</p>
<h3 id="为什么要用单例模式"><a href="#为什么要用单例模式" class="headerlink" title="为什么要用单例模式?"></a>为什么要用单例模式?</h3><p><strong>1、单例模式节省公共资源</strong></p>
<p>比如：大家都要喝水，但是没必要每人家里都打一口井是吧，通常的做法是整个村里打一个井就够了，大家都从这个井里面打水喝。</p>
<p>对应到我们计算机里面，像日志管理、打印机、<strong>数据库连接池</strong>、应用配置。</p>
<p><strong>2、单例模式方便控制</strong></p>
<p>就像日志管理，如果多个人同时来写日志，你一笔我一笔那整个日志文件都乱七八糟，如果想要控制日志的正确性，那么必须要对关键的代码进行上锁，只能一个一个按照顺序来写，而单例模式只有一个人来向日志里写入信息方便控制，避免了这种多人干扰的问题出现。</p>
<h3 id="实现单例模式的思路"><a href="#实现单例模式的思路" class="headerlink" title="实现单例模式的思路"></a>实现单例模式的思路</h3><p><strong>1.</strong> <strong>构造私有:</strong></p>
<p>如果要保证一个类不能多次被实例化，那么我肯定要<strong>阻止对象被new</strong> 出来，所以需要把<strong>类的所有构造方法私有化</strong>。</p>
<p><strong>2.以静态方法返回实例</strong>。</p>
<p>因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</p>
<p><strong>3.确保对象实例只有一个</strong>。</p>
<p>只对类进行一次实例化，以后都直接获取第一次实例化的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">//确保对象实例只有一个。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="comment">//构造方法私有</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//以静态方法返回实例</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里类的实例在类初始化的时候已经生成，不再进行第二次实例化了，而外界只能通过SingleCase.getInstance()方法来获取SingleCase对象， 所以这样就保证整个系统只能获取一个类的对象实例。</p>
<h3 id="单例模式的两种实现模式"><a href="#单例模式的两种实现模式" class="headerlink" title="单例模式的两种实现模式"></a>单例模式的两种实现模式</h3><p>饿汉模式：就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：简单</span><br><span class="line">缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// C++98 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="comment">// or</span></span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">// 在程序入口之前就完成单例对象的初始化</span></span><br></pre></td></tr></table></figure>

<p>如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。</p>
<hr>
<p>懒汉模式：等到用的的时候程序再创建实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</span><br><span class="line">缺点：复杂 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意多线程环境下一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">			m_mtx.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">				m_pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			m_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CGarbo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CGarbo</span>()&#123;</span><br><span class="line">			<span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">				<span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">	<span class="type">static</span> CGarbo Garbo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="type">static</span> Singleton* m_pInstance; <span class="comment">// 单例对象指针</span></span><br><span class="line">	<span class="type">static</span> mutex m_mtx; <span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">Singleton::CGarbo Garbo;</span><br><span class="line">mutex Singleton::m_mtx;</span><br></pre></td></tr></table></figure>

<p>添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">CSingleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton &amp;);</span><br><span class="line">    CSingleton &amp; <span class="keyword">operator</span> = (<span class="type">const</span> CSingleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> CSingleton instance;   <span class="comment">//局部静态变量，在这个局部静态函数销毁才销毁，也就是当程序结束才销毁</span></span><br><span class="line">		<span class="keyword">return</span> &amp;instance;<span class="comment">//不管怎么getinstance，都只定义一次instance，返回的都是同一个实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用局部静态变量是非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。</p>
<h2 id="sql数据库连接"><a href="#sql数据库连接" class="headerlink" title="sql数据库连接"></a>sql数据库连接</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>数据库连接的头文件声明了很多信息，我们先分析头文件的逻辑，再去看定义的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CONNECTION_POOL_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONNECTION_POOL_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">MYSQL *<span class="title">GetConnection</span><span class="params">()</span></span>;				 <span class="comment">//获取数据库连接</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ReleaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">//释放连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>;					 <span class="comment">//获取空闲连接数目</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>;					 <span class="comment">//销毁所有连接</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">connection_pool</span>();</span><br><span class="line">	~<span class="built_in">connection_pool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_MaxConn;  <span class="comment">//最大连接数</span></span><br><span class="line">	<span class="type">int</span> m_CurConn;  <span class="comment">//当前已使用的连接数</span></span><br><span class="line">	<span class="type">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">	locker lock;<span class="comment">//互斥锁</span></span><br><span class="line">	list&lt;MYSQL *&gt; connList; <span class="comment">//连接池</span></span><br><span class="line">	sem reserve;<span class="comment">//信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_url;			 <span class="comment">//主机地址</span></span><br><span class="line">	string m_Port;		 <span class="comment">//数据库端口号</span></span><br><span class="line">	string m_User;		 <span class="comment">//登陆数据库用户名</span></span><br><span class="line">	string m_PassWord;	 <span class="comment">//登陆数据库密码</span></span><br><span class="line">	string m_DatabaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">	<span class="type">int</span> m_close_log;	<span class="comment">//日志开关</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connectionRAII</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双指针对MYSQL *con修改。数据库连接本身是指针类型，所以参数需要通过双指针才能对其进行修改。</span></span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;<span class="comment">//这个RAII类拥有一个MYSQL连接</span></span><br><span class="line">	connection_pool *poolRAII;<span class="comment">//且要有一个连接池指针指向那个单例对象，调用释放函数把MYSQL连接释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件里主要是对connection_pool这个类的功能进行了声明：</p>
<ul>
<li>四种主要功能：获取数据库连接、获取空闲连接数目、释放连接、销毁所有连接。四个功能函数实际上从返回值就可以看出区别和要做什么事。</li>
<li>数据库初始化init函数，它通过地址、端口、用户名密码、使用的数据库名称来进行数据库的连接。</li>
<li>单例模式，把构造函数放private，使得只能用静态成员函数在类中创建类对象；把析构函数放private，使得无法在外部delete类对象，只能用内部的成员函数delete this，因为内部成员函数才能访问私有的析构函数。不过这里的单例模式不用new，因此也就没有对应的delete函数。</li>
</ul>
<p>还有一个connectionRAII类，这个类对连接池对象进行RAII式的管理，前面可以看到有个释放连接的功能，我们不想手动释放，就可以在这个类的析构函数里释放，具体看实现就好了。</p>
<ul>
<li>为什么con是双指针，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/bin510729392/article/details/51476327">c&#x2F;c++向函数传递指针并修改其指向的问题_AlanChaw292的博客-CSDN博客_c++改变指针指向</a>。大概的意思就是，如果是单指针传进来，编译器也会为形参做一个备份，如传入一个p，会备份一个p1（我们实际上使用的是p1，跟值传递是一个意思），p和p1的值相同，都指向对象的地址。我们当然可以使用p1来修改指向的值，但无法通过修改p1修改p（就像形参无法影响实参），也就是说传入的指针不能修改指针本身的地址（不能修改指针的指向，不是不允许，而是没意义）。这种时候，就需要用双指针，指向我们想修改的指针的地址，这样就行了，那篇博客讲的很清楚。</li>
</ul>
<h3 id="cpp实现"><a href="#cpp实现" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>话不多说，先上源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">connection_pool::<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;	<span class="comment">//类内成员初始化</span></span><br><span class="line">	m_CurConn = <span class="number">0</span>;<span class="comment">//已使用的是0</span></span><br><span class="line">	m_FreeConn = <span class="number">0</span>;<span class="comment">//空闲的还不知道，但是没有init时就是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span><span class="comment">//静态成员函数，单例模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> connection_pool connPool;<span class="comment">//创建静态的连接池对象，只定义一次，每次调用都返回它</span></span><br><span class="line">	<span class="keyword">return</span> &amp;connPool;<span class="comment">//且是通过指针（地址）返回，不会导致拷贝构造</span></span><br><span class="line">    <span class="comment">//这个静态对象销毁是在静态成员函数销毁时销毁，而这个函数在程序结束才销毁...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">//给类成员赋值，这些类成员是为了以后访问连接池对象可以获取信息</span></span><br><span class="line"></span><br><span class="line">	m_url = url;</span><br><span class="line">	m_Port = Port;</span><br><span class="line">	m_User = User;</span><br><span class="line">	m_PassWord = PassWord;</span><br><span class="line">	m_DatabaseName = DBName;</span><br><span class="line">	m_close_log = close_log;</span><br><span class="line">    m_MaxConn = m_FreeConn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)<span class="comment">//一共（最多）可以有maxconn个连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">		con = <span class="built_in">mysql_init</span>(con);<span class="comment">//分配并初始化一个新对象</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//NULL说明没有足够的内存分配</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//前面的init初始化了一个mysql的数据结构，现在real connect进行真正的连接</span></span><br><span class="line">		con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//连接失败返回NULL</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		connList.<span class="built_in">push_back</span>(con);<span class="comment">//成功则在连接池(list)里添加</span></span><br><span class="line">		++m_FreeConn;<span class="comment">//空闲连接+1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reserve = <span class="built_in">sem</span>(m_FreeConn);<span class="comment">//给这个信号量赋值，实际上可以在for循环里post，不过逻辑有点怪就是了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">connection_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL *con = <span class="literal">NULL</span>;<span class="comment">//创建一个指针，将要指向连接池已经创建的连接</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())<span class="comment">//没有就没有了，不阻塞</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">wait</span>();<span class="comment">//有的话就让信号量减一，不过既然前面return了，不阻塞了还有信号量干啥嘞</span></span><br><span class="line">	</span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//互斥访问这个连接，修改连接池（连接池是共享的），以及互斥修改一些表示buffer大小数据</span></span><br><span class="line"></span><br><span class="line">	con = connList.<span class="built_in">front</span>();</span><br><span class="line">	connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">	--m_FreeConn;<span class="comment">//连接池容量buffer-1</span></span><br><span class="line">	++m_CurConn;<span class="comment">//连接池buffer使用+1</span></span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection_pool::ReleaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//回收连接，放回连接池，既然访问连接池这个公共资源，要互斥锁住</span></span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);<span class="comment">//放回</span></span><br><span class="line">	++m_FreeConn;</span><br><span class="line">	--m_CurConn;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">post</span>();<span class="comment">//信号量+1，越发感觉信号量和freeconn是一个东西？以及connlist.size()...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//主线程要关闭连接池，要等连接池操作完再说，不然在销毁过程中可能又同时放回，会混乱</span></span><br><span class="line">    			<span class="comment">//且其他线程在获取连接时，也要等连接池销毁的操作，不然连接池都销毁了还拿到了一个连接</span></span><br><span class="line">	<span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			MYSQL *con = *it;</span><br><span class="line">			<span class="built_in">mysql_close</span>(con);<span class="comment">//一个一个关闭掉，但mysql对象、结构还在list里</span></span><br><span class="line">		&#125;</span><br><span class="line">		m_CurConn = <span class="number">0</span>;<span class="comment">//这些遍历的修改也要在临界区嘛</span></span><br><span class="line">		m_FreeConn = <span class="number">0</span>;</span><br><span class="line">		connList.<span class="built_in">clear</span>();<span class="comment">//移除所有元素，把那些关闭了的连接都删掉</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前空闲的连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connection_pool::GetFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_FreeConn;<span class="comment">//这个就不锁了，没什么意义，就放回“当下”的值就好了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection_pool::~<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestroyPool</span>();<span class="comment">//析构连接池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个RAII类是针对单个sql连接的，具体怎么使用还要看实际代码，</span></span><br><span class="line"><span class="comment">//注意这个双指针修改sql连接本身的值（指向连接的地址），使这个连接可以更改指向，（可能从null）指向连接池的可用的连接。</span></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">	*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">	</span><br><span class="line">	conRAII = *SQL;<span class="comment">//这个RAII类本身也要存一个备份，使得调用析构函数释放连接时知道要释放的连接的地址</span></span><br><span class="line">	poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">	poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);<span class="comment">//析构函数：释放连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL *mysql_init(MYSQL *mysql)<ul>
<li>分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。</li>
<li>返回值：初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。</li>
</ul>
</li>
<li>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)<ul>
<li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。</li>
<li>参数：<ul>
<li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。</li>
<li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP&#x2F;IP连接到服务器。</li>
<li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。</li>
<li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li>
<li>“db”是数据库名称。如果db为NULL，连接会将默认的数据库设为该值。</li>
<li>如果“port”不是0，其值将用作TCP&#x2F;IP连接的端口号。注意，“host”参数决定了连接的类型。</li>
<li>如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。</li>
<li>client_flag的值通常为0，其他标志可以实现特定的功能</li>
</ul>
</li>
<li>返回值：如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。</li>
</ul>
</li>
<li>void mysql_close(MYSQL *mysql)<ul>
<li>关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。</li>
</ul>
</li>
<li>string.c_str()：<ul>
<li>const char *c_str();</li>
<li>c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同。</li>
<li>这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。</li>
</ul>
</li>
</ul>
<h1 id="第三站"><a href="#第三站" class="headerlink" title="第三站"></a>第三站</h1><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>这里可以看看作者的讲解先理解一下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg">最新版Web服务器项目详解 - 09 日志系统（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/f-ujwFyCe1LZa3EB561ehA">最新版Web服务器项目详解 - 10 日志系统（下） (qq.com)</a></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>写入日志有同步的写入和异步的写入方式，同步的方式是当产生日志时就写入，主线程工作推迟；异步的写入方式是使用一个日志线程来管理，“写入日志”这个任务就需要有地方放，因此就要用一个阻塞队列来存放任务。为什么是阻塞的呢，日志线程有多个吗？实际上日志线程只有一个，但其他线程可以有多个，这就是一个多生产者–单消费者的模型。因此常规的解法就是用互斥锁+buffer信号量的组合。但这个阻塞队列还添加了超时处理的功能，信号量就需要改成条件变量，条件变量我没怎么使用过，之后回过头再整理一下，不过具体的功能在lock那章中写了。</p>
<p>下面是阻塞队列的代码，在头文件block_queue.h中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*循环数组实现的阻塞队列，m_back = (m_back + 1) % m_max_size;  </span></span><br><span class="line"><span class="comment">*线程安全，每个操作前都要先加互斥锁，操作完后，再解锁</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCK_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="type">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[max_size];</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//剩下的操作，涉及对队列内部元素的操作（插入删除）、对队列变量的访问（size，头尾指针等），都需要互斥访问</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">block_queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array != <span class="literal">NULL</span>)<span class="comment">//少见...不过健壮（也许多余？）</span></span><br><span class="line">            <span class="keyword">delete</span> [] m_array;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否满了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">front</span><span class="params">(T &amp;value)</span><span class="comment">//以参数形式返回 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_front];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">back</span><span class="params">(T &amp;value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_back];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;<span class="comment">//不直接return，因为要加锁，return不能放锁里</span></span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_max_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往队列添加元素，需要将所有使用队列的线程先唤醒，这些线程除了等待锁，还要等待任务出现以pop，因此push要唤醒它们</span></span><br><span class="line">    <span class="comment">//在应用上，调用pop的就一个日志线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当有元素push进队列,相当于生产者生产了一个元素</span></span><br><span class="line">    <span class="comment">//若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)<span class="comment">//队列满了，赶紧让pop线程做事</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒所有在wait的线程</span></span><br><span class="line">            <span class="comment">//在wait说明之前队列空了，但怎么会从空-&gt;满呢？可能是一直被push抢了互斥锁</span></span><br><span class="line">            <span class="comment">//因此这个唤醒让那些卡在while的pop从wait解放，然后一个一个等待抢占互斥锁做事（和pop抢也和push抢）</span></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line"></span><br><span class="line">        m_size++;</span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//条件变量在临界区用，wait自身会解锁-等待唤醒-抢占锁</span></span><br><span class="line">        <span class="comment">//pop被多个线程调用，前面push都唤醒了那么这里会竞争任务，可能只有一部分线程执行了这个m_size就=0了</span></span><br><span class="line">        <span class="comment">//那么此时就要继续等待，因此用while而不是用if，if只能wait一次（这种情况是虚假唤醒）</span></span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))<span class="comment">//等待唤醒</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//wait出错就return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//条件变量被唤醒，抢到了互斥锁，且whlie正常退出，开始做事</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了超时处理</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> ms_timeout)</span><span class="comment">//可以超时多少毫秒</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//时间类下面介绍</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个纳秒</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//获取系统当前时间</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//如果要等待的话，就进去wait，注意这里不是一直等到可以调用，所以不用while</span></span><br><span class="line">        <span class="comment">//如果超时就到下面的if返回，如果没超时就被唤醒，那么会有虚假唤醒的情况，</span></span><br><span class="line">        <span class="comment">//因此下面还要if判断一下，虚假唤醒就直接返回，所以这里超时就不做、虚假唤醒也不做</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//t是前面获取的时间加上超时的时间</span></span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;<span class="comment">//取秒位</span></span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;<span class="comment">//剩下没取到的毫秒（余数）弄成纳秒（为什么是*1000）</span></span><br><span class="line">            <span class="comment">//整体时间计算是秒+纳秒</span></span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t))<span class="comment">//时间到了就不等待唤醒了，直接润</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上面润完就到这里，注意因为抢了锁，所以不可能有push，这里一定是返回的</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//正常干活</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    cond m_cond;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line">    T *m_array;<span class="comment">//队列空间</span></span><br><span class="line">    <span class="type">int</span> m_size;<span class="comment">//队列目前大小</span></span><br><span class="line">    <span class="type">int</span> m_max_size;<span class="comment">//队列大小，使用这个变量就无需额外留一个空间</span></span><br><span class="line">    <span class="type">int</span> m_front;<span class="comment">//队列头部</span></span><br><span class="line">    <span class="type">int</span> m_back;<span class="comment">//队列尾部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在C语言中可以使用函数gettimeofday()函数来得到精确时间。它的精度可以达到微妙，是C标准库的函数。</p>
<p>在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体。</p>
<p>函数执行成功后返回0，失败后返回-1，错误代码存于errno中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span>  timeval*tv,<span class="keyword">struct</span>  timezone *tz )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span>  timeval</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_sec;  <span class="comment">/*秒*/</span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_usec; <span class="comment">/*微妙*/</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">timezone</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_minuteswest;<span class="comment">/*和greenwich 时间差了多少分钟*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_dsttime;    <span class="comment">/*type of DST correction*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：在使用gettimeofday()函数时，第二个参数一般都为空，因为我们一般都只是为了获得当前时间，而不用获得timezone的数值。</p>
<h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>定义了Log类，其中使用宏来为其他程序提供接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span><span class="comment">//与宏有关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="type">void</span> *args)</span><span class="comment">//是一个worker函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();<span class="comment">//静态成员函数的调用：A::func()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size = <span class="number">8192</span>, <span class="type">int</span> split_lines = <span class="number">5000000</span>, <span class="type">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">async_write_log</span><span class="params">()</span><span class="comment">//write_log执行push任务的功能，这个函数只取任务写到文件</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line">        <span class="comment">//从阻塞队列中取出一个日志string，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))<span class="comment">//取是互斥的，写也是互斥的，但是两个锁并不相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();<span class="comment">//写入m_fp中，共享的文件空间的要锁一下</span></span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> dir_name[<span class="number">128</span>]; <span class="comment">//路径名</span></span><br><span class="line">    <span class="type">char</span> log_name[<span class="number">128</span>]; <span class="comment">//log文件名</span></span><br><span class="line">    <span class="type">int</span> m_split_lines;  <span class="comment">//日志最大行数</span></span><br><span class="line">    <span class="type">int</span> m_log_buf_size; <span class="comment">//日志缓冲区大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_count;  <span class="comment">//日志行数记录</span></span><br><span class="line">    <span class="type">int</span> m_today;        <span class="comment">//因为按天分类,记录当前时间是那一天</span></span><br><span class="line">    FILE *m_fp;         <span class="comment">//打开log的文件指针</span></span><br><span class="line">    <span class="type">char</span> *m_buf;</span><br><span class="line">    block_queue&lt;string&gt; *m_log_queue; <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="type">bool</span> m_is_async;                  <span class="comment">//是否同步标志位</span></span><br><span class="line">    locker m_mutex;</span><br><span class="line">    <span class="type">int</span> m_close_log; <span class="comment">//关闭日志</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏接口，调用write_log和flush</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="cpp实现-1"><a href="#cpp实现-1" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>主要是一些string的操作，因为写日志就是把字符写入文件嘛</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_count = <span class="number">0</span>;<span class="comment">//每次行数重置为0，包括天数的记录也会重置，所以如果关闭了的话前面的记录就不存在，重复写一个日志文件就可能出错，因此如果关掉程序再打开的话，最好换一个文件重新开始写</span></span><br><span class="line">    m_is_async = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Log::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size, <span class="type">int</span> split_lines, <span class="type">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果设置了max_queue_size,则设置为异步，只有一个线程在取任务处理</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;<span class="comment">//设置写入方式flag</span></span><br><span class="line">        m_log_queue = <span class="keyword">new</span> <span class="built_in">block_queue</span>&lt;string&gt;(max_queue_size);<span class="comment">//创建并设置阻塞队列长度</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">//flush_log_thread为回调函数,这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员初始化</span></span><br><span class="line">    m_close_log = close_log;<span class="comment">//1的话关闭日志功能</span></span><br><span class="line">    m_log_buf_size = log_buf_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="type">char</span>[m_log_buf_size];<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);<span class="comment">//缓冲区数值初始化</span></span><br><span class="line">    m_split_lines = split_lines;<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//见后面，实际上就是得到具体的本地的时间，年月日时分秒等等</span></span><br><span class="line">    <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后往前找到第一个/的位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//该函数见后面</span></span><br><span class="line">    <span class="type">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//接下来要生成一个具体的日志文件名</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来相当于自定义日志名</span></span><br><span class="line">    <span class="comment">//若输入的文件名没有/，则直接将时间+文件名作为日志名</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);<span class="comment">//该函数见后面</span></span><br><span class="line">        <span class="comment">//下面两行是我自己分析觉得要加上的地方，否则创建新日志的名字可能不协同</span></span><br><span class="line">        dir_name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        log_name = file_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有的话，就是一个路径了，就要从/后面开始添加时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将/的位置向后移动一个位置，然后复制到logname中</span></span><br><span class="line">   	    <span class="comment">//p - file_name + 1是文件所在路径文件夹的长度</span></span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);<span class="comment">//存一下log_name</span></span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);<span class="comment">//dirname相当于./，这里就比上面多一个路径名，不过把filename拆分为dirname和logname，补个时间</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    m_today = my_tm.tm_mday;<span class="comment">//更新日期</span></span><br><span class="line">    </span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据上面的一系列操作获得的名称打开文件或创建文件</span></span><br><span class="line">    <span class="comment">//a表示追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</span></span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">//可变参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取具体时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//返回当前距离1970年的秒数和微妙数</span></span><br><span class="line">    <span class="type">time_t</span> t = now.tv_sec;<span class="comment">//取得从1970年1月1日至今的秒数。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//将time_t表示的时间转换为经过时区转换的UTC时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志类型标头</span></span><br><span class="line">    <span class="keyword">switch</span> (level)<span class="comment">//日志分级</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入一个log，对m_count++</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//m_count和m_fp是共享的，要用锁修改，这就表明上面的时间是调用的时间而不是写的时间，因为锁要阻塞耗时</span></span><br><span class="line">    m_count++;<span class="comment">//先++，因为是从0开始的，++后判断是否到最大行数了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//日志不是今天或写入的日志行数是最大行的倍数，这个时候要新换一个日志文件</span></span><br><span class="line">    <span class="comment">//m_split_lines为最大行数</span></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志内容</span></span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);<span class="comment">//把缓冲区的内容强制写入文件，准备换新文件了</span></span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);<span class="comment">//关闭</span></span><br><span class="line">        <span class="type">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//时间信息</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);<span class="comment">//02表示月份和日期以两位数的形式呈现</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)<span class="comment">//新的一天，换一个文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);<span class="comment">//这里可能有点问题，因为dirname和logname不一定有，如果前面p是NULL的话，那么新的文件就只有日期了，前面最好更新一个logname</span></span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//这一天的日志行数太多了，要分文件，m_count / m_split_lines表示这是第几份</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);<span class="comment">//打开新文件，把日志系统当前写入的文件更换</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;<span class="comment">//解决变参问题的宏，下面介绍</span></span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);<span class="comment">//初始化，指向第一个参数地址</span></span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    <span class="comment">//接下来开始写内容</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//写缓冲区，要锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入的具体时间内容格式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);<span class="comment">//前面分级的s在这里出现，它是内容开头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时间、级别都写进缓冲区之后，把内容写入，内容就是可变参数，通过valst写入</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - <span class="number">1</span>, format, valst);<span class="comment">//该函数后面介绍</span></span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//添加一个换行</span></span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//这一个缓冲区字符串结束</span></span><br><span class="line">    log_str = m_buf;<span class="comment">//变成string</span></span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())<span class="comment">//如果是异步的且阻塞队列有空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);<span class="comment">//把写的任务推入队列，参数就是要写的全部内容，不执行写的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//同步的话或者阻塞队列已经满了就直接写</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//互斥写入文件中</span></span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);<span class="comment">//清空参数列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//强制刷新写入流缓冲区</span></span><br><span class="line">    <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的与时间类相关的知识：</p>
<ul>
<li><p>struct tm *localtime(const time_t *timer)</p>
</li>
<li><p>timer – 这是指向表示日历时间的 time_t 值的指针。</p>
</li>
<li><p>C 库函数 <strong>struct tm *localtime(const time_t *timer)</strong> 使用 timer 的值来填充 <strong>tm</strong> 结构。<strong>timer</strong> 的值被分解为 <strong>tm</strong> 结构，并用本地时区表示。</p>
</li>
<li><p>该函数返回指向 <strong>tm</strong> 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">   <span class="type">int</span> tm_sec;         <span class="comment">/* 秒，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_min;         <span class="comment">/* 分，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_hour;        <span class="comment">/* 小时，范围从 0 到 23                */</span></span><br><span class="line">   <span class="type">int</span> tm_mday;        <span class="comment">/* 一月中的第几天，范围从 1 到 31                    */</span></span><br><span class="line">   <span class="type">int</span> tm_mon;         <span class="comment">/* 月份，范围从 0 到 11                */</span></span><br><span class="line">   <span class="type">int</span> tm_year;        <span class="comment">/* 自 1900 起的年数                */</span></span><br><span class="line">   <span class="type">int</span> tm_wday;        <span class="comment">/* 一周中的第几天，范围从 0 到 6                */</span></span><br><span class="line">   <span class="type">int</span> tm_yday;        <span class="comment">/* 一年中的第几天，范围从 0 到 365                    */</span></span><br><span class="line">   <span class="type">int</span> tm_isdst;       <span class="comment">/* 夏令时                        */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>char *strrchr(const char *str, int c)</p>
</li>
<li><p>C 库函数 <strong>char *strrchr(const char *str, int c)</strong> 在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</li>
<li><p>该函数返回 str 中最后一次出现字符 c 的位置。如果未找到该值，则函数返回一个空指针。</p>
</li>
<li><p>int snprintf ( char * str, size_t size, const char * format, … );</p>
</li>
<li><p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数**(…)<strong>按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，</strong>size** 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断。</p>
</li>
<li><p>返回值</p>
<ul>
<li>1、如果格式化后的字符串长度小于 <strong>size</strong>，则会把字符串全部复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>；</li>
<li>2、如果格式化后的字符串长度大于等于 <strong>size</strong>，超过 <strong>size</strong> 的部分会被截断，只将其中的 <strong>(size-1)</strong> 个字符复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>，返回值为欲写入的字符串长度。</li>
</ul>
</li>
<li><p>VA_LIST 解决变参问题的一组宏，所在头文件：<code>#include &lt;stdarg.h&gt;</code>，用于获取不确定个数的参数，这种获取是根据参数类型对应的大小，找到对应的内存地址，然后获取参数来实现的</p>
</li>
<li><pre><code>typedef char *va_list;

获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）
#define va_start(list,param1) 

获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）
#define va_arg(list,mode)

清空va_list可变参数列表
#define va_end(list)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  va_list的使用方法：</span><br><span class="line">  a)  首先在函数中定义一个具有va_list型的变量，这个变量是指向参数的指针。</span><br><span class="line">  b)  然后用va_start宏初始化变量刚定义的va_list变量，使其指向第一个可变参数的地址。</span><br><span class="line">  c)  然后va_arg返回可变参数，va_arg的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用va_arg获取各个参数）。</span><br><span class="line">  d)  最后使用va_end宏结束可变参数的获取。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>int vsnprintf (char * s, size_t n, const char * format, va_list arg );</p>
</li>
<li><p>将格式化的数据从变量参数列表写入大小已设置的缓冲区</p>
</li>
<li><p>参数</p>
<ul>
<li><p>s</p>
<p>指向存储结果C-string的缓冲区的指针。 缓冲区的大小至少应为<em>n</em>字符。</p>
</li>
<li><p>n</p>
<p>缓冲区中要使用的最大字节数。 生成的字符串的长度最大为<code>n-1</code>，为其他终止空字符留出空间。</p>
</li>
<li><p>format</p>
<p>包含格式字符串的C字符串，其格式与prinf相同。</p>
</li>
<li><p>arg</p>
<p>一个值，该值标识用初始化的变量参数列表。</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功打印到sbuf中的字符的个数，不包括末尾追加的\0。如果格式化解析失败，则返回负数。</li>
</ul>
</li>
</ul>
<h1 id="第四站"><a href="#第四站" class="headerlink" title="第四站"></a>第四站</h1><h2 id="http——前置知识"><a href="#http——前置知识" class="headerlink" title="http——前置知识"></a>http——前置知识</h2><p>这部分内容很多，耐心些，别急</p>
<p>作者写的三篇介绍：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BfnNl-3jc_x5WPrWEJGdzQ">最新版Web服务器项目详解 - 04 http连接处理（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wAQHU-QZiRt1VACMZZjNlw">最新版Web服务器项目详解 - 05 http连接处理（中） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/451xNaSFHxcxfKlPBV3OCg">最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com)</a></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是linux新内核中替换select来做事件触发的机制，效率非常高，底层使用红黑树实现。这篇博客讲的非常清楚，强烈推荐：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljx0305/article/details/4065058">epoll使用详解（精髓）_ljx0305的博客-CSDN博客_epoll</a>。下面简单介绍下API，头文件<code>#include &lt;sys/epoll.h&gt;</code>。</p>
<ul>
<li><p>int epoll_create(int size)</p>
<ul>
<li>创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。(从Linux 2.6.8开始，max_size参数将被忽略，但必须大于零。)</li>
</ul>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p>
<ul>
<li><p>该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
</li>
<li><p>epfd：为epoll_creat的句柄</p>
</li>
<li><p>op：表示动作，用3个宏来表示：</p>
</li>
<li><ul>
<li>EPOLL_CTL_ADD (注册新的fd到epfd)，相当于把fd加到epfd这棵红黑树上</li>
<li>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</li>
<li>EPOLL_CTL_DEL (从epfd删除一个fd)；</li>
</ul>
</li>
<li><p>fd：文件描述符</p>
</li>
<li><p>event：告诉内核需要监听的事件，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events，是一串比特，设置类型时把类型或起来 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>events描述事件类型，其中epoll事件类型有以下几种</p>
</li>
<li><ul>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</p>
<ul>
<li><p>该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</p>
<ul>
<li><p>events：用来存内核得到事件的集合，</p>
</li>
<li><p>maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</p>
</li>
<li><p>timeout：是超时时间</p>
</li>
<li><ul>
<li>-1：阻塞</li>
<li>0：立即返回，非阻塞</li>
<li>&gt;0：指定毫秒</li>
</ul>
</li>
<li><p>返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发模式：</p>
<ul>
<li><p>LT水平触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll还会再次向应用程序通知此事件，直到该事件被处理完毕。</li>
</ul>
</li>
<li><p>ET边缘触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</li>
<li>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain</li>
</ul>
</li>
<li><p>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，故效率要比LT模式高。LT模式是epoll的默认工作模式</p>
</li>
<li><p>EPOLLONESHOT</p>
</li>
<li><ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<p>项目中epoll相关代码部分包括非阻塞模式、内核事件表注册事件、删除事件、重置EPOLLONESHOT事件四种。</p>
<ul>
<li><p>非阻塞模式</p>
</li>
<li><pre><code class="c++">//对文件描述符设置非阻塞
int setnonblocking(int fd)
&#123;
    int old_option = fcntl(fd, F_GETFL);//返回fd的状态标志，是一串比特位
    int new_option = old_option | O_NONBLOCK;//设置非阻塞的比特位，把前面获得的flag和它或起来就可以了
    fcntl(fd, F_SETFL, new_option);//重新设置
    return old_option;
&#125;
/*
阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为
的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .
 
如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，
或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.
*/
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd);</span><br><span class="line">int fcntl(int fd, int cmd, long arg);</span><br><span class="line">int fcntl(int fd, int cmd ,struct flock* lock);</span><br></pre></td></tr></table></figure>

fcntl函数功能依据cmd的值的不同而不同。参数对应功能如下：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">（1）F_DUPFD</span><br><span class="line">与dup函数功能一样，复制由fd指向的文件描述符，调用成功后返回新的文件描述符，与旧的文件描述符共同指向同一个文件。</span><br><span class="line"></span><br><span class="line">（2）F_GETFD</span><br><span class="line">读取文件描述符close-on-exec标志。</span><br><span class="line">close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特位代表一个打开的文件描述符，用于确定在调用系统调用execve()时需要关闭的文件句柄（参见include/fcntl.h）。当一个程序使用fork()函数创建了一个子进程时，通常会在该子进程中调用execve()函数加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中开始执行新程序。若一个文件描述符在close_on_exec中的对应比特位被设置，那么在执行execve()时该描述符将被关闭，否则该描述符将始终处于打开状态。</span><br><span class="line">试想一下这样的场景：在Webserver中，首先会使用root权限启动，以此打开root权限才能打开的端口、日志等文件。然后降权到普通用户，fork出一些worker进程，这些进程中再进行解析脚本、写日志、输出结果等进一步操作。</span><br><span class="line">然而这里，就会发现隐含一个安全问题：子进程中既然继承了父进程的FD，那么子进程中运行的脚本只需要继续操作这些FD，就能够使用普通权限“越权”操作root用户才能操作的文件。</span><br><span class="line"></span><br><span class="line">（3）F_SETFD</span><br><span class="line">将文件描述符close-on-exec标志设置为第三个参数arg的最后一位</span><br><span class="line"></span><br><span class="line">（4）F_GETFL</span><br><span class="line">获取文件打开方式的标志，标志值含义与open调用一致</span><br><span class="line"></span><br><span class="line">（5）F_SETFL</span><br><span class="line">设置文件打开方式标志为arg指定方式</span><br><span class="line"></span><br><span class="line">(6)F_SETLK</span><br><span class="line">此时fcntl函数用来设置或释放锁。当short_l_type为F_RDLCK为读锁，F_WDLCK为写锁，F_UNLCK为解锁。</span><br><span class="line">如果锁被其他进程占用，则返回-1;</span><br><span class="line">这种情况设的锁遇到锁被其他进程占用时，会立刻停止进程。</span><br><span class="line"></span><br><span class="line">(7)F_SETLKW</span><br><span class="line">此时也是给文件上锁，不同于F_SETLK的是，该上锁是阻塞方式。当希望设置的锁因为其他锁而被阻止设置时，该命令会等待相冲突的锁被释放。</span><br><span class="line"></span><br><span class="line">(8)F_GETLK</span><br><span class="line">第3个参数lock指向一个希望设置的锁的属性结构，如果锁能被设置，该命令并不真的设置锁，而是只修改lock的l_type为F_UNLCK,然后返回该结构体。如果存在一个或多个锁与希望设置的锁相互冲突，则fcntl返回其中的一个锁的flock结构。</span><br></pre></td></tr></table></figure>

返回值：与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。下列三个命令有特定返回值：F_DUPFD,F_GETFD,F_GETFL以及F_GETOWN。第一个返回新的文件描述符，第二个返回相应标志，最后一个返回一个正的进程ID或负的进程组ID。

</code></pre>
</li>
<li><p>内核事件表注册新事件，开启EPOLLONESHOT，针对客户端连接的描述符，listenfd不用开启</p>
</li>
<li><pre><code class="c++"> void addfd(int epollfd, int fd, bool one_shot)
 &#123;
     epoll_event event;
     event.data.fd = fd;
 
 #ifdef ET
     event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;//告知要监听可读事件、文件描述符被挂断事件
 #endif
 
#ifdef LT
    event.events = EPOLLIN | EPOLLRDHUP;//可读、文件描述符被挂断
#endif

    if (one_shot)
        event.events |= EPOLLONESHOT;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);//处理好描述的事件类型后，添加进内核事件表的文件描述符epfd
    setnonblocking(fd);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 内核事件表删除事件</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  void removefd(int epollfd, int fd)</span><br><span class="line">  &#123;</span><br><span class="line">      epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);//标志是delete，删除这个fd</span><br><span class="line">      close(fd);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>重置EPOLLONESHOT事件</p>
</li>
<li><p>&#96;&#96;&#96;c++<br> void modfd(int epollfd, int fd, int ev)<br> {<br> epoll_event event;<br> event.data.fd &#x3D; fd;<br> #ifdef ET<br> event.events &#x3D; ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<br> #endif</p>
<p>#ifdef LT<br>event.events &#x3D; ev | EPOLLONESHOT | EPOLLRDHUP;<br>#endif</p>
<pre><code>epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### http细节</span><br><span class="line"></span><br><span class="line">请求报文：get和post，报文的请求头部不一定全部都有，但可以有：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  GET &#x2F;562f25980001b1b106000338.jpg HTTP&#x2F;1.1<br>  Host:img.mukewang.com<br>  User-Agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64)<br>  AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36<br>  Accept:image&#x2F;webp,image&#x2F;<em>,</em>&#x2F;*;q&#x3D;0.8<br>  Referer:<a target="_blank" rel="noopener" href="http://www.imooc.com/">http://www.imooc.com/</a><br>  Accept-Encoding:gzip, deflate, sdch<br>  Accept-Language:zh-CN,zh;q&#x3D;0.8<br>  空行<br>  请求数据为空</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive
空行
name=Professional%20Ajax&amp;publisher=Wiley
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **请求行**，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</span><br><span class="line">  GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</span><br><span class="line"></span><br><span class="line">- **请求头部**，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</span><br><span class="line"></span><br><span class="line">- - HOST，给出请求资源所在服务器的域名。</span><br><span class="line">  - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</span><br><span class="line">  - Accept，说明用户代理可处理的媒体类型。</span><br><span class="line">  - Accept-Encoding，说明用户代理支持的内容编码。</span><br><span class="line">  - Accept-Language，说明用户代理能够处理的自然语言集。</span><br><span class="line">  - Content-Type，说明实现主体的媒体类型。</span><br><span class="line">  - Content-Length，说明实现主体的大小。</span><br><span class="line">  - Connection，连接管理，可以是Keep-Alive或close。</span><br><span class="line"></span><br><span class="line">- **空行**，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。</span><br><span class="line"></span><br><span class="line">- **请求数据**也叫主体，可以添加任意的其他数据。</span><br><span class="line"></span><br><span class="line">响应报文：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HTTP&#x2F;1.1 200 OK<br>Date: Fri, 22 May 2009 06:07:21 GMT<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8<br> 空行</p>
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</span><br><span class="line">  第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。</span><br><span class="line">- 消息报头，用来说明客户端要使用的一些附加信息。</span><br><span class="line">  第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。</span><br><span class="line">- 空行，消息报头后面的空行是必须的。</span><br><span class="line">- 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</span><br><span class="line"></span><br><span class="line">状态码：</span><br><span class="line"></span><br><span class="line">HTTP有5种类型的状态码，具体的：</span><br><span class="line"></span><br><span class="line">- 1xx：指示信息--表示请求已接收，继续处理。</span><br><span class="line"></span><br><span class="line">- 2xx：成功--表示请求正常处理完毕。</span><br><span class="line"></span><br><span class="line">- - 200 OK：客户端请求被正常处理。</span><br><span class="line">  - 206 Partial content：客户端进行了范围请求。</span><br><span class="line"></span><br><span class="line">- 3xx：重定向--要完成请求必须进行更进一步的操作。</span><br><span class="line"></span><br><span class="line">- - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</span><br><span class="line">  - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。</span><br><span class="line"></span><br><span class="line">- 4xx：客户端错误--请求有语法错误，服务器无法处理请求。</span><br><span class="line"></span><br><span class="line">- - 400 Bad Request：请求报文存在语法错误。</span><br><span class="line">  - 403 Forbidden：请求被服务器拒绝。</span><br><span class="line">  - 404 Not Found：请求不存在，服务器上找不到请求的资源。</span><br><span class="line"></span><br><span class="line">- 5xx：服务器端错误--服务器处理请求出错。</span><br><span class="line"></span><br><span class="line">- - 500 Internal Server Error：服务器在执行请求时出现错误。</span><br><span class="line"></span><br><span class="line">http报文处理流程：</span><br><span class="line"></span><br><span class="line">- 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</span><br><span class="line">- 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</span><br><span class="line">- 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</span><br><span class="line"></span><br><span class="line">### http类</span><br><span class="line"></span><br><span class="line">这一部分代码在TinyWebServer/http/http_conn.h中，主要是http类的定义。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef HTTPCONNECTION_H</span><br><span class="line">#define HTTPCONNECTION_H</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;//存储错误</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;../lock/locker.h&quot;</span><br><span class="line">#include &quot;../CGImysql/sql_connection_pool.h&quot;</span><br><span class="line">#include &quot;../timer/lst_timer.h&quot;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">class http_conn</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //设置读取文件的名称m_real_file大小</span><br><span class="line">    static const int FILENAME_LEN = 200;</span><br><span class="line">    //设置读缓冲区m_read_buf大小</span><br><span class="line">    static const int READ_BUFFER_SIZE = 2048;</span><br><span class="line">    //设置写缓冲区m_write_buf大小</span><br><span class="line">    static const int WRITE_BUFFER_SIZE = 1024;</span><br><span class="line">    </span><br><span class="line">    //报文的请求方法，本项目只用到GET和POST</span><br><span class="line">    enum METHOD</span><br><span class="line">    &#123;</span><br><span class="line">        GET = 0,</span><br><span class="line">        POST,</span><br><span class="line">        HEAD,</span><br><span class="line">        PUT,</span><br><span class="line">        DELETE,</span><br><span class="line">        TRACE,</span><br><span class="line">        OPTIONS,</span><br><span class="line">        CONNECT,</span><br><span class="line">        PATH</span><br><span class="line">    &#125;;</span><br><span class="line">    //主状态机的状态</span><br><span class="line">    enum CHECK_STATE</span><br><span class="line">    &#123;</span><br><span class="line">        CHECK_STATE_REQUESTLINE = 0,</span><br><span class="line">        CHECK_STATE_HEADER,</span><br><span class="line">        CHECK_STATE_CONTENT</span><br><span class="line">    &#125;;</span><br><span class="line">    //报文解析的结果</span><br><span class="line">    enum HTTP_CODE</span><br><span class="line">    &#123;</span><br><span class="line">        NO_REQUEST,</span><br><span class="line">        GET_REQUEST,</span><br><span class="line">        BAD_REQUEST,</span><br><span class="line">        NO_RESOURCE,</span><br><span class="line">        FORBIDDEN_REQUEST,</span><br><span class="line">        FILE_REQUEST,</span><br><span class="line">        INTERNAL_ERROR,</span><br><span class="line">        CLOSED_CONNECTION</span><br><span class="line">    &#125;;</span><br><span class="line">    //从状态机的状态</span><br><span class="line">    enum LINE_STATUS</span><br><span class="line">    &#123;</span><br><span class="line">        LINE_OK = 0,</span><br><span class="line">        LINE_BAD,</span><br><span class="line">        LINE_OPEN</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    http_conn() &#123;&#125;</span><br><span class="line">    ~http_conn() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //初始化套接字地址，函数内部会调用私有方法init</span><br><span class="line">    void init(int sockfd, const sockaddr_in &amp;addr, char *, int, int, string user, string passwd, string sqlname);</span><br><span class="line">    //关闭http连接</span><br><span class="line">    void close_conn(bool real_close = true);</span><br><span class="line">    </span><br><span class="line">    void process();</span><br><span class="line">    </span><br><span class="line">    //读取浏览器端发来的全部数据</span><br><span class="line">    bool read_once();</span><br><span class="line">    //响应报文写入函数</span><br><span class="line">    bool write();</span><br><span class="line">    </span><br><span class="line">    sockaddr_in *get_address()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;m_address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //同步线程初始化数据库读取表</span><br><span class="line">    void initmysql_result(connection_pool *connPool);</span><br><span class="line">    </span><br><span class="line">    int timer_flag;</span><br><span class="line">    int improv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void init();</span><br><span class="line">    //从m_read_buf读取，并处理请求报文</span><br><span class="line">    HTTP_CODE process_read();</span><br><span class="line">    //向m_write_buf写入响应报文数据</span><br><span class="line">    bool process_write(HTTP_CODE ret);</span><br><span class="line">    //主状态机解析报文中的请求行数据</span><br><span class="line">    HTTP_CODE parse_request_line(char *text);</span><br><span class="line">    //主状态机解析报文中的请求头数据</span><br><span class="line">    HTTP_CODE parse_headers(char *text);</span><br><span class="line">    //主状态机解析报文中的请求内容</span><br><span class="line">    HTTP_CODE parse_content(char *text);</span><br><span class="line">    //生成响应报文</span><br><span class="line">    HTTP_CODE do_request();</span><br><span class="line">    </span><br><span class="line">    //m_start_line是已经解析的字符</span><br><span class="line">    //get_line用于将指针向后偏移，指向未处理的字符</span><br><span class="line">    char *get_line() &#123; return m_read_buf + m_start_line; &#125;;</span><br><span class="line">    </span><br><span class="line">    //从状态机读取一行，分析是请求报文的哪一部分</span><br><span class="line">    LINE_STATUS parse_line();</span><br><span class="line">    void unmap();</span><br><span class="line">    </span><br><span class="line">    //根据响应报文格式，生成对应8个部分，以下函数均由do_request调用</span><br><span class="line">    bool add_response(const char *format, ...);</span><br><span class="line">    bool add_content(const char *content);</span><br><span class="line">    bool add_status_line(int status, const char *title);</span><br><span class="line">    bool add_headers(int content_length);</span><br><span class="line">    bool add_content_type();</span><br><span class="line">    bool add_content_length(int content_length);</span><br><span class="line">    bool add_linger();</span><br><span class="line">    bool add_blank_line();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int m_epollfd;//内核事件表，类共享的</span><br><span class="line">    static int m_user_count;//记录总数，静态变量的形式</span><br><span class="line">    MYSQL *mysql;</span><br><span class="line">    int m_state;  //读为0, 写为1</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_sockfd;</span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    </span><br><span class="line">    //存储读取的请求报文数据</span><br><span class="line">    char m_read_buf[READ_BUFFER_SIZE];</span><br><span class="line">    //缓冲区中m_read_buf中数据的最后一个字节的下一个位置</span><br><span class="line">    int m_read_idx;</span><br><span class="line">    //m_read_buf读取的位置m_checked_idx</span><br><span class="line">    int m_checked_idx;</span><br><span class="line">    //m_read_buf中已经解析的字符个数</span><br><span class="line">    int m_start_line;</span><br><span class="line">    </span><br><span class="line">    //存储发出的响应报文数据</span><br><span class="line">    char m_write_buf[WRITE_BUFFER_SIZE];</span><br><span class="line">    //指示buffer中的长度</span><br><span class="line">    int m_write_idx;</span><br><span class="line">    </span><br><span class="line">    //主状态机的状态</span><br><span class="line">    CHECK_STATE m_check_state;</span><br><span class="line">    //请求方法</span><br><span class="line">    METHOD m_method;</span><br><span class="line">    </span><br><span class="line">    //以下为解析请求报文中对应的6个变量</span><br><span class="line">    //存储读取文件的名称</span><br><span class="line">    char m_real_file[FILENAME_LEN];</span><br><span class="line">    char *m_url;</span><br><span class="line">    char *m_version;</span><br><span class="line">    char *m_host;</span><br><span class="line">    int m_content_length;</span><br><span class="line">    bool m_linger;</span><br><span class="line">    </span><br><span class="line">    //读取服务器上的文件地址</span><br><span class="line">    char *m_file_address;</span><br><span class="line">    </span><br><span class="line">    //stat iovec后面介绍</span><br><span class="line">    struct stat m_file_stat;//获取文件的信息</span><br><span class="line">    //io向量机制iovec</span><br><span class="line">    struct iovec m_iv[2];</span><br><span class="line">    int m_iv_count;</span><br><span class="line">    int cgi;        //是否启用的POST</span><br><span class="line">    char *m_string; //存储请求头数据</span><br><span class="line">    int bytes_to_send;//剩余发送字节数</span><br><span class="line">    int bytes_have_send;//已发送字节数</span><br><span class="line">    char *doc_root;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; m_users;</span><br><span class="line">    int m_TRIGMode;</span><br><span class="line">    int m_close_log;</span><br><span class="line"></span><br><span class="line">    char sql_user[100];</span><br><span class="line">    char sql_passwd[100];</span><br><span class="line">    char sql_name[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在http请求接收部分，会涉及到init和read_once函数，但init仅仅是对私有成员变量进行初始化，不用过多讲解。</p>
<p>这里，对read_once进行介绍。read_once读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_idx。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m_read_idx&gt;=READ_BUFFER_SIZE)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> bytes_read=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从套接字接收数据，存储在m_read_buf缓冲区</span></span><br><span class="line">        bytes_read=<span class="built_in">recv</span>(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,<span class="number">0</span>);<span class="comment">//该函数后面介绍</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_read==<span class="number">-1</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//非阻塞ET模式下，需要一次性将数据读完</span></span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN||errno==EWOULDBLOCK)<span class="comment">//这种错误是系统告知要再尝试一次，可能是因为没有数据了，break返回true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bytes_read==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改m_read_idx的读取字节数</span></span><br><span class="line">        m_read_idx+=bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int recv(int sockfd, char * buf, int len, int flags);</p>
<ul>
<li>sockfd：连接的fd</li>
<li>buf：用于接收数据的缓冲区</li>
<li>len：缓冲区长度，一般是参数2的字节数-1，把<code>\0</code>字符串结尾留出来</li>
<li>flags：指定调用方式，一般设置为0</li>
<li>返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0 。</li>
</ul>
</li>
<li><p>在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。EAGAIN和 EWOULDBLOCK等效！</p>
<ul>
<li>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以O_NONBLOCK的标志打开文件&#x2F;socket&#x2F;FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</li>
<li>这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</li>
</ul>
</li>
<li><p>struct iovec 结构体定义了一个向量元素，通常这个 iovec 结构体用于一个多元素的数组，对于每一个元素，iovec 结构体的字段 iov_base 指向一个缓冲区，这个缓冲区存放的是网络接收的数据（read），或者网络将要发送的数据（write）。iovec 结构体的字段 iov_len 存放的是接收数据的最大长度（read），或者实际写入的数据长度（write）。</p>
<ul>
<li><pre><code class="c++">struct iovec &#123;
    /* Starting address (内存起始地址）*/
    void  *iov_base;   

    /* Number of bytes to transfer（这块内存长度） */
    size_t iov_len;  
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct stat  </span><br><span class="line">    &#123;   </span><br><span class="line">        dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">        ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">        mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">        nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">        uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">        gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">        dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">        off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">        blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">        blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">        time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">        time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">        time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="c++">//_stat函数用来获取指定路径的文件或者文件夹的信息。


//! 需要包含de头文件  
#include &lt;sys/types.h&gt;    
#include &lt;sys/stat.h&gt;   
int stat(
　　const char *filename    //文件或者文件夹的路径
　　, struct stat *buf      //获取的信息保存在内存中
); //! prototype,原型     

//正确——返回0
//错误——返回-1，具体错误码保存在errno中
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。</span><br><span class="line">  </span><br><span class="line">* #### mmap</span><br><span class="line"></span><br><span class="line">  * 用于将一个文件或其他对象映射到内存，提高文件的访问速度。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">    int munmap(void* start,size_t length);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址</p>
</li>
<li><p>length：映射区的长度</p>
</li>
<li><p>prot：期望的内存保护标志，不能与文件的打开模式冲突</p>
</li>
<li><ul>
<li>PROT_READ 表示页内容可以被读取</li>
</ul>
</li>
<li><p>flags：指定映射对象的类型，映射选项和映射页是否可以共享</p>
</li>
<li><ul>
<li>MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</li>
</ul>
</li>
<li><p>fd：有效的文件描述符，一般是由open()函数返回</p>
</li>
<li><p>off_toffset：被映射对象内容的起点</p>
</li>
<li><p>返回值：成功返回创建的映射区的首地址；失败返回<strong>宏MAP_FAILED。</strong></p>
</li>
</ul>
</li>
<li><h4 id="writev"><a href="#writev" class="headerlink" title="writev"></a>writev</h4><ul>
<li><p>writev函数用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;uio.h&gt;<br>ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * filedes表示文件描述符</span><br><span class="line"></span><br><span class="line">  * iov为前述io向量机制结构体iovec</span><br><span class="line"></span><br><span class="line">  * iovcnt为结构体的个数</span><br><span class="line"></span><br><span class="line">  * 若成功则返回已写的字节数，若出错则返回-1。`writev`以顺序`iov[0]`，`iov[1]`至`iov[iovcnt-1]`从缓冲区中聚集输出数据。`writev`返回输出的字节总数，通常，它应等于所有缓冲区长度之和。</span><br><span class="line"></span><br><span class="line">  * **特别注意：** 循环调用writev时，需要重新处理iovec中的指针和长度，该函数不会对这两个成员做任何处理。writev的返回值为已写的字节数，但这个返回值“实用性”并不高，因为参数传入的是iovec数组，计量单位是iovcnt，而不是字节数，我们仍然需要通过遍历iovec来计算新的基址，另外写入数据的“结束点”可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"></span><br><span class="line">Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。</span><br><span class="line"></span><br><span class="line">&gt; *PS: 只有当系统调用或者调用lib函数时出错，才会置位`errno`！*</span><br><span class="line"></span><br><span class="line">查看系统中所有的`errno`所代表的含义，可以采用如下的代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/* Function: obtain the errno string</span><br><span class="line">*   char *strerror(int errno)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;     //for strerror()</span><br><span class="line">//#include &lt;errno.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    for(tmp = 0; tmp &lt;=256; tmp++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;errno: %2d\t%s\n&quot;,tmp,strerror(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出信息如下：</span><br><span class="line">errno:  0       Success</span><br><span class="line">errno:  1       Operation not permitted</span><br><span class="line">errno:  2       No such file or directory</span><br><span class="line">errno:  3       No such process</span><br><span class="line">errno:  4       Interrupted system call</span><br><span class="line">errno:  5       Input/output error</span><br><span class="line">errno:  6       No such device or address</span><br><span class="line">errno:  7       Argument list too long</span><br><span class="line">errno:  8       Exec format error</span><br><span class="line">errno:  9       Bad file descriptor</span><br><span class="line">errno: 10       No child processes</span><br><span class="line">errno: 11       Resource temporarily unavailable</span><br><span class="line">errno: 12       Cannot allocate memory</span><br><span class="line">errno: 13       Permission denied</span><br><span class="line">errno: 14       Bad address</span><br><span class="line">errno: 15       Block device required</span><br><span class="line">errno: 16       Device or resource busy</span><br><span class="line">errno: 17       File exists</span><br><span class="line">errno: 18       Invalid cross-device link</span><br><span class="line">errno: 19       No such device</span><br><span class="line">errno: 20       Not a directory</span><br><span class="line">errno: 21       Is a directory</span><br><span class="line">errno: 22       Invalid argument</span><br><span class="line">errno: 23       Too many open files in system</span><br><span class="line">errno: 24       Too many open files</span><br><span class="line">errno: 25       Inappropriate ioctl for device</span><br><span class="line">errno: 26       Text file busy</span><br><span class="line">errno: 27       File too large</span><br><span class="line">errno: 28       No space left on device</span><br><span class="line">errno: 29       Illegal seek</span><br><span class="line">errno: 30       Read-only file system</span><br><span class="line">errno: 31       Too many links</span><br><span class="line">errno: 32       Broken pipe</span><br><span class="line">errno: 33       Numerical argument out of domain</span><br><span class="line">errno: 34       Numerical result out of range</span><br><span class="line">errno: 35       Resource deadlock avoided</span><br><span class="line">errno: 36       File name too long</span><br><span class="line">errno: 37       No locks available</span><br><span class="line">errno: 38       Function not implemented</span><br><span class="line">errno: 39       Directory not empty</span><br><span class="line">errno: 40       Too many levels of symbolic links</span><br><span class="line">errno: 41       Unknown error 41</span><br><span class="line">errno: 42       No message of desired type</span><br><span class="line">errno: 43       Identifier removed</span><br><span class="line">errno: 44       Channel number out of range</span><br><span class="line">errno: 45       Level 2 not synchronized</span><br><span class="line">errno: 46       Level 3 halted</span><br><span class="line">errno: 47       Level 3 reset</span><br><span class="line">errno: 48       Link number out of range</span><br><span class="line">errno: 49       Protocol driver not attached</span><br><span class="line">errno: 50       No CSI structure available</span><br><span class="line">errno: 51       Level 2 halted</span><br><span class="line">errno: 52       Invalid exchange</span><br><span class="line">errno: 53       Invalid request descriptor</span><br><span class="line">errno: 54       Exchange full</span><br><span class="line">errno: 55       No anode</span><br><span class="line">errno: 56       Invalid request code</span><br><span class="line">errno: 57       Invalid slot</span><br><span class="line">errno: 58       Unknown error 58</span><br><span class="line">errno: 59       Bad font file format</span><br><span class="line">errno: 60       Device not a stream</span><br><span class="line">errno: 61       No data available</span><br><span class="line">errno: 62       Timer expired</span><br><span class="line">errno: 63       Out of streams resources</span><br><span class="line">errno: 64       Machine is not on the network</span><br><span class="line">errno: 65       Package not installed</span><br><span class="line">errno: 66       Object is remote</span><br><span class="line">errno: 67       Link has been severed</span><br><span class="line">errno: 68       Advertise error</span><br><span class="line">errno: 69       Srmount error</span><br><span class="line">errno: 70       Communication error on send</span><br><span class="line">errno: 71       Protocol error</span><br><span class="line">errno: 72       Multihop attempted</span><br><span class="line">errno: 73       RFS specific error</span><br><span class="line">errno: 74       Bad message</span><br><span class="line">errno: 75       Value too large for defined data type</span><br><span class="line">errno: 76       Name not unique on network</span><br><span class="line">errno: 77       File descriptor in bad state</span><br><span class="line">errno: 78       Remote address changed</span><br><span class="line">errno: 79       Can not access a needed shared library</span><br><span class="line">errno: 80       Accessing a corrupted shared library</span><br><span class="line">errno: 81       .lib section in a.out corrupted</span><br><span class="line">errno: 82       Attempting to link in too many shared libraries</span><br><span class="line">errno: 83       Cannot exec a shared library directly</span><br><span class="line">errno: 84       Invalid or incomplete multibyte or wide character</span><br><span class="line">errno: 85       Interrupted system call should be restarted</span><br><span class="line">errno: 86       Streams pipe error</span><br><span class="line">errno: 87       Too many users</span><br><span class="line">errno: 88       Socket operation on non-socket</span><br><span class="line">errno: 89       Destination address required</span><br><span class="line">errno: 90       Message too long</span><br><span class="line">errno: 91       Protocol wrong type for socket</span><br><span class="line">errno: 92       Protocol not available</span><br><span class="line">errno: 93       Protocol not supported</span><br><span class="line">errno: 94       Socket type not supported</span><br><span class="line">errno: 95       Operation not supported</span><br><span class="line">errno: 96       Protocol family not supported</span><br><span class="line">errno: 97       Address family not supported by protocol</span><br><span class="line">errno: 98       Address already in use</span><br><span class="line">errno: 99       Cannot assign requested address</span><br><span class="line">errno: 100      Network is down</span><br><span class="line">errno: 101      Network is unreachable</span><br><span class="line">errno: 102      Network dropped connection on reset</span><br><span class="line">errno: 103      Software caused connection abort</span><br><span class="line">errno: 104      Connection reset by peer</span><br><span class="line">errno: 105      No buffer space available</span><br><span class="line">errno: 106      Transport endpoint is already connected</span><br><span class="line">errno: 107      Transport endpoint is not connected</span><br><span class="line">errno: 108      Cannot send after transport endpoint shutdown</span><br><span class="line">errno: 109      Too many references: cannot splice</span><br><span class="line">errno: 110      Connection timed out</span><br><span class="line">errno: 111      Connection refused</span><br><span class="line">errno: 112      Host is down</span><br><span class="line">errno: 113      No route to host</span><br><span class="line">errno: 114      Operation already in progress</span><br><span class="line">errno: 115      Operation now in progress</span><br><span class="line">errno: 116      Stale file handle</span><br><span class="line">errno: 117      Structure needs cleaning</span><br><span class="line">errno: 118      Not a XENIX named type file</span><br><span class="line">errno: 119      No XENIX semaphores available</span><br><span class="line">errno: 120      Is a named type file</span><br><span class="line">errno: 121      Remote I/O error</span><br><span class="line">errno: 122      Disk quota exceeded</span><br><span class="line">errno: 123      No medium found</span><br><span class="line">errno: 124      Wrong medium type</span><br><span class="line">errno: 125      Operation canceled</span><br><span class="line">errno: 126      Required key not available</span><br><span class="line">errno: 127      Key has expired</span><br><span class="line">errno: 128      Key has been revoked</span><br><span class="line">errno: 129      Key was rejected by service</span><br><span class="line">errno: 130      Owner died</span><br><span class="line">errno: 131      State not recoverable</span><br><span class="line">errno: 132      Operation not possible due to RF-kill</span><br><span class="line">errno: 133      Memory page has hardware error</span><br><span class="line">errno: 134~255  unknown error!</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Linux中，在头文件 <code>/usr/include/asm-generic/errno-base.h</code> 对基础常用errno进行了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPERM        1  <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOENT       2  <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRCH        3  <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINTR        4  <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIO      5  <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENXIO        6  <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E2BIG        7  <span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOEXEC      8  <span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADF        9  <span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHILD      10  <span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN      11  <span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEM      12  <span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACCES      13  <span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFAULT      14  <span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTBLK     15  <span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUSY       16  <span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEXIST      17  <span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDEV       18  <span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODEV      19  <span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTDIR     20  <span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISDIR      21  <span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINVAL      22  <span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENFILE      23  <span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMFILE      24  <span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTTY      25  <span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETXTBSY     26  <span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFBIG       27  <span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSPC      28  <span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESPIPE      29  <span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS       30  <span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMLINK      31  <span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPIPE       32  <span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM        33  <span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE      34  <span class="comment">/* Math result not representable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在 <code>/usr/include/asm-asm-generic/errno.h</code> 中，对剩余的errno做了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/errno-base.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLK     35  <span class="comment">/* Resource deadlock would occur */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAMETOOLONG    36  <span class="comment">/* File name too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLCK      37  <span class="comment">/* No record locks available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSYS      38  <span class="comment">/* Function not implemented */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTEMPTY   39  <span class="comment">/* Directory not empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELOOP       40  <span class="comment">/* Too many symbolic links encountered */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWOULDBLOCK EAGAIN  <span class="comment">/* Operation would block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMSG      42  <span class="comment">/* No message of desired type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIDRM       43  <span class="comment">/* Identifier removed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHRNG      44  <span class="comment">/* Channel number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2NSYNC    45  <span class="comment">/* Level 2 not synchronized */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3HLT      46  <span class="comment">/* Level 3 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3RST      47  <span class="comment">/* Level 3 reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELNRNG      48  <span class="comment">/* Link number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUNATCH     49  <span class="comment">/* Protocol driver not attached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOCSI      50  <span class="comment">/* No CSI structure available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2HLT      51  <span class="comment">/* Level 2 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADE       52  <span class="comment">/* Invalid exchange */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADR       53  <span class="comment">/* Invalid request descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXFULL      54  <span class="comment">/* Exchange full */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOANO      55  <span class="comment">/* No anode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADRQC     56  <span class="comment">/* Invalid request code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADSLT     57  <span class="comment">/* Invalid slot */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLOCK   EDEADLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBFONT      59  <span class="comment">/* Bad font file format */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSTR      60  <span class="comment">/* Device not a stream */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODATA     61  <span class="comment">/* No data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIME       62  <span class="comment">/* Timer expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSR       63  <span class="comment">/* Out of streams resources */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENONET      64  <span class="comment">/* Machine is not on the network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPKG      65  <span class="comment">/* Package not installed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTE     66  <span class="comment">/* Object is remote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLINK     67  <span class="comment">/* Link has been severed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADV        68  <span class="comment">/* Advertise error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRMNT      69  <span class="comment">/* Srmount error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECOMM       70  <span class="comment">/* Communication error on send */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTO      71  <span class="comment">/* Protocol error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMULTIHOP   72  <span class="comment">/* Multihop attempted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOTDOT     73  <span class="comment">/* RFS specific error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADMSG     74  <span class="comment">/* Not a data message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOVERFLOW   75  <span class="comment">/* Value too large for defined data type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTUNIQ    76  <span class="comment">/* Name not unique on network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADFD      77  <span class="comment">/* File descriptor in bad state */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMCHG     78  <span class="comment">/* Remote address changed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBACC     79  <span class="comment">/* Can not access a needed shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBBAD     80  <span class="comment">/* Accessing a corrupted shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBSCN     81  <span class="comment">/* .lib section in a.out corrupted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBMAX     82  <span class="comment">/* Attempting to link in too many shared libraries */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBEXEC    83  <span class="comment">/* Cannot exec a shared library directly */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EILSEQ      84  <span class="comment">/* Illegal byte sequence */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERESTART    85  <span class="comment">/* Interrupted system call should be restarted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTRPIPE    86  <span class="comment">/* Streams pipe error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUSERS      87  <span class="comment">/* Too many users */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTSOCK    88  <span class="comment">/* Socket operation on non-socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDESTADDRREQ    89  <span class="comment">/* Destination address required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSGSIZE    90  <span class="comment">/* Message too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTOTYPE  91  <span class="comment">/* Protocol wrong type for socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPROTOOPT 92  <span class="comment">/* Protocol not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTONOSUPPORT 93  <span class="comment">/* Protocol not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESOCKTNOSUPPORT 94  <span class="comment">/* Socket type not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOPNOTSUPP  95  <span class="comment">/* Operation not supported on transport endpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPFNOSUPPORT    96  <span class="comment">/* Protocol family not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAFNOSUPPORT    97  <span class="comment">/* Address family not supported by protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRINUSE  98  <span class="comment">/* Address already in use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRNOTAVAIL   99  <span class="comment">/* Cannot assign requested address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETDOWN    100 <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETUNREACH 101 <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETRESET   102 <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNABORTED    103 <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNRESET  104 <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOBUFS     105 <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISCONN     106 <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTCONN    107 <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESHUTDOWN   108 <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETOOMANYREFS    109 <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIMEDOUT   110 <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNREFUSED    111 <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTDOWN   112 <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTUNREACH    113 <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EALREADY    114 <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINPROGRESS 115 <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTALE      116 <span class="comment">/* Stale file handle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUCLEAN     117 <span class="comment">/* Structure needs cleaning */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTNAM     118 <span class="comment">/* Not a XENIX named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAVAIL     119 <span class="comment">/* No XENIX semaphores available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISNAM      120 <span class="comment">/* Is a named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTEIO   121 <span class="comment">/* Remote I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDQUOT      122 <span class="comment">/* Quota exceeded */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEDIUM   123 <span class="comment">/* No medium found */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMEDIUMTYPE 124 <span class="comment">/* Wrong medium type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECANCELED   125 <span class="comment">/* Operation Canceled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOKEY      126 <span class="comment">/* Required key not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYEXPIRED 127 <span class="comment">/* Key has expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREVOKED 128 <span class="comment">/* Key has been revoked */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREJECTED    129 <span class="comment">/* Key was rejected by service */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for robust mutexes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOWNERDEAD  130 <span class="comment">/* Owner died */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTRECOVERABLE 131 <span class="comment">/* State not recoverable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERFKILL     132 <span class="comment">/* Operation not possible due to RF-kill */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHWPOISON   133 <span class="comment">/* Memory page has hardware error */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="http的调用"><a href="#http的调用" class="headerlink" title="http的调用"></a>http的调用</h3><p>这不是http的实现，实现后面再说，这里是使用epoll调用的运行代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建MAX_FD个http类对象</span></span><br><span class="line"> http_conn* users=<span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建内核事件表</span></span><br><span class="line"> epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line"> <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//将listenfd放在epoll树上</span></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上述epollfd赋值给http类对象的m_epollfd属性</span></span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待所监控文件描述符上有事件的产生</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对所有就绪事件进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;<span class="comment">//通过epollfd监听到的就绪事件会放在events数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">//LT水平触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ET非阻塞边缘触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">            <span class="comment">//需要循环接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读入对应缓冲区</span></span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//服务器关闭连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="http实现"><a href="#http实现" class="headerlink" title="http实现"></a>http实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义http响应的一些状态信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to staisfy.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file form this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the request file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">locker m_lock;</span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::initmysql_result</span><span class="params">(connection_pool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))<span class="comment">//从mysql这个接口输入查询语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;SELECT error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(mysql));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="comment">//这可以把一个fd绑定在epollfd上，接下来对内核事件的操作（唤醒什么的）都是针对fd文件描述符的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)<span class="comment">//边缘触发模式</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<span class="comment">//add一个</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从内核时间表删除描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//从epollfd中删掉fd，然后关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件重置为EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<span class="comment">//修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态变量定义</span></span><br><span class="line"><span class="type">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接，关闭一个连接，客户总量减一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;close %d\n&quot;</span>, m_sockfd);</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化连接,外部调用初始化套接字地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr, <span class="type">char</span> *root, <span class="type">int</span> TRIGMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> close_log, string user, string passwd, string sqlname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>, m_TRIGMode);<span class="comment">//注册一个连接</span></span><br><span class="line">    m_user_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当浏览器出现连接重置时，可能是网站根目录出错或http响应格式出错或者访问的文件中内容完全为空</span></span><br><span class="line">    doc_root = root;</span><br><span class="line">    m_TRIGMode = TRIGMode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(sql_user, user.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_passwd, passwd.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_name, sqlname.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化新接受的连接</span></span><br><span class="line"><span class="comment">//check_state默认为分析请求行状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mysql = <span class="literal">NULL</span>;</span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">    m_linger = <span class="literal">false</span>;</span><br><span class="line">    m_method = GET;</span><br><span class="line">    m_url = <span class="number">0</span>;</span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line">    cgi = <span class="number">0</span>;</span><br><span class="line">    m_state = <span class="number">0</span>;</span><br><span class="line">    timer_flag = <span class="number">0</span>;</span><br><span class="line">    improv = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从状态机，用于分析出一行内容，见作者的分析中篇</span></span><br><span class="line"><span class="comment">//返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_read_buf[m_checked_idx];<span class="comment">//temp为将要分析的字节</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//如果当前是\r字符，则有可能会读取到完整行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx)<span class="comment">//下一个字符达到了buffer结尾，则接收不完整，需要继续接收</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//下一个字符是\n，将\r\n改为\0\0</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;<span class="comment">//如果都不符合，则返回语法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果当前字符是\n，也有可能读取到完整行</span></span><br><span class="line">        &#123;<span class="comment">//一般是上次读取到\r就到buffer末尾了，没有接收完整，再次接收时会出现这种情况</span></span><br><span class="line">            <span class="keyword">if</span> (m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//前一个字符是\r，则接收完整</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;<span class="comment">//并没有找到\r\n，需要继续接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"><span class="comment">//非阻塞ET工作模式下，需要一次性将数据读完</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LT读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET读数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//循环读取</span></span><br><span class="line">        &#123;</span><br><span class="line">            bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)<span class="comment">//这时说明读完了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_read_idx += bytes_read;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="comment">//在HTTP报文中，请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本，其中各个部分之间通过\t或空格分隔。</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//请求行中最先含有空格和\t任一字符的位置并返回</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//检索字符串 str1 中第一个匹配字符串 str2 中字符的字符</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url)<span class="comment">//如果没有空格或\t，则报文格式有误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将该位置改为\0，用于将前面数据取出</span></span><br><span class="line">    <span class="type">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)<span class="comment">//取出数据，并通过与GET和POST比较，以确定请求方式</span></span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标，该函数返回 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);<span class="comment">//因为报文后面可能还有空格，跳过这些空格</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用与判断请求方式的相同逻辑，判断HTTP版本号</span></span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)<span class="comment">//只支持1.1版本</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)<span class="comment">//对请求资源前7个字符进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//同样增加https情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)<span class="comment">//一般的不会带有上述两种符号，直接是单独的/或/后面带访问资源</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    <span class="comment">//当url为/时，显示判断界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;<span class="comment">//请求行处理完毕，将主状态机转移处理请求头</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//判断是空行还是请求头</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_content_length != <span class="number">0</span>)<span class="comment">//判断是GET还是POST请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;<span class="comment">//POST需要跳转到消息体处理状态</span></span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部连接字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//跳过空格和\t字符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>)<span class="comment">//如果是长连接，则将linger标志设置为true</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部内容长度字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部HOST字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;oop!unknow header: %s&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//判断http请求是否被完整读入</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主状态机</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;<span class="comment">//初始化从状态机状态、HTTP请求解析结果</span></span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="type">char</span> *text = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在GET请求报文中，每一行都是\r\n作为结束，所以对报文进行拆解时，仅用从状态机的状态line_status=parse_line())==LINE_OK语句即可。</span></span><br><span class="line">    <span class="comment">//在POST请求报文中，消息体的末尾没有任何字符，所以不能使用从状态机的状态，这里转而使用主状态机的状态作为循环入口条件。</span></span><br><span class="line">    <span class="comment">//解析完消息体后，报文的完整解析就完成了，但此时主状态机的状态还是CHECK_STATE_CONTENT，符合循环入口条件，还会再次进入循环，这并不是我们所希望的</span></span><br><span class="line">    <span class="comment">//为此，增加了该语句，并在完成消息体解析后，将line_status变量更改为LINE_OPEN，此时可以跳出循环，完成报文解析任务。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有当从状态机处理好了，主状态机才运行</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line">        <span class="comment">//m_start_line是每一个数据行在m_read_buf中的起始位置</span></span><br><span class="line">        <span class="comment">//m_checked_idx表示从状态机在m_read_buf中读取的位置</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">        <span class="keyword">switch</span> (m_check_state)<span class="comment">//主状态机的三种状态转移逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">        &#123;	<span class="comment">//解析请求行</span></span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">        &#123;	<span class="comment">//解析请求头</span></span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="comment">//完整解析GET请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">        &#123;	<span class="comment">//解析消息体</span></span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">            <span class="comment">//完整解析POST请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();<span class="comment">//正确的请求就转调用</span></span><br><span class="line">            line_status = LINE_OPEN;<span class="comment">//从状态机没处理好，退出循环，openline</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里跟html有关系</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file, doc_root);<span class="comment">//将初始化的m_real_file赋值为网站根目录</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//找到m_url中/的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理cgi</span></span><br><span class="line">    <span class="keyword">if</span> (cgi == <span class="number">1</span> &amp;&amp; (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))<span class="comment">//实现登录和注册校验</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据标志判断是登录检测还是注册检测</span></span><br><span class="line">        <span class="type">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">//user=123&amp;passwd=123</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = m_string[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">            <span class="comment">//没有重名的，进行增加数据</span></span><br><span class="line">            <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())<span class="comment">//没有这个名字</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_lock.<span class="built_in">lock</span>();<span class="comment">//操作数据库，互斥</span></span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);<span class="comment">//数据库，没有给mysql变量赋一个连接啊？</span></span><br><span class="line">                users.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(name, password));<span class="comment">//map</span></span><br><span class="line">                m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是登录，直接判断</span></span><br><span class="line">        <span class="comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果请求资源为/0，表示跳转注册界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/register.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)<span class="comment">//如果请求资源为/1，表示跳转登录界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/log.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果以上均不符合，即不是登录和注册，直接将url与网站目录拼接，这里的情况是welcome界面，请求服务器上的一个图片</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//通过stat获取请求资源文件信息，成功则将信息更新到m_file_stat结构体</span></span><br><span class="line">    <span class="comment">//失败返回NO_RESOURCE状态，表示资源不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件的权限，是否可读，不可读则返回FORBIDDEN_REQUEST状态</span></span><br><span class="line">    <span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件类型，如果是目录，则返回BAD_REQUEST，表示请求报文有误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只读方式获取文件描述符，通过mmap将该文件映射到内存中</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(m_real_file, O_RDONLY);</span><br><span class="line">    m_file_address = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//避免文件描述符的浪费和占用</span></span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;<span class="comment">//表示请求文件存在，且可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span><span class="comment">//解除内存映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_file_address)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(m_file_address, m_file_stat.st_size);</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//若要发送的数据长度为0</span></span><br><span class="line">    <span class="comment">//表示响应报文为空，一般不会出现这种情况</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将响应报文的状态行、消息头、空行和响应正文发送给浏览器端</span></span><br><span class="line">        temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)<span class="comment">//发送失败</span></span><br><span class="line">        &#123;	<span class="comment">//判断缓冲区是否满了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;	<span class="comment">//重新注册写事件</span></span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发送失败，但不是缓冲区问题，取消映射</span></span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	   <span class="comment">//正常发送，temp为发送的字节数</span></span><br><span class="line">        bytes_have_send += temp;<span class="comment">//更新已发送字节</span></span><br><span class="line">        bytes_to_send -= temp;<span class="comment">//偏移文件iovec的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个iovec头部信息的数据已发送完，发送第二个iovec数据</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;<span class="comment">//不再继续发送头部信息</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//继续发送第一个iovec头部信息的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断条件，数据已全部发送完</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//在epoll树上重置EPOLLONESHOT事件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)<span class="comment">//浏览器的请求为长连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();<span class="comment">//重新初始化HTTP对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE)<span class="comment">//如果写入内容超出m_write_buf大小则报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    va_list arg_list;<span class="comment">//定义可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_list, format);<span class="comment">//将变量arg_list初始化为传入参数</span></span><br><span class="line">    <span class="comment">//将数据format从可变参数列表写入缓冲区，返回写入数据的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">vsnprintf</span>(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line">    <span class="comment">//如果写入的数据长度超过缓冲区剩余空间，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;<span class="comment">//更新m_write_idx位置</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);<span class="comment">//清空可变参列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;request:%s&quot;</span>, m_write_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *title)</span><span class="comment">//添加状态行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加消息报头，具体的添加文本长度、连接状态和空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_content_length</span>(content_len) &amp;&amp; <span class="built_in">add_linger</span>() &amp;&amp;</span><br><span class="line">           <span class="built_in">add_blank_line</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加Content-Length，表示响应报文的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span><span class="comment">//添加文本类型，这里是html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span><span class="comment">//添加连接状态，通知浏览器端是保持连接还是关闭</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span><span class="comment">//添加空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content)</span><span class="comment">//添加文本content</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span><span class="comment">//逻辑上处理要写什么</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:<span class="comment">//内部错误，500</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);<span class="comment">//状态行</span></span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));<span class="comment">//消息报头</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:<span class="comment">//报文语法有误，404</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:<span class="comment">//资源没有访问权限，403</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:<span class="comment">//文件存在，200</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">        <span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>)<span class="comment">//如果请求的资源存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_headers</span>(m_file_stat.st_size);</span><br><span class="line">            <span class="comment">//第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx</span></span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">            <span class="comment">//第二个iovec指针指向mmap返回的文件指针，长度指向文件大小</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//发送的全部数据为响应报文头部信息和文件大小</span></span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;	<span class="comment">//如果请求的资源大小为0，则返回空白html文件</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除FILE_REQUEST状态外，其余状态只申请一个iovec，指向响应报文缓冲区</span></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span><span class="comment">//对读事件完成最终处理并发送响应报文</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)<span class="comment">//NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//注册并监听读事件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);<span class="comment">//调用process_write完成报文响应</span></span><br><span class="line">    <span class="keyword">if</span> (!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close_conn</span>();<span class="comment">//如果写错误就关闭连接，会把fd删除且关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//？都关闭了且没有注册怎么修改</span></span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);<span class="comment">//注册并监听写事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL_RES *mysql_store_result(MYSQL *mysql)<ul>
<li>对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result() 。</li>
<li>对于其他查询，不需要调用mysql_store_result()或mysql_use_result()，但是如果在任何情况下均调用了mysql_store_result()，它也不会导致任何伤害或性能降低。通过检查mysql_store_result()是否返回0，可检测查询是否没有结果集（以后会更多）。</li>
<li>如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。</li>
</ul>
</li>
<li>unsigned int mysql_field_count(MYSQL *mysql)<ul>
<li>返回作用在连接上的最近查询的列数。</li>
</ul>
</li>
<li>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)<ul>
<li>返回采用MYSQL_FIELD结构的结果集的列。重复调用该函数，以检索关于结果集中所有列的信息。</li>
</ul>
</li>
<li>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)<ul>
<li>检索结果集的下一行。在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL。在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL。行内值的数目由mysql_num_fields(result)给出。</li>
</ul>
</li>
<li>int munmap(void *start,size_t length);<ul>
<li>函数说明 munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。</li>
<li>返回值 如果解除映射成功则返回0，否则返回－1，错误原因存于errno中错误代码EINVAL参数 start或length 不合法。</li>
</ul>
</li>
</ul>
<h1 id="第五站"><a href="#第五站" class="headerlink" title="第五站"></a>第五站</h1><p>项目中使用的是<code>SIGALRM</code>信号，具体的，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计与定时任务的处理。</p>
<h2 id="定时器与信号API"><a href="#定时器与信号API" class="headerlink" title="定时器与信号API"></a>定时器与信号API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Linux中的信号是一种消息处理机制，它本质上是一个整数，不同的信号对应不同的值，信号在系统中的优先级是非常高的。</span><br><span class="line">- 项目中使用的信号</span><br><span class="line"> 	1. SIGALRM：定时器超时信号，超时的时间由系统调用alarm设置，默认终止进程。</span><br><span class="line"> 	2. SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</span><br><span class="line">- 两个特殊信号</span><br><span class="line">	1. SIGKILL：9号信号，无条件终止进程，不能被捕捉、阻塞和忽略。</span><br><span class="line">	2. SIGSTOP：19号信号，无条件暂停进程，不能被捕捉、阻塞和忽略。</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一个信号：SIGPIPE：当服务器close一个连接时，若client端接着发数据。根据TCP 协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。 <ul>
<li>TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown.</li>
<li>对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.</li>
<li>为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它, 给它设置SIG_IGN信号处理函数:signal(SIGPIPE, SIG_IGN);SIG_IGN表示忽略信号</li>
</ul>
</li>
</ul>
<ul>
<li>Linux中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略某些信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。</li>
<li>程序中的信号捕捉是一个注册的动作，提前告诉应用程序信号产生之后的处理动作，当进程中对应的信号产生了，这个处理动作也就被调用了。</li>
</ul>
<ul>
<li><p>sigaction结构体：</p>
<ul>
<li><pre><code class="c++">struct sigaction
&#123;
    void (*sa_handler)(int);                        // 函数指针，指向信号处理函数。
    void (*sa_sigaction)(int, siginfo_t *, void *); // 函数指针，指向信号处理函数，有三个参数。
    sigset_t sa_mask;                               // 在信号处理函数执行期间，临时屏蔽的信号。
    int sa_flags;                                   // 用于指定信号处理的行为
    void (*sa_restorer)(void);                      // 被废弃的成员，一般不使用
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * flag有以下几个：</span><br><span class="line"></span><br><span class="line">    * SA_RESTART，使被信号打断的系统调用自动重新发起</span><br><span class="line">    * SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号</span><br><span class="line">    * SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程</span><br><span class="line">    * SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号</span><br><span class="line">    * SA_RESETHAND，信号处理之后重新设置为默认的处理方式</span><br><span class="line"></span><br><span class="line">* sigaction函数：</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    int sigaction(</span><br><span class="line">        int signum,                  // 要捕捉的信号。</span><br><span class="line">        const struct sigaction *act, // 对信号设置新的处理方式。</span><br><span class="line">        struct sigaction *oldact     // 上一次信号处理方式，一般指定为NULL。</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>返回值，0 表示成功，-1 表示有错误发生。</p>
</li>
</ul>
</li>
<li><p>sigfillset函数：</p>
<ul>
<li>&#96;&#96;&#96;c++<br>int sigfillset(sigset_t * set);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里，即将所有的信号标志位置为1，屏蔽所有的信号。信号集是在执行信号处理程序时被阻塞的信号集。因此，当执行信号处理程序时，所有信号都被阻塞，不必担心另一个信号会中断信号处理程序。</span><br><span class="line"></span><br><span class="line">* SIGALRM、SIGTERM信号，是整形数</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #define SIGALRM  14     //由alarm系统调用产生timer时钟信号</span><br><span class="line">    #define SIGTERM  15     //终端发送的终止信号</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>alarm函数</p>
<ul>
<li><pre><code class="c++">#include&lt;unistd.h&gt;
unsigned int alarm（unsigned int seconds);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号。可以设置忽略或者不捕获此信号，如果采用默认方式其动作是终止调用该alarm函数的进程。</span><br><span class="line"></span><br><span class="line">  * 要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。需要注意的是，经过指定的秒数后，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一些时间。</span><br><span class="line"></span><br><span class="line">  * 返回值：成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</span><br><span class="line"></span><br><span class="line">* socketpair函数</span><br><span class="line"></span><br><span class="line">  * 在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。socketpair创建的描述符任意一端既可以读也可以写。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/socket.h&gt;</span><br><span class="line">    </span><br><span class="line">    int socketpair(int domain, int type, int protocol, int sv[2]);</span><br></pre></td></tr></table></figure>

* domain表示协议族，PF_UNIX或者AF_UNIX，AF = Address Family、PF = Protocol Family。PF_UNIX (也称作 PF_LOCAL ) 套接字族用来在同一机器上的提供有效的进程间通讯。AF\_和PF\_的值直接可以替换，没有其它区别。
* type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
* protocol表示类型，只能为0
* sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
</code></pre>
</li>
<li><p>返回结果， 0为创建成功，-1为创建失败</p>
</li>
</ul>
</li>
<li><p>send函数，当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * sockfd：指定发送端套接字描述符。</span><br><span class="line">    * buff： 存放要发送数据的缓冲区</span><br><span class="line">    * nbytes: 实际要改善的数据的字节数</span><br><span class="line">    * flags： 一般设置为0</span><br><span class="line"></span><br><span class="line">  * 1) send先比较发送数据的长度nbytes和套接字sockfd的发送缓冲区的长度，如果nbytes &gt; 套接字sockfd的发送缓冲区的长度, 该函数返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    2) 如果nbtyes &lt;= 套接字sockfd的发送缓冲区的长度，那么send先检查协议是否正在发送sockfd的发送缓冲区中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送sockfd的发送缓冲区中的数据或者sockfd的发送缓冲区中没有数据，那么send就比较sockfd的发送缓冲区的剩余空间和nbytes。</span><br><span class="line"></span><br><span class="line">    3) 如果 nbytes &gt; 套接字sockfd的发送缓冲区剩余空间的长度，send就一起等待协议把套接字sockfd的发送缓冲区中的数据发送完。</span><br><span class="line"></span><br><span class="line">    4) 如果 nbytes &lt; 套接字sockfd的发送缓冲区剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里(注意：并不是send把套接字sockfd的发送缓冲区中的数据传到连接的另一端的，而是协议传送的。send仅仅是把buf中的数据copy到套接字sockfd的发送缓冲区的剩余空间里)。</span><br><span class="line"></span><br><span class="line">    5) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    6) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    7) 在unix系统下，如果send在等待协议传送数据时网络断开，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的处理是进程终止。</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">## 头文件</span><br><span class="line"></span><br><span class="line">lst_timer.h</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef LST_TIMER</span><br><span class="line">#define LST_TIMER</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">//连接资源结构体成员需要用到定时器类</span><br><span class="line">//前向声明</span><br><span class="line">class util_timer;</span><br><span class="line"></span><br><span class="line">//连接资源</span><br><span class="line">struct client_data</span><br><span class="line">&#123;</span><br><span class="line">    //客户端socket地址，项目中未使用</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    int sockfd;//socket文件描述符</span><br><span class="line">    util_timer *timer;//定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器类</span><br><span class="line">class util_timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    util_timer() : prev(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    time_t expire;//超时时间</span><br><span class="line">    </span><br><span class="line">    void (* cb_func)(client_data *);//回调函数指针，这个回调函数会删除client_data的资源连接</span><br><span class="line">    client_data *user_data;//连接资源，嵌套类使用指针，相当于内部成员指针互相指向对方实例</span><br><span class="line">    util_timer *prev;//前向定时器</span><br><span class="line">    util_timer *next;//后继定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器容器类，双向链表</span><br><span class="line">class sort_timer_lst</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    sort_timer_lst();</span><br><span class="line">    ~sort_timer_lst();//常规销毁链表</span><br><span class="line"></span><br><span class="line">    void add_timer(util_timer *timer);//添加定时器，内部调用私有成员add_timer</span><br><span class="line">    void adjust_timer(util_timer *timer);//调整定时器，任务发生变化时，调整定时器在链表中的位置</span><br><span class="line">    void del_timer(util_timer *timer);//删除定时器</span><br><span class="line">    void tick();//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void add_timer(util_timer *timer, util_timer *lst_head);</span><br><span class="line"></span><br><span class="line">    //创建头尾指针，方便管理</span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Utils//资源管理类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Utils() &#123;&#125;</span><br><span class="line">    ~Utils() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void init(int timeslot);</span><br><span class="line"></span><br><span class="line">    //对文件描述符设置非阻塞</span><br><span class="line">    int setnonblocking(int fd);</span><br><span class="line"></span><br><span class="line">    //将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span><br><span class="line">    void addfd(int epollfd, int fd, bool one_shot, int TRIGMode);</span><br><span class="line"></span><br><span class="line">    //信号处理函数</span><br><span class="line">    static void sig_handler(int sig);</span><br><span class="line"></span><br><span class="line">    //设置信号函数</span><br><span class="line">    void addsig(int sig, void(handler)(int), bool restart = true);</span><br><span class="line"></span><br><span class="line">    //定时处理任务，重新定时以不断触发SIGALRM信号</span><br><span class="line">    void timer_handler();</span><br><span class="line"></span><br><span class="line">    void show_error(int connfd, const char *info);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int *u_pipefd;//管道描述符</span><br><span class="line">    sort_timer_lst m_timer_lst;//定时器容器</span><br><span class="line">    static int u_epollfd;//事务描述符</span><br><span class="line">    int m_TIMESLOT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void cb_func(client_data *user_data);//回调函数</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="cpp实现-2"><a href="#cpp实现-2" class="headerlink" title=".cpp实现"></a>.cpp实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lst_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sort_timer_lst::<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort_timer_lst::~<span class="built_in">sort_timer_lst</span>()<span class="comment">//常规销毁链表</span></span><br><span class="line">&#123;</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)<span class="comment">//没有timer要加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!head)<span class="comment">//链表中一个节点都没有</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = tail = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果新的定时器超时时间小于当前头部结点</span></span><br><span class="line">    <span class="comment">//直接将当前定时器结点作为头部结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire)</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;next = head;</span><br><span class="line">        head-&gt;prev = timer;</span><br><span class="line">        head = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则要插入链表中间或结尾，调用私有方法</span></span><br><span class="line">    <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    util_timer *tmp = timer-&gt;next;</span><br><span class="line">    <span class="comment">//被调整的定时器在链表尾部，不调整</span></span><br><span class="line">    <span class="comment">//定时器超时值仍然小于下一个定时器超时值，不调整（定时器刷新时间只可能更大，不用和前面的节点比较）</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, timer-&gt;next);<span class="comment">//因为timer要比next大，所以next当头节点往后add就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//删除定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::del_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line">    <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == tail)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前时间，定时器的超时时间是以前设置的时间+n个单位超时时间（成为未来时间），所以用当前时间来比较判断是否超时</span></span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="comment">//遍历定时器链表</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//链表容器为升序排列</span></span><br><span class="line">        <span class="comment">//当前时间小于定时器的超时时间，后面的定时器也没有到期</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">        <span class="comment">//将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员，被公有成员add_timer和adjust_time调用</span></span><br><span class="line"><span class="comment">//主要用于调整链表内部结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *prev = lst_head;</span><br><span class="line">    util_timer *tmp = prev-&gt;next;<span class="comment">//不可能比头节点小，所以比较后面的一个节点</span></span><br><span class="line">    <span class="comment">//遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire)<span class="comment">//可以插到tmp前面</span></span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;prev = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = timer;</span><br><span class="line">        timer-&gt;prev = prev;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::init</span><span class="params">(<span class="type">int</span> timeslot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TIMESLOT = timeslot;<span class="comment">//单位时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Utils::setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为保证函数的可重入性，保留原来的errno</span></span><br><span class="line">    <span class="comment">//可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="comment">//将信号值从管道写端写入，传输字符类型，而非整型</span></span><br><span class="line">    <span class="built_in">send</span>(u_pipefd[<span class="number">1</span>], (<span class="type">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置信号函数，信号是指SIGALRM这些信号，本质是一个int</span></span><br><span class="line"><span class="comment">//当超时时（比如alarm）会产生这个信号，这里的设置（注册）就是让这个信号的处理按照这里设置的方式，比如flag和处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(*handler)(<span class="type">int</span>), <span class="type">bool</span> restart)</span><span class="comment">//handler是sig_handler</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建sigaction结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//信号处理函数中仅仅发送信号值，不做对应逻辑处理</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="comment">//将所有信号添加到信号集sa_mask中，屏蔽所有信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">//执行sigaction函数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);<span class="comment">//这个sig信号会屏蔽其他的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(m_TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::show_error</span><span class="params">(<span class="type">int</span> connfd, <span class="type">const</span> <span class="type">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *Utils::u_pipefd = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Utils::u_epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span>;<span class="comment">//在这声明是什么意思？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器回调函数，tick函数调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除非活动连接在socket上的注册事件</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(Utils::u_epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line">    <span class="comment">//减少连接数</span></span><br><span class="line">    http_conn::m_user_count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用逻辑"><a href="#使用逻辑" class="headerlink" title="使用逻辑"></a>使用逻辑</h2><p>首先注册（设置）好信号，比如SIGALRM信号，这使得产生这个信号时，能有对应的方式和处理（默认是终止进程），这里的方式是restart、屏蔽其他信号，处理是通过管道向主循环发这个信号。产生的方式是alarm()，主循环中每次尝试从管道获取信号，如果有这个信号，则设置timeout为true说明有超时事件要处理，因为是非必须事件，在这轮循环读写完再进行处理。</p>
<p>处理会调用timer_handler()，首先调用tick()，把定时器超时的都关了（调用cb_func），然后重新alarm()。</p>
<p>关于SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</p>
<p>也就是：</p>
<ul>
<li><p>信号</p>
<ul>
<li><p>1.先知道有些动作会产生一些信号</p>
</li>
<li><p>2.设置（注册）这些信号产生后的动作——方式（flag）和处理函数（handler）</p>
</li>
<li><p>3.处理函数只是通知主循环有个信号产生，主循环要做对应的处理。</p>
</li>
</ul>
</li>
<li><p>主循环，我们看看会发生什么</p>
<ul>
<li>1.当一个连接到来时，要创建一个定时器给它，初始化时间和回调函数等变量；</li>
<li>2.如果连接有读写，更新时间；</li>
<li>3.无论有没有定时器超时，每隔timeslot（时隙）会alarm一次，触发信号后主循环得知信号产生，去查看有哪些连接的定时器超时了，超时就关闭连接，然后重新设置alarm，循环往复。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建定时器容器链表</span></span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接资源数组</span></span><br><span class="line">client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时默认为False</span></span><br><span class="line"><span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alarm定时触发SIGALRM信号</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化客户端连接地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该连接分配的文件描述符</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化该连接对应的连接资源</span></span><br><span class="line">            users_timer[connfd].address = client_address;</span><br><span class="line">            users_timer[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建定时器临时变量</span></span><br><span class="line">            util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">            <span class="comment">//设置定时器对应的连接资源</span></span><br><span class="line">            timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">            <span class="comment">//设置回调函数</span></span><br><span class="line">            timer-&gt;cb_func = cb_func;</span><br><span class="line"></span><br><span class="line">            <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置绝对超时时间</span></span><br><span class="line">            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">            <span class="comment">//创建该连接对应的定时器，初始化为前述临时变量</span></span><br><span class="line">            users_timer[connfd].timer = timer;</span><br><span class="line">            <span class="comment">//将该定时器添加到链表中</span></span><br><span class="line">            timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">            <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理定时器信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//接收到SIGALRM信号，timeout设置为True</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建定时器临时变量，将该连接对应的定时器取出来</span></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//对其在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">       &#123;</span><br><span class="line">           util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">           <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理定时器为非必须事件，收到信号并不是立马处理</span></span><br><span class="line">    <span class="comment">//完成读写事件后，再进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">timer_handler</span>();</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六站"><a href="#第六站" class="headerlink" title="第六站"></a>第六站</h1><p>内容比较少</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>头文件config.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Config</span>();</span><br><span class="line">    ~<span class="built_in">Config</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">    <span class="type">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式</span></span><br><span class="line">    <span class="type">int</span> LOGWrite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式</span></span><br><span class="line">    <span class="type">int</span> TRIGMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式</span></span><br><span class="line">    <span class="type">int</span> LISTENTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式</span></span><br><span class="line">    <span class="type">int</span> CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接</span></span><br><span class="line">    <span class="type">int</span> OPT_LINGER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量</span></span><br><span class="line">    <span class="type">int</span> sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量</span></span><br><span class="line">    <span class="type">int</span> thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> close_log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型选择</span></span><br><span class="line">    <span class="type">int</span> actor_model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Config::<span class="built_in">Config</span>()&#123;</span><br><span class="line">    <span class="comment">//端口号,默认9006</span></span><br><span class="line">    PORT = <span class="number">9006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式，默认同步</span></span><br><span class="line">    LOGWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式,默认listenfd LT + connfd LT</span></span><br><span class="line">    TRIGMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式，默认LT</span></span><br><span class="line">    LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式，默认LT</span></span><br><span class="line">    CONNTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接，默认不使用</span></span><br><span class="line">    OPT_LINGER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量,默认8</span></span><br><span class="line">    sql_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量,默认8</span></span><br><span class="line">    thread_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭日志,默认不关闭</span></span><br><span class="line">    close_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型,默认是proactor，这个后面介绍</span></span><br><span class="line">    actor_model = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Config::parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>&#123;<span class="comment">//命令行形式获取参数</span></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, str)) != <span class="number">-1</span>)<span class="comment">//这个函数下面介绍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)<span class="comment">//会重新排列参数顺序，所以要switch</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            PORT = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            LOGWrite = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            TRIGMode = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            OPT_LINGER = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sql_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            thread_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            close_log = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            actor_model = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 &lt;unistd.h&gt; 头文件中。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int getopt(int argc, char * const argv[], const char *optstring);<br>extern char *optarg;  &#x2F;&#x2F;选项的参数指针<br>extern int optind,   &#x2F;&#x2F;下一次调用getopt的时，从optind存储的位置处重新开始检查选项。<br>extern int opterr,  &#x2F;&#x2F;当opterr&#x3D;0时，getopt不向stderr输出错误信息。<br>extern int optopt;  &#x2F;&#x2F;当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回’？’、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * argc：通常由函数直接传入，表示参数的数量</span><br><span class="line"></span><br><span class="line">  * argv：通常也由函数直接传入，表示参数的字符串变量数组</span><br><span class="line"></span><br><span class="line">  * optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号</span><br><span class="line"></span><br><span class="line">    * 1.单个字符，表示选项，</span><br><span class="line">    * 2.单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</span><br><span class="line">    * 3 单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）。</span><br><span class="line"></span><br><span class="line">  * getopt处理以&#x27;-’开头的命令行参数，如optstring=&quot;ab:c::d::&quot;,命令行为getopt.exe -a -b host -ckeke -d haha</span><br><span class="line">    在这个命令行参数中，-a和-h就是选项元素，去掉&#x27;-&#x27;，a,b,c就是选项。host是b的参数，keke是c的参数。但haha并不是d的参数，因为它们中间有空格隔开。</span><br><span class="line"></span><br><span class="line">  * getopt()用来分析命令行参数。参数argc和argv是由main()传递的参数个数和内容。参数optstring 则代表欲处理的选项字符串。此函数会返回在argv 中下一个的选项字母（指针不断移动），此字母会对应参数optstring 中的字母。如果选项字符串里的字母后接着冒号“:”，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果getopt()找不到符合的参数则会印出错信息，并将全域变量optopt设为“?”字符，如果不希望getopt()印出错信息，则只要将全域变量opterr设为0即可。</span><br><span class="line"></span><br><span class="line">  * 还要注意的是默认情况下getopt会重新排列命令行参数的顺序，所以到最后所有不包含选项的命令行参数都排到最后。</span><br><span class="line">    如getopt.exe -a ima -b host -ckeke -d haha, 都最后命令行参数的顺序是： -a -b host -ckeke -d ima haha</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">关于proactor模式，小林coding的这篇分析写得很好，推荐看一看：[如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26943938)</span><br><span class="line"></span><br><span class="line">项目中用的是假reactor和模拟proactor（同步的）：[(29条消息) 两种高效的事件处理模式：Reactor模式和Proactor模式_ZY-JIMMY的博客-CSDN博客_reactor模式和proactor](https://blog.csdn.net/ZYZMZM_/article/details/98049471)</span><br><span class="line"></span><br><span class="line">## main</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //需要修改的数据库信息,登录名,密码,库名</span><br><span class="line">    string user = &quot;root&quot;;</span><br><span class="line">    string passwd = &quot;root&quot;;</span><br><span class="line">    string databasename = &quot;qgydb&quot;;</span><br><span class="line"></span><br><span class="line">    //命令行解析</span><br><span class="line">    Config config;</span><br><span class="line">    config.parse_arg(argc, argv);</span><br><span class="line"></span><br><span class="line">    WebServer server;//websever在config.h中导入了websever.h</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    server.init(config.PORT, user, passwd, databasename, config.LOGWrite, </span><br><span class="line">                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, </span><br><span class="line">                config.close_log, config.actor_model);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //日志</span><br><span class="line">    server.log_write();</span><br><span class="line"></span><br><span class="line">    //数据库</span><br><span class="line">    server.sql_pool();</span><br><span class="line"></span><br><span class="line">    //线程池</span><br><span class="line">    server.thread_pool();</span><br><span class="line"></span><br><span class="line">    //触发模式</span><br><span class="line">    server.trig_mode();</span><br><span class="line"></span><br><span class="line">    //监听</span><br><span class="line">    server.eventListen();</span><br><span class="line"></span><br><span class="line">    //运行</span><br><span class="line">    server.eventLoop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="makefile-amp-g"><a href="#makefile-amp-g" class="headerlink" title="makefile&amp;g++"></a>makefile&amp;g++</h2><p>先看这个入门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/82696682">(29条消息) Makefile 语法入门_阿飞__的博客-CSDN博客_makefile语法</a></p>
<p>再看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fangye945a/article/details/85039249">(29条消息) Makefile文件语法规则及用法总结_fangye945a的博客-CSDN博客_makefile语法规则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhaixue.cc/makefile/makefile-ifeq.html">Makefile 条件判断 - ifeq、ifneq、ifdef、ifndef - Makefile 简明教程 | 宅学部落 (zhaixue.cc)</a></p>
<p>g++参数：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104197249">C&#x2F;C++专题—gcc g++ 参数详解 - 知乎 (zhihu.com)</a></p>
<p>rm命令：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/744.html">Linux rm命令：删除文件或目录 (biancheng.net)</a></p>
<p>项目中的makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX ?= g++</span><br><span class="line"></span><br><span class="line">DEBUG ?= 1</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">    CXXFLAGS += -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CXXFLAGS += -O2</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">server: main.cpp  ./timer/lst_timer.cpp ./http/http_conn.cpp ./log/log.cpp ./CGImysql/sql_connection_pool.cpp  webserver.cpp config.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o server  <span class="variable">$^</span> <span class="variable">$(CXXFLAGS)</span> -lpthread -lmysqlclient</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm  -r server</span><br></pre></td></tr></table></figure>

<h1 id="第七站"><a href="#第七站" class="headerlink" title="第七站"></a>第七站</h1><h2 id="顶层实现"><a href="#顶层实现" class="headerlink" title="顶层实现"></a>顶层实现</h2><p>头文件websever.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./threadpool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;           <span class="comment">//最大文件描述符，即最大连接数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>; <span class="comment">//最大事件数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TIMESLOT = <span class="number">5</span>;             <span class="comment">//最小超时单位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>();</span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> port , string user, string passWord, string databaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> log_write , <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thread_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sql_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trig_mode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventListen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealclinetdata</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealwithsignal</span><span class="params">(<span class="type">bool</span>&amp; timeout, <span class="type">bool</span>&amp; stop_server)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//基础</span></span><br><span class="line">    <span class="type">int</span> m_port;<span class="comment">//端口</span></span><br><span class="line">    <span class="type">char</span> *m_root;<span class="comment">//根目录地址</span></span><br><span class="line">    <span class="type">int</span> m_log_write;<span class="comment">//是否要异步写日志，异步写用一个阻塞队列</span></span><br><span class="line">    <span class="type">int</span> m_close_log;<span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> m_actormodel;<span class="comment">//模型切换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_pipefd[<span class="number">2</span>];<span class="comment">//管道通信</span></span><br><span class="line">    <span class="type">int</span> m_epollfd;<span class="comment">//内核描述符</span></span><br><span class="line">    http_conn *users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库相关</span></span><br><span class="line">    connection_pool *m_connPool;</span><br><span class="line">    string m_user;         <span class="comment">//登陆数据库用户名</span></span><br><span class="line">    string m_passWord;     <span class="comment">//登陆数据库密码</span></span><br><span class="line">    string m_databaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">    <span class="type">int</span> m_sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池相关</span></span><br><span class="line">    threadpool&lt;http_conn&gt; *m_pool;</span><br><span class="line">    <span class="type">int</span> m_thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_event相关</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_listenfd;<span class="comment">//监听文件描述符</span></span><br><span class="line">    <span class="type">int</span> m_OPT_LINGER;</span><br><span class="line">    <span class="type">int</span> m_TRIGMode;<span class="comment">//控制连接和读写的触发模式</span></span><br><span class="line">    <span class="type">int</span> m_LISTENTrigmode;</span><br><span class="line">    <span class="type">int</span> m_CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器相关</span></span><br><span class="line">    client_data *users_timer;</span><br><span class="line">    Utils utils;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>.cpp实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//http_conn类对象</span></span><br><span class="line">    users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//root文件夹路径</span></span><br><span class="line">    <span class="type">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(server_path, <span class="number">200</span>);</span><br><span class="line">    <span class="type">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">    m_root = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">    <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    users_timer = <span class="keyword">new</span> client_data[MAX_FD];<span class="comment">//每个连接都对应一个定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">    <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">delete</span>[] users_timer;</span><br><span class="line">    <span class="keyword">delete</span> m_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::init</span><span class="params">(<span class="type">int</span> port, string user, string passWord, string databaseName, <span class="type">int</span> log_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num, <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_port = port;</span><br><span class="line">    m_user = user;</span><br><span class="line">    m_passWord = passWord;</span><br><span class="line">    m_databaseName = databaseName;</span><br><span class="line">    m_sql_num = sql_num;</span><br><span class="line">    m_thread_num = thread_num;</span><br><span class="line">    m_log_write = log_write;</span><br><span class="line">    m_OPT_LINGER = opt_linger;</span><br><span class="line">    m_TRIGMode = trigmode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_actormodel = actor_model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::trig_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//LT + LT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;<span class="comment">//读写的模式</span></span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;<span class="comment">//连接的模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LT + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + LT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::log_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_close_log)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_log_write)<span class="comment">//是否异步写日志</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">800</span>);<span class="comment">//800是阻塞队列长度</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::sql_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据库连接池</span></span><br><span class="line">    m_connPool = connection_pool::<span class="built_in">GetInstance</span>();</span><br><span class="line">    m_connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, m_user, m_passWord, m_databaseName, <span class="number">3306</span>, m_sql_num, m_close_log);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据库读取表</span></span><br><span class="line">    users-&gt;<span class="built_in">initmysql_result</span>(m_connPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::thread_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//线程池，前面创建了users一组http_conn对象，每个对象的工作处理由线程池调用</span></span><br><span class="line">    m_pool = <span class="keyword">new</span> <span class="built_in">threadpool</span>&lt;http_conn&gt;(m_actormodel, m_connPool, m_thread_num);<span class="comment">//只有这一个实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventListen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//网络编程基础步骤</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建一个套接字，监听套接口，socket函数看后面</span></span><br><span class="line">    <span class="built_in">assert</span>(m_listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">linger</span> tmp = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> linger tmp = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//地址配置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//本函数将一个32位数从主机字节顺序转换成网络字节顺序。INADDR_ANY见后面</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(m_port);<span class="comment">//将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，</span></span><br><span class="line"><span class="comment">	从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用big-endian排序方式。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//打开地址复用功能，允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    ret = <span class="built_in">bind</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address));<span class="comment">//见后面</span></span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line">    ret = <span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">init</span>(TIMESLOT);<span class="comment">//初始化资源管理类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll创建内核事件表</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];<span class="comment">//事件集合</span></span><br><span class="line">    m_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);<span class="comment">//事件表描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_listenfd, <span class="literal">false</span>, m_LISTENTrigmode);<span class="comment">//内核事件表注册读事件，监听socket</span></span><br><span class="line">    http_conn::m_epollfd = m_epollfd;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_pipefd);<span class="comment">//创建管道套接字</span></span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    utils.<span class="built_in">setnonblocking</span>(m_pipefd[<span class="number">1</span>]);<span class="comment">//信号写端，设置非阻塞，当缓冲区满了时候不阻塞，减少send执行时间</span></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_pipefd[<span class="number">0</span>], <span class="literal">false</span>, <span class="number">0</span>);<span class="comment">//设置管道读端为ET非阻塞</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传递给主循环的信号值，这里为信号注册处理函数，restart是false，在程序中手动重新设置</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);<span class="comment">//忽略连接断开信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//超时信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//终止信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);<span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具类,信号和描述符基础操作</span></span><br><span class="line">    Utils::u_pipefd = m_pipefd;</span><br><span class="line">    Utils::u_epollfd = m_epollfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span><span class="comment">//获取一个连接后，初始化计时器和用户数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    users[connfd].<span class="built_in">init</span>(connfd, client_address, m_root, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化client_data数据</span></span><br><span class="line">    <span class="comment">//创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span></span><br><span class="line">    users_timer[connfd].address = client_address;</span><br><span class="line">    users_timer[connfd].sockfd = connfd;</span><br><span class="line">    util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">    timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">    timer-&gt;cb_func = cb_func;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    users_timer[connfd].timer = timer;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"><span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;adjust timer once&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">    <span class="keyword">if</span> (timer)</span><br><span class="line">    &#123;</span><br><span class="line">        utils.m_timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;close fd %d&quot;</span>, users_timer[sockfd].sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealclinetdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_LISTENTrigmode)<span class="comment">//LT模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<span class="comment">//返回值是连接描述符</span></span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">timer</span>(connfd, client_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//ET模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//必须一次把监听到的连接读取完，因此循环读取、初始化，直至缓冲区为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">timer</span>(connfd, client_address);<span class="comment">//读取一个连接就初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealwithsignal</span><span class="params">(<span class="type">bool</span> &amp;timeout, <span class="type">bool</span> &amp;stop_server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    ret = <span class="built_in">recv</span>(m_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);<span class="comment">//从读管道读取信号，放到signals缓冲区</span></span><br><span class="line">    <span class="comment">//recv的作用，就是通过fdt找到这个缓冲区，并把数据复制到咱们的参数2指向的地址，复制参数3个</span></span><br><span class="line">    <span class="comment">//返回：读出来的字节大小；客户端下线，返回0；执行失败，返回-1</span></span><br><span class="line">    <span class="comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (signals[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            &#123;</span><br><span class="line">                timeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            &#123;</span><br><span class="line">                stop_server = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reactor，非阻塞同步</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若监测到读事件，将该事件放入请求队列（线程池的请求队列中），同步模式让线程处理整个读过程和相响应报文生成过程</span></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">0</span>);<span class="comment">//users[sockfd]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//一直等待这个读事件完成，很多评论说是作者偷懒了，</span></span><br><span class="line">        <span class="comment">//这不是reactor模式，这相当于阻塞了，最多只有一个http请求。完全没有发挥线程池的作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)<span class="comment">//完成标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)<span class="comment">//如果要关闭的话</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);<span class="comment">//关闭连接</span></span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//异步，主线程和内核执行IO，工作线程负责业务处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor，实际上这里是模拟proactor模式，是同步的模式，只有主线程串行IO</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())<span class="comment">//读数据成功的话（无论是LT还是ET），返回true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;deal with the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">            m_pool-&gt;<span class="built_in">append_p</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">    <span class="comment">//reactor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;send data to the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventLoop</span><span class="params">()</span><span class="comment">//主循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;epoll failure&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理新到的客户连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == m_listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealclinetdata</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">                <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理信号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == m_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealwithsignal</span>(timeout, stop_server);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;dealclientdata failure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithread</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithwrite</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">timer_handler</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;timer tick&quot;</span>);</span><br><span class="line"></span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c++">int socket(int af, int type, int protocol);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</span><br><span class="line">  * type 为数据传输方式/套接字类型，常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（数据报套接字/无连接的套接字）。</span><br><span class="line">  * protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</span><br><span class="line">  * 为什么还需要第三个参数呢？一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</span><br><span class="line"></span><br><span class="line">* 若无错误发生，socket()返回引用新套接口的描述字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
</li>
<li><p>成功返回0</p>
</li>
<li><pre><code class="c++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。</p>
</li>
<li><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为客户端协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
</li>
</ul>
<hr>
<ul>
<li><p>struct linger用法：</p>
</li>
<li><p>Linux下tcp连接断开的时候调用close()函数，有优雅断开和强制断开两种方式。那么如何设置断开连接的方式呢？是通过设置socket描述符一个linger结构体属性。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>struct linger {<br>　　int l_onoff;<br>　　int l_linger;<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 三种断开方式：</span><br><span class="line"></span><br><span class="line">  * 1. l_onoff = 0; l_linger忽略：close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</span><br><span class="line">    2. l_onoff != 0; l_linger = 0：close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。</span><br><span class="line">    3. l_onoff != 0; l_linger &gt; 0：close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则close()会直接返回值。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">使用完linger之后，就用setsockopt()设置</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int setsockopt( int socket, int level, int option_name,const void *option_value, size_t ，ption_len);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第一个参数socket是套接字描述符。第二个参数level是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。 option_name指定准备设置的选项，len是选项的长度。option_name可以有哪些取值，这取决于level，以linux 2.6内核为例（在不同的平台上，这种关系可能会有不同），在套接字级别上(SOL_SOCKET)，option_name可以有以下取值：</p>
<ul>
<li><p>SO_LINGER，如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后&gt;才会返回. 否则, 调用将立即返回。该选项的参数（option_value)是一个linger结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linger</span> &#123;</span><br><span class="line">      <span class="type">int</span>  l_onoff;</span><br><span class="line">      <span class="type">int</span>  l_linger; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果linger.l_onoff值为0(关闭），则清 sock-&gt;sk-&gt;sk_flag中的SOCK_LINGER位；</span></span><br><span class="line"><span class="comment">否则，置该位，并赋sk-&gt;sk_lingertime值为 linger.l_linger。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SO_DEBUG，打开或关闭调试信息。当option_value不等于0时，打开调试信息，否则，关闭调试信息。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置 SOCK_DBG(第10)位，或清SOCK_DBG位。</p>
</li>
<li><p>SO_REUSEADDR，打开或关闭地址复用功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是置sock-&gt;sk-&gt;sk_reuse为1或0。</p>
<ul>
<li>SO_REUSEADDR是一个很有用的选项，一般服务器的监听socket都应该打开它。它的大意是允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接，比如：<ul>
<li><p>服务器启动后，有客户端连接并已建立，如果服务器主动关闭，那么和客户端的连接会处于TIME_WAIT状态，此时再次启动服务器，就会bind不成功，报：Address already in use。</p>
</li>
<li><p>服务器父进程监听客户端，当和客户端建立链接后，fork一个子进程专门处理客户端的请求，如果父进程停止，因为子进程还和客户端有连接，所以再次启动父进程，也会报Address already in use。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SO_DONTROUTE，打开或关闭路由查找功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_LOCALROUTE位。</p>
</li>
<li><p>SO_BROADCAST，允许或禁止发送广播数据。当option_value不等于0时，允许，否则，禁止。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_BROADCAST位。</p>
</li>
<li><p>等等…太多了。</p>
</li>
</ul>
<hr>
<ul>
<li><p>sockaddr_in</p>
</li>
<li><pre><code class="c++">struct sockaddr_in &#123;
    __uint8_t sin_len;
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sin_family指代协议族，在socket编程中只能是AF_INET</span><br><span class="line">  * sin_port存储端口号（使用网络字节顺序）</span><br><span class="line">  * sin_addr存储IP地址，使用in_addr这个数据结构</span><br><span class="line">  * sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span><br><span class="line">  * addr.sin_len=sizeof(addr);//socket字节长度</span><br><span class="line"></span><br><span class="line">* sockaddr_in 结构体：struct sockaddr_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_INET地址族，非常地常用</span><br><span class="line"></span><br><span class="line">* sin_zero 初始值应该使用函数 bzero() 来全部置零。一般采用下面语句</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct sockaddr_in cliaddr; </span><br><span class="line">    bzero(&amp;cliaddr,sizeof(cliaddr)); </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>sockaddr_in结构体变量的基本配置</p>
<ul>
<li>&#96;&#96;&#96;c++<br>struct sockaddr_in ina;<br>bzero(&amp;ina,sizeof(ina));<br>ina.sin_family&#x3D;AF_INET;<br>ina.sin_port&#x3D;htons(23);<br>ina.sin_addr.s_addr &#x3D; inet_addr(“132.241.5.10”);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* sockaddr</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  struct sockaddr &#123;</span><br><span class="line">  unsigned short sa_family; /* address family, AF_xxx */</span><br><span class="line">  char sa_data[14]; /* 14字节，包含目标地址和端口信息 */</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了</p>
</li>
<li><p>sockaddr_in和sockaddr二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。二者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p>
</li>
<li><p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p>
</li>
<li><p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>
</li>
</ul>
<hr>
<ul>
<li>INADDR_ANY</li>
<li>转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。<br>比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢?</li>
<li>如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？</li>
<li>所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</li>
</ul>
<hr>
<ul>
<li><p>bind：服务端用于将把用于通信的地址和端口绑定到 socket上。</p>
</li>
<li><pre><code class="C++">int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
</code></pre>
<ul>
<li>参数 sockfd ，需要绑定的socket。</li>
<li>参数 addr ，存放了服务端用于通信的地址和端口。ip地址和端口号是放在 socketaddr_in 结构体里面的。</li>
<li>参数 addrlen ，表示 addr 结构体的大小。</li>
</ul>
</li>
<li><p>返回值：成功则返回0 ，失败返回-1，错误原因存于 errno 中。如果绑定的地址错误，或者端口已被占用，bind 函数一定会报错，否则一般不会返回错误</p>
</li>
</ul>
<h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>先安装依赖</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%951.png" alt="image-20220919164341581"></p>
<p>然后到webbench-1.5的目录下：make clean，再make。</p>
<p>测试：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%952.png" alt="image-20220919164437394"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E5%8A%9B%E6%89%A3/" class="post-title-link" itemprop="url">刷刷力扣</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 20:14:54" itemprop="dateCreated datePublished" datetime="2022-08-23T20:14:54+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-01 19:20:23" itemprop="dateModified" datetime="2022-10-01T19:20:23+08:00">2022-10-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>很简单的一道题，用哈希映射可以做出来，需要额外空间，另一种解法比较难想，是“原地交换”的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地交换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)</span><br><span class="line">                &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]]==nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="built_in">swap</span>(nums[nums[i]],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：24 ms, 在所有 C++ 提交中击败了96.40%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.4 MB, 在所有 C++ 提交中击败了66.33%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> array[n];<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            array[i]=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(array[nums[i]]==<span class="number">-1</span>)</span><br><span class="line">                array[nums[i]]=<span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时: 32 ms</span></span><br><span class="line"><span class="comment">内存消耗: 22.9 MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>蛮简单的，但是有些细节需要注意。从左下角看上去就类似是一个二叉搜索树。按照这个性质，从左下角开始比较，目标元素小就往上找，大就往右找，每次都能消去一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target = 20，返回 false。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意，必须先判断大小即数组合不合法，因为如果n=0.说明是空数组，这样取m就是错误的了，因为根本没有matrix[0]这个元素</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=m<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：20 ms, 在所有 C++ 提交中击败了79.82%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.7 MB, 在所有 C++ 提交中击败了51.61%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上上面的if判断有冗余，可以利用bool表达式的形式来简化代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>())<span class="comment">//一旦i&lt;0说明n&lt;=0，此时已经是false，不会判断后面的j，也就不会取matrix[0]</span></span><br><span class="line">            				<span class="comment">//这样一个n的if在while里判断了，一个m的if省略掉了</span></span><br><span class="line">            				<span class="comment">//不能写成j&lt;=matrix[0].size()-1，不造为啥，力扣编译器的问题？</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.12%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.8 MB, 在所有 C++ 提交中击败了5.28%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>这题主要是对string要有了解。首先需要一个更长的sting，这是我们替换字符（字符数变多）的前提。string可以原地腾出空间，即用resize弄出空位，这给了一个不用额外多一个辅助空间的条件。</p>
<p>所以首先要算出长度，即先遍历一遍sting看空格数，然后resize。</p>
<p>接着重点是，两个指针<strong>从尾向前遍历</strong>、替换。正是因为从后往前才不会影响到原有的元素（对尾部操作是由于尾部都是空的）。并且从后往前，当两个指针位置相等时就可以停止，因为不可能再替换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="comment">//变换大小，变换后是替换后的大小，尾部那些是空位</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len+count*<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从两个尾部开始，一个是原先的尾部，一个是现在的尾部</span></span><br><span class="line">        <span class="type">int</span> i = len<span class="number">-1</span>, j = len+count*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)<span class="comment">//不用换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=s[i];</span><br><span class="line">                i--;</span><br><span class="line">                j--;<span class="comment">//减了刚好进行下一个if判断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//要替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j-=<span class="number">3</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了83.37%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>因为是从尾到头，有种先进后出的意思，那么可以用一个辅助栈来存储。如果不允许额外的空间，则可以先反转链表，再顺序取出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助栈</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.6 MB, 在所有 C++ 提交中击败了35.04%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        ListNode* cur = head;<span class="comment">//当前指针</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;<span class="comment">//前向指针，注意head的next变为NULL，故pre初始化为nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.3 MB, 在所有 C++ 提交中击败了93.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>将栈分为一个主栈一个辅助栈，这样就能将插入和删除更具有目的性，因此插入就很简单，直接push主栈里，而不去考虑位置，这个问题留到删除来解决。</p>
<p>对于删除，主要是要删头部也就是第一个进来的，但在栈中它位于底部。因此要把主栈元素都倒出来，放辅助栈里，这样辅助栈就是一个按顺序的队列。因此：如果辅助栈不是空的，说明它被倒进来了，顶部元素就是第一个元素，删掉它；如果辅助栈是空的，则元素都在主栈里，如果主栈是空的，返回-1；如果主栈不是空的，就需要把元素倒出来给辅助栈，然后删顶部元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        smain.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!shelp.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=shelp.<span class="built_in">top</span>();</span><br><span class="line">            shelp.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smain.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!smain.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            shelp.<span class="built_in">push</span>(smain.<span class="built_in">top</span>());</span><br><span class="line">            smain.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = shelp.<span class="built_in">top</span>();</span><br><span class="line">        shelp.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; smain;<span class="comment">//主栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; shelp;<span class="comment">//辅助栈</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：248 ms, 在所有 C++ 提交中击败了76.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：101 MB, 在所有 C++ 提交中击败了72.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>简单的动态规划，注意要在运算过程中取模，不然会越界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.1%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><p>一次跳1或2，则到第n个台阶为从n-1或从n-2；因此f(n)&#x3D;f(n-1)+f(n-2)，本质也是斐波那契问题，用动态规划。不同的是初值不同，f(0)&#x3D;f(1)&#x3D;1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了93.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>这题的数组在某种程度上是有序的，因此用二分。但二分是用中间值和target比较，这里的target在哪呢？就用两个端点值，而且只能用右端点的值，这样才能缩小区间。为何要用右端点呢，是因为右端点是截断点，根据比较能缩小区间，左端点则不行。原则上将数组分成两个有序数组（左边段和右边段），就可以缩小区间了。</p>
<p>在比较之后，如果中间大于右端点，说明中间在左边段，而最小值一定在右边段，即在low之后，因此可以缩小区间，把low变成mid，而此时mid不可能是最小值，因此可以变成mid+1。并且必须这样，不然假如是5，1，那么low&#x3D;mid，一直死循环。</p>
<p>如果中间小于右端点，则中间点在右边段了，最小值位置在mid及mid以前，缩小区间high&#x3D;mid，因为mid也可能是最小值，因此high不能mid-1。</p>
<p>如果中间和右端点相等，这是因为这里的数组元素可以相等，此时high不能直接&#x3D;mid，因为左边段可以和右边段相等，如3，3，1，3。直接相等就越过了1。也不能让low&#x3D;mid，因为右段也可以和右端点相等。1，3，3的情况下，就越过了1。因此，直接将high-1就可以了，这样可以保证不越过又可以慢慢缩小区间，如果high是最小值，那么mid也是最小值，不会越过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line"></span><br><span class="line">给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </span><br><span class="line"></span><br><span class="line">注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&lt;numbers[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[high]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了86.65%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.7 MB, 在所有 C++ 提交中击败了71.43%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>这道题找路径的，就可以用深度优先搜索（dfs），由于每个元素都可以当开头，因此要对每个元素都用一次dfs。然后考虑一下剪枝，在dfs的过程中每个位置都可以继续向上下左右出发（用逻辑或连接起来），因此第一个要考虑的部分就是越界问题；其次，每次dfs都向后探一个字符串单词的字母，如果正确才能继续，因此第二个要考虑的就是当这个位置的字母不正确就返回false。这样就可以保证找到所有的可能。</p>
<p>还要考虑标记的问题，因为矩阵的元素不能重复使用，当这个元素正确要向后dfs时，必须先把这个元素标记不可用，在c++中用’\0’就可以。在dfs之后，还要标记回来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//初始化行列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,word,i,j,<span class="number">0</span>))<span class="comment">//对每个位置都dfs，0表示单词开始，如果找到则直接返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//声明行列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=n||j&gt;=m||board[i][j]!=word[k]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//越界或不对应则剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(k==word.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没越界且对应，长度也对应，成功</span></span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//向上下左右出发，k+1</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>)||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, i<span class="number">-1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j<span class="number">-1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];<span class="comment">//标记回来</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：520 ms, 在所有 C++ 提交中击败了18.67%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了98.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="I-剪绳子"><a href="#I-剪绳子" class="headerlink" title="I-剪绳子"></a>I-剪绳子</h2><p>这种题首先是求最大值，然后因为乘积是可分解的，因此这个问题可以缩小规模，就可以考虑用动态规划，实际上有更简单的数学解法。对于动态规划，n是从2开始的，然后当长度是n的时候，可以将乘积分两段，要么直接乘，要么对前一段再分（也就是小规模的再动态规划），后一段的长度通过遍历解决，就不用动态规划了。因此长度n时有两种选择，两段乘或再分，然后还要继续遍历，因此要保存好前面求的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]\*k[1]\*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)<span class="comment">//i从3开始，到n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)<span class="comment">//j从1开始，长度到i-1（最简单的遍历方式），</span></span><br><span class="line">                <span class="comment">//这里j从2开始也可以，长度到i-2也可以，因为长度为1的划分没有意义</span></span><br><span class="line">                <span class="comment">//但不能同时，要确保能进入循环，才有dp的定义</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],<span class="built_in">max</span>((i-j)*j,dp[i-j]*j));<span class="comment">//首先要和之前遍历出来的dp[i]比较。然后看</span></span><br><span class="line">        									<span class="comment">//是直接乘更大还是继续划分，j不用dp，因为是遍历的</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><h2 id="II-剪绳子"><a href="#II-剪绳子" class="headerlink" title="II-剪绳子"></a>II-剪绳子</h2><p>这题就不方便用动态规划了，因为会溢出。这个问题出自我们是对结果取余，用动态规划max比较时，取余会造成max比较不正确，比如一个大的取余反而小了。因此不能在比较时候取余，那么在计算过程中就会溢出，即使用long long int也存在这个问题。</p>
<p>那么就可以用到数学的解法，因为数学的解法不需要比较，只需要一直运算就可以：</p>
<ul>
<li><p>根据几何不等式，等分时乘积最大；</p>
</li>
<li><p>等分为长x的a段有：x&#x3D;an，则乘积为$x^a$，由于 n 为常数，因此当 $x^{\frac{1}{x}}$ 取最大值时， 乘积达到最大值。因为$x^a&#x3D;x^{\frac{n}{x}}$</p>
</li>
<li><p>因此对$x^{\frac{1}{x}}$求极大值，取对数有lny &#x3D; lnx&#x2F;x，求导得x&#x3D;e。那么x可取2或3，代入一下2和3，同时取6次方发现3^2&#x3D;9大一些，因此最好分成长为3的。</p>
</li>
</ul>
<p>结论：</p>
<p>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。<br>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 $2 \times 2 &gt; 3 \times 1$。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]\*k[1]\*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;<span class="comment">//必须切分一次</span></span><br><span class="line">        <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="number">4</span>;<span class="comment">//最后的4变成2*2</span></span><br><span class="line">            n = n - <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            ret = <span class="number">2</span>;<span class="comment">//最后的2留着</span></span><br><span class="line">            n = n - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            ret = ret * <span class="number">3</span> % <span class="number">1000000007</span>;<span class="comment">//这里可以取模的原因是，跟max不同，ret是已经确定好的答案，只是一直没算完，</span></span><br><span class="line">            						<span class="comment">//先模后模的结果是一样的           </span></span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.22%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>第一种方法是逐位看是不是1，直接把1左移然后和n与运算那就好。也可以模2来做。</p>
<p>第二种方法是用n&amp;(n-1)，因为n-1会把第一个1右边的0变成1，且这个1变成0，那么再与n做与运算时，实际上就是把n的第一个1消去了（原来的0和1&amp;也是0，但原来的1由于变成了0，&amp;后也是0），因此每做一次这个操作，就有一个1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &#x27;1&#x27; 的个数（也被称为 [汉明重量]。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逐位比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1</span>&lt;&lt;i))<span class="comment">//不断将1左移i位，也就是和n的第i位对齐，然后取与运算</span></span><br><span class="line">                res++;<span class="comment">//如果结果非0，则是一个1</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了33.03%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n&amp;(n-1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n &amp;= n<span class="number">-1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.8 MB, 在所有 C++ 提交中击败了82.14%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h1><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>简单的快速幂+迭代，假如数值是x，次方的n，那么就是要分n是奇数还是偶数，这是因为如果是奇数要多一项，偶数则直接x平方。把n看成二进制的话，举个例子，如果n&#x3D;1000，则是$x^8$，把x的二次方再二次方再二次方，整个过程三次即可（因为有三个零），但如果是1001，则要先乘一个x，再乘$x^8$。</p>
<p>也就是说，如果n是奇数，则底数累乘一个“x”。为了循环计算，我们要把n每次除以2（其实就是一位一位看是不是1），然后再看是不是奇数。对应此，所谓的“x”就也是累成的，可以定义一个k存储中间结果。</p>
<p>再注意一下细节，如果n是负数，那么要把x取倒数，然后把n正过来。但是负数的n正过来可能会使int溢出，所以要用longlong来做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>)<span class="comment">//预处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            N=-N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> k = x;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                res *= k;<span class="comment">//如果最后一位是1，说明对应的k要乘</span></span><br><span class="line">            k = k*k;<span class="comment">//不管如何，因为N要右移了，k要平方一次</span></span><br><span class="line">            N/=<span class="number">2</span>;<span class="comment">//右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了82.47%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h1><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><p>这题之所以是简单题，是因为题目设计时不需要考虑大数问题，这类题目最好直接以大数的形式来写，这就需要string来辅助。</p>
<p>由于最后要返回vector，因此定义一个vector成员变量，这里面存int；同时使用两个辅助函数，一个用来递增数，一个用来将string转换为int存到vector里。</p>
<p>public内是主函数，由于定义string需要数的大小n，这是主函数的参数，因此string也要在主函数定义，所以辅助函数也需要传入string这个参数（用引用，递增函数要修改number），具体见代码。然后循环递增，每个数都转int放vector，最后返回就可以了。循环的结束判断利用递增函数的返回值来做，如果溢出则结束（溢出表明数已经大于给定的位数了）</p>
<p>对于转int函数，重点是把string前面多余的’0’去掉，从头开始遍历这些0，当不是0时就退出，然后用另一个string用+&#x3D;把剩下的都连接起来，最后用stoi函数转int。</p>
<p>对于递增函数，重点是进位。首先定义一个表示进位的变量，然后就能得出每个位置上应该变成的值了：<code>num = number[i]-&#39;0&#39;+takeOver;//当前位等于原来的加上进位的</code>，当然最低位因为递增要加一。takeOver初始化为0，因为最低位没有进位。然后要循环判断进位，因为有可能是…99999的情况。所以我们的循环从最低位开始，最低位的num得出后要num++，然后如果num&#x3D;&#x3D;10说明要进位，takerOver&#x3D;1，这一位变成0；同时如果是最高位了，就溢出了，返回false。如果没有进位，就到此为止了，设置这一位的string的值就可以了，最后返回true表示可以继续递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个能容纳最大值的字符数组，由于需要n，因此在函数里创建而不成为类成员，这导致辅助函数需要传入number这个参数</span></span><br><span class="line">        <span class="function">string <span class="title">number</span><span class="params">(n,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="comment">//初始全部设置为0，因为输出从1开始，后面就先增加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">increment</span>(number))<span class="comment">//在increment的过程中判断是否结束，因为increment既有到哪一位的信息、也有是否进位的信息</span></span><br><span class="line">            <span class="built_in">saveNum</span>(number);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//将string转int，放数组里</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increment</span><span class="params">(string &amp;number)</span><span class="comment">//运行一次就+1</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> takeOver = <span class="number">0</span>;<span class="comment">//最大的要点就是考虑进位，一开始的进位是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)<span class="comment">//i从最后开始，代表数从最低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = number[i]-<span class="string">&#x27;0&#x27;</span>+takeOver;<span class="comment">//当前位等于原来的加上进位的</span></span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">                num++;<span class="comment">//如果是最低位，则要+1，代表增加一个1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">10</span>)<span class="comment">//若要进位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最高位，且加上进位是10，溢出了，结束</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    number[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    takeOver = <span class="number">1</span>;<span class="comment">//不用再设回0，因为一旦不用进位就结束了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//不用进位就到此为止</span></span><br><span class="line">            &#123;</span><br><span class="line">                number[i] = num+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveNum</span><span class="params">(string &amp;number)</span><span class="comment">//这个函数主要是把number前面多余的0去掉</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> notzero = len;<span class="comment">//如果都为0则notzero不会被重新赋值，这会使后面那个循环直接跳过，使得s不变就是&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//找到第一个不为0的地方</span></span><br><span class="line">            &#123;</span><br><span class="line">                notzero = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=notzero;i&lt;len;i++)</span><br><span class="line">            s += number[i];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> resnum = <span class="built_in">stoi</span>(s);</span><br><span class="line">        res.<span class="built_in">push_back</span>(resnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了14.22%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.6 MB, 在所有 C++ 提交中击败了12.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h1><h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><p>简单的双指针应用，一个前一个后，cur指针来判定，pre指针要进行节点越过操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;<span class="comment">//现在head不是目标节点，从next开始</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val==val)<span class="comment">//如果找到</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;<span class="comment">//越过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则两个指针向后</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.51%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.9 MB, 在所有 C++ 提交中击败了84.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>简单的快排思想的应用，其实就是头尾双指针。这份代码我进行了一些小的细节上的优化，效果不错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> i&lt;j)<span class="comment">//这个过程要加i&lt;j的判断，一方面防止全是奇数时nums[i]的i越界了，一方面减少循环次数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> i&lt;j)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)<span class="comment">//减少不必要的交换和动作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="comment">//手动推进，可以减少大while或小while的一次判断</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了99.32%的用户</span></span><br><span class="line"><span class="comment">内存消耗：17.5 MB, 在所有 C++ 提交中击败了87.78%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h1><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p>用快慢双指针就很简单了，快指针先走k步（指向第k+1个节点），然后两个指针再一起走直至快指针为null，此时快指针又走了n-k步，慢指针也走了n-k步，倒数过来就是倒数第k个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</span><br><span class="line"></span><br><span class="line">例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *quick = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(quick)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了68.49%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.2 MB, 在所有 C++ 提交中击败了73.69%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>简单的双指针pre和cur，前面的从尾到头打印链表写过了。感觉也可以用辅助栈，不过不推荐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.85%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.9 MB, 在所有 C++ 提交中击败了93.81%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>简单题，大概是一个merge。使用一个非nullptr的伪头节点能减少代码重复（new一个），当然不用也行，这样还是得要一个head和一个cur，不过先比较l1和l2的头节点大小得出head和cur的指向，然后再进while循环。原因是while内要cur-&gt;next，如果cur没有指向节点而是null则它都没有next，只能在while里面再if判断是不是第一次进入，这样每次又多了一个if。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于一开始不知道是l1头小还是l2小，因此可以定义一个伪头节点(不是nullptr，所以用new构建一个)，这样可以</span></span><br><span class="line">        <span class="comment">//使头节点的比较也放在while里，和其他节点一样。这样减少了代码重复</span></span><br><span class="line">        ListNode *cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = cur;<span class="comment">//head用来保存，cur用来移动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;<span class="comment">//伪头节点后就是</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了92.19%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.6 MB, 在所有 C++ 提交中击败了78.85%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用伪头节点，先比较获得头节点，代码比较臃肿，但是性能不差</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置处理</span></span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *head;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.83%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了92.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>细节在要注意给的矩阵是不是空的，如果是空要直接返回了，否则会有些越界问题。然后我们先获得上下左右四个边界，然后进入一个大的while循环一遍不断地“绕圈”。然后在while内根据边界右、下、左、上遍历元素，同时更新边界，并判断是否越界，越界就可以退出了。总体下来就是根据“边界”，在while(true)里for循环，知道这个就比较简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>()<span class="number">-1</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(bottom==<span class="number">-1</span>)<span class="comment">//没有元素</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：9.6 MB, 在所有 C++ 提交中击败了73.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>使用双栈来简化操作，一个主栈就进行push、pop和top（不进行其他操作），另一个辅助栈维护min，这样设计就能明确要做什么。</p>
<p>为了维护min，辅助栈的每次push就需要比较，除了空的时候直接放入，后面的push都只放入不大于栈顶的值。因为大于栈顶的值必然不可能再成为最小值了，它会在最小值被pop之前pop（因为先后顺序的原因），同时相等的元素要放入，因为pop了一个最小值，剩下的也可以是最小值。对于pop，只有当主栈pop出去的是最小值时，辅助栈才pop，因此要判断相不相等。</p>
<p>这样，返回min就只用返回辅助栈的top。实际上，核心是将辅助栈设计成一个升序栈（从顶到底），原理是因为后来的更大的值不可能成为最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; xstack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; hstack;<span class="comment">//help stack，辅助栈维护升序栈</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        xstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(hstack.<span class="built_in">empty</span>())</span><br><span class="line">            hstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;=hstack.<span class="built_in">top</span>())</span><br><span class="line">                hstack.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="comment">//辅助栈维护最小值，因此只有更小的才放进去。大的不放是因为辅助栈的顶部一定是最小值，假如说这个最小值被pop出去不存在了</span></span><br><span class="line">    <span class="comment">//那么这个更大的值肯定也更早被pop出去（因为最小值更先存在，大的在更顶上），所以这个最大值不会成为最小值，没必要放进去。</span></span><br><span class="line">        <span class="comment">//使用等于判断是因为可能有多个最小值，pop出一个还有其他的也算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = xstack.<span class="built_in">top</span>();<span class="comment">//要看辅助栈的最小值要不要pop出去</span></span><br><span class="line">        xstack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==hstack.<span class="built_in">top</span>())</span><br><span class="line">            hstack.<span class="built_in">pop</span>();<span class="comment">//如果主栈pop出去的是一个最小值，那么这个最小值也要pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.07%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.6 MB, 在所有 C++ 提交中击败了86.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>这题主要用模拟，根据生活中“手动判断”的过程来模拟。这是怎么样的过程呢：我们一般会跟踪元素一个个push的过程，然后对比poped序列，一旦一个元素可以pop，那就pop并且把前面能pop的也pop。这是因为数字都是不同的，如果错过了pop时机，再有元素进来就不再能pop了，也就错了。</p>
<p>而这里给的两个序列都是vector，我们模拟要不断pop，这不太方便，所以用到一个辅助栈（这也就是我们手动模拟用到的容器）。这样模拟就是：把pushed一个一个放进辅助栈（pushed如同数组，所以用for循环放直观一些），每放进一个就查看poped序列（记录好上次查看的位置），如果相等就pop，然后poped序列向后继续比较看能不能pop（这就用while循环，因为while直接能进行比较判断，并且也不知道for的次数）。</p>
<p>辅助栈不断加入元素，并且在合适时pop，如果最后辅助栈是空的，那么就是正确的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.<span class="built_in">size</span>()!=popped.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//先考虑大小，不同直接false</span></span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果大小为0就true</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//然后开始模拟，pushed和popped是不同排列，所以数字相同</span></span><br><span class="line">        <span class="comment">//如果直接对pushed栈模拟，不好操作，因为pushed是个vector，不对顶操作</span></span><br><span class="line">        <span class="comment">//所以用一个辅助栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> pop_j = <span class="number">0</span>;<span class="comment">//指向popped的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//注意pushed和popped是vector而不是stack，要以数组形式使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pushed[i]);<span class="comment">//不断按顺序放入元素</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() <span class="keyword">and</span> st.<span class="built_in">top</span>()==popped[pop_j])<span class="comment">//然后尝试倒出，如果能倒则一直倒出，</span></span><br><span class="line">                                         <span class="comment">//因为数字不同正确性是唯一的，能倒时不倒，下一个进来时就不可能再倒出了</span></span><br><span class="line">                <span class="comment">//!st.empty()不能漏，因为top()在没有元素时出错、popped[pop_j]可能会越界，也不能直接判断pop_j，</span></span><br><span class="line">                <span class="comment">//因为存在st空了但pop_j还没越界的情况，使用st一举两得</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                pop_j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了70.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.8 MB, 在所有 C++ 提交中击败了73.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>这题有难度，主要在于没见过不太好想。先从正常的复制开始，如果只是复制next，那么我们遍历一遍原来的链表就可以得到next的信息了。为什么不能得到random呢，原因是random指向的那个节点不知道在哪里，不可能再用一层遍历去找。你可能会想着先遍历复制next的信息，再遍历一遍得到random，这里的关键问题是，我们在第二遍遍历的时候，确实是可以知道原来链表的节点random指向的位置，假设为A，但新的链表的节点random指针要指向的节点在哪呢？假设这个节点叫B，我们的问题是不能从A来找到B，B还是未知的。</p>
<p>因此，重点就是解决这个问题。简单的方法是，就把每个新的节点先放在原来节点的后面，这样就可以用next来找到复制的节点。因此上面的B就是A-&gt;next。于是就建立好了关系：<code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</code>。然而random可以指向null，没有next，所以要判空。</p>
<p>最后执行两个链表的拆分即可。整个过程就是：原地拷贝延申、修改random、拆分。注意拷贝要用new。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置判空</span></span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原地拷贝延申</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newcur-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur;</span><br><span class="line">            cur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改random指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random)<span class="comment">//如果这个random不是null才有意义</span></span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<span class="comment">//cur-&gt;next表示那个新复制的节点，然后-&gt;random表示修改指向，</span></span><br><span class="line">                                                    <span class="comment">//指向的是cur-&gt;random这个节点的next，也就是对应的新复制的节点</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *newhead = head-&gt;next;<span class="comment">//记录下来，因为要用到next，所以head不能为null，因此前面要判断是否为null</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur-&gt;next;<span class="comment">//cur非null，那么newcur非null，但newcur-&gt;next可能是null，也即这是最后一对节点</span></span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next)<span class="comment">//如果不是null</span></span><br><span class="line">                newcur-&gt;next  =cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则直接是null，因为没有null-&gt;next</span></span><br><span class="line">                newcur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了73.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.9 MB, 在所有 C++ 提交中击败了90.72%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>挺难的一道题，我用的是“下一个排列”的方法。</p>
<p>下一个排列的方法很难理解，一共有四步：1.从后往前找到第一个（严格）升序的元素对，这个元素对的前一个是“较小数”，后面那一段都是降序（非严格，跳过相同的字符，这里面i和j的比较都加”&#x3D;”）的；2.从后往前找到第一个比“较小数”大的数，这个数是“较大数”；3.“较小数”和“较大数”交换；4.交换后，降序的那段依然降序，要反过来变成升序（用reverse函数或前后双指针swap）。在第一步中，我们用i和i+1判断元素对，如果字符串已经是最后一个排列了，或字符串是全相等的（或部分相等，不需要再排列了）时，i会变成-1（找不到），则此时要返回false了。</p>
<p>有了下一个排列，就可以慢慢获得所有排列了，首先就是要把原字符串sort变成最小的排列，然后do-while（因为第一个排列总是要放进去的），注意do-while的while有”;”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串，打印出该字符串中字符的所有排列。</span><br><span class="line"></span><br><span class="line">你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//因为是取下一个排列遍历，所以先排序得到最小排列</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">nextpermutation</span>(s));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">nextpermutation</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="comment">//加等号是因为字符串可能有相同字符，这里要加等号越过它们，表示重复的只有一种情况；</span></span><br><span class="line">        <span class="comment">//否则i会停在重复的字符，j会更向前，导致前面的情况又换回来，进入死循环</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;s[i]&gt;=s[i+<span class="number">1</span>])<span class="comment">//从右向左找到第一个非降序的，即突然凹下去的那里</span></span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果都是降序的，说明已经是最后一个排列了</span></span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]&gt;=s[j])</span><br><span class="line">            j--;<span class="comment">//从右向左找到第一个比a[i]大的</span></span><br><span class="line">        <span class="comment">//if(j&lt;0)</span></span><br><span class="line">            <span class="comment">//return false;//如果字符串都是相等的就可能一直往前走越界，但这种情况已经被i判断了，不用在j这考虑</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        <span class="comment">//现在后面i+1开始那一段是降序的，反转一下变成升序会更小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=i+<span class="number">1</span>,m=s.<span class="built_in">size</span>()<span class="number">-1</span>;n&lt;m;n++,m--)</span><br><span class="line">            <span class="built_in">swap</span>(s[n],s[m]);</span><br><span class="line">        <span class="comment">//可以调库reverse(s.begin() + i + 1, s.end());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.9 MB, 在所有 C++ 提交中击败了99.15%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>摩尔投票法，记住两个变量：候选者、投票数。如果没有计数就重置候选者，然后通过比较候选者和当前值看票数要加一还是减一。知道这个方法就很简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的组总是存在多数元素。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常逻辑版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">            &#123;</span><br><span class="line">                cand = num;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==cand)<span class="comment">//如果有计数说明有候选者，相等则计数++</span></span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//即有计数，也不相等</span></span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了65.56%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了66.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">                cand = num;</span><br><span class="line">            count+= num==cand?<span class="number">1</span>:<span class="number">-1</span>;<span class="comment">//无论如果都判断一次，这里把count是不是0的情况都包含了</span></span><br><span class="line">            				<span class="comment">//因为count是0也是count++</span></span><br><span class="line">           	<span class="comment">//这种方式也就是把上面的else if的else去掉了，变成两个独立的if而不是一个大if，会快一些。</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了97.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了85.24%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p>方法是快速排序，使用快排的思想，注释写了很多了，能达到O(n)的时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size == k)<span class="comment">//刚好就不用排了</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="built_in">quickSelect</span>(arr,k,<span class="number">0</span>,size<span class="number">-1</span>);<span class="comment">//快速选择：把最小的k个放在最前面</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr[i]);<span class="comment">//前k个都是小的了，拷贝一下</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l,j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)<span class="comment">//先快排</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[j]&gt;=arr[l])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[i]&lt;=arr[l])<span class="comment">//加等号使得相同元素相对位置不改变，稳定排序</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[l]);</span><br><span class="line">        <span class="comment">//快排要把arr[l]放在两段的中间，就需要保证arr[i]是一个不比arr[l]大的数；</span></span><br><span class="line">        <span class="comment">//因此那两个while必须先从j开始，因为当j停下时，要么是碰到了i（上一轮的i已经是小的了），这时全部结束，i是较小的</span></span><br><span class="line">        <span class="comment">//要么是等待置换，此时轮到i走，要结束只能碰到j，j在等待，是较小的</span></span><br><span class="line">        <span class="comment">//如果while先对i做，可以想到i可能停在上一轮的j处，此时j是大的</span></span><br><span class="line">        <span class="comment">//因此如果用左边界，则要从右开始，置换i；用右边界则从左开始，置换j</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时快排做完，i和i前的元素都是小的，前i+1个元素都是小的，且前i个元素小于第i+1个元素（i代表第i+1个元素）</span></span><br><span class="line">        <span class="comment">//与快排不相同的是，这里分情况再排，而不是两段直接排</span></span><br><span class="line">        <span class="keyword">if</span>(i==k||i==k<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//i=k或者i+1=k</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;k)  <span class="built_in">quickSelect</span>(arr,k,l,i<span class="number">-1</span>);<span class="comment">//i左边元素有些多，对左边再排，i本身不用排了，不可能是</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">quickSelect</span>(arr,k,i+<span class="number">1</span>,r);<span class="comment">//i&lt;k-1，这里只用排k-i-1个元素了，但为什么参数仍然是k呢？</span></span><br><span class="line">        							<span class="comment">//因为我们是从左边界i+1开始的</span></span><br><span class="line">                                      <span class="comment">//排序只对l-r之间的元素，但位置i仍是整体的，并不是从左边界开始从0算起，因此参数仍是k</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了52.99%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>动态规划，递推方程是：<code>dp[i] = max(dp[i-1],0)+nums[i];</code>。dp[i]的意思是前i个数的子数组的最大和，则dp[i]是前面的最大值加上nums[i]，其中如果前面的最大值是一个负数就从头开始，就是0+nums[i]。加上nums[i]才使得这样的递推的子数组是连续的，因为dp[i-1]也加上了nums[i-1]，如果大于0，那么使用它的话就是连续的子数组了。</p>
<p>这里面动态规划注意一个要点，如果递推式不利用历史信息的话，只利用前面一项或几项，那就可以用一个或几个变量代替dp数组，能把空间复杂度从O(n)变成O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line"></span><br><span class="line">要求时间复杂度为O(n)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划普通版本，使用dp数组递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],<span class="number">0</span>)+nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了81.76%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.8 MB, 在所有 C++ 提交中击败了27.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里面呢，实际上dp数组在遍历时只用到前面一项，更之前的信息完全不用，实际上就可以简化为两个变量cur和pre，一个代表dp[i]，一个代表dp[i-1]。更进一步，cur和pre只是前一轮和这一轮的关系，用一个变量完全足够了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            等价于：</span></span><br><span class="line"><span class="comment">            cur = max(pre,0)+nums[i];</span></span><br><span class="line"><span class="comment">            pre = cur;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pre = <span class="built_in">max</span>(pre,<span class="number">0</span>)+nums[i];<span class="comment">//其实就是pre = cur = max(pre,0)+nums[i]; cur完全不需要。</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了95.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.3 MB, 在所有 C++ 提交中击败了88.01%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p>这题是困难的，比较难想，不会就快排再算。这里考虑的是数据流，比较偏应用，就是要用一个合适的数据结构来做（也说了要选数据结构）。这里插入对于数据结构都好说，主要是中位数怎么找。根据中位数的性质可以把数据均分成较大的一组和较小的一组，然后只要找到两个数据组中“突出”的那一个就好了，也就是中位数或两个用于计算中位数的数。我们只要一个或两个数，这些数是较大组的最小值或较小组的最大值（这样才居中）。</p>
<p>因此就可以用堆，因为堆就是用来存最大值和最小值的，在c++中可以用优先级队列priority_queue来做。堆有两个，一个小顶堆存较大数据的最小值、一个大顶堆存较小数据的最大值。这里的重点是维护数据均分，如果是偶数则两个堆数据个数相同，如果是奇数则其中任意一个多一个数据，这里选大顶堆多一个元素。</p>
<p>因此就分两种情况插入数据，如果插入前两个堆大小相等，则要向大顶堆插入。但不知道这个数据多大，因此不能直接插入，而需要先插入小顶堆，再从小顶堆拿出（pop）顶部元素插入大顶堆。这个过程就是把新元素和较大元素比较，拿出最小的放入大顶堆，保证了大顶堆中的元素全都小于小顶堆。如果插入前大顶堆个数多（根据设计不可能小顶堆更多），则要向小顶堆插入，同样的要先插入大顶堆，然后拿出顶部元素插入小顶堆。</p>
<p>最后是取中位数，如果堆大小相等，则取两个堆顶部元素（即数据流大小最中间的两个元素）取平均；否则大顶堆多一个元素，根据大小关系直接返回大顶堆的顶部元素。注意这里取平均在除以2之前要*1.0转double。</p>
<p>这样插入时间复杂度是O(logn)，取中位数是O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line"></span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line"></span><br><span class="line">[2,3] 的中位数是 (2 + 3) / 2 = 2.5</span><br><span class="line"></span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大顶堆，存储较小的一半的数据，堆顶为最大值</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;<span class="comment">//less表示降序排序</span></span><br><span class="line">    <span class="comment">// 小顶堆， 存储较大的一半的数据，堆顶为最小值</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;<span class="comment">//greater表示升序排序</span></span><br><span class="line">    <span class="comment">//第一个参数是类型、第二个参数是底部容器（使用heap的算法）、第三个参数是比较方式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当两堆的数据个数相等时候，向大顶堆添加元素（也可以向小顶堆添加，指定一个堆放多的元素）。</span></span><br><span class="line"><span class="comment">         * 采用的方法不是直接将数据插入大顶堆，而是将数据先插入小顶堆（因为这个元素大小不好说），算法调整后</span></span><br><span class="line"><span class="comment">         * 将堆顶的数据（较大数中最小的）插入到大顶堆，这样保证大顶堆插入的元素始终比小顶堆的元素小。</span></span><br><span class="line"><span class="comment">         * 同理如果大顶堆数据多，往小顶堆添加数据的时候，先将数据放入大顶堆，选出最大值（top）放到小顶堆中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//这种添加方式是让奇数个数时多的那一个放到大顶堆中，实际上也可以放小顶堆中，方式是镜像的</span></span><br><span class="line">        <span class="comment">//但使用一种方式后，其他的操作要适应它。因为这些数据个数决定了中位数的取法。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(num);<span class="comment">//先放小顶堆</span></span><br><span class="line">            <span class="type">int</span> top = minHeap.<span class="built_in">top</span>();<span class="comment">//把较大的值中最小的那个拿出来</span></span><br><span class="line">            minHeap.<span class="built_in">pop</span>();<span class="comment">//pop</span></span><br><span class="line">            maxHeap.<span class="built_in">push</span>(top);<span class="comment">//给大顶堆</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="type">int</span> top = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            minHeap.<span class="built_in">push</span>(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> (maxHeap.<span class="built_in">top</span>()+minHeap.<span class="built_in">top</span>())*<span class="number">1.0</span>/<span class="number">2</span>;<span class="comment">//转double</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>()*<span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：92 ms, 在所有 C++ 提交中击败了75.35%的用户</span></span><br><span class="line"><span class="comment">内存消耗：40.6 MB, 在所有 C++ 提交中击败了84.11%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h1><h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><p>本质是找规律的题目，个位数有9个（下标从0开始，序列算了0，相当于抵消）、个位数有90个、百位数有900个…根据这些规律就能得出n在那一个位数的阶段中，比如n&#x3D;11就在10~99这个两位数的段里。然后就能得出从这个段起始开始还要走多少个数字x（因为前面的总数字数肯定是知道的，这样才能得到在哪个段嘛），根据这个x和位数的关系又能得出是第几个数的第几位，然后转string取出来就好了。</p>
<p>注意这里当n比这一位数和前面位数的数字要多时，要算后面的位数的总个数，但是这样可能会越界，因为乘以了9，数没有那么多。那么就要有溢出判断，不应该乘以9时就不做了。</p>
<p>这种题还是用些实例来想过程，比如取11、12等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</span><br><span class="line"></span><br><span class="line">请写一个函数，求任意第n位对应的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> intmax = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//溢出判断，false是溢出</span></span><br><span class="line">        <span class="type">int</span> digit = <span class="number">1</span>;<span class="comment">//位数</span></span><br><span class="line">        <span class="type">int</span> total = <span class="number">9</span>;<span class="comment">//总数</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;<span class="comment">//起始点，因为每个起始都是10、100、1000这样的，每次乘10就可以</span></span><br><span class="line">        <span class="comment">//因为下标也从0开始计数，所以n=9时对应的是9，因此total为9表示个位数</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;total)<span class="comment">//首先确定n代表的数在哪个位数中</span></span><br><span class="line">        &#123;</span><br><span class="line">            digit++;<span class="comment">//表示进入下一位数的范围</span></span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit*start&gt;=intmax/<span class="number">9</span>)<span class="comment">//做乘法会溢出，不做了</span></span><br><span class="line">            &#123;   </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += digit*start*<span class="number">9</span>;<span class="comment">//下一位数有9*start个数，每个数有digit位，这就能算出下一位数的数字个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> x;<span class="comment">//x是从start开始的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="comment">//如果没溢出</span></span><br><span class="line">            x = n-total+digit*start*<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果要溢出，说明最后的total是没做的</span></span><br><span class="line">            x = n-total;<span class="comment">//前面有total个单个的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num = start + (x<span class="number">-1</span>)/digit;<span class="comment">//第num个数，x-1是因为start本身就是第一位，比如10的话应该是10+0/digit，但此时x是1</span></span><br><span class="line">        <span class="type">int</span> k = (x<span class="number">-1</span>)%digit;<span class="comment">//k是指第num个数的第k位，x要减一同理</span></span><br><span class="line"></span><br><span class="line">        string nums = <span class="built_in">to_string</span>(num);<span class="comment">//to_string函数把int转string</span></span><br><span class="line">        <span class="keyword">return</span> nums[k]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//这里nums[k]是char要转一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了89.87%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p>这题也比较难想，一般直接去想会想成遍历或规划问题。实际上这题被做成了一道排序问题，假如有数字x，y，如果x+y&gt;y+x，那么x应该放在y前面（后面充要证明）。当x和y相邻时这很好理解，但当xy不相邻时，为什么x一定要在y前面呢？必要性：我们假设有一个最小的排列axyzb，我们很容易得到a&lt;x，x&lt;y，y&lt;z，z&lt;b，否则我们可以交换相邻的元素得到更小的排列，即假如z&gt;b我们可以交换z和b。充分性：如果a&lt;x，x&lt;y，y&lt;z，z&lt;b，那么按axyzb的排列一定最小，因为交换 a,b（表示任意交换两个元素）相当于依次交换 ax,ay,az，接着交换 zb,yb,xb 。每一次相邻交换都使得交换后的值更大。</p>
<p>因此，如果x+y&gt;y+x，那么x应该放在y前面。那么我们对这个数组进行排序就可以了，能够排序的原因是每两个元素都能得到明确的大小关系和可传递性（一旦x&gt;y，y&gt;z，那么x&gt;z，即如果x在y前面，y在z前面，根据前面的充要证明，x一定在z前面），这和正常的比大小一样。因此能使用快排来做，每次都和左边界标值比较，看x应该放在标值前还是后。</p>
<p>将数组转string的vector，然后排序，再拼接就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先转string</span></span><br><span class="line">        vector&lt;string&gt; str;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(str,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(string strs : str)</span><br><span class="line">            s += strs;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; str,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//排序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i=l, j = r;<span class="comment">//左边界右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j <span class="keyword">and</span> str[l]+str[j]&lt;=str[j]+str[l]) j--;</span><br><span class="line">            <span class="comment">//j--的情况是前+后的值小于后+前，前是标值l，后是值j，此时说明不用换</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j <span class="keyword">and</span> str[l]+str[i]&gt;=str[i]+str[l]) i++;</span><br><span class="line">            <span class="built_in">swap</span>(str[i],str[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(str[i],str[l]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(str,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(str,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了91.34%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11 MB, 在所有 C++ 提交中击败了53.92%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h1><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><p>通过读题目可以发现，要么对一位数字直接翻译，要么对两位数字进行翻译，即1或2，这和动态规划的青蛙跳台阶很像。对于第i位结尾的数字，如果能知道第i-1位结尾时翻译总数和第i-2位结尾时的翻译总数，那么就有f(i)&#x3D;f(i-1)+f(i-2)。这个递推式是解释是，第i位要么单独翻译要么和i-1位一起翻译，能这么做的原因是这两种翻译出来的字符串肯定不一样。</p>
<p>然而还需要考虑的是，i和i-1位组成的数字不一定能够翻译（10–25之间），因此在不能翻译时，递推式退化成f(i)&#x3D;f(i-1)，这只是一个if的事情。</p>
<p>根据这个递推式，就可以使用动态规划，由于最多往前两项，那么用三个变量即可，不用用数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。</span><br><span class="line">一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//翻译范围是0-9，10-25</span></span><br><span class="line">        <span class="comment">//f(i) = f(i-1)+f(i-2)，其中i和i-1要能满足翻译范围，否则f(i) = f(i-1)</span></span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;<span class="comment">//f(i-1)</span></span><br><span class="line">        <span class="type">int</span> prepre = <span class="number">0</span>;<span class="comment">//f(i-2)</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            string s = str.<span class="built_in">substr</span>(i<span class="number">-1</span>,<span class="number">2</span>);<span class="comment">//拿出i和i-1</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * string substr (size_t pos = 0, size_t len = npos) const;</span></span><br><span class="line"><span class="comment">            * 在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(s&lt;=<span class="string">&quot;25&quot;</span>&amp;&amp;s&gt;=<span class="string">&quot;10&quot;</span>)</span><br><span class="line">                cur = pre + prepre;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = pre;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了82.92%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><p>一眼动态规划。<code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])+gird[i][j]</code>，从左边或上边到来，选一个大的路径加上本身（价值大于0）。这里巧妙的地方是，不需要一个额外的dp[n][m]数组，可以直接修改grid，因为遍历到grid某处时的值只需要使用自身和前面的累加值，那么在使用了自身后就可以把自己修改成累加值，以后不用自身原来的值了：<code>grid[i][j] = max(grid[i-1][j],grid[i][j-1])+gird[i][j]</code>，简便写法：<code>grid[i][j] += max(grid[i-1][j],grid[i][j-1])</code>。最后，最大值一定是右下角元素，因为所有礼物最大值都大于0，路径一定会走到那里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。</span><br><span class="line">你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。</span><br><span class="line">给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i-1][j],dp[i][j-1])+gird[i][j]，从左边或上边到来，选一个大的路径加上本身（价值大于0）</span></span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt;&gt; dp;不用额外的数组，在grid原地修改即可，</span></span><br><span class="line">        <span class="comment">//因为grid本身的数组并不需要，后面的计算使用的是前面的累加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dp数组初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m;i++)<span class="comment">//累加第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i<span class="number">-1</span>];<span class="comment">//第一行右边的价值只能由左边累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++)<span class="comment">//累加第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];<span class="comment">//第一列下边的价值只能由上边累加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一定走到右下角，因为价值大于0</span></span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.90%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.7 MB, 在所有 C++ 提交中击败了94.41%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h1><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><p>这种字符串的问题，可以考虑以第i位为结尾的后缀怎么怎么样。设dp[i]是以第i位结尾的字符串的最长不含重复字符的子字符串的长度，注意这里隐含地说明了第i位一定在这个字符串里，这给连续性带来了方便。</p>
<p>那么假如知道了dp[i-1]，那么dp[i]怎么得出呢？我们只需要知道s[i]上一次出现的位置即可（假设是j）。如果上一次出现的位置在dp[i-1]到i的范围内，那么这个子串需要缩小，dp[i]&#x3D;i-j，从j开始算。否则，i在dp[i-1]前面或者根本没出现，这两种情况都可以直接dp[i]&#x3D;d[i-1]+1，即s[i]和前面连接</p>
<p>如何记录上一次s[i]的位置呢？用一个哈希表存储，map[s[i]]表示和s[i]相同的字符上一次出现的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这种字符串的问题，可以考虑以第i位为结尾的后缀怎么怎么样</span></span><br><span class="line"><span class="comment">        设dp[i]是以第i位结尾的字符串的最长不含重复字符的子字符串的长度，</span></span><br><span class="line"><span class="comment">        注意这里隐含地说明了第i位一定在这个字符串里，这给连续性带来了方便</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        那么假如知道了dp[i-1]，那么dp[i]怎么得出呢？我们只需要知道s[i]上一次出现的位置即可（假设是j）。</span></span><br><span class="line"><span class="comment">        如果上一次出现的位置在dp[i-1]到i的范围内，那么这个子串需要缩小，dp[i]=i-j，从j开始算</span></span><br><span class="line"><span class="comment">        否则，i在dp[i-1]前面或者根本没出现，这两种情况都可以直接dp[i]=d[i-1]+1，即s[i]和前面连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如何记录上一次s[i]的位置呢？用一个哈希表存储，map[s[i]]表示和s[i]相同的字符上一次出现的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;<span class="comment">//因为要创建dp和map，如果n是0就出问题。这里顺便把n=1的情况也一起干了</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_v = <span class="number">1</span>;</span><br><span class="line">        map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//map.find()在找到元素时返回迭代器，否则返回map.end()。当还不确定找不到得到时，先判断一下</span></span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i]) == map.<span class="built_in">end</span>())<span class="comment">//没有这个元素，如果直接map[s[i]]就报错了，所以这里的顺序很重要</span></span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map[s[i]]&lt;i-dp[i<span class="number">-1</span>])</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = i-map[s[i]];</span><br><span class="line"></span><br><span class="line">            map[s[i]] = i;<span class="comment">//更新</span></span><br><span class="line">            max_v = <span class="built_in">max</span>(dp[i],max_v);<span class="comment">//每次都要和dp[i]比较，这是这个解法的核心：每个不同位置结尾的子串都可能最长</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_v;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>简单的规律是一个丑数乘以2、3或5能得到更大的丑数，更进一步可以推导到：每个丑数都无非是前面的丑数乘2、3或5不断增加得来的。那么我们可以用动态规划，把前面得到的丑数不断乘以2、3、5就能得到更大的、后面的丑数</p>
<p>这里的问题是如果单单对一个数同时乘以2、3、5，那么会导致顺序不对，我们明确了要第n个丑数，因此这里有个排序的问题。除了排序的问题，还有重复的问题（如2*5和5*2是同一个丑数）</p>
<p>因此好的解法是，当要求下一个丑数时，一定是某些数（不一定是同一个数）乘2、3或5，把最小的那个拿来，然后把对应的数移向下一个（这导致了数不同）并判断重复，如果重复了这个数也要后移。因为上一个丑数是更前面的某些数乘2、3或5得到的最小值，且考虑了重复问题，那么这个新的最小的丑数比上一个丑数要大，且会比下一个丑数要小，这就有顺序了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个丑数都无非是前面的丑数乘2、3或5不断增加得来的</span></span><br><span class="line">        <span class="comment">//那么我们可以用动态规划，把前面得到的数字不断乘以2、3、5就能得到更大的、后面的丑数</span></span><br><span class="line">        <span class="comment">//这里的问题是如果单单对一个数同时乘以2、3、5，那么会导致顺序不对，因此这里有个排序的问题。</span></span><br><span class="line">        <span class="comment">//除了排序的问题，还有重复的问题</span></span><br><span class="line">        <span class="comment">//因此好的解法是，当要求下一个丑数时，一定是某些数乘2、3或5，把最小的那个拿来</span></span><br><span class="line">        <span class="comment">//然后把对应的数移向下一个并判断重复，如果有重复其他也要后移</span></span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;<span class="comment">//分别指向下一次要乘2、3、5的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;<span class="comment">//记录第i个丑数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//重复n次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> numa = dp[a]*<span class="number">2</span>, numb = dp[b]*<span class="number">3</span>, numc = dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(numa,<span class="built_in">min</span>(numb,numc));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果dp[i]等于这些数的某个或某几个，说明是使用了或者有重复，要向下跳一个</span></span><br><span class="line">            <span class="keyword">if</span>(numa == dp[i])</span><br><span class="line">                a++;</span><br><span class="line">            <span class="keyword">if</span>(numb == dp[i])</span><br><span class="line">                b++;</span><br><span class="line">            <span class="keyword">if</span>(numc == dp[i])</span><br><span class="line">                c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];<span class="comment">//返回第n个丑数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.4 MB, 在所有 C++ 提交中击败了73.97%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h1><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p>哈希表查看有没有重复，然后再遍历一次找到第一个没重复的即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">bool</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历查看重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i])==map.<span class="built_in">end</span>())<span class="comment">//用find函数看是否已存在</span></span><br><span class="line">                map[s[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map[s[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历查询第一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(map[s[i]])<span class="comment">//按s[i]的顺序来遍历</span></span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：40 ms, 在所有 C++ 提交中击败了39.13%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.4 MB, 在所有 C++ 提交中击败了75.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p>算法课写过的一道题，可以使用归并排序，只需要添加一点细节就可以了。这个算法的核心是，在归并排序merge的过程中，我们有两个指针指向前一段和后一段，如果后一段的元素要放上去，说明这个元素比前面一段的剩余元素要小，这就产生了逆序对，数量是前面那一段剩余的元素。而当我们把递归的小的段排好后，把这一段产生的逆序对给上层累加，上层继续merge就又可以计算了。排序并不会影响逆序对的数量，因为前一段和后一段分别有序，也不影响前后之间的相对关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSortCount</span>(<span class="number">0</span>,n<span class="number">-1</span>,nums,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSortCount</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终结果是这一次归并加上左右递归归并产生的逆序对，因为递归时已经排序好了，那个过程中记录的逆序对数要返回上层</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSortCount</span>(left,middle,nums,tmp)+<span class="built_in">mergeSortCount</span>(middle+<span class="number">1</span>,right,nums,tmp);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//现在左右两段分别是有序的，要创建一个辅助空间，有三种方式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.vector&lt;int&gt; tmp = nums;//辅助空间，如果这样写每次都要拷贝一个很大的nums，会超时</span></span><br><span class="line"><span class="comment">        * 2.</span></span><br><span class="line"><span class="comment">        * int tmp[right-left+1];</span></span><br><span class="line"><span class="comment">        * for(int k=0;k&lt;right-left+1;k++)</span></span><br><span class="line"><span class="comment">        *     tmp[k] = nums[left+k];//创建对应位置的tmp，不过后面使用tmp就要注意下标了</span></span><br><span class="line"><span class="comment">        * 3.像1一样创建一个大的全局tmp，这使得下标能和nums对应，同时使用2的做法，只</span></span><br><span class="line"><span class="comment">        * 在使用时拷贝对应的元素，这就使得全过程只进行了线性拷贝</span></span><br><span class="line"><span class="comment">        * 这个使用时是指在底层的两段排序好后，像2一样，不过既然是全局的，就要用引用传入参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//tmp拷贝元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=left;k&lt;=right;k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left, j = middle+<span class="number">1</span>;<span class="comment">//双指针分别指向两段的开头</span></span><br><span class="line">        <span class="type">int</span> cur = left;<span class="comment">//指向nums数组</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle <span class="keyword">and</span> j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])</span><br><span class="line">                nums[cur++] = tmp[i++];<span class="comment">//赋值同时指针移动</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//后面的小于前面的，只有这时要产生逆序对，所有i-middle的元素都可以和j构成逆序对</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[cur++] = tmp[j++];<span class="comment">//赋值同时指针移动</span></span><br><span class="line">                res += middle-i+<span class="number">1</span>;<span class="comment">//i-middle共有middle-i+1个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收尾</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle) nums[cur++] = tmp[i++];<span class="comment">//前一段剩下的都大于后一段，不过对应的j要产生的逆序对在前面的while产生完了</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right) nums[cur++] = tmp[j++];<span class="comment">//后面的大于前面的</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：144 ms, 在所有 C++ 提交中击败了86.13%的用户</span></span><br><span class="line"><span class="comment">内存消耗：43.3 MB, 在所有 C++ 提交中击败了64.45%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day18"><a href="#day18" class="headerlink" title="day18"></a>day18</h1><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p>这个算法的核心是，A指针走完A就从B的头开始走，B指针走完B就从A的头开始走，那么它们就能在走过相同步长后在相交点相遇。</p>
<p>假如没有相交点，最终会同时到达nullptr（等长则第一轮抵达，不等长则第二轮抵达）这就使得我们可以和判断相交一样，采用判断A&#x3D;&#x3D;B的形式，此时退出循环刚好返回nullptr，这在注释里有更详细的解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//有没有都不影响算法的正确性</span></span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断是否要跳转或是否往下走，而不是先往下走再判断或者先判断再往下走</span></span><br><span class="line"><span class="comment">        如果先往下再判断，那么while中A和B就不可能是nullptr</span></span><br><span class="line"><span class="comment">        如果先判断再往下走，那么跳到head之后总会next，而head可能是相交节点</span></span><br><span class="line"><span class="comment">        因此跳转和next是互斥的，不能同时做（要同时的话需要其他辅助手段）</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        当没有交点时，最终会同时到达nullptr（等长则第一轮抵达，不等长则第二轮抵达）</span></span><br><span class="line"><span class="comment">        采用判断的话，A和B可以在执行next后同时到达nullptr达成break条件</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        而有交点时，如果A和B等长，则在第一轮中间就结束返回</span></span><br><span class="line"><span class="comment">        如果不等长，则第一轮A和B不会同时为nullptr，是nullptr就跳，不是就往下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(A != B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A == <span class="literal">nullptr</span>) A = headB;<span class="comment">//跳转</span></span><br><span class="line">            <span class="keyword">else</span> A = A-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(B == <span class="literal">nullptr</span>) B = headA;</span><br><span class="line">            <span class="keyword">else</span> B = B-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：32 ms, 在所有 C++ 提交中击败了97.75%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.1 MB, 在所有 C++ 提交中击败了90.20%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找数字I"><a href="#在排序数组中查找数字I" class="headerlink" title="在排序数组中查找数字I"></a>在排序数组中查找数字I</h2><p>排序数组第一时间想二分法，同时根据二分法比较时有没有“&#x3D;”，即<code>nums[middle]&lt;target</code>和<code>nums[middle]&lt;=target</code>的不同，指针会停在不同的位置，我们设置两次二分，得到左边界和右边界就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分法，判断条件的“=”能使得算法指针停在不同的边界</span></span><br><span class="line">        <span class="comment">//分别得出target左边界和右边界即可知道有多少个</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> middle = i + (r-i)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target)</span><br><span class="line">                i = middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = middle<span class="number">-1</span>;<span class="comment">//如果找到target，会缩小右边界，继续往前找</span></span><br><span class="line">            <span class="comment">//也就是说i是左边界，i是target第一次出现的位置（如果有）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=nums.<span class="built_in">size</span>() || nums[i]!=target) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//i越界或者i的位置不是target，说明找不到，提前返回</span></span><br><span class="line">                                    <span class="comment">//越界是因为可能所有元素都比target小</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> middle = j + (r-j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)<span class="comment">//如果找到target，会缩小左边界，继续往后找</span></span><br><span class="line">                j = middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = middle<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//也就是说j是右边界，这个右边界是target之后的那个数，因为找到target会继续往后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了90.78%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.8 MB, 在所有 C++ 提交中击败了82.86%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day19"><a href="#day19" class="headerlink" title="day19"></a>day19</h1><h2 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h2><p>排序数组用二分，这些题其实就二分的判断条件改改就完事了，然后注意边界怎么缩小的，要不要-1，while结束是i&lt;j还是i&lt;&#x3D;j。一般来讲，边界都是m+1和m-1，对应的结束条件就是i&lt;&#x3D;j。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。</span><br><span class="line">在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = i+(j-i)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//索引k处的值要么大于k要么等于k</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==middle)</span><br><span class="line">                i = middle+<span class="number">1</span>;<span class="comment">//middle和middle前都是正确的，缩小左边界</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//大于</span></span><br><span class="line">                j = middle<span class="number">-1</span>;<span class="comment">//middle处已经大于了，要么是middle要么往前，缩小右边界</span></span><br><span class="line">                    <span class="comment">//那么middle为什么能-1呢？这样不会跳过正确答案吗？</span></span><br><span class="line">                    <span class="comment">//这是因为如果middle是正确答案且-1跳过了，那么会一直i=middle+1，最后回到正确答案且结束循环</span></span><br><span class="line">                    <span class="comment">//同时如果不减一则while循环无法结束，卡在i=j处（一直执行j=middle=i）</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了53.30%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.6 MB, 在所有 C++ 提交中击败了94.64%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><p>这个问题特殊之处在于，除了出现一次的数字，其他数字都出现了两次，这个两次很关键，它可以通过异或运算来加工——两个相同的数异或为0，0异或其他数字为其他数字。因此，把这些出现了两次的数字都异或了，结果就是0，接着去异或一个出现一次的数字，那么异或的结果就是这个数字了。</p>
<p>然而问题还没有这么简单，这个数组有两个出现一次的数字。我们的想法是，如果能把这两个数字分分组，就像奇偶一样分成两组就好了，因为每一组其他的数字都出现两次（相同的当然在一组啦），那么分别对这两组异或就能得到两个答案了。</p>
<p>但这两个目标数字不一定一个是奇数一个是偶数，我们可以肯定的是它们数值不一样。我们接着从异或出发，因为我们在异或整个数组前不知道两个数字是什么，那么我们在异或整个数组后能得到一个数z，z相当于这两个数字异或，肯定有一位是1，记这一位是m（全0说明这两数相同了）。就像奇数偶数一样，它们只是最后一位不同，那么我们也可以根据这一位m来分组，第m位为1的一组，第m位为0的一组，这样就分成两组了，分别异或就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先遍历异或找出z</span></span><br><span class="line">        <span class="type">int</span> z = <span class="number">0</span>;<span class="comment">//初始为0，因为0异或谁结果就是谁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">            z ^= num;<span class="comment">//注意这里是^=，z=z异或num</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出z为1的第m位</span></span><br><span class="line">        <span class="type">int</span> m = <span class="number">1</span>;<span class="comment">//00000....00001</span></span><br><span class="line">        <span class="keyword">while</span>((z&amp;m) == <span class="number">0</span>)</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;<span class="comment">//如果与运算是0，说明还没到1的那位，m左移把1对过去，注意这里是&lt;&lt;=，m等于m左移一位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在知道m了，边分组边异或</span></span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;<span class="comment">//初始化同z</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;m)</span><br><span class="line">                x ^= num;<span class="comment">//第m位为1的异或</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y ^= num;<span class="comment">//第m位为0的异或</span></span><br><span class="line">            <span class="comment">//两个数字肯定不在一起异或，因为第m位不同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;x,y&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了89.84%的用户</span></span><br><span class="line"><span class="comment">内存消耗：15.6 MB, 在所有 C++ 提交中击败了85.82%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day20"><a href="#day20" class="headerlink" title="day20"></a>day20</h1><h2 id="数组中数字出现的次数II"><a href="#数组中数字出现的次数II" class="headerlink" title="数组中数字出现的次数II"></a>数组中数字出现的次数II</h2><p>上一个问题是出现两次的数字异或是0，现在呢，出现三次的数字加起来，再模三就是0。因此所有数字加起来模三就是那个只出现一次的数字模三，但这只能求得余数，不过这至少给我们一些启发。</p>
<p>这个余数是小于3的，如果要用加法和余数表示这个数字的话，那么这个数字原来的那位数就必须小于3。由此联想到二进制的一位数，我们把所有的数字都看成二进制的话，它们相加就是每一位相加。对于那些出现三次的数字，全部来看的话，二进制上每个位都正好被3整除，因为数字要么这一位是0，要么就有三个1。最后我们把目标数字的二进制添加上去，因为要么是0要么是1，没有超出余数的范围，这样的话模三就可以了。</p>
<p>注意这里的二进制“相加”并不是真的相加，而是统计每个二进制位到底有多少个1，然后模三，余数就是目标数字二进制的对应位置的值。</p>
<p>总结一下就是：考虑数字的二进制形式，对于出现三次的数字，各二进制位出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int最多只有三十二位，所以只需要统计32位上每一位的1的个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">binary</span><span class="params">(<span class="number">32</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历统计每一个num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)</span><br><span class="line">            <span class="comment">//对于每一个数，统记二进制位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)<span class="comment">//0表示最低位，往高位走</span></span><br><span class="line">            &#123;</span><br><span class="line">                binary[i] += num&amp;<span class="number">1</span>;<span class="comment">//取最后一位，如果是1就+1，如果是0就+0，数值对应就不用if-else了，直接加法</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>;<span class="comment">//num右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在要模三，取每一位数</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从高位来，这样res不断左移就往高处推了</span></span><br><span class="line">            <span class="comment">//如果从低位开始，res不能左移不能右移，反而k每次要左移i次</span></span><br><span class="line">            <span class="comment">//虽然影响不大，总究浪费点效率 </span></span><br><span class="line">            <span class="type">int</span> k = binary[<span class="number">31</span>-i]%<span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//k要么是0要么是1，k总是在最低位，所以res要不断左移</span></span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;<span class="comment">//先左移再取位，顺序反了的话最低位总是会左移...</span></span><br><span class="line">            res |= k;<span class="comment">//res = res|k</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：32 ms, 在所有 C++ 提交中击败了66.58%的用户</span></span><br><span class="line"><span class="comment">内存消耗：15.6 MB, 在所有 C++ 提交中击败了89.42%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><p>前后双指针，老生常谈了。</p>
<p>优化的话，可把while里面if判等的条件放在while判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。</span><br><span class="line">如果有多对数字的和等于s，则输出任意一对即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]+nums[j]!=target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]&gt;target)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[j]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：140 ms, 在所有 C++ 提交中击败了96.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：98.1 MB, 在所有 C++ 提交中击败了67.91%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day21"><a href="#day21" class="headerlink" title="day21"></a>day21</h1><h2 id="和为s的连续正整数序列"><a href="#和为s的连续正整数序列" class="headerlink" title="和为s的连续正整数序列"></a>和为s的连续正整数序列</h2><p>双指针一直往前滑动，维护一个滑动窗口就好了。这种方式实际上是在不断否定前面的序列，因为如果大了，那么右边界移动就更不可能了，所以只能左边界移动；如果小了就只移动右边界扩大，因为左边界起始点不动是可能的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line"></span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">2</span>;<span class="comment">//窗口的左边界和右边界，一直往前看就行</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)<span class="comment">//i不能=j</span></span><br><span class="line">        &#123;   </span><br><span class="line">            count = (i+j)*(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==target)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(k);</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                i++;<span class="comment">//i往后一位</span></span><br><span class="line">                j++;<span class="comment">//i往后肯定更小，j一定要往后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count&lt;target)</span><br><span class="line">                j++;<span class="comment">//小了就j++，扩大右边界</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;<span class="comment">//大了就i++，缩小左边界，减去小的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6.5 MB, 在所有 C++ 提交中击败了62.75%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><p>用个辅助栈咯，在遍历过程中用个string存单词字母，遇到空格说明单词存好了，放入栈里，同时这个string变成空。那么如果后面还是空格，string是空，就可以辨别出是不是连续的空格了，因为单词后的空格string不是空。</p>
<p>最后要拼接，再把多余的空格删除。string经常要删除最后一个字符，用pop_back()舒服点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</span><br><span class="line">为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; help;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//这轮遍历只记单词，空格一律过滤掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> tmp==<span class="string">&quot;&quot;</span>)<span class="comment">//遇到连续的空格</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> tmp!=<span class="string">&quot;&quot;</span>)<span class="comment">//遇到第一个空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                help.<span class="built_in">push</span>(tmp);</span><br><span class="line">                tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//最后一个单词不一定有空格，所以还要if一下</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                tmp+=s[i];<span class="comment">//不是空格的话</span></span><br><span class="line">                <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="comment">//最后的了</span></span><br><span class="line">                    help.<span class="built_in">push</span>(tmp);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!help.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res += help.<span class="built_in">top</span>();</span><br><span class="line">            help.<span class="built_in">pop</span>();</span><br><span class="line">            res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后会多一个空格</span></span><br><span class="line">        <span class="comment">//可以用substr(0,len-1)左闭右开</span></span><br><span class="line">        <span class="comment">//可以用earse(len-1)</span></span><br><span class="line">        <span class="comment">//可以用pop_back()</span></span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了77.87%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.2 MB, 在所有 C++ 提交中击败了50.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day22"><a href="#day22" class="headerlink" title="day22"></a>day22</h1><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        string tmp = s.<span class="built_in">substr</span>(<span class="number">0</span>,n);<span class="comment">//把前面n个记录下来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-n;i++)</span><br><span class="line">            s[i] = s[i+n];<span class="comment">//往前挪</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size-n;i&lt;size;i++)</span><br><span class="line">            s[i] = tmp[i-size+n];<span class="comment">//把后面填上去</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.2 MB, 在所有 C++ 提交中击败了52.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day23"><a href="#day23" class="headerlink" title="day23"></a>day23</h1><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>记住：使用一个辅助的非严格递减的双端队列，先进先出，头部元素就是窗口的最大值。</p>
<p>这题正常想挺难想的，关键词是顺序遍历（滑动）、最值，实际上跟min栈很像，也是以一定顺序push和pop。min栈用的是辅助栈，滑动窗口是先进先出的，因此可以考虑用一个辅助的单调双端队列。</p>
<p>这个队列是维持窗口可能的最大值的，要怎么设计的呢？我们的窗口向后移动时，会移除最前面的元素，添加后面的元素。如果后的元素较大，那么更前的比它小的元素一定不可能再成为之后某个窗口的最大值，因为它们比后面的元素先出去，还比后面的元素小。</p>
<p>基于这样的思想，就可以在插入单调队列时把比这个元素小的都移除，这些被移除的元素在nums数组的位置肯定在插入的元素前。那么怎么移除呢，完全遍历的话就浪费时间，如果能维持单调递减，就可以从后往前比较大小和pop了，</p>
<p>在窗口移动的过程中，我们不仅增加了一个元素还减少了一个元素，如果这个元素在单调队列里面，我们需要把它删掉。如果它不是前一个窗口的最大值，那么它一定不在单调队列了，因为它是前一个窗口的第一个元素，没有后面元素大肯定不在；如果它是前一个窗口的最大值，那它在队列头部，pop掉就完事了。这能保持队列内的候选者都是当前窗口内的元素。</p>
<p>这样，单调队列的第一个元素，即最大的元素一定是这个滑动窗口的最大值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单调队列，非严格递减</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">        deq.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);<span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//没形成窗口前，先维护双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把比nums[i]小的都丢了，当然如果队列已经空了就不做了</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() <span class="keyword">and</span> nums[i]&gt;deq.<span class="built_in">back</span>())</span><br><span class="line">                deq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//把nums[i]添加进去</span></span><br><span class="line">            deq.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(deq[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//现在已经有一个滑动窗口了</span></span><br><span class="line">        <span class="comment">//移向下一个滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=k;j&lt;nums.<span class="built_in">size</span>();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//deq现在是上一个滑动窗口的单调队列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]==deq[<span class="number">0</span>])</span><br><span class="line">                deq.<span class="built_in">pop_front</span>();<span class="comment">//如果移除的值是最大值，就把最大值移出单调队列 </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把比nums[j]小的都丢了，当然如果队列已经空了就不做了</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() <span class="keyword">and</span> nums[j]&gt;deq.<span class="built_in">back</span>())</span><br><span class="line">                deq.<span class="built_in">pop_back</span>();<span class="comment">//在j之前的数还比j小的话，那么这些数不可能是最大值了，因为这些数走得早</span></span><br><span class="line">            <span class="comment">//把nums[j]添加进去</span></span><br><span class="line">            deq.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             前面的操作能保证i-j窗口以外的元素已经绝对不在deq里了</span></span><br><span class="line"><span class="comment">             因为j之后的还没添加，i之前的，如果i-1不是最大值，那么上一个窗口的最大值就在i-j-1之间</span></span><br><span class="line"><span class="comment">             根据单调队列的实现，i之前的元素都不会在，如果i-1是最大值，那么i-1之前的元素都不会在</span></span><br><span class="line"><span class="comment">             且i-1会被pop掉</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(deq[<span class="number">0</span>]);<span class="comment">//添加最大值</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：212 ms, 在所有 C++ 提交中击败了32.23%的用户</span></span><br><span class="line"><span class="comment">内存消耗：125 MB, 在所有 C++ 提交中击败了34.95%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day24"><a href="#day24" class="headerlink" title="day24"></a>day24</h1><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><p>在现实中，我们计算概率的时候会从前n-1个骰子的结果推向第n个骰子的结果，因为第n个骰子无非是1-6，某个值s的概率就是前n-1个骰子产生s-i的概率除以6（i从1到6），然后这些s-i都可以到达s，因此把这些概率累加。这种递推的想法给我们动态规划的考虑。</p>
<p>动态规划f(n,x) &#x3D; f(n-1,x-i)&#x2F;6.0（i：1-6，累加）。</p>
<p>这是逆向的想法，我们想要得到一个f(n,x)，要逆向推f(n-1,x-i)。但如果逆向，即从骰子为n一直向前推，当x&lt;&#x3D;6时都要做特殊处理。</p>
<p>因此改成正向的动态规划，从骰子为1开始，由于新增骰子的点数只可能为 1 至 6 ，因此概率 f(n−1,x) 仅与 f(n,x+1) , f(n,x+2), … , f(n,x+6) 相关。正向的递推就是当我们得到一个f(n,x)，可以产生一部分f(n+1,x+i)的概率，对不同的x，累加这些x+i即可。</p>
<p>因而，遍历 f(n−1) 中各点数和的概率，并将其相加至 f(n) 中所有相关项，即可完成 f(n−1) 至 f(n) 的递推。</p>
<p>具体的：动态规划正向递推，从小到大遍历n个骰子，遍历每个骰子的每一个值，对每个值遍历下一个骰子的1-6的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//动态规划f(n,x) = f(n-1,x-i)/6.0（i：1-6，累加）</span></span><br><span class="line"><span class="comment">//如果逆向，即从骰子为n一直向前推，当x&lt;=6时都要做特殊处理</span></span><br><span class="line"><span class="comment">//因此改成正向的动态规划，从骰子为1开始，由于新增骰子的点数只可能为 1 至 6 ，因此概率 f(n−1,x) 仅与 f(n,x+1) , f(n,x+2), ... , f(n,x+6) 相关。</span></span><br><span class="line"><span class="comment">//因而，遍历 f(n−1) 中各点数和的概率，并将其相加至 f(n) 中所有相关项，即可完成 f(n−1) 至 f(n) 的递推。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点数范围是n-6n，个数是5n+1</span></span><br><span class="line">        <span class="comment">//真实的值s是下标+1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6.0</span>)</span></span>;<span class="comment">//初始化，骰子1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//遍历骰子数量</span></span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span>*i+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//i个骰子时，有5i+1个值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dp.<span class="built_in">size</span>();j++)<span class="comment">//对上一个骰子的每一个值，能对下一个骰子产生的值起作用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;k++)<span class="comment">//下一个骰子的值是1-6，每个值概率是六分之一</span></span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span>;<span class="comment">//第j+k个值可以由dp[j]产生，概率是六分之一。注意是+=，累加的，比如2+3和3+2点数都是5</span></span><br><span class="line">            dp = tmp;<span class="comment">//如果还有循环，dp就代表上一个骰子的值的概率</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了94.82%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day25"><a href="#day25" class="headerlink" title="day25"></a>day25</h1><h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><p>很自然地想到排序（顺子嘛），然后正常的想法是遍历0，然后知道0的数目（4个0直接true），再接下去遍历，如果后面遍历遇到重复就false，如果往后都是+1递增就继续，如果不是+1递增，就把当前值+1（同时把0的数目减少一个，相当于补充一个中间+1值），再看是不是+1，如果不是，再用一个0…这样下去，遍历完就true，0用完就false。</p>
<p>当有更直观的办法，如果知道0的数目，也判断了没有重复，那么这5张牌是顺子的充要条件是max-min&lt;5。max是最大值，min是除0外的最小值。只要差值比5小，由于没有重复，那么0就可以填充在序列的中间，或者序列的外部（如果原来就是顺子，就填充在外部）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。</span><br><span class="line">2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,<span class="number">4</span>);<span class="comment">//数组长度为5，就直接利用了</span></span><br><span class="line">    <span class="comment">//统计大小王与判断重复</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只遍历前四个元素呢？</span></span><br><span class="line">    <span class="comment">//原因是比较前后两个元素对头尾的下标有要求，不能越界，这里少遍历一个元素</span></span><br><span class="line">    <span class="comment">//更重要的一点是，如果有四个大小王，那么无论如何也能形成顺子，最后一个元素不用看了</span></span><br><span class="line">    <span class="comment">//如果没有四个大小王，说明第四个不是0，最后一个无论如何也不是0，没必要看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果重复就false，注意要elseif，因为0是可以重复的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//四个王就结束了</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里很关键，如果没有重复，那么除去0后剩下的元素要形成顺子，它们的梯度小于5即可</span></span><br><span class="line">    <span class="keyword">return</span> (nums[<span class="number">4</span>]-nums[count]&lt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=nums[l]) i++;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[l]);<span class="comment">//最后i停在比nums[l]小的元素，交换它们，把基准值放中间</span></span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：9.7 MB, 在所有 C++ 提交中击败了92.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day26"><a href="#day26" class="headerlink" title="day26"></a>day26</h1><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p>约瑟夫环问题，用链表模拟会超时。约瑟夫环有数学上的递推公式，因此有动态规划的解法。</p>
<p>输入 n, m，记此约瑟夫环问题为 「n, m 问题」 ，设解（即最后留下的数字）为 f(n) ，则有：</p>
<p>「n, m 问题」：数字环为 0, 1, 2, …, n - 1，解为 f(n) ；<br>「n-1, m 问题」：数字环为 0, 1, 2, …, n - 2，解为 f(n-1)；</p>
<p>对于「n, m 问题」，首轮删除环中第 m 个数字后，得到一个长度为 n - 1 的数字环。由于有可能 m &gt; n ，因此删除的数字为 (m−1)%n ，删除后的数字环从下个数字（即 m%n ）开始，设 t&#x3D;m%n ，可得数字环：</p>
<p><em>t</em>,<em>t</em>+1,<em>t</em>+2,…,0,1,…,<em>t</em>−3,<em>t</em>−2</p>
<p>删除一轮后的数字环也变为一个「n-1, m 问题」，观察以下数字编号对应关系：</p>
<table>
<thead>
<tr>
<th>「n−1,m问题」</th>
<th>→</th>
<th>「n,m问题」删除后</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>→</td>
<td>t+0</td>
</tr>
<tr>
<td>1</td>
<td>→</td>
<td>t+1</td>
</tr>
<tr>
<td>…</td>
<td>→</td>
<td>…</td>
</tr>
<tr>
<td>n-2</td>
<td>→</td>
<td>t-2</td>
</tr>
</tbody></table>
<p>  设「n-1, m 问题」某数字为 x ，则可得递推关系：<em>x</em>→(<em>x</em>+<em>t</em>)%n。</p>
<p>换而言之，若已知「n-1, m 问题」的解 f(n - 1) ，则可通过以上公式计算得到「n, m 问题」的解 f(n)，即：</p>
<p><em>f</em>(<em>n</em>)&#x3D;(<em>f</em>(<em>n</em>−1)+<em>t</em>)%<em>n</em>&#x3D;(<em>f</em>(<em>n</em>−1)+<em>m</em>%<em>n</em>)%<em>n</em>&#x3D;**(<em>f</em>(<em>n</em>−1)+<em>m</em>)%<em>n</em>**</p>
<hr>
<p>这个怎么理解呢？从正向递推去看，如果知道n-1问题的解，那么能对应到n问题的解。因为n问题首先要删除一个数变成n-1问题，而<strong>n问题的解和n-1问题的解从元素角度看必然是同一个</strong>（因为本来就是同一个问题的不同过程），只是它们在不同的序列，拥有<strong>不同的值</strong>而已。那么我们只需要把值做一次映射，就能从n-1问题的解的值映射到n问题的解的值。从n问题到n-1问题，删除了(m-1)%n，新序列每个值都减了或加了(m-1)%n+1，反过来只要加回去就可以了（加什么值最好用一个例子推）。从n&#x3D;1时开始往后推，不断映射到下一个规模的解返回即可（因为最终返回的解的值是在n问题序列的解）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。</span><br><span class="line">求出这个圆圈里剩下的最后一个数字。</span><br><span class="line"></span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，</span><br><span class="line">则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//n=1时的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//从n=1递推到n=2，一直递推到n</span></span><br><span class="line">            x = (x+m)%i;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了93.52%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了94.35%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day27"><a href="#day27" class="headerlink" title="day27"></a>day27</h1><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>动态规划，不谈了，ez</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果今天的价格比存储的最小值小，则更改最小值</span></span><br><span class="line">            <span class="keyword">if</span>(num&lt;=min)</span><br><span class="line">                min = num;<span class="comment">//不可能在今天卖出，因为一定是亏的或者是0</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果大的话可以卖一下，min存储了前几天的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                profit = <span class="built_in">max</span>(profit,num-min);<span class="comment">//更新利润</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了88.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.4 MB, 在所有 C++ 提交中击败了79.39%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day28"><a href="#day28" class="headerlink" title="day28"></a>day28</h1><h2 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h2><p>首先不能用while等循环，显然就用递归了。然后当n&gt;0才递归，因此要判断，但是不能用if那些，可以考虑用布尔逻辑的短路效应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNums</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n&gt;0时，n是真，根据与表达式，还要看后面的真假，所以会做 n+=sumNums(n-1);</span></span><br><span class="line">        <span class="comment">//n=0时，整个表达式已经是假了，不会做后面的运算了，递归终止。</span></span><br><span class="line">        <span class="comment">//整个表达式的布尔真假没有意义，并不需要，只需要用来根据n的值决定做不做递归即可，最后返回n</span></span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6.1 MB, 在所有 C++ 提交中击败了25.90%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day29"><a href="#day29" class="headerlink" title="day29"></a>day29</h1><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p>加法器原理，用位运算实现。a+b相当于无进位加法加上进位。假设无进位加法结果是n，进位是c，则a+b&#x3D;n+c。无进位加法n&#x3D;a^b，即两数异或，位全1或全0这一位的结果都是0。进位可以用与运算，c&#x3D;(a&amp;b)&lt;&lt;1，因为是进位所以要左移。</p>
<p>在位运算后，我们就变成了要计算n+c，这还是一个加法，因此又要一轮无进位加法和进位，像递归一样不断往复下去，直到没有进位就可以停止了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//分为无进位加法结果n和进位结果c，则a+b=n+c</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算，把a当结果，把b加到a上</span></span><br><span class="line">        <span class="type">int</span> c;<span class="comment">//存储进位，无进位加法结果直接存a上，相当于n=a^b，下一轮两个加数是n和c，则n=a，b=c；n可以用a替代</span></span><br><span class="line">        <span class="keyword">while</span>(b)<span class="comment">//b不为0时进行，b为0说明加完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//c++不支持负数左移，要转unsigned，因为整个过程只是bit串运算，不用管正负，不需要c++去解释正负</span></span><br><span class="line">            c = (<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b) &lt;&lt; <span class="number">1</span>;<span class="comment">//两数的每个bit的进位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//无进位加法，加完再和进位加就可以</span></span><br><span class="line">            a = a^b;<span class="comment">//对于加法，都是1就进位，结果是0，都是0那结果也是0。都是1时进位在c那</span></span><br><span class="line">            b=c;<span class="comment">//c已经左移过了，本身是要a+c，但也不能用加法，所以还是要异或，a+c就像a+b一样，一直循环直到没进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了69.28%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day30"><a href="#day30" class="headerlink" title="day30"></a>day30</h1><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p>不能用除法，所以考虑乘法，再考虑性能的话就要考虑乘法的递推。累乘的中间是割裂的，但割裂的这个i是递增的，所以这里面也有些规律可循。</p>
<p>再来思考一下，从形式上看有递推的效果，可以考虑动态规划，但是递推总是割裂的，差一点，原因是还要找规律。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>B[0]&#x3D;</td>
<td><strong>1</strong></td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>B[1]&#x3D;</td>
<td>A[0]</td>
<td><strong>1</strong></td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>B[2]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>1</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>B[n-1]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td><strong>1</strong></td>
<td>A[n]</td>
</tr>
<tr>
<td>B[n]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td><strong>1</strong></td>
</tr>
</tbody></table>
<p> 整个累乘可以分成上三角矩阵和下三角矩阵，B[i]的计算可以分成两次计算。前面动态规划差一点的原因就是中间有断裂，那么可以分别从两个三角来。比如先计算下三角的部分，那么<code>B[0] = 1; B[i] = B[i-1]*A[i-1];</code>，这样子迭代就计算好了下三角，注意我们是迭代的递推的，因此要从小的开始慢慢乘起来，所以在回头计算上三角时，是从下往上的，从A[n]累乘到A[1]，从B[n-1]到B[0]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, </span><br><span class="line">即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下三角递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;<span class="comment">//不能用B[i-1]来递推了，用个tmp保存递推的中间值</span></span><br><span class="line">        <span class="comment">//上三角递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp *= a[i+<span class="number">1</span>];</span><br><span class="line">            B[i] *= tmp;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了86.75%的用户</span></span><br><span class="line"><span class="comment">内存消耗：23.7 MB, 在所有 C++ 提交中击败了91.26%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day31"><a href="#day31" class="headerlink" title="day31"></a>day31</h1><p>今天忘记了，明天补一道&#x2F;(ㄒoㄒ)&#x2F;~~</p>
<h1 id="day32"><a href="#day32" class="headerlink" title="day32"></a>day32</h1><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p>主要是越界的处理，要提前去判断。先说一下具体的操作：</p>
<ul>
<li>先把开头的空格遍历过去</li>
<li>获得第一个非空格字符，如果非数字和正负号，返回0</li>
<li>如果是负号，存储sign变量；正号同理</li>
<li>如果是数字，说明是正号，正号可以不显式出现，因此默认情况下sign是正号。</li>
<li>然后开始处理连续的数字，前面存储的是res，当前数字是num，num&#x3D;str[i]-‘0’，res &#x3D; res*10+num。在此过程中，要提前判断：<ul>
<li>如果遇到非数字字符就直接break，返回res和正负</li>
<li>如果是数字字符，要判断拼接后会不会溢出，一个是res是否大于max&#x2F;10，如果大于的话*10就溢出了。最恰好的情况是res&#x3D;&#x3D;max&#x2F;10，如果num&gt;7就溢出了，根据正负号返回max或min。因为8的时候是正的溢出，返回max；但8不是负的溢出，但是此时的值也是min，不用再额外判断了。这种判断方式对于判断溢出、返回max和min很有效。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；</span><br><span class="line">假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> sign = <span class="literal">true</span>;   <span class="comment">//默认为正数</span></span><br><span class="line">        <span class="comment">//先舍弃开头可能存在的空格</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        <span class="comment">//接着判断首个字符是否为正负号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = <span class="literal">false</span>;  <span class="comment">//该字符串片段为负数</span></span><br><span class="line">            i++;          <span class="comment">//移至下一个字符接着判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span>) i++;   <span class="comment">//如果首个字符为‘+’则sign已经默认为true而无须更改，直接移动到下一位即可</span></span><br><span class="line">        <span class="comment">//下面开始对非正负符号位进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//如果第一个正负号字符后的首个字符就不是数字字符(也可能第一个字符就不是正负号)，那么直接返回0</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;   <span class="comment">//这里res用的int型，需要更加仔细考虑边界情况，但如果用long的话可以省去一些麻烦</span></span><br><span class="line">        <span class="type">int</span> num;      <span class="comment">//用来单独存储单个字符转换而成的数字</span></span><br><span class="line">        <span class="type">int</span> border = INT_MAX / <span class="number">10</span>;  <span class="comment">//用来验证计算结果是否溢出int范围的数据</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">//遇到非数字字符则返回已经计算的res结果</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; border || res == border &amp;&amp; str[i] &gt; <span class="string">&#x27;7&#x27;</span>)  <span class="comment">//注意这句话要放在字符转换前，因为需要验证的位数比实际值的位数要少一位</span></span><br><span class="line"><span class="comment">//这里比较巧妙的地方在于 1. 用低于int型数据长度一位的数据border判断了超过int型数据长度的值 2. 将超过最大值和低于最小值的情况都包括了</span></span><br><span class="line">            <span class="keyword">return</span> sign == <span class="literal">true</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            <span class="comment">//开始对数字字符进行转换</span></span><br><span class="line">            num = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后结果根据符号添加正负号</span></span><br><span class="line">        <span class="keyword">return</span> sign == <span class="literal">true</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了63.07%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了78.85%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制加法"><a href="#二进制加法" class="headerlink" title="二进制加法"></a>二进制加法</h2><p>手动模拟，逐位加。把顺序先倒过来会好一点。然后这里遍历的长度是较长的那个，同时判断，如果短的到边了那就是+0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。</span><br><span class="line"></span><br><span class="line">输入为 非空 字符串且只包含数字 1 和 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: a = &quot;11&quot;, b = &quot;10&quot;</span><br><span class="line">输出: &quot;101&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//carry即表示进位又表示结果</span></span><br><span class="line">        <span class="comment">//carry表示进位和a、b位相加，其实就是三者中有多少个1。模二就是结果，结果是二就继续进位</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;<span class="comment">//如果长度不够就是0，够的话用比较或者-&#x27;0&#x27;都行</span></span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);<span class="comment">//当前位相加的结果，转char</span></span><br><span class="line">            carry /= <span class="number">2</span>;<span class="comment">//下一位的进位，三者之和是2或3才有进位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;<span class="comment">//最后的处理</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了85.36%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day33"><a href="#day33" class="headerlink" title="day33"></a>day33</h1><h2 id="前n个数字二进制中1的个数"><a href="#前n个数字二进制中1的个数" class="headerlink" title="前n个数字二进制中1的个数"></a>前n个数字二进制中1的个数</h2><p>动态规划，二进制中1的个数要想到 n&amp;(n-1)能把n中最低的1变成0。这个变成0一方面让数字变小，一方面让1的个数少了1；也即：缩小了规模同时得到了数值关系。因此就有了递推式：bit[i] &#x3D; bit[ i&amp;(i-1) ] +1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: n = 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">解释: </span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: n = 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br><span class="line">解释:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;<span class="comment">//初始化，bits[0] = 0;起始条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;<span class="comment">//递推，i缩小了规模，尽管缩小的程序不知道，但因为i是递增的，所以&lt;i的都解决了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.6 MB, 在所有 C++ 提交中击败了72.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day34"><a href="#day34" class="headerlink" title="day34"></a>day34</h1><h2 id="单词长度的最大乘积"><a href="#单词长度的最大乘积" class="headerlink" title="单词长度的最大乘积"></a>单词长度的最大乘积</h2><p>传统的暴力解法：遍历每个字符串对，然后再看两个字符串有没有相同字母。</p>
<p>先思考下一定要遍历字符串对吗，有没有递推的方式？答案是没有，因为这里不同的字符串对前后文没有关系，没有什么能够保存的状态，无法递推或分治，每对字符串都是新状态，所以一定要遍历所有字符串。同时要判断重复，就又得遍历两个字符串的字母，时间复杂度是大于n方的。</p>
<p>采取空间换取时间的方式，利用一个额外空间把字符串是否重复的信息存取。注意不能遍历字符串对去获取信息，这样就没有差别了。因此，要对每个字符串自身获取信息，同时利用这个信息在O(1)的复杂度判断有无重复。</p>
<p>O(1)的复杂度值得我们去考虑数学运算或位运算，尤其是判断重复会想到哈希表，也就想到映射。因此可以把字符串的字母映射到26位长的比特串上，如果有对应字母，对应的位置就是1。由于最多26位，所以可以用单个int来保存这个信息，也就是掩码。在判重时，两个掩码进行与运算，如果结果为0说明没有相同字母。</p>
<p>核心是：利用位掩码判断两个字符串是否有相同字符（进行与运算)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。</span><br><span class="line">假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masks</span><span class="params">(length)</span></span>;<span class="comment">//掩码，初始化为0。一个掩码由一位int表示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//遍历所有字符串，words[i]对应masks[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            string word = words[i];</span><br><span class="line">            <span class="type">int</span> wordLength = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordLength; j++)<span class="comment">//遍历某个字符串，每个掩码假想有26位对应26个字母</span></span><br><span class="line">            &#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (word[j] - <span class="string">&#x27;a&#x27;</span>);<span class="comment">//获取是哪个字母，然后把1左移到对应位置上或起来。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//遍历每个字符串对</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)<span class="comment">//j从i后面开始就可以了，降重</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>) <span class="comment">//没有相同字母也就是掩码对应的1位置不同，与的结果是0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    maxProd = <span class="built_in">max</span>(maxProd, <span class="built_in">int</span>(words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：40 ms, 在所有 C++ 提交中击败了76.83%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.1 MB, 在所有 C++ 提交中击败了47.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day35"><a href="#day35" class="headerlink" title="day35"></a>day35</h1><h2 id="数组中和为0的三个数"><a href="#数组中和为0的三个数" class="headerlink" title="数组中和为0的三个数"></a>数组中和为0的三个数</h2><p>固定元素+双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，</span><br><span class="line">同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span><br><span class="line"></span><br><span class="line">你返回所有和为 0 且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//排序双指针</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i ++)<span class="comment">//固定第一个元素，0到倒数第三个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="comment">//如果跟前面一个一样，那么就算找到了也是和前面答案一样的，重复了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> c = - nums[i];<span class="comment">//c是剩下两个元素的和</span></span><br><span class="line">            <span class="comment">//头尾双指针</span></span><br><span class="line">            <span class="type">int</span> ll = i + <span class="number">1</span>, rr = n - <span class="number">1</span>;               <span class="comment">//j从i+1开始可以避免重复</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(ll &lt; rr)<span class="comment">//左右边界不重合，注意一定要遍历完，因为3+7和4+6都是答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[ll] + nums[rr];</span><br><span class="line">                <span class="comment">//移动头尾双指针找到第一个target</span></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; c)</span><br><span class="line">                    rr --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; c)</span><br><span class="line">                    ll ++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[ll], nums[rr]&#125;);<span class="comment">//找到了就添加答案</span></span><br><span class="line">                    <span class="comment">//然后要把重复的都过滤掉，不然又是一组相同答案</span></span><br><span class="line">                    <span class="keyword">while</span>(ll &lt; rr &amp;&amp; nums[ll] == nums[++ ll]);      <span class="comment">//找到一个不重复的ll</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(ll &lt; rr &amp;&amp; nums[rr] == nums[-- rr]);</span><br><span class="line">                    <span class="comment">//过滤完后继续找下一个</span></span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：48 ms, 在所有 C++ 提交中击败了99.33%的用户</span></span><br><span class="line"><span class="comment">内存消耗：19.4 MB, 在所有 C++ 提交中击败了71.60%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day36"><a href="#day36" class="headerlink" title="day36"></a>day36</h1><h2 id="和大于等于target的最短子数组"><a href="#和大于等于target的最短子数组" class="headerlink" title="和大于等于target的最短子数组"></a>和大于等于target的最短子数组</h2><p>这种连续子数组，尤其时牵扯到子数组的长度、连续和等等，可以用滑动窗口，更新边界即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line"></span><br><span class="line">找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。</span><br><span class="line">如果不存在符合条件的子数组，返回 0 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span> ,j=<span class="number">0</span>;<span class="comment">//相等是因为可以只有1个元素满足</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//j不能改成&lt;n-1，因为j=n-1时虽然到最后了，不能退出，还要再判断更新一次minlen</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j <span class="keyword">and</span> j&lt;n)<span class="comment">//i&gt;j时返回，说明有len=1的满足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= count)<span class="comment">//当前窗口符合，缩小左边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen,j-i+<span class="number">1</span>);<span class="comment">//更新，窗口是i-j，大小是j-i+1</span></span><br><span class="line">                count -= nums[i];<span class="comment">//左边界移动更新count</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j++;<span class="comment">//右边界移动，注意j++和i++顺序不同，因为一个是加新的，一个是减旧的</span></span><br><span class="line">                <span class="keyword">if</span>(j==n) </span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//提前返回，当到最后（即使前面有符合的）不存在符合的子数组会越界</span></span><br><span class="line">                            <span class="comment">//因为当j到n-1时，在符合的窗口i++后可能不符合，j会尝试++，nums会越界</span></span><br><span class="line">                            <span class="comment">//一直不符合就更简单了，j一直++，但是又不能在while里改条件</span></span><br><span class="line">                count += nums[j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (minlen==INT_MAX)?<span class="number">0</span>:minlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.59%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.2 MB, 在所有 C++ 提交中击败了79.18%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day37"><a href="#day37" class="headerlink" title="day37"></a>day37</h1><h2 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a>乘积小于K的子数组</h2><p>滑动窗口，控制边界。这里的重点是对子数组个数的计数，如何不重复又如何不遗漏。这里子数组的连续性给了比较好的性质。当我们的窗口乘积比较大的时候，要缩小左边界，用乘积除以左边界的值更新乘积；而当乘积小于K的时候，这时就产生了子数组，且移动右边界。</p>
<p>我们从移动右边界的情形来看计数，当我们要更新计数时，上一个右边界（右边界-1）已经计数好了，那么当前的这个窗口只需要更新那些新产生的子数组的个数。这些新产生的子数组必然包含了右边界的元素（因为没包含右边界元素的子数组在上一次计数就算进去了）且包含了右边界的元素一定是新产生的子数组，那么我们从右边界往左边界数子数组的个数，子数组大小从1开始（根据子数组的连续性）：[nums[j]]，[nums[j],num[j-1]],…,[nums[j],…,nums[i]]，个数就是窗口的大小j-i+1。这本质上是由于递推，上一次的子数组已经计算进去了。</p>
<p>因此，当乘积大时，更新左边界；当乘积符合时，更新计数，然后更新右边界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [10,5,2,6], k = 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,2,3], k = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pro = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据右边界来计数，每移动一次j都要更新值，所以用for的形式移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pro *= nums[j];</span><br><span class="line">            <span class="comment">//i能等于j是为了能跳过某个本身就大于k的数，此时i=j+1，更新计数j-i+1也是0，然后就从下一个数开始</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j &amp;&amp; pro &gt;= k)<span class="comment">//如果pro较大，移动左边界直到窗口符合条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                pro /= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有符合的窗口</span></span><br><span class="line">            res += j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：64 ms, 在所有 C++ 提交中击败了71.68%的用户</span></span><br><span class="line"><span class="comment">内存消耗：59.7 MB, 在所有 C++ 提交中击败了65.21%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day38"><a href="#day38" class="headerlink" title="day38"></a>day38</h1><h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><p>本以为这题和上一题差不多，但还是不一样，因为数组中的数字可以是负的，这把思路都改变了。前面小于的话，当找到合适的窗口，里面的更小的子数组都可以算进去，这样每次滑动窗口就可以了。但是由于这里数字是负的，并不知道该移动哪个边界，移动左边界窗口和既有可能增大也有可能减小。</p>
<p>如果没有负数，测试了几个例子，理论上滑动窗口也是可以解决的。而当前这种情况，就要用到一种更为通用的方式：前缀和（对应前一题为前缀积）。</p>
<p>这里使用额外的空间，保存一些前缀和pre[i]，其中pre[i]表示从0-i所有元素的和。那么当我们每次遍历i时，能够通过之前的线性迭代很快获得当前的前缀和，这时要向前看x步找寻有没有和为k的一个子数组序列，本质上就是截出一段来，那么假设pre[i] - pre[j] &#x3D;k，我们就截到了j-i这一段，注意由于我们是遍历过来的，所以j会比i小（这里的本质是，发现所有符合条件的以nums[i]结尾的子数组，既然是nums[i]结尾，那么其余元素一定是向前的）。</p>
<p>如果找到了这么一个pre[j] &#x3D; pre[i] - k，就可以计数了。注意这样的pre[j]也许不只有一个，那么就可以用哈希表映射到次数，每次遍历完更新一下哈希表就好了。</p>
<p>注意前缀和是0的情况，因为为0时，也许有前缀和为0，也可以就是pre[i]而不减去其他前缀和，因此hash[0]本身应该多1，即初始化为1，其他为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入:nums = [1,2,3], k = 3</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//key为前缀和，value为次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums) &#123;</span><br><span class="line">            pre += x;<span class="comment">//前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;<span class="comment">//如果找得到pre-k的前缀和，则找到一组子数组</span></span><br><span class="line">                count += mp[pre - k];<span class="comment">//mp的值是pre-k的前缀和出现的次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;<span class="comment">//pre这个对应的前缀和+1，初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：48 ms, 在所有 C++ 提交中击败了99.09%的用户</span></span><br><span class="line"><span class="comment">内存消耗：35.1 MB, 在所有 C++ 提交中击败了72.84%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day39"><a href="#day39" class="headerlink" title="day39"></a>day39</h1><h2 id="0-和-1-个数相同的子数组"><a href="#0-和-1-个数相同的子数组" class="headerlink" title="0 和 1 个数相同的子数组"></a>0 和 1 个数相同的子数组</h2><p>核心思想就是把0看成-1，这样个数相同的子数组的和就是0，这样问题归约为：最长和为0的连续子数组。这与上一题相似，只不过上一题是个数，这一题是最长长度。假设有前缀和count，位置为i，那么上一次出现的count处，位置为j，j+1——i这一段子数组就符合要求。因此使用一个哈希表，把前缀和映射到count出现的第一个位置（这样能使子数组最长）。具体的，这个第一个位置，只要我们在找到count时不更新即可，如果找不到count就更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//长度就映射到位置，个数就映射到个数</span></span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        mp[counter] = <span class="number">-1</span>;<span class="comment">//如果此时前缀和为0的话，就是从头开始，这个要手动初始化</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;<span class="comment">//为1就累加前缀和</span></span><br><span class="line">                counter++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//为0就前缀和减一</span></span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(counter)) &#123;<span class="comment">//从下标prevIndex+1 到下标 i 的子数组中有相同数量的 0 和 1，该子数组的长度为i−prevIndex</span></span><br><span class="line">                <span class="type">int</span> prevIndex = mp[counter];</span><br><span class="line">                maxLength = <span class="built_in">max</span>(maxLength, i - prevIndex);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果counter 的值在哈希表中不存在，则将当前余数和当前下标 i 的键值对存入哈希表中。</span></span><br><span class="line">                mp[counter] = i;<span class="comment">//第一次出现count的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：100 ms, 在所有 C++ 提交中击败了78.11%的用户</span></span><br><span class="line"><span class="comment">内存消耗：81.7 MB, 在所有 C++ 提交中击败了74.39%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day40"><a href="#day40" class="headerlink" title="day40"></a>day40</h1><h2 id="左右两边子数组的和相等"><a href="#左右两边子数组的和相等" class="headerlink" title="左右两边子数组的和相等"></a>左右两边子数组的和相等</h2><p>很简单的一道题，实际上就是遍历i，看每个i能不能当中心下标，那么在遍历的时候，累加前缀和和累减后缀和就可以判断了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，请计算数组的 中心下标 。</span><br><span class="line"></span><br><span class="line">数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</span><br><span class="line"></span><br><span class="line">如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</span><br><span class="line"></span><br><span class="line">如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,7,3,6,5,6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">中心下标是 3 。</span><br><span class="line">左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，</span><br><span class="line">右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心下标。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [2, 1, -1]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">中心下标是 0 。</span><br><span class="line">左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），</span><br><span class="line">右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际上就是遍历i，看每个i能不能当中心下标</span></span><br><span class="line">        <span class="comment">//那么在遍历的时候，累加前缀和和累减后缀和就可以判断了</span></span><br><span class="line">        <span class="type">int</span> after = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)</span><br><span class="line">            after += num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            after -= nums[i];<span class="comment">//首先要减去这个值，把i空出来</span></span><br><span class="line">            <span class="keyword">if</span>(pre == after)<span class="comment">//然后pre先别加再判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                res = i;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//找最左边的</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            pre += nums[i];<span class="comment">//往后移，pre填上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了97.48%的用户</span></span><br><span class="line"><span class="comment">内存消耗：30.1 MB, 在所有 C++ 提交中击败了92.36%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">317k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
