<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Re：从零开始的写博客生活">
<meta property="og:type" content="website">
<meta property="og:title" content="JySama">
<meta property="og:url" content="https://jysama.cn/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="Re：从零开始的写博客生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/06/20/STL%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/20/STL%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">《STL源码剖析》学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-20 14:32:28" itemprop="dateCreated datePublished" datetime="2022-06-20T14:32:28+08:00">2022-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-09 22:46:35" itemprop="dateModified" datetime="2022-07-09T22:46:35+08:00">2022-07-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重返C++，先STL入手。这里会记录一些重点，但是不会记录得很全面。</p>
<p>follow 侯捷大师的《STL源码剖析》</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>博客大部分内容都来源于《STL源码剖析》这本书（copy了个人认为重要的部分，包括代码），对于一些不容易明白的地方会查找其他资料进行补充。</p>
<p>由于电子的文字版只有前四章，因此后面的章节只能截扫描版的图。(′⌒&#96;) </p>
<h1 id="概念与基础"><a href="#概念与基础" class="headerlink" title="概念与基础"></a>概念与基础</h1><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>1.容器（containers）：各种数据结构，如vector, list, deque, set, map，用来存放数据。从实作的角度看，STL 容器是一种 class template。就体积而言，这一部份很像冰山在海面下的比率。</p>
<p>2.算法（algorithms）：各种常用算法如sort, search, copy, erase…。从实作的角度看，STL 算法是一种 function template。</p>
<p>3.迭代器（iterators）：扮演容器与算法之间的胶着剂，是所谓的「泛型指标」。共有五种类型，以及其它衍生变化。从实作的角度看，迭代器是一种将operator*, operator-&gt;, operator++, operator–等指标相关操作予以多载化的 class template。所有STL容器都附带有自己专属的迭代器—是的，只有容器设计者才知道如何巡访自己的元素。原生指标（native pointer）也是一种迭代器。</p>
<p>4.仿函式（functors）：行为类似函式，可做为算法的某种策略（policy）。从实作的角度看，仿函式是一种重载了 operator()的 class 或class template。一般函式指标可视为狭义的仿函式。</p>
<p>5.配接器（adapters）：一种用来修饰容器（containers）或仿函式（functors）或迭代器（iterators）接口的东西。例如 STL 提供的 queue 和stack，虽然看似容器，其实只能算是一种容器配接器，因为它们的底部完全借重 deque，所有动作都由底层的 deque供应。改变functor接口者，称为function adapter，改变container接口者，称为container adapter，改变iterator界面者，称为iterator adapter。配接器的实作技术很难一言以蔽之，必须逐一分析。</p>
<p>6.配置器（allocators）：负责空间配置与管理，详见第 2 章。从实作的角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。 </p>
<p><strong>STL六大组件的交互关系：</strong>Container透过Allocator取得数据储存空间，Algorithm透过Iterator存取Container内容，Functor可以协助 Algorithm完成不同的策略变化，Adapter可以修饰或套接 Functor。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="image-20220620143742620"></p>
<h2 id="SGI-STL文件分布与简介"><a href="#SGI-STL文件分布与简介" class="headerlink" title="SGI STL文件分布与简介"></a>SGI STL文件分布与简介</h2><p>概略可分为五组： </p>
<ul>
<li><p>C++标准规范下的 C 头文件（无扩展名），例如cstdio, cstdlib, cstring… </p>
</li>
<li><p>C++标准链接库中不属于 STL范畴者，例如 stream, string…相关文件。</p>
</li>
<li><p>STL标准头文件（无扩展名），例如vector, deque, list, map, algorithm, functional… </p>
</li>
<li><p><em>C++ Standard</em> 定案前，HP 所规范的 STL 头文件，例如vector.h, deque.h, list.h, map.h, algo.h, function.h… </p>
</li>
<li><p>SGI STL 内部文件（STL 真正实作于此），例如stl_vector.h, stl_deque.h, stl_list.h, stl_map.h, stl_algo.h, stl_function.h…</p>
</li>
</ul>
<h2 id="SGI-STL-的编译器组态设定-configuration"><a href="#SGI-STL-的编译器组态设定-configuration" class="headerlink" title="SGI STL 的编译器组态设定(configuration)"></a>SGI STL 的编译器组态设定(configuration)</h2><p>不同的<strong>编译器</strong>对C++语言的支持程度不尽相同。做为一个希望具备广泛移植能力的链接库，SGI STL 准备了一个环境组态文件&lt;stl_config.h&gt;，其中定义许多常数，标示某些状态的成立与否。所有 STL 头文件都会直接或间接含入这个组态文件，并以条件式写法，让前处理器（pre-processor）根据各个常数决定取舍哪一段程序码。</p>
<p>&lt;stl_config.h&gt;文件起始处有一份常数定义说明，然后即针对各家不同的编译器以及可能的不同版ᴀ，给予常数设定。</p>
<p>这里先介绍&lt;stl_config.h&gt;中的预定义<strong>组态配置项</strong>：</p>
<ul>
<li><p><strong>__STL_STATIC_TEMPLATE_MEMBER_BUG</strong></p>
<p>如果编译器无法处理static member of template classes(模板类静态成员)就定义</p>
</li>
<li><p><strong>__STL_CLASS_PARTIAL_SPECIALIZATION</strong></p>
<p>如果编译器支持 partial specialization of class templates(模板类偏特化)就定义。</p>
<p><strong>偏特化</strong>：模板为什么要特化，因为编译器认为，对于特定的类型，如果你能对某一功能更好的实现，那么就该听你的。</p>
<p>模板分为<strong>类模板</strong>与<strong>函数模板</strong>，特化分为全特化与偏特化。全特化就是限定死模板实现的具体类型，偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。</p>
<p>使用template定义类时可以使用const *等做特殊设计。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&lt;T*, <span class="type">const</span> T* &gt; &#123;....&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_FUNCTION_TMPL_PARTIAL_ORDER</strong></p>
<p>如果编译器支持partial ordering of function templates或者说partial specialization of function templates就定义，可以理解为对<strong>函数模板的重载</strong>的支持</p>
<p>对于一个函数模板，如果定义了另一个函数模板且函数名相同，会根据template的参数表进行调用，要注意的是，第二个函数模板需要知道参数，可以在函数后面加上例如，max&lt;T,T&gt;或者函数之前声明类struct&lt;T,T&gt;。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T1 <span class="type">const</span>&amp; t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;In Bar&lt;T1, T2&gt;(&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&lt;<span class="type">int</span>, T2&gt;<span class="comment">//声明&lt;T1,T2&gt;</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;In Bar&lt;int, T2&gt;(&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 下列代码也可以</span></span><br><span class="line"><span class="comment">template&lt;typename T2&gt;</span></span><br><span class="line"><span class="comment">void operator()&lt;int, T2&gt;(int t1, T2 const&amp; t2)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">    std::cerr &lt;&lt; &quot;In Bar&lt;int, T2&gt;(&quot; &lt;&lt; t1 &lt;&lt; &quot;, &quot; &lt;&lt; t2 &lt;&lt; &quot;)\n&quot;;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T1 <span class="type">const</span>&amp; t1, T2 <span class="type">const</span>&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Bar&lt;T1, T2&gt; b;</span><br><span class="line">   <span class="built_in">b</span>(t1, t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_MEMBER_TEMPLATES</strong></p>
<p>如果编译器支持template members of classes 就定义，看英文就知道，模板类中<strong>嵌套模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">TT</span>&gt; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(TT a,TT b)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_LIMITED_DEFAULT_TEMPLAES</strong></p>
<p>用到前一个模板的模板形参的某一个具现体作为当前模板的模板形参的默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Se</span> = queue&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> test &#123;....&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_NON_TYPE_TMPL_PARAM_BUG</strong></p>
<p>测试类模板是否使用非类型模板参数（non-type template parameters），或着是否template 可以使用无参数类型模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> m_data[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        CTest&lt;<span class="number">10</span>&gt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非类型模板</strong>：非类型模板参数(nontype template parameters), 可以使用<strong>整型类型</strong>(integral type)，<strong>指针</strong>(pointer)或者是<strong>引用</strong>(reference);绑定非类型整数形参(nontype integral parameter) 的 实参(argument) 必须是<strong>常量表达式(constant expression, constexpr)<strong>；不能把</strong>普通的局部对象</strong>或者<strong>动态对象</strong> 绑定指针或引用的非类型形参, 可以使用<strong>全局类型</strong>进行绑定。</p>
</li>
<li><p><strong>__STL_NULL_TMPL_ARGS</strong></p>
<p>友元约束模板：可以依据之前对非友元函数的定义来对友元函数进行约束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T,Sequence&gt;&amp; x,<span class="type">const</span> stack&lt;T,Sequence&gt;&amp; y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>=deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//friend bool operator==&lt;T&gt;(const stack&lt;T&gt;&amp;,const stack&lt;T&gt;&amp;);</span></span><br><span class="line">    <span class="comment">//下面的都是等价于上面的</span></span><br><span class="line">    <span class="comment">//friend bool operator== &lt;T&gt;(const stack&amp;,const stack&amp;);</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== &lt;&gt;(<span class="type">const</span> stack&amp;,<span class="type">const</span> stack&amp;);</span><br><span class="line">    Sequence c;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Sequence</span>&gt;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T,Sequence&gt; &amp;x,<span class="type">const</span> stack&lt;T,Sequence&gt; &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cout&lt;&lt;<span class="string">&quot;operator==&quot;</span>&lt;&lt;<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; y;</span><br><span class="line">    cout&lt;&lt;(x==y)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; y1;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;(x==y1)&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>__STL_TEMPLATE_NULL</strong></p>
<p>即 template &lt;&gt; 显示的模板特化，对template进行具体化，在定义参数时就可以使用具体化的定义。函数同理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">test</span> &#123;....&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">test</span>&lt;<span class="type">int</span>&gt;&#123;.....&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Any&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Any &amp;,Any &amp;b)</span></span>&#123;......;&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;,<span class="type">int</span> &amp;)&#123;......;&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下是 GNU C++ 2.91.57 &lt;stl_config.h&gt;的完整内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_CONFIG_H </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CONFIG_H </span></span><br><span class="line"><span class="comment">//文件所做的事情：</span></span><br><span class="line"><span class="comment">// (1) 如果编译器没有定义 bool, true, false，就定义它们</span></span><br><span class="line"><span class="comment">// (2) 如果编译器的标准链接库᳾支持 drand48()函式，就定义 __STL_NO_DRAND48 </span></span><br><span class="line"><span class="comment">// (3) 如果编译器无法处理 static members of template classes，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="comment">// (4) 如果编译器᳾支持关键词 typename，就将&#x27;typename&#x27;定义为一个 null macro. </span></span><br><span class="line"><span class="comment">// (5) 如果编译器支持 partial specialization of class templates，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_CLASS_PARTIAL_SPECIALIZATION. </span></span><br><span class="line"><span class="comment">// (6) 如果编译器支持 partial ordering of function templates（亦称为</span></span><br><span class="line"><span class="comment">// 		partial specialization of function templates），就定义</span></span><br><span class="line"><span class="comment">// 		__STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="comment">// (7) 如果编译器允许我们在呼叫一个 function template时可以明白指定其</span></span><br><span class="line"><span class="comment">// 		template arguments，就定义__STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="comment">// (8) 如果编译器支持 template members of classes，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_MEMBER_TEMPLATES. </span></span><br><span class="line"><span class="comment">// (9) 如果编译器不支持关键词 explicit，就定义&#x27;explicit&#x27;为一个 null macro. </span></span><br><span class="line"><span class="comment">// (10) 如果编译器无法根据前一个 template parameters设定下一个 template </span></span><br><span class="line"><span class="comment">// 		parameters 的默认值，就定义__STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="comment">// (11) 如果编译器针对 non-type template parameters 执行 function template </span></span><br><span class="line"><span class="comment">// 		的自变量推导（argument deduction）时有问题，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_NON_TYPE_TMPL_PARAM_BUG. </span></span><br><span class="line"><span class="comment">// (12) 如果编译器无法支持迭代器的 operator-&gt;，就定义</span></span><br><span class="line"><span class="comment">// 		__SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="comment">// (13) 如果编译器（在你所选择的模式中）支持 exceptions，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_USE_EXCEPTIONS</span></span><br><span class="line"><span class="comment">// (14) 定义__STL_USE_NAMESPACES 可使我们自动获得 using std::list;之类的叙句</span></span><br><span class="line"><span class="comment">// (15) 如果本链接库由 SGI编译器来编译，而且使用者并未选择 pthreads </span></span><br><span class="line"><span class="comment">// 		或其它 threads，就定义__STL_SGI_THREADS. </span></span><br><span class="line"><span class="comment">// (16) 如果ᴀ链接库由一个 WIN32 编译器编译，并且在多绪模式下，就定义</span></span><br><span class="line"><span class="comment">// 		__STL_WIN32THREADS</span></span><br><span class="line"><span class="comment">// (17) 适当地定义与 namespace相关的 macros 如 __STD, __STL_BEGIN_NAMESPACE。</span></span><br><span class="line"><span class="comment">// (18) 适当地定义 exception 相关的 macros 如 __STL_TRY, __STL_UNWIND。</span></span><br><span class="line"><span class="comment">// (19) 根据__STL_ASSERTIONS是否定义，将 __stl_assert 定义为一个</span></span><br><span class="line"><span class="comment">// 		测试动作或一个 null macro。</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _PTHREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_PTHREADS </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__sgi) &amp;&amp; !defined(__GNUC__) </span></span><br><span class="line"><span class="comment">//使用 SGI STL但却不是使用 GNU C++ </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_BOOL) <span class="comment">//没有BOOL就定义</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_TYPENAME_IS_KEYWORD) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_EXPLICIT_IS_KEYWORD) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> (_COMPILER_VERSION &gt;= 721) &amp;&amp; defined(_NAMESPACES)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; !defined(__STL_PTHREADS) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_SGI_THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"># ifdef__GNUC__</span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;_G_config.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC__ &lt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 8) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_STATIC_TEMPLATE_MEMBER_BUG </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> <span class="comment">// 这里可看出 GNUC 2.8+ 的能力</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_FUNCTION_TMPL_PARTIAL_ORDER</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_EXPLICIT_FUNCTION_TMPL_ARGS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">/* glibc pre 2.0 is very buggy. We have to disable thread for it. </span></span><br><span class="line"><span class="comment"> It should be upgraded to glibc 2.0 or later. */</span> </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> !defined(_NOTHREADS) &amp;&amp; __GLIBC__ &gt;= 2 &amp;&amp; defined(_G_USING_THUNKS) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_PTHREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__SUNPRO_CC) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__COMO__) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_MEMBER_TEMPLATES </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACES </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">//侯捷注：VC6的版ᴀ号码是 1200 </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(_MSC_VER) </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> _MSC_VER &gt; 1000 </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;yvals.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="comment">//此文件在 MSDEV\VC98\INCLUDE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_BOOL</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NO_DRAND48 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> _MSC_VER &lt; 1100 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _CPPUNWIND </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _MT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_WIN32THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">//侯捷注：Inprise Borland C++builder也定义有此常数。</span></span><br><span class="line"><span class="comment">// C++Builder 的表现岂有如下所示这般差劲？</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__BORLANDC__) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NO_DRAND48 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _CPPUNWIND </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __MT__ </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_WIN32THREADS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_NEED_BOOL) </span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">int</span> <span class="type">bool</span>; </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> true 1 </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> false 0 </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_TYPENAME </span></span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> typename<span class="comment">//侯捷：难道不该 #define typename class 吗？</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_NEED_EXPLICIT </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> explicit</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"># ifdef__STL_EXPLICIT_FUNCTION_TMPL_ARGS</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NULL_TMPL_ARGS<span class="string">&lt;&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NULL_TMPL_ARGS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line">第 <span class="number">1</span> 章 STL 概论与版ᴀ简介</span><br><span class="line"># ifdef__STL_CLASS_PARTIAL_SPECIALIZATION</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TEMPLATE_NULLtemplate<span class="string">&lt;&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TEMPLATE_NULL </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// __STL_NO_NAMESPACES is a hook so that users can disable namespaces </span></span><br><span class="line"><span class="comment">// without having to edit library headers. </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__STL_USE_NAMESPACES) &amp;&amp; !defined(__STL_NO_NAMESPACES) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD std </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_NAMESPACE namespacestd &#123; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_NAMESPACE &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_USE_NAMESPACE_FOR_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE namespace std &#123; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD_RELOPS std </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> __STL_USE_NAMESPACE_FOR_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_BEGIN_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_END_RELOPS_NAMESPACE </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STD_RELOPS </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TRY try </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CATCH_ALL catch(...) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_RETHROWthrow </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NOTHROWthrow() </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_UNWIND(action) catch(...) &#123; action; throw; &#125; </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_TRY </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_CATCH_ALL <span class="keyword">if</span> (false) </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_RETHROW </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_NOTHROW </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __STL_UNWIND(action) </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_ASSERTIONS </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr) \ </span></span><br><span class="line"> <span class="keyword">if</span> (!(expr)) &#123;<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%s:%d STL assertion failure: %s\n&quot;</span>, \ </span><br><span class="line"> __FILE__, __LINE__,<span class="meta"># expr);abort(); &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __stl_assert(expr) </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_CONFIG_H */</span> </span></span><br><span class="line"><span class="comment">// Local Variables: </span></span><br><span class="line"><span class="comment">// mode:C++ </span></span><br><span class="line"><span class="comment">// End:</span></span><br></pre></td></tr></table></figure>

<p>下面这个小程序，用来测试 <strong>GCC</strong> 的常数设定：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config.cpp </span></span><br><span class="line"><span class="comment">// test configurations defined in &lt;stl_config.h&gt; </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// which included &lt;stl_algobase.h&gt;, </span></span></span><br><span class="line"><span class="comment">// and then &lt;stl_config.h&gt; </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__sgi) </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__sgi&quot;</span> &lt;&lt; endl; <span class="comment">// none! </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined(__GNUC__) </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__GNUC__&quot;</span> &lt;&lt; endl; <span class="comment">// __GNUC__ </span></span><br><span class="line"> cout &lt;&lt; __GNUC__ &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; __GNUC_MINOR__ &lt;&lt; endl; <span class="comment">// 2 91 </span></span><br><span class="line"> <span class="comment">// cout &lt;&lt; __GLIBC__ &lt;&lt; endl; // __GLIBC__ undeclared </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 2 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_NO_DRAND48 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_NO_DRAND48 defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_NO_DRAND48 undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 3 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_STATIC_TEMPLATE_MEMBER_BUG undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 5 </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION defined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;__STL_CLASS_PARTIAL_SPECIALIZATION undefined&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// case 6 </span></span><br><span class="line">...以下写法类似。详见文件 config.cpp（可自侯捷网站下载）。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下，由此可窥见 GCC 对各种 C++特性的支持程度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__GNUC__ </span><br><span class="line">2 91 </span><br><span class="line">__STL_NO_DRAND48 undefined </span><br><span class="line">__STL_STATIC_TEMPLATE_MEMBER_BUG undefined </span><br><span class="line">__STL_CLASS_PARTIAL_SPECIALIZATION defined </span><br><span class="line">__STL_FUNCTION_TMPL_PARTIAL_ORDER defined </span><br><span class="line">__STL_EXPLICIT_FUNCTION_TMPL_ARGS defined </span><br><span class="line">__STL_MEMBER_TEMPLATES defined </span><br><span class="line">__STL_LIMITED_DEFAULT_TEMPLATES undefined </span><br><span class="line">__STL_NON_TYPE_TMPL_PARAM_BUG undefined </span><br><span class="line">__SGI_STL_NO_ARROW_OPERATOR undefined </span><br><span class="line">__STL_USE_EXCEPTIONS defined </span><br><span class="line">__STL_USE_NAMESPACES undefined </span><br><span class="line">__STL_SGI_THREADS undefined </span><br><span class="line">__STL_WIN32THREADS undefined </span><br><span class="line">__STL_NO_NAMESPACES undefined </span><br><span class="line">__STL_NEED_TYPENAME undefined </span><br><span class="line">__STL_NEED_BOOL undefined </span><br><span class="line">__STL_NEED_EXPLICIT undefined </span><br><span class="line">__STL_ASSERTIONS undefined</span><br></pre></td></tr></table></figure>

<h2 id="C-一些特殊语法"><a href="#C-一些特殊语法" class="headerlink" title="C++ 一些特殊语法"></a>C++ 一些特殊语法</h2><h3 id="暂时对象产生与运用"><a href="#暂时对象产生与运用" class="headerlink" title="暂时对象产生与运用"></a>暂时对象产生与运用</h3><p>所谓暂时对象（临时对象），就是一种无名对象（unnamed objects）。它的出现如果不在程序员的预期之下（例如任何pass by value动作都会引发copy动作，于是形成一个暂时对象），往往造成效率上的负担。</p>
<p>有时候刻意制造一些暂时对象，却又是使程序干净清爽的技巧。刻意制造暂时对象的方法是，在型别名称之后直接加<strong>一对小括号</strong>，并可指定初值，例如Shape(3,5)或int(8)，其意义相当于<strong>唤起相应的constructor</strong>且<strong>不指定物件名称</strong> 。<br>STL 中将暂时对象技巧用于仿函式（functor）与算法搭配，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config-temporary-object.cpp </span></span><br><span class="line"><span class="comment">//ᴀ例测试仿函式用于 for_each() 的情形</span></span><br><span class="line"><span class="comment">// vc6[o] cb4[o] gcc[o] </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; elem)</span> <span class="comment">// operator() 多载化</span></span></span><br><span class="line"><span class="function"> </span>&#123; cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> ia[<span class="number">6</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;; </span><br><span class="line"> <span class="function">vector&lt; <span class="type">int</span> &gt; <span class="title">iv</span><span class="params">(ia, ia+<span class="number">6</span>)</span></span>; </span><br><span class="line"> <span class="comment">// print&lt;int&gt;() 是一个暂时对象，不是一个函式呼叫动作</span></span><br><span class="line"> for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="built_in">print</span>&lt;<span class="type">int</span>&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行便是产生「function template具现体」print<int>的一个暂时对象。这个对象将被传入for_each()之中起作用。当for_each()结束，这个暂时对象也就结束了它的生命。</p>
<h3 id="静态常量整数成员在类内直接初始化"><a href="#静态常量整数成员在类内直接初始化" class="headerlink" title="静态常量整数成员在类内直接初始化"></a>静态常量整数成员在类内直接初始化</h3><p>如果 class内含 const static <em>integral</em> data member，那么根据 C++标准规格，可以在class之内直接给予初值。所谓<em>integral</em>泛指所有整数型别，不单只是指int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 1config-inclass-init.cpp </span></span><br><span class="line"><span class="comment">// test in-class initialization of static const integral members </span></span><br><span class="line"><span class="comment">// ref. C++ Primer 3/e, p.643 </span></span><br><span class="line"><span class="comment">// vc6[x] cb4[o] gcc[o] </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// expedient </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> _datai = <span class="number">5</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> _datal = <span class="number">3L</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> _datac = <span class="string">&#x27;c&#x27;</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datai &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datal &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> cout &lt;&lt; testClass&lt;<span class="type">int</span>&gt;::_datac &lt;&lt; endl; <span class="comment">// c </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="increment-x2F-decrement-x2F-dereference运算子"><a href="#increment-x2F-decrement-x2F-dereference运算子" class="headerlink" title="increment&#x2F;decrement&#x2F;dereference运算子"></a>increment&#x2F;decrement&#x2F;dereference运算子</h3><p>increment &#x2F; dereference 运算子在迭代器的实作上占有非常重要的地位，因为任何一个迭代器都必须实作出前进（<em>increment</em>,operator++ ）和取值（<em>dereference</em>, operator*）功能，前者还分为前置式（prefix）和后置式（postfix）两种，有非常规律的写法。有些迭代器具备双向移动功能，那么就必须再提供 decrement 运算子（也分前置式和后置式两种）。</p>
<h3 id="前闭后开区间表示法"><a href="#前闭后开区间表示法" class="headerlink" title="前闭后开区间表示法[)"></a>前闭后开区间表示法[)</h3><p>任何STL 算法都需要获得由一对迭代器（泛型指针）所表示的区间，表示操作范围，这一对所表示的区间是前闭后开的，[first ,lasr) 表示 first 到 last - 1。迭代器 last 所指的是「最后一个元素的下一位置」。这种<em>off by one</em>（偏移一格，或说 <em>pass the end</em>）的标示法，带来许多方便。</p>
<h3 id="function-call-函数调用-运算子（operator-）"><a href="#function-call-函数调用-运算子（operator-）" class="headerlink" title="function call(函数调用) 运算子（operator()）"></a>function call(函数调用) 运算子（operator()）</h3><p>函式呼叫动作（C++ 语法中的左右小括号）也可以被多载化（重载）。许多STL算法都提供两个版本，一个用于<strong>一般状况</strong>（例如排序时以递增方式排列），一个用于<strong>特殊状况</strong>（例如排序时由使用者指定以何种特殊关系进行排列）。像这种情况，需要使用者指定某个条件或某个策略，而条件或策略的背后由一整组动作构成，便需要某种特殊的东西来代表这「一整组动作」。代表「一整组动作」的，当然是<strong>函式</strong>。过去 C语言时代，欲将函式当做参数传递，唯有透过函式指针（pointer to function，或称 function pointer）才能达成。<br>但是函数指针使用时有缺点：1. 无法持有自己的状态（所谓区域状态，local states）；2.无法达到组件技术中的可配接性（adaptability）—也就是无法再将某些修饰条件加诸于其上而改变其状态。</p>
<p>STL 算法的特殊版本所接受的所谓「条件」或「策略」或「一整组动作」，都以仿函式形式呈现。所谓仿函式（functor）就是使用起来像函式一样的东西。如果你针对某个 class 进行operator() 多载化，它就成为一个仿函式。</p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。</p>
<p>仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须<strong>重载 operator()</strong> 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p>
<p>使用：对类进行operator() 进行重载，这个类就是仿函数，可以通过编码使仿函数变为可配接的，对象当做函数名</p>
<p>优点：</p>
<ul>
<li>仿函数是对象，可以拥有成员函数和成员变量，即仿函数拥有状态(states)</li>
<li>每个仿函数都有自己的类型</li>
<li>仿函数通常比一般函数快（很多信息编译期确定）</li>
</ul>
<p>仿函数与函数指针相比的优势</p>
<ul>
<li>仿函数是一个类，是数据以及对数据操作的行为的集合，要成为仿函数必须重载<code>()</code>。函数指针是无法保存数据的，所以仿函数比函数指针功能更强，因为它<strong>可以保存数据</strong>，这一特性，是函数指针无法比拟的优势。</li>
</ul>
<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p><em>以STL 的运用角度而言，空间配置器是最不需要介绍的东西，它总是隐藏在一切组件（更具体地说是指容器，container）的背后，默默工作默默付出。但若以STL 的实作角度而言，第一个需要介绍的就是空间配置器，因为整个STL的操作对象（所有的数值）都存放在容器之内，而容器一定需要配置空间以置放数据。不先掌握空间配置器的原理，难免在观察其它 STL 组件的实作时处处遇到挡路石。</em></p>
<p><em>为什么不说allocator是内存配置器而说它是空间配置器呢？因为，空间不一定是内存，空间也可以是磁盘或其它辅助储存媒体。是的，你可以写一个 allocator，直接向硬盘取空间。以下介绍的是 SGI STL 提供的配置器，配置的对象，呃，是的，是内存 。</em></p>
<h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//各种type</span></span><br><span class="line">allocator::value_type </span><br><span class="line">allocator::pointer </span><br><span class="line">allocator::const_pointer </span><br><span class="line">allocator::reference </span><br><span class="line">allocator::const_reference </span><br><span class="line">allocator::size_type </span><br><span class="line">allocator::difference_type</span><br><span class="line">    </span><br><span class="line">allocator::rebind </span><br><span class="line"><span class="comment">//一个巢状的（nested）class template。class rebind&lt;U&gt;拥有唯一成员other，那是一个 typedef，代表allocator&lt;U&gt;。</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>() </span><br><span class="line"><span class="comment">//default constructor。//默认构造函数</span></span><br><span class="line">allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&amp;) </span><br><span class="line"><span class="comment">//copy constructor。//拷贝构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;allocator::<span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;U&gt;&amp;) </span><br><span class="line"><span class="comment">//泛化的copy constructor。//泛化的拷贝构造</span></span><br><span class="line">allocator::~<span class="built_in">allocator</span>() </span><br><span class="line"><span class="comment">//default constructor。//析构函数</span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回某个对象的地址。算式a.address(x)等同于&amp;x。//返回某个对象的地址</span></span></span><br><span class="line"><span class="function">const_pointer <span class="title">allocator::address</span><span class="params">(const_reference x)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回某个const对象的地址。算式a.address(x)等同于&amp;x。//返回某个const对象的地址</span></span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n, cosnt <span class="type">void</span>* = <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//配置空间，足以储存n个T对象。第二自变量是个提示。实作上可能会利用它来增进区域性（locality），或完全忽略之。</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p, size_type n)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//归还先前配置的空间。</span></span></span><br><span class="line"><span class="function">size_type <span class="title">allocator::max_size</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"><span class="comment">//传回可成功配置的最大量。</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::construct</span><span class="params">(pointer p, <span class="type">const</span> T&amp; x)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//等同于new(const void*) p) T(x)。//构造T对象</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocator::destroy</span><span class="params">(pointer p)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//等同于p-&gt;~T()。//对象T的析构</span></span></span><br></pre></td></tr></table></figure>

<h3 id="设计一个简单的空间配置器JJ-allocator"><a href="#设计一个简单的空间配置器JJ-allocator" class="headerlink" title="设计一个简单的空间配置器	JJ::allocator"></a>设计一个简单的空间配置器	JJ::allocator</h3><p>根据前述的标准介 面，我们可以自行完成一个 功能简单、介 面 不怎么齐全的allocator如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 2jjalloc.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _JJALLOC_ </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _JJALLOC_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// for placement new. </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span> <span class="comment">// for ptrdiff_t, size_t </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for exit() </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span> <span class="comment">// for UINT_MAX </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// for cerr </span></span></span><br><span class="line"><span class="keyword">namespace</span> JJ</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">//使用operator new 分配空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> T* _allocate(<span class="type">ptrdiff_t</span> size, T*) &#123; </span><br><span class="line"> <span class="built_in">set_new_handler</span>(<span class="number">0</span>); <span class="comment">//注释1</span></span><br><span class="line"> T* tmp = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));<span class="comment">//注释2 </span></span><br><span class="line"> <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123; </span><br><span class="line"> cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//使用operator delete回收空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _deallocate(T* buffer) &#123; </span><br><span class="line"> ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//在指定内存上构造一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _construct(T1* p, <span class="type">const</span> T2&amp; value) &#123; </span><br><span class="line"> <span class="keyword">new</span>(p) <span class="built_in">T1</span>(value); <span class="comment">// placement new. invoke ctor of T1. </span></span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//析构一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _destroy(T* ptr) &#123; </span><br><span class="line"> ptr-&gt;~<span class="built_in">T</span>(); </span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">//遵循allocator的标准定义相关结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> Tvalue_type; </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* const_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> ptrdiff_tdifference_type; </span><br><span class="line"><span class="comment">// rebind allocator of type U </span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> allocator&lt;U&gt; other; </span><br><span class="line"> &#125;; </span><br><span class="line"><span class="comment">// hint used for locality. ref.[Austern],p189 </span></span><br><span class="line"> <span class="built_in">pointerallocate</span>(size_type n, <span class="type">const</span> <span class="type">void</span>* hint=<span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> _allocate((difference_type)n, (pointer)<span class="number">0</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type n)</span> </span>&#123; _deallocate(p); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line">_construct(p, value); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;_destroy(p); &#125; </span><br><span class="line"> <span class="built_in">pointeraddress</span>(reference x) &#123; <span class="keyword">return</span> (pointer)&amp;x; &#125; </span><br><span class="line"> <span class="built_in">const_pointerconst_address</span>(const_reference x) &#123; </span><br><span class="line"> <span class="keyword">return</span> (const_pointer)&amp;x; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">size_typemax_size</span>() <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(UINT_MAX/<span class="built_in">sizeof</span>(T)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">&#125; <span class="comment">// end of namespace JJ </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _JJALLOC_</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释1：<strong>set_new_handler(0);</strong></p>
<p>new_handler，顾名思义就是一个处理程序，当程序向内存的分配请求无法满足时将有两种可能:</p>
<ol>
<li>抛出异常</li>
<li>设置一个异常处理函数，这就是所谓的new_handler（类似于中断机制，本质上来说就是一个函数指针）</li>
</ol>
<p>当第二种情况发生以后，我们可以通过new_handler删除无用的内存，以及设置新的new_handler，而这个set_new_handler就是来进行设置的。</p>
<p>set_new_handler(0)主要是为了卸载目前的内存分配异常处理函数，这样一来一旦分配内存失败的话，C++就会强制性抛出std:bad_alloc异常，而不是跑到处理某个异常处理函数去处理。</p>
</li>
<li><p>注释2：*<em>T <em>tmp&#x3D;(T</em>)(::operator new((size_t)(size</em>sizeof(T)))); **<code>::</code>访问符放到最前面的意思是使用全局版本，这个<code>operator new</code>就得好好说说。</p>
<p><strong>new 的三种形式</strong></p>
<ul>
<li>1.new operator (就是我们常用的new)</li>
<li>2.operator new</li>
<li>3.placement new</li>
</ul>
<p>我们在程序中使用new的时候，实际上做了两件事情：<br>一、申请内存<br>二、构造对象<br>简单的理解，new完成了一套比较完备的服务，而<code>operator new</code>，只是申请内存，<code>placement new</code>是在申请的内存中进行构造对象，第2、3中形式就是对new的拆分。</p>
</li>
</ul>
<p><strong>简单应用：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 2jjalloc.cpp </span></span><br><span class="line"><span class="comment">// VC6[o], BCB4[o], GCC2.9[x]. </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;jjalloc.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> ia[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; </span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> i; </span><br><span class="line"> vector&lt;<span class="type">int</span>,JJ::allocator&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">iv</span>(ia, ia+<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); i++) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具备次配置力（sub-allocation）的-SGI-空间配置器"><a href="#具备次配置力（sub-allocation）的-SGI-空间配置器" class="headerlink" title="具备次配置力（sub-allocation）的 SGI 空间配置器"></a>具备次配置力（sub-allocation）的 SGI 空间配置器</h2><p>SGI STL 的配置器与众不同 ， 也与标准规范不同，其名称是alloc而非allocator，而且不接受任何自变量。换句话说如果你要在程序中明白采用SGI 配置器，不能采用标准写法：<code>vector&lt;int,**std::allocator&lt;int&gt;** &gt; iv;// in VC or CB</code>。</p>
<p>必须这么写：<code>vector&lt;int,**std::alloc**&lt;int&gt;&gt; iv; // in GCC </code></p>
<p>SGI STL allocator᳾能符合标准规格，这个事实通常不会对我们带来困扰，因为通常我们使用预设的空间配置器，很少需要自行指定配置器名称，而SGI STL的每一个容器都已经指定其预设的空间配置器为alloc。</p>
<h3 id="SGI-标准的空间配置器std-allocator"><a href="#SGI-标准的空间配置器std-allocator" class="headerlink" title="SGI 标准的空间配置器	std::allocator"></a>SGI 标准的空间配置器	std::allocator</h3><p>虽然 SGI 也定义有一个符合部份标准、名为allocator的配置器，但SGI自己从未用过它，也不建议我们使用。主要原因是效率不彰，只把 C++的::operator new和::operator delete做一层薄薄的包装而已。</p>
<h3 id="SGI-特殊的空间配置器std-alloc"><a href="#SGI-特殊的空间配置器std-alloc" class="headerlink" title="SGI 特殊的空间配置器	std::alloc"></a>SGI 特殊的空间配置器	std::alloc</h3><p>allocator只是基层内存配置&#x2F;解放行为（也就是::operator new和::operator delete）的一层薄薄包装，并没有考虑到任何效率上的强化。SGI 另有法宝供本身内部使用。</p>
<p>一般而言，我们所习惯的 C++ 内存配置动作和释放动作是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123; ... &#125;; </span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;<span class="comment">//配置内存，然后建构对象</span></span><br><span class="line"><span class="keyword">delete</span> pf; <span class="comment">//将对象解构，然后释放内存</span></span><br></pre></td></tr></table></figure>

<p>这其中的 new算式内含两阶段动作：</p>
<ul>
<li><p>(1) 呼叫::operator new配置内存；</p>
</li>
<li><p>(2) 呼叫Foo::Foo()建构对象内容。</p>
</li>
</ul>
<p>delete算式也内含两阶段动作：</p>
<ul>
<li><p>(1)呼叫 Foo::~Foo()将对象解构；</p>
</li>
<li><p>(2)呼叫::operator delete释放内存。</p>
</li>
</ul>
<p>为了精密分工，STL allocator决定将这两阶段动作区分开来。内存配置动作由alloc:allocate()负责，内存释放动作由alloc::deallocate()负责；对象建构动作由::construct()负责，对象解构动作由::destroy()负责。</p>
<p>STL标准规格告诉我们，配置器定义于<memory>之中，SGI <memory>内含以下两个文件：</p>
<p>#include &lt;stl_alloc.h&gt; &#x2F;&#x2F;负责内存空间的配置与释放</p>
<p>#include &lt;stl_construct.h&gt; &#x2F;&#x2F;负责对象内容的建构与解构</p>
<p>内存空间的配置&#x2F;释放与对象内容的建构&#x2F;解构，分别着落在这两个文件身上。其中&lt;stl_construct.h&gt;定义有两个基本函数：建构用的 construct()和解构用的destroy()。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/STL_memory%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="image-20220621205109870"></p>
<h3 id="建构和解构基本工具：construct-和-destroy"><a href="#建构和解构基本工具：construct-和-destroy" class="headerlink" title="建构和解构基本工具：construct() 和 destroy()"></a>建构和解构基本工具：construct() 和 destroy()</h3><p>下面是&lt;stl_construct.h&gt; 的部份内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new.h&gt;</span> <span class="comment">//欲使用placement new，需先含入此文件</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123; </span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T1</span>(value); <span class="comment">//placement new;唤起 T1::T1(value); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是 destroy()第一版本，接受一个指标。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span> </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line">pointer-&gt;~<span class="built_in">T</span>(); <span class="comment">//唤起 dtor ~T() </span></span><br><span class="line"><span class="comment">//以下是 destroy()第二版本，接受两个迭代器。此函式设法找出元素的数值型别，</span></span><br><span class="line"><span class="comment">//进而利用 __type_traits&lt;&gt;求取最适当措施。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123; </span><br><span class="line">__destroy(first, last, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//判断元素的数值型别（value type）是否有trivial destructor </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; </span><br><span class="line">__destroy_aux(first, last, <span class="built_in">trivial_destructor</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果元素的数值型别（value type）有non-trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123; </span><br><span class="line"> <span class="keyword">for</span> ( ; first &lt; last; ++first) </span><br><span class="line"><span class="built_in">destroy</span>(&amp;*first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果元素的数值型别（value type）有trivial destructor…</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125; </span><br><span class="line"><span class="comment">//以下是 destroy()第二版本针对迭代器为 char*和 wchar_t*的特化版</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123;&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/construct()%E5%92%8Cdrestroy()%E7%A4%BA%E6%84%8F.png" alt="image-20220621211422260"></p>
<p>这两个做为建构、解构之用的函式被设计为全域函式，符合 STL 的规范。此外STL 还规定配置器必须拥有名为 construct()和destroy()的两个成员函式，然而真正在 SGI STL 中大显身手的那个名为 std::alloc 的配置器并未遵守此一规则。</p>
<p>上述construct()接受一个指标p和一个初值value，此函式的用途就是将初值设定到指标所指的空间上。C++ 的placement new运算子可用来完成此一 任务。</p>
<p>destroy()有两个版本，第一版本接受一个指标，准备将该指标所指之物解构掉。 这很简单，直接呼叫该对象的解构式即可。第二版本接受first和last两个迭代器（所谓迭代器，第三章有详细介绍），准备将[first,last)范围内的所有物件解构掉。我们不知道这个范围有多大，万一很大，而每个物件的解构式都无关痛痒（所谓 <em>trivial</em>destructor），那么一次次呼叫这些无关痛痒的解构式，对效率是一种蕲伤。</p>
<p>因此，这里首先利用value_type()获得迭代器所指物件的型别， 再利用 <code>__type_traits&lt;T&gt;</code> 判别该型别的解构式是否无关痛痒 。若是（<code>__true_type</code>），什么也不做就结束；若否（<code>__false_type</code>），这才以循环方式巡访整个范围，并在循环中每经历一个对象就呼叫第一个版本的 destroy()。</p>
<h3 id="空间的配置与释放std-alloc"><a href="#空间的配置与释放std-alloc" class="headerlink" title="空间的配置与释放	std::alloc"></a>空间的配置与释放	std::alloc</h3><p>看完了内存配置后的对象建构行为，和内存释放前的对象解构行为，现在我们来看看内存的配置和释放。</p>
<p>对象建构前的空间配置，和对象解构后的空间释放，由&lt;stl_alloc.h&gt;负责，SGI 对此的设计哲学如下： </p>
<ul>
<li>向 system heap要求空间。</li>
<li>考虑多绪（multi-threads）状态。</li>
<li>考虑内存不足时的应变措施。</li>
<li>考虑过多「小型区块」可能造成的内存破碎（fragment）问题。</li>
</ul>
<p><em>为了将问题控制在一定的复杂度内，以下的讨论以及所摘录的源码，皆排除多绪状态的处理。</em></p>
<p>C++的记忆体配置基本动作是::operator new() ，记忆体释放基本动作是::operator delete()。这两个全域函式相当于 C 的 malloc()和 free() 函式。是的，正是如此，SGI 正是以malloc() 和free() 完成内存的配置与释放。</p>
<p>考虑小型区块所可能造成的内存破碎问题，SGI 设计了双层级配置器，第一级配置器直接使用 malloc()和free()，第二级配置器则视情况采用不同的策略：</p>
<ul>
<li><p>当配置区块超过128bytes，视之为「足够大」，便呼叫第一级配置器；</p>
</li>
<li><p>当配置区块小于 128bytes，视之为「过小」，为了降低额外负担（overhead），便采用复杂的memory pool整理方式，而不再求助于第一级配置器。整个设计究竟只开放第一级配置器，或是同时开放第二级配置器，取决于<code>__USE_MALLOC</code>是否被定义（可以轻易测试出来，SGI STL 并未定义<code>__USE_MALLOC</code>）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_MALLOC </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc; </span><br><span class="line"><span class="keyword">typedef</span> malloc_alloc alloc; <span class="comment">//令 alloc为第一级配置器</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line">... </span><br><span class="line"><span class="comment">//令 alloc 为第二级配置器</span></span><br><span class="line"><span class="keyword">typedef</span> __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, <span class="number">0</span>&gt; alloc; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ! __USE_MALLOC */</span></span></span><br></pre></td></tr></table></figure>

<p>其 中 <code>__malloc_alloc_template</code>就 是 第 一 级 配 置 器 ，<code> __default_alloc__template</code>就是第二级配置器。再次提醒，<strong>alloc</strong>并不接受任何 template 型别参数。</p>
</li>
</ul>
<p>无论<strong>alloc</strong>被定义为第一级或第二级配置器，SGI 还为它再包装一个接口如下，使配置器的接口能够符合 STL规格：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span> (T)); &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其内部四个成员函式其实都是单纯的转呼叫，呼叫传入之配置器（可能是第一级，也可能是第二级）的成员函式。这个接口使配置器的配置单位从 bytes转为个别元素的大小（sizeof(T)）。SGI STL 容器全都使用这个 simple_alloc 接口，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, classAlloc = alloc&gt; <span class="comment">// 预设使用 alloc为配置器</span></span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt;data_allocator; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (...) </span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start); </span><br><span class="line"> &#125; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一、二级配置器的关系，接口包装，及实际运用方式，可于下图略见端倪。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%AC%AC%E4%B8%80%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8%E4%B8%8E%E7%AC%AC%E4%BA%8C%E7%BA%A7%E9%85%8D%E7%BD%AE%E5%99%A8.png" alt="image-20220621214155381"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E9%85%8D%E7%BD%AE%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%92%8C%E8%BF%90%E7%94%A8%E6%96%B9%E5%BC%8F.png" alt="image-20220622142742725"></p>
<h3 id="第一级配置器-malloc-alloc-template"><a href="#第一级配置器-malloc-alloc-template" class="headerlink" title="第一级配置器	__malloc_alloc_template"></a>第一级配置器	__malloc_alloc_template</h3><p>第一级配置器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0 </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;new&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __THROW_BAD_ALLOC throw bad_alloc </span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> !defined(__THROW_BAD_ALLOC) </span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __THROW_BAD_ALLOC cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; exit(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// malloc-based allocator. 通常比稍后介绍的 default alloc 速度慢，</span></span><br><span class="line"><span class="comment">//一般而言是 thread-safe，并且对于空间的运用比较高效（efficient）。</span></span><br><span class="line"><span class="comment">//以下是第一级配置器。</span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」。至于「非型别参数」inst，完全没派上用场。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">//以下都是函式指标，所代表的函式将用来处理内存不足的情况。</span></span><br><span class="line"><span class="comment">// oom : out of memory. </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">void</span> *result =<span class="built_in">malloc</span>(n);<span class="comment">//第一级配置器直接使用 malloc() </span></span><br><span class="line"> <span class="comment">// 以下，无法满足需求时，改用 oom_malloc() </span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_malloc</span>(n); </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//第一级配置器直接使用 free() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">void</span> * result =<span class="built_in">realloc</span>(p, new_sz);<span class="comment">//第一级配置器直接使用 realloc() </span></span><br><span class="line"> <span class="comment">// 以下，无法满足需求时，改用 oom_realloc() </span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == result) result = <span class="built_in">oom_realloc</span>(p, new_sz); </span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以下模拟 C++的 set_new_handler(). 换句话说，你可以透过它，</span></span><br><span class="line"><span class="comment">//指定你自己的 out-of-memory handler </span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">void</span> (* old)() = __malloc_alloc_oom_handler; </span><br><span class="line">__malloc_alloc_oom_handler = f; </span><br><span class="line"> <span class="keyword">return</span>(old); </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="comment">//初值为 0。有待客端设定。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="built_in">void</span> (* my_malloc_handler)(); </span><br><span class="line"> <span class="type">void</span> *result; </span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//不断尝试释放、配置、再释放、再配置…</span></span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; </span><br><span class="line"> (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。</span></span><br><span class="line"> result = <span class="built_in">malloc</span>(n); <span class="comment">//再次尝试配置内存。</span></span><br><span class="line"> <span class="keyword">if</span> (result) <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="built_in">void</span> (* my_malloc_handler)(); </span><br><span class="line"> <span class="type">void</span> *result; </span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//不断尝试释放、配置、再释放、再配置…</span></span><br><span class="line">my_malloc_handler = __malloc_alloc_oom_handler; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; </span><br><span class="line"> (*my_malloc_handler)();<span class="comment">//呼叫处理例程，企图释放内存。</span></span><br><span class="line"> result = <span class="built_in">realloc</span>(p, n);<span class="comment">//再次尝试配置内存。</span></span><br><span class="line"> <span class="keyword">if</span> (result) <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//注意，以下直接将参数 inst指定为 0。</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>

<p>第一级配置器以malloc(), free(), realloc()等 C函式执行实际的内存配置、释放、重配置动作，并实作出类似 C++ new-handler的机制。它不能直接运用 C++ new-handler机制，因为它并非使用::operatornew来配置内存。</p>
<p>所谓 C++ new handler 机制是，你可以要求系统在内存配置需求无法被满足时，唤起一个你所指定的函式。换句话说一旦::operator new无法达成任务，在丢出<em>std::bad_alloc</em>异常状态之前，会先呼叫由客端指定的处理例程。此处理例程通常即被称为 new-handler。</p>
<h3 id="第二级配置器-default-alloc-template"><a href="#第二级配置器-default-alloc-template" class="headerlink" title="第二级配置器	__default_alloc_template"></a>第二级配置器	__default_alloc_template</h3><p>第二级配置器多了一些机制，避免太多小额区块造成内存的破碎。小额区块带来的其实不仅是内存破碎而已，配置时的额外负担（overhead）也是一大问题。额外负担永远无法避免，毕竟系统要靠这多出来的空间来管理内存，但是区块愈小，额外负担所占的比例就愈大、愈显得浪费。 额外负担图示如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9D%97%E9%A2%9D%E5%A4%96%E8%B4%9F%E6%8B%85.png" alt="image-20220622143926124"></p>
<p>SGI第二级配置器的作法是，如果区块够大，超过 128 bytes，就移交第一级配置器处理。当区块<strong>小于 128 bytes</strong>，则以<strong>记忆池（memory pool）</strong>管理，此法又称为次层配置（sub-allocation）：每次配置一大块内存，并维护对应之自由串行（<em>free-list</em>）。下次若再有相同大小的内存需求，就直接从<em>free-lists</em>中拨出。如果客端释还小额区块，就由配置器回收到<em>free-lists</em>中—配置器除了负责配置，也负责回收。为了方便管理，SGI第二级配置器会主动将任何小额区块的内存需求量上调至8的倍数（例如客端要求 30 bytes，就自动调整为 32 bytes），并维护 16 个 <em>free-lists</em>，各自管理大小分别为 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128 bytes的小额区块。<em>free-lists</em> 的节点结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unionobj &#123; </span><br><span class="line"> <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link; </span><br><span class="line"> <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span> </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>或许会想，为了维护串行（lists），每个节点需要额外的指标（指向下一个节点），这不又造成另一种额外负担吗？这个顾虑是对的，但早已有好的解决办法。注意，上述obj所用的是union（联合），由于union之故，从其第一字段观之，obj可被视为一个指标，指向相同形式的另一个obj。从其第二字段观之，obj可被视为一个指标，指向实际区块，如下图。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%87%AA%E7%94%B1%E4%B8%B2%E8%A1%8C%E5%AE%9E%E4%BD%9C%E6%8A%80%E5%B7%A7.png" alt="image-20220622145056139"></p>
<p>一物二用的结果是，不会为了维护串行所必须的指针而造成内存的另一种浪费。这种技巧在强型（strongly typed）语言如 Java 中行不通，但是在非强型语言如 C++ 中十分普遍</p>
<p>注：<strong>Union</strong>在C++内存模型，可以理解为一块“共享内存”(不是多线（进）程概念中的共享内存)。Union开辟的大小，是其内部定义的所有元素中最大的元素。“联合”是一种特殊的类，也是一种构造类型的数据结构。在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，已达到节省空间的目的（还有一个节省空间的类型：位域）。 这是一个非常特殊的地方，也是联合的特征。这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。</p>
<p>第二级配置器的部份实作内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;<span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;<span class="comment">//free-lists个数</span></span><br><span class="line"><span class="comment">//以下是第二级配置器。</span></span><br><span class="line"><span class="comment">//注意，无「template 型别参数」，且第二参数完全没派上用场。</span></span><br><span class="line"><span class="comment">//第一参数用于多绪环境下。本书不讨论多绪环境。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> <span class="comment">// ROUND_UP() 将 bytes上调至 8的倍数。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>)); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> unionobj &#123; <span class="comment">//free-lists 的节点构造</span></span><br><span class="line"> <span class="keyword">union</span> <span class="title class_">obj</span> * free_list_link; </span><br><span class="line"> <span class="type">char</span> client_data[<span class="number">1</span>]; <span class="comment">/* The client sees this. */</span> </span><br><span class="line"> &#125;; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="comment">// 16 个 free-lists </span></span><br><span class="line"> <span class="type">static</span> obj * volatilefree_list[__NFREELISTS]; </span><br><span class="line"><span class="comment">// 以下函式根据区块大小，决定使用第 n号 free-list。n 从 1 起算。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>); </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 传回一个大小为 n的对象，并可能加入大小为 n的其它区块到free list. </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>; </span><br><span class="line"><span class="comment">// 配置一大块空间，可容纳 nobjs 个大小为 &quot;size&quot; 的区块。</span></span><br><span class="line"> <span class="comment">// 如果配置 nobjs个区块有所不便，nobjs可能会降低。</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>; </span><br><span class="line"> <span class="comment">// Chunk allocation state. </span></span><br><span class="line"> <span class="type">static</span> <span class="type">char</span> *start_free;<span class="comment">//记忆池起始位置。只在 chunk_alloc()中变化</span></span><br><span class="line"> <span class="type">static</span> <span class="type">char</span> *end_free;<span class="comment">//记忆池结束位置。只在 chunk_alloc()中变化</span></span><br><span class="line"> <span class="type">static</span> <span class="type">size_t</span> heap_size; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后 */</span> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span> </span>&#123; <span class="comment">/* 详述于后 */</span> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//以下是 static data member 的定义与初值设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line">size_t__default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj *<span class="keyword">volatile</span> </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = </span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="空间配置函式-allocate"><a href="#空间配置函式-allocate" class="headerlink" title="空间配置函式	 allocate()"></a>空间配置函式	 allocate()</h3><p>身为一个配置器，__default_alloc_template 拥有配置器的标准介面函式allocate()。此函式首先判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就检查对应的 <em>free list</em>。如果<em>free list</em>之内有可用的区块，就直接拿来用，如果没有可用区块，就将区块大小上调至 8 倍数边界，然后呼叫refill()，准备为 <em>free list</em> 重新填充空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n must be &gt; 0 </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line"> obj * result; </span><br><span class="line"><span class="comment">// 大于 128 就呼叫第一级配置器</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) </span><br><span class="line"> <span class="keyword">return</span>(malloc_alloc::<span class="built_in">allocate</span>(n)); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 寻找 16 个 free lists 中适当的一个</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"> result = *my_free_list; </span><br><span class="line"> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 没找到可用的 free list，准备重新填充 free list</span></span><br><span class="line"> <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n)); </span><br><span class="line"> <span class="keyword">return</span> r; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 调整 free list</span></span><br><span class="line"><span class="comment">//下节详述</span></span><br><span class="line"> *my_free_list = result -&gt; free_list_link; </span><br><span class="line"> <span class="keyword">return</span> (result); </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>区块自<em>free list</em>拨出的操作如下图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8C%BA%E5%9D%97%E8%87%AAfreelist%E8%B0%83%E5%87%BA.png" alt="image-20220622150916002"></p>
<h3 id="空间释还函式-deallocate"><a href="#空间释还函式-deallocate" class="headerlink" title="空间释还函式	 deallocate()"></a>空间释还函式	 deallocate()</h3><p>身为一个配置器，__default_alloc_template 拥有配置器标准介面函式deallocate()。此函式首先判断区块大小，大于 128 bytes 就呼叫第一级配置器，小于 128 bytes 就找出对应的 <em>free list</em>，将区块回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 不可以是 0 </span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> obj *q = (obj *)p; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list; </span><br><span class="line"><span class="comment">// 大于 128 就呼叫第一级配置器</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) &#123; </span><br><span class="line">malloc_alloc::<span class="built_in">deallocate</span>(p, n); </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 寻找对应的 free list</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"><span class="comment">// 调整 free list，回收区块</span></span><br><span class="line"> q -&gt; free_list_link = *my_free_list; </span><br><span class="line"> *my_free_list = q; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>区块回收纳入<em>free list</em>的动作，如下图</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8C%BA%E5%9D%97%E5%9B%9E%E6%94%B6%E7%BA%B3%E5%85%A5freelist.png" alt="image-20220622151423842"></p>
<h3 id="重新充填-free-lists"><a href="#重新充填-free-lists" class="headerlink" title="重新充填 	free lists"></a>重新充填 	<em>free list</em>s</h3><p>讨论先前说过的 allocate()。当它发现<em>free list</em>中没有可用区块了，就呼叫refill() 准备为<em>free list</em>重新填充空间。新的空间将取自内存池（经由chunk_alloc()完成）。预设取得20个新节点（新区块），但万一内存池空间不足，获得的节点数（区块数）可能小于 20：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传回一个大小为 n的对象，并且有时候会为适当的freelist增加节点. </span></span><br><span class="line"><span class="comment">//假设 n已经适当上调至 8的倍数。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> nobjs = <span class="number">20</span>; </span><br><span class="line"><span class="comment">// 呼叫 chunk_alloc()，尝试取得 nobjs个区块做为 free list的新节点。</span></span><br><span class="line"> <span class="comment">// 注意参数 nobjs是pass by reference。</span></span><br><span class="line"> <span class="type">char</span> * chunk =<span class="built_in">chunk_alloc</span>(n, nobjs); <span class="comment">//下节详述</span></span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list; </span><br><span class="line"> obj * result; </span><br><span class="line"> obj * current_obj, * next_obj; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"><span class="comment">// 如果只获得一个区块，这个区块就拨给呼叫者用，free list无新节点。</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk); </span><br><span class="line"><span class="comment">// 否则准备调整 free list，纳入新节点。</span></span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n); </span><br><span class="line"><span class="comment">// 以下在 chunk空间内建立freelist</span></span><br><span class="line"> result = (obj *)chunk; <span class="comment">//这一块准备传回给客端</span></span><br><span class="line"><span class="comment">// 以下导引 free list指向新配置的空间（取自内存池）</span></span><br><span class="line"> *my_free_list = next_obj = (obj *)(chunk + n); </span><br><span class="line"><span class="comment">// 以下将 free list 的各节点串接起来。</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;<span class="comment">//从 1 开始，因为第 0 个将传回给客端</span></span><br><span class="line"> current_obj = next_obj; </span><br><span class="line"> next_obj = (obj *)((<span class="type">char</span> *)next_obj + n); </span><br><span class="line"> <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123; </span><br><span class="line"> current_obj -&gt; free_list_link = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> current_obj -&gt; free_list_link = next_obj; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存池（memory-pool）"><a href="#内存池（memory-pool）" class="headerlink" title="内存池（memory pool）"></a>内存池（memory pool）</h3><p>从记忆池中取空间给<em>free list</em>使用，是 chunk_alloc()的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设 size 已经适当上调至 8的倍数。</span></span><br><span class="line"><span class="comment">//注意参数 nobjs是pass by reference。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt; </span><br><span class="line"><span class="type">char</span>* </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line"><span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">char</span> * result; </span><br><span class="line"> <span class="type">size_t</span> total_bytes = size * nobjs; </span><br><span class="line"> <span class="type">size_t</span> bytes_left = end_free - start_free;<span class="comment">// 内存池剩余空间</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间完全满足需求量。</span></span><br><span class="line"> result = start_free; </span><br><span class="line"> start_free += total_bytes;</span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间不能完全满足需求量，但足够供应一个（含）以上的区块。</span></span><br><span class="line"> nobjs = bytes_left/size; </span><br><span class="line"> total_bytes = size * nobjs; </span><br><span class="line"> result = start_free; </span><br><span class="line"> start_free += total_bytes; </span><br><span class="line"> <span class="keyword">return</span>(result); </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 内存池剩余空间连一个区块的大小都无法提供。</span></span><br><span class="line"> <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>); </span><br><span class="line"><span class="comment">// 以下试着让内存池中的残余零头还有利用价值。</span></span><br><span class="line"> <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 内存池内还有一些零头，先配给适当的 free list，因为其他free list区块可能更小</span></span><br><span class="line"><span class="comment">// 首先寻找适当的 free list。</span></span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list = </span><br><span class="line"> free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left); </span><br><span class="line"><span class="comment">// 调整 free list，将内存池中的残余空间编入。</span></span><br><span class="line"> ((obj *)start_free) -&gt; free_list_link = *my_free_list; </span><br><span class="line"> *my_free_list = (obj *)start_free; </span><br><span class="line"> &#125;</span><br><span class="line">     <span class="comment">// 配置 heap 空间</span></span><br><span class="line"> start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get); </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123; </span><br><span class="line"><span class="comment">// heap 空间不足，malloc() 失败。</span></span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> obj * <span class="keyword">volatile</span> * my_free_list, *p; </span><br><span class="line"><span class="comment">// 试着检视我们手上拥有的东西。这不会造成伤害。我们不打算尝试配置</span></span><br><span class="line"> <span class="comment">// 较小的区块，因为那在多行程（multi-process）机器上容易导致灾难</span></span><br><span class="line"><span class="comment">// 以下搜寻适当的 free list，</span></span><br><span class="line"> <span class="comment">// 所谓适当是指「尚有未用区块，且区块够大」之 free list。</span></span><br><span class="line"> <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; </span><br><span class="line"> my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i); </span><br><span class="line"> p = *my_free_list; </span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;<span class="comment">//free list 内尚有未用区块。</span></span><br><span class="line"> <span class="comment">// 调整 free list以释出未用区块</span></span><br><span class="line"> *my_free_list = p -&gt; free_list_link; </span><br><span class="line"> start_free = (<span class="type">char</span> *)p; </span><br><span class="line"> end_free = start_free + i; </span><br><span class="line"><span class="comment">// 递归呼叫自己，为了修正 nobjs。</span></span><br><span class="line"> <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); </span><br><span class="line"><span class="comment">// 注意，任何残余零头终将被编入适当的 free-list中备用。</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> end_free = <span class="number">0</span>; <span class="comment">// 如果出现意外（山穷水尽，到处都没内存可用了）</span></span><br><span class="line"><span class="comment">// 呼叫第一级配置器，看看out-of-memory机制能否尽点力</span></span><br><span class="line"> start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get); </span><br><span class="line"><span class="comment">// 这会导致掷出异常（exception），或内存不足的情况获得改善。</span></span><br><span class="line">     &#125; </span><br><span class="line"> heap_size += bytes_to_get; </span><br><span class="line"> end_free = start_free + bytes_to_get; </span><br><span class="line"> <span class="comment">// 递归呼叫自己，为了修正 nobjs。</span></span><br><span class="line"> <span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的 chunk_alloc()函式以end_free - start_free 来判断内存池的“水量”。如果水量<strong>充足</strong>，就直接拨出 20 个区块传回给 <em>free list</em>。如果水量不足以提供 20 个区块，但还足够供应<strong>一个以上的区块</strong>，就拨出这不足20个区块的空间出去。这时候其pass by reference 的 nobjs 参数将被修改为实际能够供应的区块数。如果内存池连一个区块空间都无法供应，对客端显然无法交待，此时便需利用malloc() <strong>从 heap 中配置内存</strong>，为内存池注入活水源头以应付需求。新水量的大小为需求量的两倍，再加上一个随着配置次数增加而愈来愈大的附加量。</p>
<p>一个例子见下图，假设程序一开始，客端就呼叫chunk_alloc(32,20)，于是malloc()配置 40个 32bytes区块，其中第 1 个交出，另 19 个交给free_list[3] 维护，余20个留给内存池。接下来客端呼叫chunk_alloc(64,20)，此时free_list[7] 空空如也，必须向内存池要求支持。内存池只够供应 (32*20)&#x2F;64&#x3D;10 个 64bytes区块，就把这 10 个区块传回，第 1 个交给客端，余 9个由 free_list[7] 维护。此时内存池全空。接下来再呼叫chunk_alloc(96, 20)，此时 free_list[11] 空空如也，必须向内存池要求支持，而内存池此时也是空的，于是以malloc()配 置 40+n（附加量）个 96bytes 区块，其中第 1 个交出，另 19 个交给 free_list[11] 维护，余 20+n（附加量）个区块留给内存池……。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%86%85%E5%AD%98%E6%B1%A0%E6%93%8D%E7%BB%83%E7%BB%93%E6%9E%9C.png" alt="image-20220622152750430"></p>
<p>万一整个<strong>system heap 空间都不够了</strong>（以至无法为内存池注入活水源头），malloc()行动失败，chunk_alloc()就四处寻找有无<strong>「尚有未用区块，且区块够大」之<em>free lists</em></strong>。找到的话就挖一块交出，找不到的话就<strong>呼叫第一级配置器</strong>。第一级配置器其实也是使用malloc()来配置内存，但它有 out-of-memory 处理机制（类似 new-handler 机制），或许有机会<strong>释放其它的内存</strong>拿来此处使用。如果可以，就成功，否则发出<strong><em>bad_alloc</em>异常</strong>。 </p>
<h2 id="内存基本处理工具"><a href="#内存基本处理工具" class="headerlink" title="内存基本处理工具"></a>内存基本处理工具</h2><p>STL定义有五个全域函式，作用于未初始化空间上。这样的功能对于容器的实作很有帮助。</p>
<p>前两个函式是用于建构的construct()和用于解构的destroy()，另三个函式是uninitialized_copy()、uninitialized_fill()、uninitialized_fill_n()，分别对应于高阶函式copy()、fill()、fill_n()——这些都是 STL 算法。如果要使用本节的三个低阶函式，应该含入<memory>，不过SGI 把它们实际定义于<stl_uninitialized>。</p>
<h3 id="uninitialized-copy（复制迭代器）"><a href="#uninitialized-copy（复制迭代器）" class="headerlink" title="uninitialized_copy（复制迭代器）"></a>uninitialized_copy（复制迭代器）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputIterator：输入迭代器。支持对容器元素的逐个遍历，以及对元素的读取（input)；</span><br><span class="line">OutputIterator：输出迭代器。支持对容器元素的逐个遍历，以及对元素的写入（output)。</span><br><span class="line">ForwardIterator：前向迭代器。向前逐个遍历元素。可以对元素读取；</span><br><span class="line">BidirectionalIterator：双向迭代器。支持向前向后逐个遍历元素，可以对元素读取。</span><br><span class="line">RandomAccessIterator：随机访问迭代器。支持O(1)时间复杂度对元素的随机位置访问，支持对元素的读取。</span><br><span class="line"></span><br><span class="line">输出迭代器可以修改元素，这可能会导致内部结构的调整，进而导致原有的迭代器失效！可能的情况有：</span><br><span class="line">	结构和元素顺序变更：比如对map，set，priority_queue插入元素；</span><br><span class="line">	内存变化：比如对vector插入元素，可能导致重新申请内存并拷贝</span><br></pre></td></tr></table></figure>

<p>uninitialized_copy() 使我们能够将内存的配置与对象的建构行为分离开来。如果做为输出目的地的 [result, result+(last-first)) 范围内的每一个迭代器都指向未初始化区域，则 uninitialized_copy() 会使用copy constructor，为身为输入来源之 [first,last) 范围内的每一个对象产生一份复制品，放进输出范围中。换句话说，针对输入范围内的每一个迭代器 i，此函式会呼叫<code>construct(&amp;*(result+(i-first)),*i)</code>，产生*i的复制品，放置于输出范围的相对位置上。</p>
<p>如果需要实作一个容器，uninitialized_copy()这样的函式会带来很大的帮助，因为容器的全范围建构式（range constructor）通常以两个步骤完成：</p>
<ul>
<li><p>配置内存区块，足以包含范围内的所有元素。</p>
</li>
<li><p>使用uninitialized_copy()，在该内存区块上建构元素。</p>
</li>
</ul>
<p>C++标准规格书要求uninitialized_copy()具有 “<em>commit</em> or <em>rollback</em>“语意，意思是要不就<strong>「建构出所有必要元素」</strong>，要不就（当有任何一个copy constructor 失败时）<strong>「不建构任何东西」</strong>。</p>
<h3 id="uninitialized-fill-（填充给定对象的值）"><a href="#uninitialized-fill-（填充给定对象的值）" class="headerlink" title="uninitialized_fill （填充给定对象的值）"></a>uninitialized_fill （填充给定对象的值）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>uninitialized_fill() 也能够使我们将内存配置与对象的建构行为分离开来。如果[first,last)范围内的每个迭代器都指向未初始化的内存，那么</p>
<p>uninitialized_fill()会在该范围内产生x（上式第三参数）的复制品。换句话说uninitialized_fill()会针对操作范围内的每个迭代器 i ，呼叫construct(&amp;*i, x)，在i所指之处产生x的复制品。</p>
<p>和 uninitialized_copy()一样，uninitialized_fill() 必须具备 “<em>commit</em> or <em>rollback</em>“语意，换句话说它要不就产生出所有必要元素，要不就不产生任何元素。如果有任何一个copy constructor丢出异常（exception），uninitialized_fill() 必须能够将已产生之所有元素解构掉。</p>
<h3 id="uninitialized-fill-n-（fill的不同参数写法）"><a href="#uninitialized-fill-n-（fill的不同参数写法）" class="headerlink" title="uninitialized_fill_n （fill的不同参数写法）"></a>uninitialized_fill_n （fill的不同参数写法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>uninitialized_fill_n()能够使我们将内存配置与对象建构行为分离开来。它会为指定范围内的所有元素设定相同的初值。</p>
<p>如果[first, first+n)范围内的每一个迭代器都指向未初始化的内存，那么uninitialized_fill_n()会呼叫copy constructor，在该范围内产生x（上式第三参数）的复制品。也就是说面对 [first,first+n)范围内的每个迭代器 i，uninitialized_fill_n()会呼叫construct(&amp;*i, x)，在对应位置处产生x 的复制品。</p>
<p>uninitialized_fill_n()也具有 “<em>commit</em> or <em>rollback</em>“语意：要不就产生所有必要的元素，否则就不产生任何元素。如果任何一个copy constructor丢出异常（exception），uninitialized_fill_n() 必须解构已产生的所有元素。 </p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="uninitialized-fill-n"><a href="#uninitialized-fill-n" class="headerlink" title="uninitialized_fill_n"></a>uninitialized_fill_n</h4><p>本函式接受三个参数：</p>
<ul>
<li><p>迭代器first指向欲初始化空间的起始处</p>
</li>
<li><p>n表示欲初始化空间的大小</p>
</li>
<li><p>x表示初值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIteratorfirst, Size n, <span class="type">const</span> T&amp;x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line"> <span class="comment">// 以上，利用 value_type() 取出 first的 value type. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 first 的 <em>value type</em>（详见下节），然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*)</span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 以下 __type_traits&lt;&gt; 技法，详见下节</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_typeis_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>POD</strong>意指 <strong>Plain Old Data</strong>，也就是纯量型别（scalar types）或传统的 C struct型别。POD型别必然拥有 <em>trivial</em>ctor&#x2F;dtor&#x2F;copy&#x2F;assignment函式，因此，可以对POD型别采取最有效率的初值填写手法，而对non-POD 型别采取最保险安全的作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);<span class="comment">//交由高阶函式执行。见第6节。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果不是 POD 型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type) &#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, x); </span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uninitialized-copy"><a href="#uninitialized-copy" class="headerlink" title="uninitialized_copy"></a>uninitialized_copy</h4><p>本函式接受三个参数：</p>
<ul>
<li>迭代器first指向输入端的起始位置</li>
<li>迭代器last指向输入端的结束位置（前闭后开区间）</li>
<li>迭代器result指向输出端（欲初始化空间）的起始处</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator </span></span><br><span class="line"><span class="function"><span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_copy(first, last, result,<span class="built_in">value_type</span>(result)); </span><br><span class="line"> <span class="comment">// 以上，利用 value_type() 取出 first的 value type. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 result 的 <em>value type</em>，然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_copy(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, T*) &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::is_POD_type is_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result,<span class="built_in">is_POD</span>()); </span><br><span class="line"> <span class="comment">// 以上，企图利用 is_POD() 所获得的结果，让编译器做自变量推导。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, </span><br><span class="line">__true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">copy</span>(first, last, result);<span class="comment">//呼叫 STL算法 copy() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果是 non-POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_copy_aux(InputIterator first, InputIterator last, </span><br><span class="line"> ForwardIterator result, </span><br><span class="line">__false_type) &#123; </span><br><span class="line"> ForwardIterator cur = result; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; first != last; ++first, ++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, *first);<span class="comment">//必须一个一个元素地建构，无法批量进行</span></span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对char<em>和wchar_t</em>两种型别，可以最具效率的作法memmove（直接搬移内存内容）来执行复制行为。因此 SGI 得以为这两种型别设计一份特化版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下是针对 const char*的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>*<span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">char</span>* result)</span> </span>&#123; </span><br><span class="line"><span class="built_in">memmove</span>(result, first, last - first); </span><br><span class="line"> <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是针对 const wchar_t* 的特化版本</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">wchar_t</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">wchar_t</span>* result)</span> </span>&#123; </span><br><span class="line"><span class="built_in">memmove</span>(result, first, <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) * (last - first)); </span><br><span class="line"> <span class="keyword">return</span> result + (last - first); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="uninitialized-fill"><a href="#uninitialized-fill" class="headerlink" title="uninitialized_fill"></a>uninitialized_fill</h4><p>本函式接受三个参数：</p>
<ul>
<li>迭代器first指向输出端（欲初始化空间）的起始处</li>
<li>迭代器last指向输出端（欲初始化空间）的结束处（前闭后开区间） </li>
<li>x表示初值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line">__uninitialized_fill(first, last, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函式的进行逻辑是，首先萃取出迭代器 first 的 <em>value type</em>，然后判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __uninitialized_fill(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, T1*) &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD; </span><br><span class="line">__uninitialized_fill_aux(first, last, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 copy construction 等同于 assignment, 而且</span></span><br><span class="line"><span class="comment">// destructor 是 trivial，以下就有效。</span></span><br><span class="line"><span class="comment">//如果是 POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, __true_type) </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">fill</span>(first, last, x);<span class="comment">//呼叫 STL算法 fill() </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果是 non-POD型别，执行流程就会转进到以下函式。这是藉由 function template </span></span><br><span class="line"><span class="comment">//的自变量推导机制而得。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> </span><br><span class="line">__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, </span><br><span class="line"> <span class="type">const</span> T&amp; x, __false_type) </span><br><span class="line">&#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅，以下将原本该有的异常处理（exception handling）省略。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; cur != last; ++cur) </span><br><span class="line"><span class="built_in">construct</span>(&amp;*cur, x);<span class="comment">//必须一个一个元素地建构，无法批量进行</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是三个内存基本函数的泛型版本和特化版本图示</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%B8%89%E4%B8%AA%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%89%88%E6%9C%AC%E5%92%8C%E7%89%B9%E5%8C%96%E7%89%88%E6%9C%AC.png" alt="image-20220622225921035"></p>
<h1 id="迭代器（iterators）概念-与traits-编程技法"><a href="#迭代器（iterators）概念-与traits-编程技法" class="headerlink" title="迭代器（iterators）概念 与traits 编程技法"></a>迭代器（iterators）概念 与traits 编程技法</h1><p>迭代器（iterators）是一种抽象的设计概念，现实程序语言中并没有直接对映于这个概念的实物。《<em>Design Patterns</em>》一书提供有 23 个设计样式（design patterns）的完整描述，其中 <em>iterator</em> 样式定义如下：提供一种方法，俾得依序巡访某个聚合物（容器）所含的各个元素，而又无需曝露该聚合物的内部表述方式。</p>
<h2 id="迭代器设计思维—STL-关键所在"><a href="#迭代器设计思维—STL-关键所在" class="headerlink" title="迭代器设计思维—STL 关键所在"></a>迭代器设计思维<strong>—</strong>STL 关键所在</h2><p>STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++ 的 class templates 和 function templates可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题。</p>
<p>以下是容器、算法、迭代器（iterator，扮演黏胶角色）的合作展示。以算法 find() 为例，它接受两个迭代器和一个「搜寻标的」：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//摘自 SGI &lt;stl_algo.h&gt; </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first, </span></span></span><br><span class="line"><span class="params"><span class="function"> InputIterator last, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">while</span> (first != last &amp;&amp; *first != value) </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要给予不同的迭代器，find()便能够对不同的容器做搜寻动作。</p>
<h2 id="迭代器（iterator）是一种-smart-pointer"><a href="#迭代器（iterator）是一种-smart-pointer" class="headerlink" title="迭代器（iterator）是一种 smart pointer"></a>迭代器（iterator）是一种 smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是<strong>内容提领（<em>dereference</em>）</strong>和<strong>成员取用（member access）</strong>，因此迭代器最重要的编程工作就是对 <strong>operator</strong>* 和 <strong>operator-&gt;</strong> 进行多载化（<em>overloading</em>）工程。</p>
<p>C++ 标准链接库有一个auto_ptr可供我们参考。任何一本详尽的 C++ 语法书籍都应该谈到auto_ptr，这是一个用来包装原生指标（native pointer）的对象，声名狼藉的内存漏洞（memory leak）问题可藉此获得解决。auto_ptr用法如下，和原生指标一模一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="function">auto_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;jjhou&quot;</span>))</span></span>; </span><br><span class="line"> cout &lt;&lt; *ps &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; ps-&gt;<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">//输出：jjhou </span></span><br><span class="line"><span class="comment">//输出：5 </span></span><br><span class="line"><span class="comment">// 离开前不需 delete, auto_ptr 会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函式第一行的意思是，以算式new 动态配置一个初值为”jjhou”的string物件，并将所得结果（一个原生指针）做为<code>auto_ptr&lt;string&gt;</code>对象的初值。注意，auto_ptr 角括号内放的是<strong>「原生指针所指对象」</strong>的型别，而不是<strong>原生指标</strong>的型别。</p>
<p>auto_ptr的源码在头文件<memory>中，这里就不给出了。</p>
<p>现在来为list（串行）设计一个迭代器。假设 list 及其节点的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 3mylist.h </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> <span class="comment">//容器</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_front</span><span class="params">(T value)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_end</span><span class="params">(T value)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream &amp;os = std::cout)</span> <span class="type">const</span></span>; </span><br><span class="line"> <span class="comment">// ... </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> ListItem&lt;T&gt;* _end; </span><br><span class="line"> ListItem&lt;T&gt;* _front; </span><br><span class="line"> <span class="type">long</span> _size; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListItem</span> <span class="comment">//节点结构，值和指针</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125; </span><br><span class="line"> <span class="function">ListItem* <span class="title">next</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _next; &#125; </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> T _value; </span><br><span class="line"> ListItem* _next; <span class="comment">// 单向串行（single linked list）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要将这个List套用到先前所说的find()，需要为它设计一个行为类似指标的外衣，也就是一个迭代器。当我们提领（<em>dereference</em>）此一迭代器（用***<strong>），传回的应该是个ListItem 对象；当我们累加该迭代器（用</strong>++**），它应该指向下一个ListItem 物件。为了让此迭代器适用于任何型态的节点，而不只限于ListItem，我们可以将它设计为一个 class template： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 3mylist-iter.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;3mylist.h&quot;</span> </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt; <span class="comment">// Item 可以是单向串行节点或双向串行节点。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span> <span class="comment">//此处这个迭代器特定只为串行服务，因为其</span></span><br><span class="line">&#123; <span class="comment">//独特的 operator++ 之故。</span></span><br><span class="line"> Item* ptr;<span class="comment">//保持与容器之间的一个联系（keep a reference to Container）</span></span><br><span class="line"> <span class="built_in">ListIter</span>(Item* p = <span class="number">0</span>) <span class="comment">// default ctor </span></span><br><span class="line"> : <span class="built_in">ptr</span>(p) &#123; &#125; </span><br><span class="line"><span class="comment">// 不必实作 copy ctor，因为编译器提供的预设行为已足够。</span></span><br><span class="line"> <span class="comment">// 不必实作 operator=，因为编译器提供的预设行为已足够。</span></span><br><span class="line"> Item&amp;<span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; </span><br><span class="line"> Item*<span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125; </span><br><span class="line"><span class="comment">// 以下两个 operator++ 遵循标准作法，参见[Meyers96]条款 6 </span></span><br><span class="line"><span class="comment">// (1) pre-increment operator </span></span><br><span class="line"> ListIter&amp;<span class="keyword">operator</span>++() </span><br><span class="line"> &#123; ptr = ptr-&gt;<span class="built_in">next</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125; </span><br><span class="line"><span class="comment">// (2) post-increment operator </span></span><br><span class="line"> ListIter <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123; ListIter tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span> </span><br><span class="line"> &#123; <span class="keyword">return</span> ptr == i.ptr; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListIter&amp; i) <span class="type">const</span> </span><br><span class="line"> &#123; <span class="keyword">return</span> ptr != i.ptr; &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们可以这样子将 List和find()藉由ListIter 黏合起来（使自己设计的List能通过ListIter来使用find()）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3mylist-iter-test.cpp </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> List&lt;<span class="type">int</span>&gt; mylist; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) &#123; </span><br><span class="line"> mylist.<span class="built_in">insert_front</span>(i); </span><br><span class="line"> mylist.<span class="built_in">insert_end</span>(i+<span class="number">2</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> mylist.<span class="built_in">display</span>(); <span class="comment">// 10 ( 4 3 2 1 0 2 3 4 5 6 ) </span></span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">begin</span>(mylist.<span class="built_in">front</span>()); </span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt;end; <span class="comment">// default 0, null </span></span><br><span class="line"> ListIter&lt;ListItem&lt;<span class="type">int</span>&gt; &gt; iter; <span class="comment">// default 0, null</span></span><br><span class="line"> iter = <span class="built_in">find</span>(begin, end, <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (iter == end) </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;found. &quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 执行结果：found. 3 </span></span><br><span class="line"> iter = <span class="built_in">find</span>(begin, end, <span class="number">7</span>); </span><br><span class="line"> <span class="keyword">if</span> (iter == end) </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;found. &quot;</span> &lt;&lt; iter-&gt;<span class="built_in">value</span>() &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 执行结果：not found </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于find()函式内以*iter !&#x3D; value来检查元素值是否吻合，而本例之中value的型别是int，iter的型别是<code>ListItem&lt;int&gt;</code>，两者之间并无可供使用的operator!&#x3D;，所以我必须另外写一个全域的operator!&#x3D;多载函式，并以int和<code>ListItem&lt;int&gt;</code>做为它的两个参数型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typenameT&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ListItem&lt;T&gt;&amp; item,T n) </span><br><span class="line">&#123; <span class="keyword">return</span> item.<span class="built_in">value</span>() != n; &#125;</span><br></pre></td></tr></table></figure>

<p>从以上实作可以看出，为了完成一个针对 List 而设计的迭代器，我们无可避免地 曝露了太多List实作细节：在main()之中为了制作begin和end两个迭代器，我们曝露了ListItem；在ListIter class之中为了达成operator++的目的，我们曝露了 ListItem 的操作函式next()。</p>
<p>如果不是为了迭代器，ListItem 原本应该完全隐藏起来不曝光的。换句话说，要设计出 ListIter，首先必须对 List 的实作细节有非常丰富的了解。既然这无可避免，干脆就把迭代器的开发工作交给List的设计者好了，如此一来所有实作细节反而得以封装起来不被使用者看到。这正是为什么每一种 STL容器都提供有专属迭代器的缘故。</p>
<h2 id="迭代器相应型别（associated-types）"><a href="#迭代器相应型别（associated-types）" class="headerlink" title="迭代器相应型别（associated types）"></a>迭代器相应型别（associated types）</h2><p>上述的ListIter提供了一个迭代器雏形。如果将思想拉得更高远一些，我们便会发现，算法之中运用迭代器时，很可能会用到其相应型别（associated type）。什么是相应型别？迭代器所指之物的型别便是其一。</p>
<p>假设算法中有必要宣告一 个变量，以「迭代器所指对象的型别」为型别，如何是好？毕竟C++只支援**sizeof()<strong>，并未支持</strong>typeof()**。</p>
<p>解决办法是：利用 function template （函数模板）的<strong>自变量推导（argument deducation）</strong>机制，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span> <span class="comment">//多了类型T，T是迭代器指向对象的类型</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> T tmp; <span class="comment">// 这里解决了问题。T就是迭代器所指之物的型别，本例为 int </span></span><br><span class="line"><span class="comment">// ... 这里做原本 func()应该做的全部工作</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">func_impl</span>(iter,*iter);<span class="comment">// func 的工作全部移往 func_impl </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="built_in">func</span>(&amp;i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以func()为对外界面，却**把实际动作全部置于func_impl() **之中。由于func_impl()是一个 function template，一旦被呼叫，编译器会自动进行 template 自变量推导。于是导出型别T，顺利解决了问题。</p>
<p>迭代器相应型别（associated types）不只是「迭代器所指对象的型别」一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的 template自变量推导机制来取得。我们需要更全面的解法。</p>
<h2 id="Traits-编程技法——STL-源码门钥"><a href="#Traits-编程技法——STL-源码门钥" class="headerlink" title="Traits 编程技法——STL 源码门钥"></a>Traits 编程技法——STL 源码门钥</h2><p>迭代器所指物件的型别，称为该迭代器的<em>value type</em>。上述的自变量型别推导技巧虽然可用于 <em>value type</em>，却非全面可用：万一<em>value type</em>必须用于函式的传回值，就束手无策了，毕竟函式的「template 自变量推导机制」推而导之的只是自变量，无法推导函式的回返值型别。</p>
<p>声明内嵌型别似乎是个好主意，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyIter</span> </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; <span class="comment">// 内嵌型别声明（nested type）</span></span><br><span class="line"> T* ptr; </span><br><span class="line"> <span class="built_in">MyIter</span>(T* p=<span class="number">0</span>) : <span class="built_in">ptr</span>(p) &#123; &#125; </span><br><span class="line"> T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; </span><br><span class="line"> <span class="comment">// ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> I::value_type <span class="comment">//这一整行是 func的回返值型别</span></span><br><span class="line"><span class="built_in">func</span>(I ite) </span><br><span class="line">&#123; <span class="keyword">return</span> *ite; &#125; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="function">MyIter&lt;<span class="type">int</span>&gt; <span class="title">ite</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">8</span>))</span></span>; </span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(ite); <span class="comment">//输出：8</span></span><br></pre></td></tr></table></figure>

<p>注意，func()的回返型别必须加上关键词 typename，因为T是一个 template参数，在它被编译器具现化之前，编译器对T一无所悉，换句话说编译器此时并不知道<code>MyIter&lt;T&gt;::value_type</code>代表的是一个型别或是一个 member function或是一个 data member。关键词typename的用意在告诉编译器说这是一个型别，如此才能顺利通过编译。</p>
<p>看起来不错。但是有个隐晦的陷阱：并不是所有迭代器都是 class type。原生指标就不是。如果不是 class type，就无法为它定义内嵌型别。但 STL（以及整个泛型思维）绝对必须接受原生指标做为一种迭代器，所以上面这样还不够。更好的方式是使用template partial specialization（模板偏特化）。</p>
<p><strong>Partial Specialization（偏特化）的意义</strong>：如果 class template拥有一个以上的 template 参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。换句话说我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。</p>
<p>假设有一个 class template如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V, <span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>partial specialization的字面意义容易误导我们以为，所谓「偏特化版」一定是对template参数 U 或 V 或 T（或某种组合）指定某个自变量值。事实不然，「所谓partial specialization的意思是提供另一份 template定义式，而其本身仍为 templatized」。《泛型技术》 一书对 partial specialization 的定义是：「针对（任何）template 参数更进一步的条件限制，所设计出来的一个特化版本」。</p>
<p>由此，面对以下这么一个 class template：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; ... &#125;; <span class="comment">// 这个泛化版本允许（接受）T为任何型别</span></span><br></pre></td></tr></table></figure>

<p>我们便很容易接受它有一个型式如下的partial specialization：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&lt;T*&gt; &#123; ... &#125;; <span class="comment">//这个特化版本仅适用于「T为原生指针」的情况</span></span><br><span class="line"> <span class="comment">// 「T为原生指针」便是「T 为任何型别」的一个更进一步的条件限制</span></span><br></pre></td></tr></table></figure>

<p>注：原生指针即  (类型名<em>p)样子的指针，类型名可以是基础类型，如int，double等，也可以是一个自己定义的Class类。相反的如果一个类重载了‘</em><em>*’*<em>和‘</em></em>-&gt;*<em>’的运算符，可以像指针一样用‘</em>’和‘-&gt;’操作，就不是原生的，如iterator等。</p>
<p>有了这项利器，我们便可以解决前述「内嵌型别」未能解决的问题。先前的问题是，原生指针并非 class，因此无法为它们定义内嵌型别。现在，我们可以针对「迭代器之 template自变量为指标」者，设计特化版的迭代器。</p>
<p>下面这个 class template专门用来「萃取」迭代器的特性，而 <em>value type</em> 正是迭代器的特性之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; <span class="comment">// traits 意为「特性」</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个所谓的<strong>traits</strong>，其意义是，如果I定义有自己的<em>value type</em>，那么透过这个<strong>traits</strong>的作用，萃取出来的value_type就是I::value_type。换句话说如果I 定义有自己的<em>value type</em>，先前那个func()可以改写成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type <span class="comment">// 这一整行是函式回返型别</span></span><br><span class="line"><span class="built_in">func</span>(I ite) </span><br><span class="line">&#123; <span class="keyword">return</span> *ite; &#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处是<strong>traits</strong>可以拥有特化版本。现在，我们令 iterator_traites拥有一个partial specializations 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; <span class="comment">//偏特化版—迭代器是个原生指标</span></span><br><span class="line"> typedefT value_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，原生指标int* 虽然不是一种 class type，亦可透过<strong>traits</strong>取其<em>value type</em>。这就解决了先前的问题。</p>
<p>但是请注意，针对「指向常数对象的指针（pointer-to-const）」，下面这个式子得到什么结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;<span class="type">const</span> <span class="type">int</span>*&gt;::value_type</span><br></pre></td></tr></table></figure>

<p>获得的是const int而非int。这不是所期望的。我们希望利用这种机制来宣告一个暂时变量，使其型别与迭代器的<em>value type</em>相同，而现在，宣告一个无法赋值（因const之 故 ）的暂时变数，没什么用！因此，如果迭代器是个pointer-to-const，我们应该设法令其<em>value type</em>为一个 non-const型别。只要另外设计一个特化版本，就能解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123; <span class="comment">// 偏特化版—当迭代器是个pointer-to-const </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; <span class="comment">// 萃取出来的型别应该是 T 而非 const T</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>现在，不论面对的是迭代器MyIter，或是原生指标int<em>或const int</em>，都可以透过<strong>traits</strong>取出正确的（我们所期望的）<em>value type</em>。 </p>
<p>下图说明<strong>traits</strong>所扮演的「特性萃取机」角色，萃取各个迭代器的特性。这里所谓的迭代器特性，指的是迭代器的相应型别（associated types）。当然，若要这个「特性萃取机」<strong>traits</strong>能够有效运作，每一个迭代器必须遵循约定，自行以内嵌型别定义（nested typedef）的方式定义出相应型别（associated types）。这种一个约定，谁不遵守这个约定，谁就不能相容于 STL 这个大家庭。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/traits%E7%89%B9%E6%80%A7%E8%90%83%E5%8F%96%E6%9C%BA.png" alt="image-20220623154430152"></p>
<p>根据经验，最常用到的迭代器相应型别有五种：</p>
<ul>
<li>value type</li>
<li>difference type</li>
<li>pointer</li>
<li>reference</li>
<li>iterator catagoly</li>
</ul>
<p>如果你希望你所开发的容器能与 STL 水乳交融，一 定要为你的容器的迭代器定义这五种相应型别。「特性萃取机」<strong>traits</strong> 会很忠实地 </p>
<p>将原汁原味榨取出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator_traits必须针对传入之型别为 pointer 及 pointer-to-const者，设计特化版本，见下节。</p>
<h3 id="迭代器相应型别之一：value-type"><a href="#迭代器相应型别之一：value-type" class="headerlink" title="迭代器相应型别之一：value type"></a>迭代器相应型别之一：<em>value type</em></h3><p>所谓<em>value type</em>，是指迭代器所指对象的型别。任何一个打算与 STL算法有完美搭配的 class，都应该定义自己的 <em>value type</em> 内嵌型别，作法就像上节所述。</p>
<h3 id="迭代器相应型别之二：difference-type"><a href="#迭代器相应型别之二：difference-type" class="headerlink" title="迭代器相应型别之二：difference type"></a>迭代器相应型别之二：<em>difference type</em></h3><p><em>difference type</em> 用来表示两个迭代器之间的距离，也因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</p>
<p>如果一个泛型算法提供计数功能，例如 STL的count()，其传回值就必须使用迭代器的 <em>difference type</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type <span class="comment">//这一整行是函式回返型别</span></span><br><span class="line"><span class="built_in">count</span>(I first, I last, <span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> ( ; first != last; ++first) </span><br><span class="line"> <span class="keyword">if</span> (*first == value) </span><br><span class="line"> ++n; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对相应型别<em>difference type</em>，<strong>traits</strong>的两个（针对原生指标而写的）特化版本如下，以C++内建的ptrdiff_t（定义于<cstddef>头文件）做为原生指标的<em>difference type</em>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化（partial specialization）」版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化（partial specialization）」版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，任何时候当我们需要任何迭代器 I的<em>difference type</em>，可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type</span><br></pre></td></tr></table></figure>

<h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：<em>reference type</em></h3><p>从<strong>「迭代器所指之物的内容是否允许改变」</strong>的角度观之，迭代器分为两种：不允许改变「所指对象之内容」者，称为constant iterators，例如constint* pic；允许改变「所指对象之内容」者，称为 mutable iterators，例如int* pi。</p>
<p>当我们对一个 mutable iterators做提领动作时，获得的不应该是个右值（rvalue），应该是个左值（lvalue），因为右值不允许赋值动作（assignment），左值才允许：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>); </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">9</span>); </span><br><span class="line">*pi = <span class="number">7</span>; <span class="comment">// 对 mutable iterator做提领动作时，获得的应该是个左值，允许赋值。</span></span><br><span class="line">*pci = <span class="number">1</span>; <span class="comment">// 这个动作不允许，因为 pci是个constant iterator，</span></span><br><span class="line"><span class="comment">// 提领 pci所得结果，是个右值，不允许被赋值。</span></span><br></pre></td></tr></table></figure>

<p>在 C++中，函式如果要传回左值，都是以by reference的方式进行，所以当p是个 mutable iterators时，如果其<em>value type</em>是T，那么*p的型别不应该是T，应该是 T&amp;。将此道理扩充，如果 p是一个 constant iterators，其<em>value type</em>是 T，那么*p的型别不应该是const T，而应该是const T&amp;。这里所讨论的*p的型别，即所谓的<em>reference type</em>。实作细节将在下一小节一并展示。</p>
<h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：<em>pointer type</em></h3><p>pointers和 references 在 C++中有非常密切的关连。如果「传回一个左值，令它代表p所指之物」是可能的，那么「传回一个左值，令它代表p所指之物的位址」也一定可以。也就是说我们能够传回一个 pointer，指向迭代器所指之物。</p>
<p>这些相应型别已在先前的ListIter class中出现过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr; &#125; </span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br></pre></td></tr></table></figure>

<p>Item&amp;便是 ListIter的<em>reference type</em>而 Item*便是其<em>pointer type</em>。</p>
<p>现在把 <em>reference type</em>和<em>pointer type</em> 这两个相应型别加入<strong>traits</strong>内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：<em>iterator_category</em></h3><p>最后一个（第五个）迭代器相应型别会引发较大规模的写码工程。在那之前，必须先讨论迭代器的分类。</p>
<p>根据移动特性与施行动作，迭代器被分为五类：</p>
<ul>
<li>Input Iterator：这种迭代器所指对象，不允许外界改变。只读（read only）。</li>
<li>Output Iterator：唯写（write only）。</li>
<li>Forward Iterator：允许「写入型」算法（例如replace()）在此种迭代器所形成的区间上做读写动作。</li>
<li>Bidirectional Iterator：可双向移动。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），就可以使用 Bidirectional Iterators。</li>
<li>Random Access Iterator：前四种迭代器都只供应一部份指标算术能力（前三 种支持operator++，第四种再加上operator–），第五种则涵盖所有指标算术能力，包括p+n, p-n, p[n], p1-p2, p1&lt;p2。</li>
</ul>
<p>这些迭代器的分类与从属关系，可以用下图表示。直线与箭头代表的并非 C++ 的继承关系，而是所谓concept（概念）与refinement（强化）的关系。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E4%BB%8E%E5%B1%9E%E5%85%B3%E7%B3%BB.png" alt="image-20220624144559043"></p>
<p>设计算法时，如果可能，我们尽量针对图中的某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一种定义，这样才能在不同情况下提供最大效率。研究STL 的过程中，每一分每一秒我们都要明确，效率是个重要课题。假设有个算法可接受<em>Forward Iterator</em>，你以<em>Random Access Iterator</em>喂给它，它当然也会接受，因为一个<em>Random Access Iterator</em>必然是一个<em>Forward Iterator</em>（如图）。但是可用并不代表最佳！</p>
<p><strong>以 advanced()为例</strong></p>
<p>拿advance() 来说（这是许多算法内部常用的一个函式），此函式有两个参数，迭代器p和数值n；函式内部将p累进n次（前进n距离）。下面有三 份定义，一份针对<em>Input Iterator</em>，一份针对<em>Bidirectional Iterator</em>，另一份针对<em>Random Access Iterator</em>。倒是没有针对<em>ForwardIterator</em>而设计的版本，因为那和针对<em>InputIterator</em>而设计的版本完全一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 单向，逐一前进</span></span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; <span class="comment">//或写 for ( ; n &gt; 0; --n, ++i );</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_BI</span><span class="params">(BidirectionalIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 双向，逐一前进</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//或写 for ( ; n &gt; 0; --n, ++i ); </span></span><br><span class="line"><span class="comment">//或写 for ( ; n &lt; 0; ++n, --i ); </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance_RAI</span><span class="params">(RandomAccessIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">// 双向，跳跃前进</span></span><br><span class="line"> i += n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当程序呼叫 advance()，应该选用（呼叫）哪一份函式定义呢？如果选择advance_II()，对<em>Random Access Iterator</em>而言极度缺乏效率，原本<em>O(1)<em>的操作竟成为</em>O(N)<em>。如果选择advance_RAI()，则它无法接受</em>Input Iterator</em>。我们需要将三者合一，下面是一种作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">is_random_access_iterator</span>(i)) </span><br><span class="line">	<span class="built_in">advance_RAI</span>(i, n); </span><br><span class="line"><span class="comment">//此函式有待设计</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_bidirectional_iterator</span>(i))<span class="comment">//此函式有待设计</span></span><br><span class="line">	<span class="built_in">advance_BI</span>(i, n); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">	<span class="built_in">advance_II</span>(i, n); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是像这样在执行时期才决定使用哪一个版本，会影响程序效率。最好能够在<strong>编译期</strong>就选择正确的版本。多载化函式机制可以达成这个目标：</p>
<p>前述三个advance_xx()都有两个函式参数，型别都未定（因为都是 template参数）。为了令其同名，形成多载化函式，我们必须加上一个型别已确定的函式参数，使函式多载化机制得以有效运作起来。</p>
<p>设计考虑如下：如果<strong>traits</strong>有能力萃取出迭代器的种类，我们便可利用这个「迭代器类型」相应型别做为advanced()的第三参数。这个相应型别一定必须是个class type，不能只是数值号码类的东西，因为编译器需仰赖它（一个型别）来进行多载化决议程序（overloaded resolution）。下面定义五个 classes，代表五种迭代器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五个做为标记用的型别（tag types）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;; <span class="comment">//继承，见后面的分析</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123; &#125;; <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;<span class="comment">//继承</span></span><br></pre></td></tr></table></figure>

<p>这些 classes只做为标记用，所以不需要任何成员。至于为什么运用继承机制，稍后再解释。现在重新设计 __advance()（由于只在内部使用，所以函式名称加上特定的前导符），并加上第三参数，使它们形成多载化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 单向，逐一前进</span></span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这是一个单纯的转呼叫函式（trivial forwarding function）。稍后讨论如何免除之。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(ForwardIterator&amp; i, Distance n, forward_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 单纯地进行转呼叫（forwarding）</span></span><br><span class="line"> <span class="built_in">advance</span>(i, n, <span class="built_in">input_iterator_tag</span>()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidiectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(BidiectionalIterator&amp; i, Distance n, bidirectional_iterator_tag) </span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 双向，逐一前进</span></span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">// 双向，跳跃前进</span></span><br><span class="line"> i += n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述语法，每个 __advance()的最后一个参数都只宣告型别，并未指定参数名称，因为它纯粹只是用来启动多载化机制，函式之中根本不使用该参数。如果硬要加上参数名称也可以，画蛇添足罢了。</p>
<p>行进至此，还需要一个对外开放的上层控制介面，呼叫上述各个多载化的__advance()。此一上层介面只需两个参数，当它准备将工作转给上述的__advance()时，才自行加上第三自变量：迭代器类型。因此，这个上层函式必须有能力从它所获得的迭代器中推导出其类型—这份工作自然是交给 <strong>traits</strong> 机制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> __advance(i, n, iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述语法，<code>iterator_traits&lt;Iterator&gt;::iterator_category() </code>将产生一个暂时对象（道理就像 int()会产生一个 int 暂时对象一样），其型别应该隶属前述五个迭代器类型之一。然后，根据这个型别，编译器才决定呼叫哪一个__advance()多载函式。 </p>
<p>因此，为了满足上述行为，<strong>traits</strong>必须再增加一个相应型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> ... </span><br><span class="line"><span class="comment">// 注意，原生指标是一种 Random Access Iterator</span></span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生的 pointer-to-const 而设计的「偏特化版（partial specialization）」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; </span><br><span class="line"> ... </span><br><span class="line"><span class="comment">// 注意，原生的 pointer-to-const是一种 Random Access Iterator</span></span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//新增加的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>任何一个迭代器，其类型永远应该落在「该迭代器所隶属之各种类型中，<strong>最强化</strong>的那个」。例如int*既是<em>Random Access Iterator</em>又是 <em>Bidirectional Iterator</em>，同时也是<em>Forward Iterator</em>，而且也是<em>Input Iterator</em>，那么，其类型应该归属为<em>random_access_iterator_tag</em>。</p>
<p>你是否注意到advance()的 template参数名称取得好像不怎么理想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>按说advanced()既然可以接受各种类型的迭代器，就不应将其型别参数命名为InputIterator。这其实是 STL 算法的一个命名规则：以算法所能接受之<strong>最低阶</strong>迭代器类型，来为其迭代器型别参数命名。</p>
<p>**消除「单纯转呼叫函式」 **</p>
<p>以 class 来定义迭代器的各种分类标签，不仅可以促成多载化机制的成功运作（使编译器得以正确执行多载化决议程序，overloaded resolution），另一个好处是，透过继承，我们可以不必再写<strong>「单纯只做转呼叫」</strong>的函式（例如前述的advance() <em>ForwardIterator</em>版）。考虑下面这个小例子，从其输出结果可以看出端倪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 3tag-test.cpp </span></span><br><span class="line"><span class="comment">//模拟测试 tag types继承关系所带来的影响。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : <span class="keyword">public</span> B &#123; &#125;; </span><br><span class="line"><span class="comment">// B 可比拟为 InputIterator </span></span><br><span class="line"><span class="comment">// D1 可比拟为 ForwardIterator </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D1 &#123; &#125;; <span class="comment">// D2 可比拟为 BidirectionalIterator </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="built_in">func</span>(I&amp; p, B) </span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;B version&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt; </span><br><span class="line"><span class="built_in">func</span>(I&amp; p, D2) </span><br><span class="line">&#123; cout &lt;&lt; <span class="string">&quot;D2 version&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span>* p; </span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">B</span>()); <span class="comment">// 参数与自变量完全吻合。输出: &quot;B version&quot; </span></span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">D1</span>()); <span class="comment">// 参数与自变量未能完全吻合；因继承关系而自动转呼叫。输出:&quot;B version&quot; </span></span><br><span class="line"> <span class="built_in">func</span>(p, <span class="built_in">D2</span>()); <span class="comment">// 参数与自变量完全吻合。输出: &quot;D2 version&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%B1%BB%E5%88%AB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="image-20220624151349583"></p>
<p><strong>以 distance()为例</strong></p>
<p>关于「迭代器类型标签」的应用，以下再举一例。distance() 也是常用的一个迭代器操作函式，用来计算两个迭代器之间的距离。针对不同的迭代器类型，它可以有不同的计算方式，带来不同的效率。整个设计模式和前述的advance()如出一辙：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">__distance(InputIterator first, InputIterator last,  input_iterator_tag) &#123; </span><br><span class="line"> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 逐一累计距离</span></span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123; </span><br><span class="line"> ++first; ++n; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type </span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123; </span><br><span class="line"> <span class="comment">// 直接计算差距</span></span><br><span class="line"> <span class="keyword">return</span> last - first; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type </span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> __distance(first, last, <span class="built_in">category</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，distance()可接受任何类型的迭代器；其 template型别参数之所以命名为InputIterator，是为了遵循STL 算法的命名规则：以算法所能接受之最初级类型来为其迭代器型别参数命名。</p>
<p>此外也请注意，由于迭代器类型之间存在着继承关系，「转呼叫（<em>forwarding</em>）」的行为模式因此自然存在——这一点已在前一节讨论过。换句话说，当客端呼叫distance()并使用 <em>Output Iterator</em>s 或 <em>Forward Iterator</em>s 或<em>Bidirectional Iterator</em>s，统统都会转呼叫 <em>Input Iterator</em>版的那个__distance() 函式。</p>
<h2 id="std-iterator-的保证"><a href="#std-iterator-的保证" class="headerlink" title="std::iterator 的保证"></a>std::iterator 的保证</h2><p>为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利<strong>traits</strong>萃取，否则便是自外于整个STL架构，可能无法与其它 STL 组件顺利搭配。然而写码难免挂一漏万，谁也不能保证不会有粗心大意的时候。如果能够将事情简化，就好多了。STL提供了一个<strong>iterators class</strong>如下，如果每个新设计的迭代器都继承自它，就保证符合 STL 所需之规范：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">T</span>, </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line"> <span class="keyword">class</span> Pointer = T*, </span><br><span class="line"> <span class="keyword">class</span> Reference = T&amp;&gt; </span><br><span class="line"><span class="keyword">struct</span> iterator &#123; </span><br><span class="line"> <span class="keyword">typedef</span> Category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Distance difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> Pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Referencereference; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>iterator class不含任何成员，纯粹只是型别定义，所以继承它并不会招致任何额外负担。由于后三个参数皆有默认值，新的迭代器只需提供前两个参数即可。</p>
<p>先前的 ListIter，如果改用正式规格，应该这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Item</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListIter</span> : </span><br><span class="line"> <span class="keyword">public</span> std::iterator&lt;std::forward_iterator_tag, Item&gt; </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计适当的相应型别（associated types），是迭代器的责任。设计适当的迭代器，则是容器的责任。唯容器本身，才知道该设计出怎样的迭代器来走访自己，并执行迭代器该有的各种行为（前进、后退、取值、取用成员…）。至于算法，完全可以独立于容器和迭代器之外自行发展，只要设计时以迭代器为对外接口就行。</p>
<p><strong>traits</strong>编程技法，大量运用于 STL 实作品中。它利用「内嵌型别」的写码技巧与编译器的template自变量推导功能，补强 C++未能提供的关于型别认证方面的能力，补强 C++不为强型（strong typed）语言的遗憾。</p>
<h2 id="iterator-源码完整重列"><a href="#iterator-源码完整重列" class="headerlink" title="iterator 源码完整重列"></a>iterator 源码完整重列</h2><p>以下重新列出 SGI STL &lt;stl_iterator.h&gt;头文件内与本章相关的程序代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节录自 SGI STL &lt;stl_iterator.h&gt; </span></span><br><span class="line"><span class="comment">//五种迭代器类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;; </span><br><span class="line"><span class="comment">//为避免写码时挂一漏万，自行开发的迭代器最好继承自下面这个 std::iterator </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line"> <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt; </span><br><span class="line"><span class="keyword">struct</span> iterator &#123; </span><br><span class="line"> <span class="keyword">typedef</span> Category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Distance difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> Pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//「萃取机」traits </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//针对原生指标（native pointer）而设计的 traits 偏特化版。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;  </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> T&amp; reference; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//针对原生之pointer-to-const 而设计的 traits 偏特化版。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">structiterator_traits&lt;<span class="type">const</span> T*&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;  </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的类型（category）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category </span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">category</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的 distance type </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type* </span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个函式可以很方便地决定某个迭代器的 value type </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* </span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下是整组 distance 函式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::difference_type </span><br><span class="line">__distance(InputIterator first, InputIterator last, input_iterator_tag) &#123; </span><br><span class="line"> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123; </span><br><span class="line"> ++first; ++n; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type </span><br><span class="line">__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">return</span> last - first;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type </span></span><br><span class="line"><span class="function"><span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category category; </span><br><span class="line"> <span class="keyword">return</span> __distance(first, last,<span class="built_in">category</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是整组 advance函式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(BidirectionalIterator&amp; i, Distance n, bidirectional_iterator_tag) &#123; </span><br><span class="line"> <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">while</span> (n--) ++i; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">while</span> (n++) --i; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag) &#123; </span><br><span class="line"> i += n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123; </span><br><span class="line">__advance(i, n, <span class="built_in">iterator_category</span>(i)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SGI-STL-的私房菜：-type-traits-（选看）"><a href="#SGI-STL-的私房菜：-type-traits-（选看）" class="headerlink" title="SGI STL 的私房菜： __type_traits （选看）"></a>SGI STL 的私房菜： __type_traits （选看）</h2><p><strong>traits</strong>编程技法很棒，适度弥补了 C++ 语言本身的不足。STL只对迭代器加以规范，制定出iterator_traits这样的东西。SGI 把这种技法进一步扩大到迭代器以外的世界，于是有了所谓的**__type_traits<strong>。双底线前缀词意指这是SGI STL 内部所用的东西，</strong>不在 STL 标准规范之内**。</p>
<p>iterator_traits负 责萃 取 迭 代器 的特 性，__type_traits 则负责萃取<strong>型别（type）</strong>的特性。此处我们所关注的型别特性是指：这个型别是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivialassignment operator？是否具备 non-trivialdtor？如果答案是否定的，我们在对这个型别进行建构、解构、拷贝、赋值等动作时，就可以采用最有效率的措施（例如根本不唤起那些constructor, destructor），而采用内存直接处理动作如malloc()、memcpy()等等，获得最高效率。这对于大规模而动作频繁的容器，有着显著的效率提升。</p>
<p>定义于 SGI &lt;type_traits.h&gt;中的__type_traits，提供了一种机制，允许针对不同的型别属性（type attributes），在<strong>编译时期完成函式派送</strong>决定（function dispatch）。这对于撰写 template很有帮助，例如，当我们准备对一个「元素型别未知」的数组执行 copy 动作时，如果我们能事先知道其元素型别是否有一个 trivial copy constructor ， 便 能 够 帮 助 我 们 决 定 是 否 可 使 用 快 速 的memcpy()或memmove()。 </p>
<p>从iterator_traits得来的经验，我们希望，程式之中可以这样运用__type_traits&lt;T&gt;，T代表任意型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator </span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor </span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure>

<p>我们希望上述式子响应我们「真」或「假」（以便我们决定采取什么策略），但其结果不应该只是个bool值，应该是个有着真&#x2F;假性质的「对象」，因为我们希望利用其响应结果来进行自变量推导，而编译器只有面对 class object形式的自变量，才会做自变量推导。为此，上述式子应该传回这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123; &#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>这两个空白 classes没有任何成员，不会带来额外负担，却又能够标示真假，满足我们所需。 </p>
<p>为了达成上述五个式子， __type_traits内必须定义一些typedefs，其值不是__true_type就是__false_type。下面是 SGI的作法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">type</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line"> <span class="keyword">typedef</span> __true_type this_dummy_member_must_be_first; </span><br><span class="line"> <span class="comment">/* 不要移除这个成员。它通知「有能力自动将 __type_traits 特化」</span></span><br><span class="line"><span class="comment">的编译器说，我们现在所看到的这个 __type_traits template 是特</span></span><br><span class="line"><span class="comment">殊的。这是为了确保万一编译器也使用一个名为 __type_traits而其</span></span><br><span class="line"><span class="comment">实与此处定义并无任何关联的 template 时，所有事情都仍将顺利运作。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"> <span class="comment">/* 以下条件应被遵守，因为编译器有可能自动为各型别产生专属的 __type_traits </span></span><br><span class="line"><span class="comment">特化版ᴀ：</span></span><br><span class="line"><span class="comment"> - 你可以重新排列以下的成员次序</span></span><br><span class="line"><span class="comment"> - 你可以移除以下任何成员</span></span><br><span class="line"><span class="comment"> - 绝对不可以将以下成员重新命名而却没有改变编译器中的对应名称</span></span><br><span class="line"><span class="comment"> - 新加入的成员会被视为一般成员，除非你在编译器中加上适当支持。*/</span> </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_default_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_destructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type is_POD_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为什么SGI 把所有内嵌型别都定义为__false _type呢？是的，SGI 定义出最保守的值，然后（稍后可见）再针对每一个纯量型别（scalar types）设计适当的__type_traits特化版本，这样就解决了问题。 </p>
<p>上述 __type_traits可以接受任何型别的自变量，五个typedefs将经由以下管道获得实值：</p>
<p>一般具现体（general instantiation），内含对所有型别都必定有效的保守值。 上述各个has_trivial_xxx型别都被定义为__false_type，就是对所有型别都必定有效的保守值。经过宣告的特化版本，例如&lt;type_traits.h&gt; 内对所有 C++纯量型别（scalar types）提供了对映的特化宣告。这里源码不做展示了。</p>
<p>__types_traits在SGI STL中的应用很广。下面我举几个实例。第一个例子是uninitialized_fill_n()全域函式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ForwardIteratoruninitialized_fill_n</span><span class="params">(ForwardIterator first, </span></span></span><br><span class="line"><span class="params"><span class="function"> Size n, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函式以 x为蓝本，自迭代器first开始建构 n个元素。为求取最大效率，首先 以value_type()萃取出迭代器first的<em>value type</em>，再利用__type_traits判断该型别是否为 POD型别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T1</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD; </span><br><span class="line"> <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下就「是否为 POD型别」采取最适当的措施：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不是 POD型别，就会派送（dispatch）到这里</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line">ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type) &#123; </span><br><span class="line"> ForwardIterator cur = first; </span><br><span class="line"><span class="comment">// 为求阅读顺畅简化，以下将原本有的异常处理（exception handling）去除。</span></span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur) </span><br><span class="line">	<span class="built_in">construct</span>(&amp;*cur, x); </span><br><span class="line"> <span class="keyword">return</span> cur; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果是 POD型别，就会派送（dispatch）到这里。下两行是原文件所附注解。</span></span><br><span class="line"><span class="comment">//如果 copy construction等同于 assignment，而且有 trivial destructor，</span></span><br><span class="line"><span class="comment">//以下就有效。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> ForwardIterator </span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);<span class="comment">//交由高阶函式执行，如下所示。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下是定义于 &lt;stl_algobase.h&gt; 中的 fill_n() </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">Size</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">OutputIteratorfill_n</span>(OutputIterator first, Size n, <span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first) </span><br><span class="line"> *first = value; </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此如果你是 SGI STL的使用者，你可以在自己的程式中充份运用这个__type_traits。假设我自行定义了一个Shape class，__type_traits 会对它产生什么效应？如果编译器够厉害（例如Silicon Graphics 的N32 和 N64 编译器），你会发现，__type_traits针对Shape萃取出来的每一个特性，其结果将取决于我的Shape是否有 trivialdefalt ctor或trivialcopy ctor或trivial assignment operator或 trivialdtor而定。但对大部份缺乏这种特异功能的编译器而言，__type_traits 针对 Shape 萃取出来的每一个特性都是__false_type ，即使Shape是个 POD型别。这样的结果当然过于保守，但是别无选择，除非我针对 Shape，自行设计一个__type_traits 特化版本，明白地告诉编译器以下事实（举例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt; &#123; </span><br><span class="line"> <span class="keyword">typedef</span> __true_type has_trivial_default_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_assignment_operator; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type has_trivial_destructor; </span><br><span class="line"> <span class="keyword">typedef</span> __false_type is_POD_type; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>究竟一个 class什么时候该有自己的 non-trivial default constructor, non-trivial copy constructor, non-trivial assignment operator, non-trivial destructor 呢？一个简单的判断准则是：如果 class 内含指标成员，并且对它进行内存动态配置，那么这个class就需要实作出自己的 non-trivial-xxx。</p>
<p>即使你无法全面针对你自己定义的型别，设计__type_traits特化版本，无论如何，至少，有了这个__type_traits之后，当我们设计新的泛型算法时，面对C++纯量型别，便有足够的信息决定采用最有效的拷贝动作或赋值动作—因为每一个纯量型别都有对应的__type_traits 特化版ᴀ，其中每一个 typedef 的值都是__true_type。 </p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>研究数据的特定排列方式，以利搜寻或排序或其它特殊目的，这一专门学科我们称为数据结构（Data Structures）。大学信息相关教育里头，与编程最有直接关系的科目，首推数据结构与算法（Algorithms）。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL 容器即是将运用最广的一些数据结构实作出来。</p>
<p>常用的数据结构不外乎 array（数组）、list（串行）、tree（树）、stack （堆栈）、queue（队列）、hash table（杂凑表）、set（集合）、map（映像表）等等。根据「资料在容器中的排列」特性，这些数据结构分为序列式（sequence）和关系型（associative）两种。</p>
<h2 id="序列式容器（sequential-containers）"><a href="#序列式容器（sequential-containers）" class="headerlink" title="序列式容器（sequential containers）"></a>序列式容器（sequential containers）</h2><p>所谓序列式容器，其中的元素都可序（<em>ordered</em>），但未排序（<em>sorted</em>）。C++ 语言本身提供了一个序列式容器array，STL另外再提供vector,list,deque, stack,queue,priority-queue等等序列式容器。其中stack和queue由于只是将deque改头换面而成，技术上被归类为一种配接器（adapter），但仍把它们放在本章讨论。本章将带你仔细看过各种序列式容器的关键实作细节。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="vector-概述"><a href="#vector-概述" class="headerlink" title="vector 概述"></a>vector 概述</h3><p>vector的数据安排以及操作方式，与array非常像似。两者的唯一差别在于<strong>空间的运用弹性</strong>。array是静态空间，一旦配置了就不能改变；如果要换个大（或小） 一点的空间，一切细琐需由客端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，然后再把原来的空间释还给系统。vector是<strong>动态空间</strong>，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的樽节与运用弹性有很大的帮助，我们再也不必因为害怕空间不足而一开始就要求一个大块头array了，我们可以安心使用vector，需要多少用多少。</p>
<p>vector的实作技术，关键在于其对大小的控制以及重新配置时的数据搬移效率。</p>
<p>一旦vector旧有空间满载，如果客端每新增一个元素，vector内部只是扩充一 个元素的空间，实为不智，因为所谓扩充空间（不论多大），是「配置新空间 &#x2F;数据搬移 &#x2F;释还旧空间」的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。</p>
<h3 id="vector-定义式摘要"><a href="#vector-定义式摘要" class="headerlink" title="vector 定义式摘要"></a>vector 定义式摘要</h3><p>以下是vector定义式的源码摘录。虽然 STL规定，欲使用vector者必须先含入<code>&lt;vector&gt;</code>，但 SGI STL 将vector实作于更底层的<code>&lt;stl_vector.h&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alloc是 SGI STL的空间配置器，见第二章。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// vector 的内嵌型别定义</span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* iterator; </span><br><span class="line"> <span class="keyword">typedef</span> value_type&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="comment">// 以下，simple_alloc 是 SGI STL的空间配置器，见 2.2.4节。</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator; </span><br><span class="line"> iterator start; </span><br><span class="line"> iterator finish; </span><br><span class="line"> <span class="comment">//表示目前使用空间的头</span></span><br><span class="line"> <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage; <span class="comment">//表示目前可用空间的尾</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span></span>; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> start =<span class="built_in">allocate_and_fill</span>(n, value); </span><br><span class="line"> finish = start + n; </span><br><span class="line"> end_of_storage = finish; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125; </span><br><span class="line"> <span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125; </span><br><span class="line"> <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="built_in">vector</span>(<span class="type">int</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="built_in">vector</span>(<span class="type">long</span> n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125; </span><br><span class="line"> ~<span class="built_in">vector</span>() &#123;</span><br><span class="line"> <span class="built_in">destroy</span>(start, finish); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> <span class="built_in">deallocate</span>(); <span class="comment">// 这是 vector 的一个 member function </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125; <span class="comment">//第一个元素</span></span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;<span class="comment">//最后一个元素</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123; </span><br><span class="line"> <span class="comment">//将元素安插至最尾端</span></span><br><span class="line"> <span class="built_in">construct</span>(finish, x); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> ++finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">// 这是 vector 的一个 member function </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; <span class="comment">//将最尾端元素取出</span></span><br><span class="line">  --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; <span class="comment">//清除某位置上的元素</span></span><br><span class="line"> <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) </span><br><span class="line"> <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);<span class="comment">//后续元素往前搬移</span></span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> <span class="keyword">return</span> position; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line"> <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123;<span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 配置空间并填满内容</span></span><br><span class="line"> <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> iterator result =data_allocator::<span class="built_in">allocate</span>(n); </span><br><span class="line"> <span class="built_in">uninitialized_fill_n</span>(result, n, x); <span class="comment">// 全域函式，见 2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vector-的迭代器"><a href="#vector-的迭代器" class="headerlink" title="vector 的迭代器"></a>vector 的迭代器</h3><p>vector维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以做为 vector的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如 operator*,operator-&gt;,operator++,operator–,operator+, operator-, operator+&#x3D;,operator-&#x3D;，普通指针天生就具备。vector支持随机存取，而普通指针正有着这样的能力。所以，vector 提供的是 <em>Random Access Iterators</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// vector 的迭代器是普通指针</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上述定义，如果客端写出这样的码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator ivite; </span><br><span class="line">vector&lt;Shape&gt;::iterator svite;</span><br></pre></td></tr></table></figure>

<p>ivite的型别其实就是int*，svite的型别其实就是 Shape*。</p>
<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><p>vector所采用的数据结构非常简单：线性连续空间。它以两个迭代器start和finish分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器end_of_storage指向整块连续空间（含备用空间）的尾端：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, classAlloc = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> iterator start; <span class="comment">//表示目前使用空间的头</span></span><br><span class="line"> iterator finish; <span class="comment">//表示目前使用空间的尾</span></span><br><span class="line"> iterator end_of_storage; <span class="comment">//表示目前可用空间的尾，注意“使用”与“可用”之间的差别</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了降低空间配置时的速度成本，vector实际配置的大小可能比客端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的观念。换句话说一个 vector 的容量永远大于或等于其大小。一旦容量等于大小，便是满载，下次再有新增元素，整个vector就得另觅居所。</p>
<p>运用start, finish, end_of_storage三个迭代器，便可轻易提供首尾标示、大小、容量、空容器判断、注标（[ ]）运算子、最前端元素值、最后端元素值…等机能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, classAlloc = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line">... </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span>*(<span class="built_in">begin</span>() + n); &#125; <span class="comment">//重载[]运算</span></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125; </span><br><span class="line"> ... </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>大致的示意图如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/vector%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20220628153235013"></p>
<h3 id="vector-的建构与内存管理：constructor-push-back"><a href="#vector-的建构与内存管理：constructor-push-back" class="headerlink" title="vector 的建构与内存管理：constructor, push_back"></a>vector 的建构与内存管理：constructor, push_back</h3><p>下面是个小小的测试程序，观察重点在建构的方式、元素的添加，以及大小、容量的变化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4vector-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iv</span><span class="params">(<span class="number">2</span>,<span class="number">9</span>)</span></span>; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=2 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=2</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=3 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=4</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">2</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=4 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=4</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 1 2 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">push_back</span>(<span class="number">5</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=7 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 1 2 3 4 5 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">iv.<span class="built_in">pop_back</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=4 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator ivite =<span class="built_in">find</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ivite)iv.<span class="built_in">erase</span>(ivite);</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=3 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;iv.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; iv[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(), <span class="number">2</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite) ivec.<span class="built_in">insert</span>(ite,<span class="number">3</span>,<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 7 7 7 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">iv.<span class="built_in">clear</span>(); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; iv.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0 </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;capacity=&quot;</span> &lt;&lt; iv.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">// capacity=8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector预设使用alloc（第二章）做为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> vector &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="comment">// simple_alloc&lt;&gt; 见 2.2.4 节</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，<code>data_allocator::allocate(n)</code>表示配置 n 个元素空间。</p>
<p>vector 提供许多constructors，其中一个允许我们指定空间大小及初值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建构式，允许指定 vector 大小 n和初值 value </span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123;<span class="built_in">fill_initialize</span>(n, value); &#125; </span><br><span class="line"><span class="comment">// 充填并予初始化</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123; </span><br><span class="line"> start =<span class="built_in">allocate_and_fill</span>(n, value); </span><br><span class="line"> finish = start + n; <span class="comment">//指向下一个空的位置</span></span><br><span class="line"> end_of_storage = finish; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 配置而后充填</span></span><br><span class="line"> <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line"> iterator result =data_allocator::<span class="built_in">allocate</span>(n); <span class="comment">// 配置 n 个元素空间</span></span><br><span class="line"> <span class="built_in">uninitialized_fill_n</span>(result, n, x); <span class="comment">// 全域函式，见 2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>ninitialized_fill_n()会根据第一参数的型别特性（type traits，3.7 节），决定使用算法 fill_n()或反复呼叫 construct() 来完成任务（见 2.3 节描述）。</p>
<p>当我们以push_back()将新元素安插于vector 尾端，该函式首先检查是否还有备用空间？如果有就直接在备用空间上建构元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新配置、搬移数据、释放原空间）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123; <span class="comment">//还有备用空间</span></span><br><span class="line">	<span class="built_in">construct</span>(finish, x); <span class="comment">//全域函式，见 2.2.3节。</span></span><br><span class="line"> 	++finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//已无备用空间</span></span><br><span class="line">     <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">// vector member function，见以下列表</span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T&amp; x) &#123; </span><br><span class="line"> <span class="keyword">if</span> (finish != end_of_storage) &#123;<span class="comment">//还有备用空间</span></span><br><span class="line"><span class="comment">// 在备用空间起始处建构一个元素，并以 vector 最后一个元素值为其初值。</span></span><br><span class="line"><span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); </span><br><span class="line"><span class="comment">// 调整水位。</span></span><br><span class="line"> ++finish; </span><br><span class="line"> T x_copy = x; </span><br><span class="line"> <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>); </span><br><span class="line">     <span class="comment">//不要被 copy_backward() 算法的名称所误导，它不会逆转元素的顺序。它只会像 copy() 那样复制元素，但是顺序是从最后一个元素开始直到第一个元素。</span></span><br><span class="line"> *position = x_copy; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//已无备用空间</span></span><br><span class="line"> <span class="type">const</span> size_type old_size = <span class="built_in">size</span>(); </span><br><span class="line"> <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 以上配置原则：如果原大小为 0，则配置 1（个元素大小）；</span></span><br><span class="line"> <span class="comment">// 如果原大小不为 0，则配置原大小的两倍，</span></span><br><span class="line"> <span class="comment">// 前半段用来放置原资料，后半段准备用来放置新资料。</span></span><br><span class="line"> iterator new_start =data_allocator::<span class="built_in">allocate</span>(len); <span class="comment">//实际配置</span></span><br><span class="line"> iterator new_finish = new_start; </span><br><span class="line"> <span class="keyword">try</span> &#123; <span class="comment">//异常处理模型的trycatch</span></span><br><span class="line"><span class="comment">// 将原 vector 的内容拷贝到新 vector。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); <span class="comment">//[start,position)，左闭右开</span></span><br><span class="line"><span class="comment">// 为新元素设定初值 x </span></span><br><span class="line"><span class="built_in">construct</span>(new_finish, x); <span class="comment">//new_finish=position位置，是原来尾巴的下一个未用空间</span></span><br><span class="line"><span class="comment">// 调整水位。</span></span><br><span class="line"> ++new_finish;  </span><br><span class="line"><span class="comment">// 将原 vector 的备用空间中的内容也忠实拷贝过来(作者疑惑：啥用途？)</span></span><br><span class="line"> new_finish =<span class="built_in">uninitialized_copy</span>(position, finish, new_finish); </span><br><span class="line">     <span class="comment">//个人理解：实际上这个函数是在某个位置上插入x，只是恰好也有扩充空间的作用，因而拿来push_back()中扩充；</span></span><br><span class="line">     <span class="comment">//如果再考虑插入的情况，position不是最后的位置，就需要把原来后面的元素再拷贝过来</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"><span class="comment">// &quot;commit or rollback&quot; semantics. </span></span><br><span class="line"> <span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(new_start, len); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 解构并释放原 vector </span></span><br><span class="line"> <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); </span><br><span class="line"> <span class="built_in">deallocate</span>(); </span><br><span class="line"><span class="comment">// 调整迭代器，指向新 vector </span></span><br><span class="line"> start = new_start; </span><br><span class="line"> finish = new_finish; </span><br><span class="line"> end_of_storage = new_start + len; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后建构新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。</p>
<h3 id="vector-的元素操作：pop-back-erase-clear-insert"><a href="#vector-的元素操作：pop-back-erase-clear-insert" class="headerlink" title="vector 的元素操作：pop_back, erase, clear, insert"></a>vector 的元素操作：pop_back, erase, clear, insert</h3><p>vector所提供的元素操作动作很多，无法在有限篇幅中一一讲解——其实也没有这种必要。为搭配先前对空间配置的讨论，这里挑选数个相关函式做为解说对象。这些函式也出现在先前的测试程序中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将尾端元素拿掉，并调整大小。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//将尾端标记往前移一格，表示将放弃尾端元素。</span></span><br><span class="line"> <span class="comment">// destroy是全域函式，见第 2 章</span></span><br><span class="line"> <span class="comment">// 清除 [first,last) 中的所有元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> iterator i = <span class="built_in">copy</span>(last, finish, first);<span class="comment">// copy 是全域函式，第 6 章</span></span><br><span class="line"> <span class="built_in">destroy</span>(i, finish);<span class="comment">// destroy是全域函式，第 2 章</span></span><br><span class="line"> finish = finish - (last - first); </span><br><span class="line"> <span class="keyword">return</span> first; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 清除某个位置上的元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>()) </span><br><span class="line"> <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position); <span class="comment">// copy 是全域函式，第 6 章</span></span><br><span class="line"> --finish; </span><br><span class="line"> <span class="built_in">destroy</span>(finish); <span class="comment">// destroy是全域函式，2.2.3 节</span></span><br><span class="line"> <span class="keyword">return</span> position; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;<span class="comment">// erase()就定义在上面</span></span><br></pre></td></tr></table></figure>

<p>下图展示 erase(first, last)的动作。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B1%80%E9%83%A8%E5%8C%BA%E9%97%B4%E7%9A%84%E6%B8%85%E9%99%A4%E5%8A%A8%E4%BD%9Cerase(first,last).png" alt="image-20220628163842260"></p>
<p>下面是vector::insert()实作内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从 position 开始，安插 n个元素，元素初值为 x </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;<span class="comment">// 当 n != 0 才进行以下所有动作</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) </span><br><span class="line"> <span class="comment">// 备用空间大于等于「新增元素个数」</span></span><br><span class="line"> T x_copy = x; </span><br><span class="line"> <span class="comment">// 以下计算安插点之后的现有元素个数</span></span><br><span class="line"> <span class="type">const</span> size_type elems_after = finish - position; </span><br><span class="line"> iterator old_finish = finish; </span><br><span class="line"> <span class="keyword">if</span> (elems_after &gt; n) </span><br><span class="line"> <span class="comment">// 「安插点之后的现有元素个数」大于「新增元素个数」</span></span><br><span class="line"> 	<span class="built_in">uninitialized_copy</span>(finish - n, finish, finish); <span class="comment">//分两步后移n位腾出空间</span></span><br><span class="line"> finish += n;<span class="comment">//将 vector 尾端标记后移</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish); <span class="comment">//注：使用这个函数，只需要知道这一段元素的结尾应该copy到哪个位置（因为是从后往前copy），而不需要知道开头位置，实际上开头位置也可以算出来，但使用这个函数就不需要计算</span></span><br><span class="line"> <span class="built_in">fill</span>(position, position + n, x_copy);<span class="comment">//从安插点开始填入新值</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">// 「安插点之后的现有元素个数」小于等于「新增元素个数」</span></span><br><span class="line"> <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy); <span class="comment">//注：先把一些空间填上去先，而不是直接后移腾出空间（不过感觉差不多，因为要移动到的位置下面的finish也计算出来了）</span></span><br><span class="line"> finish += n - elems_after; </span><br><span class="line"> <span class="built_in">uninitialized_copy</span>(position, old_finish, finish); <span class="comment">//再把余下占用元素后移</span></span><br><span class="line"> finish += elems_after; </span><br><span class="line"> <span class="built_in">fill</span>(position, old_finish, x_copy); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="comment">// 备用空间小于「新增元素个数」（那就必须配置额外的内存）</span></span><br><span class="line"> <span class="comment">// 首先决定新长度：旧长度的两倍，或旧长度+新增元素个数。</span></span><br><span class="line"> <span class="type">const</span> size_type old_size = <span class="built_in">size</span>(); </span><br><span class="line"> <span class="type">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n); </span><br><span class="line"> <span class="comment">// 以下配置新的 vector 空间</span></span><br><span class="line"> iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); </span><br><span class="line"> iterator new_finish = new_start; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> <span class="comment">// 以下首先将旧 vector的安插点之前的元素复制到新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); </span><br><span class="line"> <span class="comment">// 以下再将新增元素（初值皆为 n）填入新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x); </span><br><span class="line"> <span class="comment">// 以下再将旧 vector 的安插点之后的元素复制到新空间。</span></span><br><span class="line"> new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __STL_USE_EXCEPTIONS </span></span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> <span class="comment">// 如有异常发生，实现 &quot;commit or rollback&quot; semantics. </span></span><br><span class="line"><span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(new_start, len); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta"># <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line"> <span class="comment">// 以下清除并释放旧的 vector </span></span><br><span class="line"><span class="built_in">destroy</span>(start, finish); </span><br><span class="line"><span class="built_in">deallocate</span>(); </span><br><span class="line"><span class="comment">// 以下调整水位标记</span></span><br><span class="line">start = new_start; </span><br><span class="line">finish = new_finish;  </span><br><span class="line">end_of_storage = new_start + len; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，安插完成后，新节点将位于标兵迭代器（上例之 position，标示出安插点）所指之节点的前方—这是STL对于「安插动作」的标准规范。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B51.png" alt="image-20220628165729556"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B52.png" alt="image-20220628165749526"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/insert(position,n,x)%E7%8A%B6%E5%86%B53.png" alt="image-20220628165819539"></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-概述"><a href="#list-概述" class="headerlink" title="list 概述"></a>list 概述</h3><p>相较于vector的连续线性空间，list就显得复杂许多，它的好处是每次安插或删除一个元素，就配置或释放一个元素空间。因此，list对于<strong>空间的运用有绝对的精准</strong>，一点也不浪费。而且，对于任何位置的元素<strong>安插</strong>或元素<strong>移除</strong>，list永远是<strong>常数时间</strong>。</p>
<p>list和vector是两个最常被使用的容器。什么时机下最适合使用哪一种容器，必须视元素的多寡、元素的构造复杂度（有无 non-trivial copy constructor, non-trivial copy assignmen operator）、元素存取行为的特性而定。</p>
<h3 id="list-的节点（node）"><a href="#list-的节点（node）" class="headerlink" title="list 的节点（node）"></a>list 的节点（node）</h3><p>list本身和 list的节点是不同的结构，需要分开设计。以下是 STL list的节点（node）结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">void</span>* void_pointer; </span><br><span class="line"> void_pointer prev; <span class="comment">//型别为 void*。其实可设为 __list_node&lt;T&gt;* </span></span><br><span class="line"> void_pointer next; </span><br><span class="line"> T data; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>显然这是一个双向串行（有前后指针）。</p>
<h3 id="list-的迭代器"><a href="#list-的迭代器" class="headerlink" title="list 的迭代器"></a>list 的迭代器</h3><p>list不再能够像vector一样以普通指针做为迭代器，因为其节点不保证在储存空间中连续存在。list迭代器必须有能力指向list的节点，并有能力做正确的递增、递减、取值、成员存取…等动作。所谓「list迭代器正确的递增、递减、取值、成员取用」动作是指，递增时指向下一个节点，递减时指向上一个节点，取值时取的是节点的值，成员取用时取用的是节点的成员。</p>
<p>由于STL list是一个双向串行（double linked-list），迭代器必须具备前移、后移的能力。所以list提供的是<em>Bidirectional Iterator</em>s。</p>
<p>list有一个重要性质：安插动作（insert）和接合动作（splice）都不会造成原有的list迭代器失效。这在vector是不成立的，因为vector的安插动作可能造成内存重新配置，导致原有的迭代器全部失效。甚至list的元素删除动作（erase），也只有「指向被删除元素」的那个迭代器失效，其它迭代器不受任何影响。</p>
<p>以下是list迭代器的设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span> &#123; </span><br><span class="line"> <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self; </span><br><span class="line"> <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> link_type node; <span class="comment">//迭代器内部当然要有一个指针，指向 list 的节点</span></span><br><span class="line"><span class="comment">// constructor </span></span><br><span class="line"> __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> __list_iterator() &#123;&#125; </span><br><span class="line"> __list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125; </span><br><span class="line"><span class="comment">// 以下对迭代器取值（dereference），取的是节点的资料值。</span></span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125; </span><br><span class="line"><span class="comment">// 以下是迭代器的成员存取（member access）运算子的标准作法。</span></span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line"><span class="comment">// 对迭代器累加 1，就是前进一个节点</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> node = (link_type)((*node).next); </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> ++*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 对迭代器递减 1，就是后退一个节点</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>--()</span><br><span class="line"> node = (link_type)((*node).prev); </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> --*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="list-的数据结构"><a href="#list-的数据结构" class="headerlink" title="list 的数据结构"></a>list 的数据结构</h3><p>SGI list不仅是一个双向串行，而且还是一个环状双向串行。所以它只需要一个指标，便可以完整表现整个串行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;<span class="comment">// 预设使用 alloc 为配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> list_node* link_type; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> link_type node;<span class="comment">// 只要一个指标，便可表示整个环状双向串行</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果让指标node指向刻意置于尾端的一个空白节点，node便能符合 STL对于「前闭后开」区间的要求，成为last迭代器。</p>
<p>示意图如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/list%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20220628201940409"></p>
<p>这么一来，以下几个函式便都可以轻易完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125; </span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125; </span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">size_type result = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result); <span class="comment">// 全域函式，第 3 章。</span></span><br><span class="line"><span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 取头节点的内容（元素值）。</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125; </span><br><span class="line"><span class="comment">// 取尾节点的内容（元素值）。</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-的建构与内存管理：constructor-push-back-insert"><a href="#list-的建构与内存管理：constructor-push-back-insert" class="headerlink" title="list 的建构与内存管理：constructor, push_back, insert"></a>list 的建构与内存管理：constructor, push_back, insert</h3><p>下面是一个测试程序，观察重点在建构的方式以及大小的变化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4list-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> list&lt;<span class="type">int</span>&gt; ilist; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0 </span></span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">0</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">1</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">2</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> ilist.<span class="built_in">push_back</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> list&lt;<span class="type">int</span>&gt;::iterator ite; </span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> ilist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 99 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> cout &lt;&lt; *(ilist.<span class="built_in">erase</span>(ite)) &lt;&lt; endl; <span class="comment">// 2 </span></span><br><span class="line"> <span class="keyword">for</span>(ite = ilist.<span class="built_in">begin</span>(); ite != ilist.<span class="built_in">end</span>(); ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 2 99 3 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list预设 使用alloc 做为空间配置器 ， 并据此另外定义了一个list_node_allocator，为的是更方便地以节点大小为配置单位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;<span class="comment">// 预设使用 alloc 为配置器</span></span><br><span class="line"><span class="keyword">class</span> list &#123; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node; </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个节点大小：</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是，list_node_allocator(n)表示配置n个节点空间。以下四个函式，分别用来配置、释放、建构、摧毁一个节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 配置一个节点并传回</span></span><br><span class="line"> <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>(); &#125; </span><br><span class="line"> <span class="comment">// 释放一个节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::<span class="built_in">deallocate</span>(p); &#125; </span><br><span class="line"> <span class="comment">// 产生（配置并建构）一个节点，带有元素值</span></span><br><span class="line"> <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> link_type p = <span class="built_in">get_node</span>(); </span><br><span class="line"> <span class="built_in">construct</span>(&amp;p-&gt;data, x); <span class="comment">//全域函式，建构/解构基本工具。</span></span><br><span class="line"> <span class="keyword">return</span> p; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 摧毁（解构并释放）一个节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123; </span><br><span class="line"> <span class="built_in">destroy</span>(&amp;p-&gt;data); <span class="comment">//全域函式，建构/解构基本工具</span></span><br><span class="line"> <span class="built_in">put_node</span>(p);</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>list提供有许多constructors，其中一个是default constructor，允许我们不指定任何参数做出一个空的list出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">list</span>() &#123;<span class="built_in">empty_initialize</span>(); &#125; <span class="comment">//产生一个空串行。</span></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> node </span>=<span class="built_in">get_node</span>(); <span class="comment">//配置一个节点空间，令 node 指向它。</span></span><br><span class="line"> node-&gt;next = node;<span class="comment">//令 node头尾都指向自己，不设元素值。</span></span><br><span class="line"> node-&gt;prev = node; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/emptylist%EF%BC%88%E7%A9%BA%E4%B8%B2%E8%A1%8C%EF%BC%89.png" alt="image-20220629142749124"></p>
<p>当我们以 push_back() 将新元素安插于 list 尾端，此函式内部呼叫insert()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125;</span><br></pre></td></tr></table></figure>

<p>insert()是一个多载化函式，有多种型式，其中最简单的一种如下，符合以上所需。首先配置并建构一个节点，然后在尾端做适当的指标动作，将新节点安插进去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函式目的：在迭代器 position 所指位置安插一个节点，内容为 x。</span></span><br><span class="line"> <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp; x)</span> </span>&#123; </span><br><span class="line"> link_type tmp =<span class="built_in">create_node</span>(x); <span class="comment">//产生一个节点（设内容为 x）</span></span><br><span class="line"> <span class="comment">// 调整双向指标，使 tmp安插进去。</span></span><br><span class="line"> tmp-&gt;next = position.node; </span><br><span class="line"> tmp-&gt;prev = position.node-&gt;prev; </span><br><span class="line"> (<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp; </span><br><span class="line"> position.node-&gt;prev = tmp; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意，安插完成后，新节点将位于标兵迭代器（标示出安插点）所指之节点的前方——这是STL对于「安插动作」的标准规范。由于 list 不像 vector 那样有可能在空间不足时做重新配置、数据搬移的动作，所以安插前的所有迭代器在安插动作之后都仍然有效。</p>
<h3 id="list-的元素操作"><a href="#list-的元素操作" class="headerlink" title="list 的元素操作"></a>list 的元素操作</h3><p>元素操作的手段包括：<code>push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort </code></p>
<p>list所提供的元素操作动作很多，无法在有限的篇幅中一一讲解—其实也没有这种必要。为搭配先前对空间配置的讨论，我挑选数个相关函式做为解说对象。先前示例中出现有尾部安插动作（push_back），现在我们来看看其它的安插动作和移除动作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安插一个节点，做为头节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x); &#125; </span><br><span class="line"><span class="comment">// 安插一个节点，做为尾节点（上一小节才介绍过）</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125; </span><br><span class="line"><span class="comment">// 移除迭代器 position 所指节点</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; </span><br><span class="line"> link_type next_node = <span class="built_in">link_type</span>(position.node-&gt;next); </span><br><span class="line"> link_type prev_node = <span class="built_in">link_type</span>(position.node-&gt;prev); </span><br><span class="line"> prev_node-&gt;next = next_node; </span><br><span class="line"> next_node-&gt;prev = prev_node; </span><br><span class="line"><span class="built_in">destroy_node</span>(position.node); </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// 移除头节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>()); &#125; </span><br><span class="line"><span class="comment">// 移除尾节点</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> iterator tmp </span>= <span class="built_in">end</span>(); </span><br><span class="line"><span class="built_in">erase</span>(--tmp); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//清除所有节点（整个串行）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>() </span><br><span class="line">&#123; </span><br><span class="line"> link_type cur = (link_type) node-&gt;next; <span class="comment">// begin() </span></span><br><span class="line"> <span class="keyword">while</span> (cur != node) &#123;<span class="comment">//巡访每一个节点</span></span><br><span class="line"> link_type tmp = cur; </span><br><span class="line"> cur = (link_type) cur-&gt;next; </span><br><span class="line"><span class="number">137</span> </span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">destroy_node</span>(tmp); <span class="comment">//摧毁（解构并释放）一个节点</span></span><br><span class="line"><span class="comment">// 恢复 node 原始状态</span></span><br><span class="line"> node-&gt;next = node; </span><br><span class="line"> node-&gt;prev = node; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数值为 value之所有元素移除</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value) &#123; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last = <span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">while</span> (first != last) &#123;<span class="comment">//巡访每一个节点</span></span><br><span class="line"> iterator next = first; </span><br><span class="line"> ++next; </span><br><span class="line"> <span class="keyword">if</span> (*first == value)<span class="built_in">erase</span>(first); <span class="comment">//找到就移除</span></span><br><span class="line"> first = next; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//移除数值相同的连续元素。注意，只有「连续而相同的元素」，才会被移除剩一个。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>() &#123; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last = <span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;<span class="comment">//空串行，什么都不必做。</span></span><br><span class="line"> iterator next = first; </span><br><span class="line"> <span class="keyword">while</span> (++next != last) &#123; <span class="comment">//巡访每一个节点</span></span><br><span class="line"> <span class="keyword">if</span> (*first == *next) <span class="comment">//如果在此区段中有相同的元素</span></span><br><span class="line"> 	<span class="built_in">erase</span>(next); <span class="comment">//移除之</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     first = next; <span class="comment">//调整指标</span></span><br><span class="line"> next = first; <span class="comment">//修正区段范围</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于list是一个双向环状串行，只要我们把边际条件处理好，那么，在头部或尾部安插元素（push_front和push_back），动作几乎是一样的，在头部或尾部移除元素（pop_front和pop_back），动作也几乎是一样的。移除（erase）某个迭代器所指元素，只是做一些指标搬移动作而已，并不复杂。</p>
<p>list内部提供一个所谓的迁移动作（transfer）：将某连续范围的元素迁移到某个特定位置之前。技术上很简单，节点间的指标移动而已。这个动作为其它的复杂动作如splice, sort, merge等奠定良好的基础。下面是transfer的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> <span class="comment">// 将 [first,last) 内的所有元素搬移到 position 之前。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position != last) &#123; </span><br><span class="line"> (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node; <span class="comment">// (1) </span></span><br><span class="line"> (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node; <span class="comment">// (2) </span></span><br><span class="line"> (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node; <span class="comment">// (3) </span></span><br><span class="line"> link_type tmp = <span class="built_in">link_type</span>((*position.node).prev); <span class="comment">// (4)</span></span><br><span class="line"> (*position.node).prev = (*last.node).prev; <span class="comment">// (5)</span></span><br><span class="line"> (*last.node).prev = (*first.node).prev; <span class="comment">// (6)</span></span><br><span class="line"> (*first.node).prev = tmp; <span class="comment">// (7)</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上七个动作，一步一步地显示于下图：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/transfer%E7%9A%84%E5%8A%A8%E4%BD%9C%E7%A4%BA%E6%84%8F.png" alt="image-20220629144350474"></p>
<p>transfer所接受的[first,last)区间，是否可以在同一个list之中呢？答案是可以。你只要想象上图所画的两条lists其实是同一个list的两个区段，就不难得到答案了。</p>
<p>上述的 transfer并非公开界面。list公开提供的是所谓的接合动作（splice）：将某连续范围的元素从一个list搬移到另一个（或同一个）list的某个定点。如果接续先前 4list-test.cpp 程序的最后执行点，继续执行以下splice动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iv[<span class="number">5</span>] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;; </span><br><span class="line"> <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist2</span><span class="params">(iv, iv+<span class="number">5</span>)</span></span>; </span><br><span class="line"> <span class="comment">// 目前，ilist的内容为 0 2 99 3 4 </span></span><br><span class="line"> ite = <span class="built_in">find</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">99</span>); </span><br><span class="line"> ilist.<span class="built_in">splice</span>(ite,ilist2); <span class="comment">// 0 2 5 6 7 8 9 99 3 4</span></span><br><span class="line"> ilist.<span class="built_in">reverse</span>(); <span class="comment">// 4 3 99 9 8 7 6 5 2 0 </span></span><br><span class="line"> ilist.<span class="built_in">sort</span>();<span class="comment">// 0 2 3 4 5 6 7 8 9 99</span></span><br></pre></td></tr></table></figure>

<p>很容易便可看出效果，接合动作技术上很简单，只是节点间的指标移动而已，这些动作已完全由transfer()做掉了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%8E%A5%E5%90%88%EF%BC%88splice%EF%BC%89%E5%8A%A8%E4%BD%9C.png" alt="image-20220629145208401"></p>
<p>为了提供各种接口弹性，list<T>::splice有许多版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// 将 x接合于 position 所指位置之前。x必须不同于 *this。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (!x.<span class="built_in">empty</span>()) </span><br><span class="line"><span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 将 i 所指元素接合于 position 所指位置之前。position 和 i 可指向同一个 list。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span> </span>&#123; </span><br><span class="line"> iterator j = i; </span><br><span class="line"> ++j; </span><br><span class="line"> <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>; </span><br><span class="line"><span class="built_in">transfer</span>(position, i, j); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 将 [first,last) 内的所有元素接合于 position所指位置之前。</span></span><br><span class="line"> <span class="comment">// position 和[first,last)可指向同一个 list，</span></span><br><span class="line"> <span class="comment">// 但 position 不能位于[first,last)之内。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (first != last) </span><br><span class="line"><span class="built_in">transfer</span>(position, first, last); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以下是merge(), reverse(), sort()的源码。有了transfer()在手，这些动作都不难完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge()将 x合并到 *this身上。两个 lists 的内容都必须先经过递增排序。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123; </span><br><span class="line"> iterator first1 = <span class="built_in">begin</span>(); </span><br><span class="line"> iterator last1 = <span class="built_in">end</span>(); </span><br><span class="line"> iterator first2 = x.<span class="built_in">begin</span>(); </span><br><span class="line"> iterator last2 = x.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="comment">// 注意：前提是，两个 lists都已经过递增排序，</span></span><br><span class="line"> <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) <span class="comment">//注：如同归并排序的合并部分</span></span><br><span class="line"> <span class="keyword">if</span> (*first2 &lt; *first1) &#123; </span><br><span class="line"> iterator next = first2; </span><br><span class="line"> <span class="built_in">transfer</span>(first1, first2, ++next); </span><br><span class="line"> first2 = next; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> ++first1; </span><br><span class="line"> <span class="keyword">if</span> (first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse()将 *this的内容逆向重置</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下判断，如果是空白串行，或仅有一个元素，就不做任何动作。</span></span><br><span class="line"> <span class="comment">// 使用 size() == 0 || size() == 1来判断，虽然也可以，但是比较慢。</span></span><br><span class="line"> <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> iterator first = <span class="built_in">begin</span>(); </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123; </span><br><span class="line"> iterator old = first; </span><br><span class="line"> ++first; </span><br><span class="line"> <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first); <span class="comment">//左闭右开，把第2个插到最前面，把第3个插到最前面...一直下去就倒序了</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 不能使用 STL 算法 sort()，必须使用自己的 sort() member function，</span></span><br><span class="line"><span class="comment">//因为 STL 算法 sort() 只接受 RamdonAccessIterator. </span></span><br><span class="line"><span class="comment">//本函式采用 quick sort. </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; </span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下判断，如果是空白串行，或仅有一个元素，就不做任何动作。</span></span><br><span class="line"> <span class="comment">// 使用 size() == 0 || size() == 1来判断，虽然也可以，但是比较慢。</span></span><br><span class="line"> <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) </span><br><span class="line"> <span class="keyword">return</span>; </span><br><span class="line"> <span class="comment">// 一些新的 lists，做为中介数据存放区</span></span><br><span class="line"> list&lt;T, Alloc&gt; carry; </span><br><span class="line"> list&lt;T, Alloc&gt; counter[<span class="number">64</span>]; </span><br><span class="line"> <span class="type">int</span> fill = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span> (!<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>()); </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> counter[i].<span class="built_in">merge</span>(carry); </span><br><span class="line"> carry.<span class="built_in">swap</span>(counter[i++]); </span><br><span class="line"> &#125; </span><br><span class="line"> carry.<span class="built_in">swap</span>(counter[i]); </span><br><span class="line"> <span class="keyword">if</span> (i == fill) ++fill; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; ++i) </span><br><span class="line"> counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]); </span><br><span class="line"><span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="deque-概述"><a href="#deque-概述" class="headerlink" title="deque 概述"></a>deque 概述</h3><p>vector是<strong>单向开口</strong>的连续线性空间，deque则是一种<strong>双向开口</strong>的连续线性空间。所谓双向开口，意思是可以在头尾两端分别做元素的安插和删除动作。vector当然也可以在头尾两端做动作（从技术观点），但是其<strong>头部动作效率奇差</strong>，无法被接受。</p>
<p>deque和vector的最大差异，一在于deque允许于常数时间内对起头端进行元素的安插或移除动作，二在于deque没有所谓容量（capacity）观念，因为它是动态地以<strong>分段连续空间</strong>组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样「因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间」这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留（reserve）功能。</p>
<p>虽然deque也提供<em>Ramdon Access Iterator</em>，但它的迭代器并不是普通指针，其复杂度和vector不可以道里计（稍后看到源码，你便知道），这当然在在影响了各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。 对 deque进行的排序动作，为了最高效率，可将deque先完整复制到一个 vector 身上，将vector排序后（利用 STL sort算法），再复制回 deque。</p>
<h3 id="deque-的中控器"><a href="#deque-的中控器" class="headerlink" title="deque 的中控器"></a>deque 的中控器</h3><p>deque是连续空间（至少逻辑看来如此），deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的界面。避开了「重新配置、复制、释放」的轮回，代价则是复杂的迭代器架构。 </p>
<p>受到分段连续线性空间的字面影响，可能以为deque的实作复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既曰分段连续线性空间，就必须有<strong>中央控制</strong>，而为了维护整体连续的假象，数据结构的设计及迭代器前进后退等动作都颇为繁琐。deque的实作码份量远比vector或list都多得多。</p>
<p>deque采用一块所谓的<em><strong>map</strong></em>（注意，不是 STL 的map容器）做为主控。这里所谓<em>map</em>是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指标，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL允许我们指定缓冲区大小，默认值 0表示将使用 512 bytes缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic types </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> ... </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"> <span class="comment">// 元素的指针的指针（pointer of pointer of T）</span></span><br><span class="line"> <span class="keyword">typedef</span> pointer* map_pointer; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Data members</span></span><br><span class="line"> map_pointermap; <span class="comment">//指向 map，map 是块连续空间，其内的每个元素</span></span><br><span class="line"> <span class="comment">// 都是一个指标（称为节点），指向一块缓冲区。</span></span><br><span class="line"> size_typemap_size;<span class="comment">// map 内可容纳多少指标。</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><em>map</em>其实是一个T**，也就是说它是一个指标，所指之物又是一 个指标，指向型别为T的一块空间</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1map.png" alt="image-20220629151506642"></p>
<h3 id="deque-的迭代器"><a href="#deque-的迭代器" class="headerlink" title="deque 的迭代器"></a>deque 的迭代器</h3><p>deque是分段连续空间 。维护其「整体连续」假象的任务 ，着落在迭代器的operator++和operator– 两个运算子身上。</p>
<p>让我们思考一下，deque迭代器应该具备什么结构。首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退时就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（<em>map</em>）。下面这种实作方式符合需求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123;<span class="comment">//᳾继承 std::iterator </span></span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt; const_iterator; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="built_in">return__deque_buf_size</span>(BufSiz, <span class="built_in">sizeof</span>(T)); &#125; </span><br><span class="line"><span class="comment">// ᳾继承 std::iterator，所以必须自行撰写五个必要的迭代器相应型别（第 3 章）</span></span><br><span class="line"> typedefrandom_access_iterator_tagiterator_category; <span class="comment">// (1) </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"><span class="comment">// (2) </span></span><br><span class="line"><span class="comment">// (3) </span></span><br><span class="line"><span class="comment">// (4) </span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;<span class="comment">// (5) </span></span><br><span class="line"> <span class="keyword">typedef</span> T** map_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator self; </span><br><span class="line"> <span class="comment">// 保持与容器的联结</span></span><br><span class="line"> T* cur;<span class="comment">//此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line"> T* first;<span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line"> T* last;<span class="comment">//此迭代器所指之缓冲区的尾（含备用空间）</span></span><br><span class="line">map_pointer node;<span class="comment">//指向管控中心</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中用来决定<strong>缓冲区大小</strong>的函式buffer_size()，呼叫__deque_buf_size()，后者是个全域函式，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 n不为 0，传回 n，表示 buffer size 由使用者自定。</span></span><br><span class="line"><span class="comment">//如果 n为 0，表示 buffer size使用默认值，那么</span></span><br><span class="line"><span class="comment">// 如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，</span></span><br><span class="line"><span class="comment">// 如果 sz 不小于 512，传回 1。</span></span><br><span class="line"><span class="type">inlinesize_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque的中控器、缓冲区、迭代器的相互关系如下图，中控器控制缓冲区，迭代器能控制缓冲区，也能获取中控器的信息。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84%E4%B8%AD%E6%8E%A7%E5%99%A8%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="image-20220629152413832"></p>
<p>假设现在我们产生一个<code>deque&lt;int&gt;</code>，并令其缓冲区大小为32，于是每个缓冲区可容纳 32&#x2F;sizeof(int)&#x3D;4 个元素。经过某些操作之后，deque 拥有 20 个元素，那么其begin()和end()所传回的两个迭代器应该如下图。这两个迭代器事实上一直保持在deque内，名为start和finish，稍后在deque数据结构中 便可看到）。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%9A%84begin%E5%92%8Cend.png" alt="image-20220629152706622"></p>
<p>20个元素需要 20&#x2F;8 &#x3D; 3 个缓冲区，所以<em>map</em>之内运用了三个节点。迭代器 start 内的 cur指标当然指向缓冲区的第一个元素，迭代器 finish内的 cur指标当然指向缓冲区的最后元素（的下一位置）。注意，最后一个缓冲区尚有备用空间。稍后如果有新元素要安插于尾端，可直接拿此备用空间来使用。</p>
<p>下面是deque迭代器的几个关键行为。由于迭代器内对各种指标运算都做了多载化动作，所以各种指标运算如加、减、前进、后退…都不能直观视之。其中最重点的关键就是：一旦行进时<strong>遇到缓冲区边缘</strong>，要特别当心，视前进或后退而定，可能需要呼叫set_node()跳一个缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123; </span><br><span class="line">node = new_node; </span><br><span class="line">first = *new_node; </span><br><span class="line">last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//以下各个多载化运算子是 __deque_iterator&lt;&gt; 成功运作的关键。</span></span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125; </span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"> difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;  </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>++() &#123; </span><br><span class="line"> ++cur; <span class="comment">//切换至下一个元素。</span></span><br><span class="line"> <span class="keyword">if</span> (cur == last) &#123; <span class="comment">//如果已达所在缓冲区的尾端，</span></span><br><span class="line"> <span class="built_in">set_node</span>(node + <span class="number">1</span>);<span class="comment">//就切换至下一节点（亦即缓冲区）的第一个元素。</span></span><br><span class="line"> cur = first; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;<span class="comment">//后置式，标准写法</span></span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> ++*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>--() &#123; </span><br><span class="line"> <span class="keyword">if</span> (cur == first) &#123; <span class="comment">//如果已达所在缓冲区的头端，</span></span><br><span class="line"> <span class="built_in">set_node</span>(node - <span class="number">1</span>);<span class="comment">//就切换至前一节点（亦即缓冲区）的最后一个元素。</span></span><br><span class="line"> cur = last; </span><br><span class="line"> &#125; </span><br><span class="line"> --cur; <span class="comment">//切换至前一个元素。</span></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;<span class="comment">//后置式，标准写法</span></span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> --*<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n个距离。</span></span><br><span class="line"> self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123; </span><br><span class="line"> difference_type offset = n + (cur - first); </span><br><span class="line"> <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) </span><br><span class="line"> <span class="comment">// 标的位置在同一缓冲区内</span></span><br><span class="line"> 	cur += n; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// 标的位置不在同一缓冲区内</span></span><br><span class="line"> difference_type node_offset = </span><br><span class="line"> offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 切换至正确的节点（亦即缓冲区）</span></span><br><span class="line"><span class="built_in">set_node</span>(node + node_offset); </span><br><span class="line"><span class="comment">// 切换至正确的元素</span></span><br><span class="line"> cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp += n; <span class="comment">// 唤起 operator+= </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> self&amp;<span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>+= -n; &#125; </span><br><span class="line"> <span class="comment">// 以上利用 operator+= 来完成 operator-= </span></span><br><span class="line"> <span class="comment">// 参考More Effective C++, item22: Consider using op= instead of </span></span><br><span class="line"> <span class="comment">// stand-alone op. </span></span><br><span class="line"> self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> <span class="keyword">return</span> tmp -= n; <span class="comment">// 唤起 operator-= </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 以下实现随机存取。迭代器可以直接跳跃 n个距离。</span></span><br><span class="line"> reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125; </span><br><span class="line"> <span class="comment">// 以上唤起 operator*, operator+ </span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque-的数据结构"><a href="#deque-的数据结构" class="headerlink" title="deque 的数据结构"></a>deque 的数据结构</h3><p>deque除了维护一个先前说过的指向<em>map</em>的指标外，也维护start, finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外它当然也必须记住目前的<em>map</em>大小。因为一旦<em>map</em>所提供的节点不足，就必须重新配置更大的一块<em>map</em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic types </span></span><br><span class="line"> <span class="keyword">typedef</span> T value_type;</span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// Iterators </span></span><br><span class="line"> <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*,BufSiz&gt; iterator; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"> <span class="comment">// 元素的指针的指针（pointer of pointer of T）</span></span><br><span class="line"> <span class="keyword">typedef</span> pointer* map_pointer; </span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// Data members </span></span><br><span class="line"> iterator start; </span><br><span class="line"> iterator finish; </span><br><span class="line"> map_pointer map; </span><br><span class="line"> <span class="comment">//表现第一个节点。</span></span><br><span class="line"> <span class="comment">//表现最后一个节点。</span></span><br><span class="line"> <span class="comment">//指向 map，map 是块连续空间，</span></span><br><span class="line"> <span class="comment">// 其每个元素都是个指针，指向一个节点（缓冲区）。</span></span><br><span class="line"> size_type map_size;<span class="comment">// map 内有多少指标。</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上述结构，以下数个机能便可轻易完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// Basic accessors </span></span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125; </span><br><span class="line"> reference <span class="keyword">operator</span>[](size_type n) &#123; </span><br><span class="line"> <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">//唤起 __deque_iterator&lt;&gt;::operator[] </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 唤起 __deque_iterator&lt;&gt;::operator* </span></span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> iterator tmp = finish; </span><br><span class="line"> --tmp;<span class="comment">//唤起 __deque_iterator&lt;&gt;::operator-- </span></span><br><span class="line"> <span class="keyword">return</span> *tmp; <span class="comment">//唤起 __deque_iterator&lt;&gt;::operator* </span></span><br><span class="line"><span class="comment">// 以上三行何不改为：return *(finish-1); </span></span><br><span class="line"> <span class="comment">// 因为 __deque_iterator&lt;&gt; 没有为 (finish-1) 定义运算子?! </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 下行最后有两个 ‘;’，虽奇怪但合乎语法。</span></span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125; </span><br><span class="line"><span class="comment">// 以上唤起 iterator::operator- </span></span><br><span class="line"> <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque-的建构与内存管理-ctor-push-back-push-front"><a href="#deque-的建构与内存管理-ctor-push-back-push-front" class="headerlink" title="deque 的建构与内存管理 ctor, push_back, push_front"></a>deque 的建构与内存管理 ctor, push_back, push_front</h3><p>下面是一个测试程序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filename : 4deque-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="function">deque&lt;<span class="type">int</span>,alloc,32&gt; <span class="title">ideq</span><span class="params">(<span class="number">20</span>,<span class="number">9</span>)</span></span>; <span class="comment">// 注意，alloc 只适用于 G++ </span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=20 </span></span><br><span class="line"><span class="comment">// 现在，应该已经建构了一个 deque，有 20 个 int 元素，初值皆为 9。</span></span><br><span class="line"> <span class="comment">// 缓冲区大小为 32bytes。</span></span><br><span class="line"><span class="comment">// 为每一个元素设定新值。</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> ideq[i] = i; </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 4 5 6...19 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"><span class="comment">// 在最尾端增加 3 个元素，其值为 0,1,2 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) </span><br><span class="line"> ideq.<span class="built_in">push_back</span>(i); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 ... 19 0 1 2 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=23 </span></span><br><span class="line"><span class="comment">// 在最尾端增加 1 个元素，其值为 3 </span></span><br><span class="line"> ideq.<span class="built_in">push_back</span>(<span class="number">3</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 ... 19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=24 </span></span><br><span class="line"><span class="comment">// 在最前端增加 1 个元素，其值为 99 </span></span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">99</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">     cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 99 0 1 2 3...19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=25 </span></span><br><span class="line"><span class="comment">// 在最前端增加 2 个元素，其值分别为 98,97 </span></span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">98</span>); </span><br><span class="line"> ideq.<span class="built_in">push_front</span>(<span class="number">97</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 97 98 99 0 1 2 3...19 0 1 2 3 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=27 </span></span><br><span class="line"><span class="comment">// 搜寻数值为 99 的元素，并打印出来。</span></span><br><span class="line"> deque&lt;<span class="type">int</span>,alloc,32&gt;::iterator itr; </span><br><span class="line"> itr =<span class="built_in">find</span>(ideq.<span class="built_in">begin</span>(), ideq.<span class="built_in">end</span>(), <span class="number">99</span>); </span><br><span class="line"> cout &lt;&lt; *itr &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line"> cout &lt;&lt; *(itr.cur) &lt;&lt; endl; <span class="comment">// 99</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序一开始宣告了一个deque：<code> deque&lt;int,alloc,32&gt; ideq(20,9);</code></p>
<p> 其缓冲区大小为 32 bytes，并令其保留 20 个元素空间，每个元素初值为 9。为了指定deque的第三个 template参数（缓冲区大小），我们必须将前两个参数都指明出来（这是 C++语法规则），因此必须明确指定alloc（第二章）为空间配置器。</p>
<p>deque自行定义了两个专属的空间配置器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>: <span class="comment">// Internal typedefs </span></span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator; </span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个指针大小</span></span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure>

<p>并提供有一个constructor如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> value_type&amp; value):<span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">fill_initialize</span>(n, value); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其内所呼叫的 fill_initialize()负责产生并安排好deque的结构，并将元素的初值设定妥当：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="type">const</span> value_type&amp; value) &#123; </span><br><span class="line"><span class="built_in">create_map_and_nodes</span>(n); <span class="comment">// 把 deque 的结构都产生并安排好</span></span><br><span class="line">map_pointer cur; </span><br><span class="line">__STL_TRY &#123; </span><br><span class="line"><span class="comment">// 为每个节点的缓冲区设定初值</span></span><br><span class="line"><span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur) </span><br><span class="line">	<span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value); </span><br><span class="line"><span class="comment">// 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）</span></span><br><span class="line"><span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);<span class="comment">//注意finish.cur指向末尾 </span></span><br><span class="line">&#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> ... </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 create_map_and_nodes()负责产生并安排好deque的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 </span></span><br><span class="line"> <span class="comment">// 如果刚好整除，会多配一个节点。</span></span><br><span class="line"> size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>; </span><br><span class="line"> <span class="comment">// 一个 map要管理几个节点。最少 8 个，最多是 “所需节点数加 2” </span></span><br><span class="line"> <span class="comment">// （前后各预留一个，扩充时可用）。</span></span><br><span class="line"> map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>); </span><br><span class="line"> map =map_allocator::<span class="built_in">allocate</span>(map_size); </span><br><span class="line"> <span class="comment">// 以上配置出一个 “具有 map_size 个节点”的 map。</span></span><br><span class="line"> <span class="comment">// 以下令 nstart 和 nfinish 指向 map 所拥有之全部节点的最中央区段。</span></span><br><span class="line"> <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。</span></span><br><span class="line"> map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>; </span><br><span class="line"> map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>; </span><br><span class="line"> map_pointer cur; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"><span class="comment">// 为 map 内的每个现用节点配置缓冲区。所有缓冲区加起来就是 deque 的</span></span><br><span class="line"> <span class="comment">// 可用空间（最后一个缓冲区可能留有一些余裕）。</span></span><br><span class="line"> <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur) </span><br><span class="line"> *cur = <span class="built_in">allocate_node</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"><span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个不留。</span></span><br><span class="line"> ...</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">// 为 deque 内的两个迭代器 start 和 end设定正确内容。</span></span><br><span class="line">start.<span class="built_in">set_node</span>(nstart); </span><br><span class="line">finish.<span class="built_in">set_node</span>(nfinish); </span><br><span class="line">start.cur = start.first; <span class="comment">// first, cur 都是 public </span></span><br><span class="line">finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>(); </span><br><span class="line"><span class="comment">// 前面说过，如果刚好整除，会多配一个节点。</span></span><br><span class="line"> <span class="comment">// 此时即令 cur 指向这多配的一个节点（所对映之缓冲区）的起头处。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来范例程序以注标运算子为每个元素重新设值，然后在尾端安插三个新元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ideq.<span class="built_in">size</span>(); ++i) </span><br><span class="line">ideq[i] = i; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) </span><br><span class="line">ideq.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>

<p>由于此时最后一个缓冲区仍有 4 个备用元素空间，所以不会引起缓冲区的再配置。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81413.png" alt="image-20220629200154708"></p>
<p>以下是push_back()函式内容： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// push_* and pop_* </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) </span><br><span class="line"> <span class="comment">// 最后缓冲区尚有一个以上的备用空间，注意是一个以上</span></span><br><span class="line"> <span class="built_in">construct</span>(finish.cur, t);<span class="comment">//直接在备用空间上建构元素</span></span><br><span class="line"> ++finish.cur;<span class="comment">//调整最后缓冲区的使用状态</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span></span><br><span class="line"> <span class="built_in">push_back_aux</span>(t); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>现在，如果再新增加一个新元素（3）于尾端，由于尾端只剩一个元素备用空间，于是push_back()呼叫push_back_aux()，先配置一整块新的缓冲区，再设妥新元素内容，然后更改迭代器finish的状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当 finish.cur == finish.last – 1时才会被呼叫。</span></span><br><span class="line"><span class="comment">//也就是说只有当最后一个缓冲区只剩一个备用元素空间时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123; </span><br><span class="line">value_type t_copy = t; </span><br><span class="line"><span class="built_in">reserve_map_at_back</span>(); <span class="comment">// 若符合某种条件则必须重换一个 map </span></span><br><span class="line">*(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();<span class="comment">//配置一个新节点（缓冲区）</span></span><br><span class="line">__STL_TRY &#123; </span><br><span class="line"><span class="built_in">construct</span>(finish.cur, t_copy); <span class="comment">//针对标的元素设值，放在之前缓冲区的最后一个</span></span><br><span class="line">finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>); <span class="comment">//改变 finish，令其指向新节点</span></span><br><span class="line">finish.cur = finish.first; <span class="comment">//设定 finish 的状态</span></span><br><span class="line">&#125; </span><br><span class="line">__STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，deque的状态如下：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81414.png" alt="image-20220629200856607"></p>
<p>在deque的前端安插一个新元素99，push_front()函式动作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: <span class="comment">// push_* and pop_* </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start.cur != start.first) &#123; <span class="comment">//第一缓冲区尚有备用空间</span></span><br><span class="line"> <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接在备用空间上建构元素</span></span><br><span class="line"> --start.cur;  <span class="comment">//调整第一缓冲区的使用状态</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="comment">// 第一缓冲区已无备用空间</span></span><br><span class="line"> <span class="built_in">push_front_aux</span>(t); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于目前状态下，第一缓冲区并无备用空间，所以呼叫push_front_aux()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当 start.cur == start.first 时才会被呼叫。</span></span><br><span class="line"><span class="comment">//也就是说只有当第一个缓冲区没有任何备用元素时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; t) </span><br><span class="line">&#123; </span><br><span class="line"> value_type t_copy = t; </span><br><span class="line"> <span class="built_in">reserve_map_at_front</span>(); <span class="comment">// 若符合某种条件则必须重换一个 map </span></span><br><span class="line"> *(start.node - <span class="number">1</span>) =<span class="built_in">allocate_node</span>();<span class="comment">//配置一个新节点（缓冲区）</span></span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>); <span class="comment">//改变 start，令其指向新节点</span></span><br><span class="line"> start.cur = start.last - <span class="number">1</span>; <span class="comment">//设定 start 的状态</span></span><br><span class="line"> <span class="built_in">construct</span>(start.cur, t_copy); <span class="comment">//针对标的元素设值</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span>(...) &#123; </span><br><span class="line"> <span class="comment">// &quot;commit or rollback&quot;语意：若非全部成功，就一个不留。</span></span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>); </span><br><span class="line"> start.cur = start.first; </span><br><span class="line"> <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>)); </span><br><span class="line"> <span class="keyword">throw</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入后如下，注意向前插入是从缓冲区尾部向前插，这样能保持空间逻辑上的连续：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/deque%E7%8A%B6%E6%80%81415.png" alt="image-20220629201304194"></p>
<p>回头看看一个悬而᳾解的问题：什么时候<em>map</em>需要重新整治？这个问题的判断由reserve_map_at_back()和reserve_map_at_front()进行，实际动作则由reallocate_map()执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map)) </span><br><span class="line"> <span class="comment">// 如果 map尾端的节点备用空间不足</span></span><br><span class="line"> <span class="comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line"> <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (nodes_to_add &gt; start.node - map) </span><br><span class="line"> <span class="comment">// 如果 map前端的节点备用空间不足</span></span><br><span class="line"> <span class="comment">// 符合以上条件则必须重换一个 map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line"><span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：我要晕倒了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"> <span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="type">bool</span> add_at_front) &#123; </span><br><span class="line"> size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>; </span><br><span class="line"> size_type new_num_nodes = old_num_nodes + nodes_to_add; </span><br><span class="line"> map_pointer new_nstart; </span><br><span class="line"> <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123; <span class="comment">//注：这里不需要新开一块map，重新分配的原因是可能前面或者后面仍然有很大的空间，只需要									//把map平移一下即可</span></span><br><span class="line"> new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add: <span class="number">0</span>); </span><br><span class="line"> <span class="keyword">if</span> (new_nstart &lt; start.node) <span class="comment">//注：向前向后平移的判断</span></span><br><span class="line"> <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> size_type new_map_size = map_size +<span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>; </span><br><span class="line"> <span class="comment">// 配置一块空间，准备给新 map 使用。</span></span><br><span class="line"> map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size); </span><br><span class="line"> new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>); </span><br><span class="line"> <span class="comment">// 把原 map内容拷贝过来。</span></span><br><span class="line"> <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart); </span><br><span class="line"> <span class="comment">// 释放原 map </span></span><br><span class="line"> map_allocator::<span class="built_in">deallocate</span>(map, map_size); </span><br><span class="line"> <span class="comment">// 设定新 map 的起始地址与大小</span></span><br><span class="line"> map = new_map; </span><br><span class="line"> map_size = new_map_size; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 重新设定迭代器 start和 finish </span></span><br><span class="line"> start.<span class="built_in">set_node</span>(new_nstart); </span><br><span class="line"> finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="deque的元素操作-pop-back-pop-front-clear-erase-insert"><a href="#deque的元素操作-pop-back-pop-front-clear-erase-insert" class="headerlink" title="deque的元素操作 pop_back, pop_front, clear, erase, insert"></a>deque的元素操作 pop_back, pop_front, clear, erase, insert</h3><p>pop_back() 和pop_front()。所谓pop，是将元素拿掉。无论从deque 的最前端或最尾端取元素，都需考虑在某种条件下，将缓冲区释放掉：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (finish.cur != finish.first) &#123; <span class="comment">//注：cur原来指向下一个空的区域</span></span><br><span class="line"> <span class="comment">// 最后缓冲区有一个（或更多）元素</span></span><br><span class="line"> --finish.cur; <span class="comment">//调整指针，相当于排除了最后元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">destroy</span>(finish.cur);<span class="comment">//将最后元素解构</span></span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="comment">// 最后缓冲区没有任何元素</span></span><br><span class="line"> <span class="built_in">pop_back_aux</span>(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当 finish.cur == finish.first 时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>() &#123; </span><br><span class="line"> <span class="built_in">deallocate_node</span>(finish.first); <span class="comment">//释放最后一个缓冲区</span></span><br><span class="line"> finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);<span class="comment">//调整 finish 的状态，使指向</span></span><br><span class="line"> finish.cur = finish.last - <span class="number">1</span>; <span class="comment">// 上一个缓冲区的最后一个元素</span></span><br><span class="line"> <span class="built_in">destroy</span>(finish.cur); <span class="comment">//将该元素解构。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123; </span><br><span class="line"> <span class="comment">// 第一缓冲区有一个（或更多）元素</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur);<span class="comment">//将第一元素解构</span></span><br><span class="line"> ++start.cur; <span class="comment">//调整指针，相当于排除了第一元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="comment">// 第一缓冲区仅有一个元素</span></span><br><span class="line"> <span class="built_in">pop_front_aux</span>(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只有当 start.cur == start.last - 1 时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123; </span><br><span class="line"> <span class="built_in">destroy</span>(start.cur); <span class="comment">//将第一缓冲区的第一个元素解构。</span></span><br><span class="line"> <span class="built_in">deallocate_node</span>(start.first); <span class="comment">//释放第一缓冲区。</span></span><br><span class="line"> start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);<span class="comment">//调整 start的状态，使指向下一个缓冲区的第一个元素。</span></span><br><span class="line"> start.cur = start.first;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面这个例子是 clear()，用来清除整个 deque。请注意，deque的最初状态（无任何元素时）保有一个缓冲区，因此clear()完成之后回复初始状态，也一样要保留一个缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，最终需要保留一个缓冲区。这是 deque的策略，也是 deque的初始状态。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123; </span><br><span class="line"> <span class="comment">// 以下针对头尾以外的每一个缓冲区（它们一定都是饱满的）</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123; </span><br><span class="line"> <span class="comment">// 将缓冲区内的所有元素解构。注意，呼叫的是 destroy() 第二版本</span></span><br><span class="line"> <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>()); </span><br><span class="line"> <span class="comment">// 释放缓冲区内存</span></span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (start.node != finish.node) &#123;<span class="comment">//至少有头尾两个缓冲区</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur, start.last);<span class="comment">//将头缓冲区的目前所有元素解构</span></span><br><span class="line"> <span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">// 将尾缓冲区的目前所有元素解构</span></span><br><span class="line"> <span class="comment">// 以下释放尾缓冲区。注意，头缓冲区保留。</span></span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span><span class="comment">//只有一个缓冲区</span></span><br><span class="line"> <span class="built_in">destroy</span>(start.cur, finish.cur);<span class="comment">//将此唯一缓冲区内的所有元素解构</span></span><br><span class="line"> <span class="comment">// 注意，并不释放缓冲区空间。这唯一的缓冲区将保留。</span></span><br><span class="line"> finish = start; <span class="comment">//调整状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子是 erase()，用来清除某个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos所指的元素。pos为清除点。</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123; </span><br><span class="line"> iterator next = pos; </span><br><span class="line"> ++next; </span><br><span class="line"> difference_type index = pos - start;<span class="comment">//清除点之前的元素个数</span></span><br><span class="line"> <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123; <span class="comment">//如果清除点之前的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(start, pos, next);<span class="comment">//就搬移清除点之前的元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">pop_front</span>(); <span class="comment">//搬移完毕，最前一个元素赘余，去除之</span></span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//清除点之后的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy</span>(next, finish, pos);<span class="comment">//就搬移清除点之后的元素</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">pop_back</span>(); <span class="comment">//搬移完毕，最后一个元素赘余，去除之</span></span><br><span class="line"> <span class="keyword">return</span> start + index; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子是 erase()，用来清除[first,last)区间内的所有元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123; </span><br><span class="line"> <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;<span class="comment">// 如果清除区间就是整个 deque </span></span><br><span class="line"> <span class="built_in">clear</span>();  <span class="comment">//直接呼叫 clear()即可</span></span><br><span class="line"> <span class="keyword">return</span> finish; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> difference_type n = last - first;  <span class="comment">//清除区间的长度</span></span><br><span class="line"> difference_type elems_before = first - start;<span class="comment">//清除区间前方的元素个数</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//注：这里的搬运是因为清除一个区间可能截断了连续的数据空间，因此要把可能产生的前后两端连接起来</span></span><br><span class="line"> <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123; <span class="comment">//如果前方的元素比较少，</span></span><br><span class="line"> <span class="built_in">copy_backward</span>(start, first, last); <span class="comment">//向后搬移前方元素（覆盖清除区间）</span></span><br><span class="line"> iterator new_start = start + n; <span class="comment">//标记 deque的新起点</span></span><br><span class="line"> <span class="built_in">destroy</span>(start, new_start); <span class="comment">//搬移完毕，将赘余的元素解构</span></span><br><span class="line"> <span class="comment">// 以下将赘余的缓冲区释放</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> start = new_start;<span class="comment">//设定 deque 的新起点</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123;<span class="comment">//如果清除区间后方的元素比较少</span></span><br><span class="line"> <span class="built_in">copy</span>(last, finish, first); <span class="comment">//向前搬移后方元素（覆盖清除区间）</span></span><br><span class="line"> iterator new_finish = finish - n;<span class="comment">//标记 deque的新尾点</span></span><br><span class="line"> <span class="built_in">destroy</span>(new_finish, finish); <span class="comment">//搬移完毕，将赘余的元素解构</span></span><br><span class="line"> <span class="comment">// 以下将赘余的缓冲区释放</span></span><br><span class="line"> <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur) </span><br><span class="line"> data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>()); </span><br><span class="line"> finish = new_finish;<span class="comment">//设定 deque 的新尾点</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> start + elems_before; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个例子是insert。deque为这个功能提供了许多版本，最基础最重要的是以下版本，允许在某个点（之前）安插一个元素，并设定其值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 position 处安插一个元素，其值为 x </span></span><br><span class="line"> <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (position.cur == start.cur) &#123;<span class="comment">//如果安插点是 deque最前端</span></span><br><span class="line"> <span class="built_in">push_front</span>(x); <span class="comment">//交给 push_front 去做</span></span><br><span class="line"> <span class="keyword">return</span> start; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123; <span class="comment">// 如果安插点是 deque最尾端</span></span><br><span class="line"> <span class="built_in">push_back</span>(x); <span class="comment">//交给 push_back去做</span></span><br><span class="line"> iterator tmp = finish; </span><br><span class="line"> --tmp;</span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x); <span class="comment">//交给 insert_aux 去做</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt; </span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line"> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type&amp; x) &#123; </span><br><span class="line"> difference_type index = pos - start;<span class="comment">//安插点之前的元素个数</span></span><br><span class="line"> value_type x_copy = x; </span><br><span class="line"> <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123; <span class="comment">//如果安插点之前的元素个数比较少</span></span><br><span class="line">     <span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//在最前端加入与第一元素同值的元素。注：相当于把安插点前面的元素向前移一格</span></span><br><span class="line">     iterator front1 = start; <span class="comment">//以下标示记号，然后进行元素搬移... </span></span><br><span class="line">     ++front1; </span><br><span class="line">     iterator front2 = front1; </span><br><span class="line">     ++front2; </span><br><span class="line">     pos = start + index; </span><br><span class="line">     iterator pos1 = pos; </span><br><span class="line">     ++pos1; </span><br><span class="line">     <span class="built_in">copy</span>(front2, pos1, front1); <span class="comment">//元素搬移，注：把原来的头元素覆盖，这样position位置就空出来了</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//安插点之后的元素个数比较少</span></span><br><span class="line">     <span class="built_in">push_back</span>(<span class="built_in">back</span>()); <span class="comment">//在最尾端加入与最后元素同值的元素。注：相当于把安插点后面的元素向后移一格</span></span><br><span class="line">     iterator back1 = finish;<span class="comment">//以下标示记号，然后进行元素搬移... </span></span><br><span class="line">     --back1; </span><br><span class="line">     iterator back2 = back1; </span><br><span class="line">     --back2; </span><br><span class="line">     pos = start + index; </span><br><span class="line">     <span class="built_in">copy_backward</span>(pos, back2, back1); <span class="comment">//元素搬移，注：把原来的尾元素覆盖，这样position位置就空出来了</span></span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line"> *pos = x_copy;<span class="comment">//在安插点上设定新值</span></span><br><span class="line"> <span class="keyword">return</span> pos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack-概述"><a href="#stack-概述" class="headerlink" title="stack 概述"></a>stack 概述</h3><p>stack是一种先进后出（First In Last Out，FILO）的数据结构。stack允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取stack的其它元素。换言之stack不允许有走访行为。</p>
<p>将元素推入 stack 的动作称为 <em>push</em>，将元素推出 stack 的动作称为<em>pop</em>。</p>
<h3 id="stack-定义式完整列表"><a href="#stack-定义式完整列表" class="headerlink" title="stack 定义式完整列表"></a>stack 定义式完整列表</h3><p>以某种既有容器做为底部结构，将其接口改变，使符合「先进后出」的特性，形成一个stack，是很容易做到的。deque是双向开口的数据结构，若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。因此，SGI STL 便 以deque做为预设情况下的stack底部结构，stack的实作因而非常简单，源码十分简短，本处完整列出。</p>
<p>由于stack系以底部容器完成其所有工作，而具有这种「<strong>修改某物接口</strong>，形成另一种风貌」之性质者，称为<strong>adapter</strong>（配接器），因此 STL stack往往不被归类为 container（容器），而被归类为<strong>container adapter</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; </span><br><span class="line"><span class="keyword">class</span> stack &#123; </span><br><span class="line"> <span class="comment">// 以下的 __STL_NULL_TMPL_ARGS 会开展为 &lt;&gt;</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;); </span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> stack&amp;, <span class="type">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//底层容器</span></span><br><span class="line"><span class="comment">// 以下完全利用 Sequence c 的操作，完成 stack的操作。</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"><span class="comment">// deque是两头可进出，stack是᳿端进，᳿端出（所以后进者先出）。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c == y.c; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> stack&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c &lt; y.c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stack-没有迭代器"><a href="#stack-没有迭代器" class="headerlink" title="stack 没有迭代器"></a>stack 没有迭代器</h3><p>stack 所有元素的进出都必须符合「先进后出」的条件，只有 stack 顶端的元素，才有机会被外界取用。stack不提供走访功能，也不提供迭代器。</p>
<h3 id="以-list做为-stack-的底层容器"><a href="#以-list做为-stack-的底层容器" class="headerlink" title="以 list做为 stack 的底层容器"></a>以 list做为 stack 的底层容器</h3><p>除了deque之外，list 也是双向开口的数据结构。上述 stack 源码中使用的底层容器的函式有empty, size, back, push_back, pop_back，凡此种种 list 都具备。因此若以list为底部结构并封闭其头端开口，一样能够轻易形成一个stack。下面是作法示范。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 4stack-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> stack&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt; &gt; istack; </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">5</span>); </span><br><span class="line"> istack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4 </span></span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> istack.<span class="built_in">pop</span>(); cout &lt;&lt; istack.<span class="built_in">top</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> cout &lt;&lt; istack.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue-概述"><a href="#queue-概述" class="headerlink" title="queue 概述"></a>queue 概述</h3><p>queue是一种先进先出（First In First Out，FIFO）的数据结构。它有两个出口。queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素。但除了最底端可以加入、最顶端可以取出，没有任何其它方法可以存取queue 的其它元素。换言之 queue 不允许有走访行为。</p>
<p>将元素推入 queue 的动作称为 <em>push</em>，将元素推出 queue 的动作称为<em>pop</em>。</p>
<h3 id="queue-定义式完整列表"><a href="#queue-定义式完整列表" class="headerlink" title="queue 定义式完整列表"></a>queue 定义式完整列表</h3><p>SGI STL 依然以deque做为预设情况下的queue底部结构，因此queue也被归类为container adapter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; </span><br><span class="line"><span class="keyword">class</span> queue &#123; </span><br><span class="line"> <span class="comment">// 以下的 __STL_NULL_TMPL_ARGS 会开展为 &lt;&gt;</span></span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y); </span><br><span class="line"> <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="type">const</span> queue&amp; x, <span class="type">const</span> queue&amp; y); </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//底层容器</span></span><br><span class="line"><span class="comment">// 以下完全利用 Sequence c 的操作，完成 queue的操作。</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; returnc.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; </span><br><span class="line"><span class="comment">// deque是两头可进出，queue 是末端进，前端出（所以先进者先出）。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c == y.c; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="type">const</span> queue&lt;T, Sequence&gt;&amp; y) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> x.c &lt; y.c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="queue-没有迭代器"><a href="#queue-没有迭代器" class="headerlink" title="queue 没有迭代器"></a>queue 没有迭代器</h3><p>queue 所有元素的进出都必须符合「先进先出」的条件，只有 queue 顶端的元素，才有机会被外界取用。queue不提供走访功能，也不提供迭代器。</p>
<h3 id="以-list做为queue-的底层容器"><a href="#以-list做为queue-的底层容器" class="headerlink" title="以 list做为queue 的底层容器"></a>以 list做为queue 的底层容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file : 4queue-test.cpp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> queue&lt;<span class="type">int</span>,list&lt;<span class="type">int</span>&gt; &gt; iqueue; </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">1</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">3</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">5</span>); </span><br><span class="line"> iqueue.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4 </span></span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 5 </span></span><br><span class="line"> iqueue.<span class="built_in">pop</span>(); cout &lt;&lt; iqueue.<span class="built_in">front</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line"> cout &lt;&lt; iqueue.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="heap-概述"><a href="#heap-概述" class="headerlink" title="heap 概述"></a>heap 概述</h3><p>heap并不归属于STL 容器组件，它是个幕后英雄，扮演priority queue （优先级队列）的推手。顾名思义，priority queue 允许使用者以任何次序将任何元素推入容器内，但取出时一定是从优先权最高（也就是数值最高）之元素开始取。binary max heap正是具有这样的特性，适合做为 priority queue的底层机制。</p>
<h4 id="为何使用堆作为优先级队列的底层"><a href="#为何使用堆作为优先级队列的底层" class="headerlink" title="为何使用堆作为优先级队列的底层"></a>为何使用堆作为优先级队列的底层</h4><p>如果使用 list 做为 priority queue 的底层机制，元素安插动作可享常数时间。但是要找到list中的极值，却需要对整个list进行线性扫描。我们也可以改个作法，让元素安插前先经过排序这一关，使得 list 的元素值总是由小到大（或由大到小），但这么一来，虽然取得极值以及元素删除动作达到最高效率，元素的安插却只有线性表现。</p>
<p>比较麻辣的作法是以binary search tree 做为priority queue的底层机制。这么一来元素的安插和极值的取得就有*O(logN)*的表现。但这样未免小题大作，一来binary search tree的输入需要足够的随机性， 二来binary search tree并不容易实作。priority queue的复杂度，最好介于queue和binary search tree之间，才算适得其所。binary heap便是这种条件下 的适当候选人。</p>
<h4 id="堆的一些细节"><a href="#堆的一些细节" class="headerlink" title="堆的一些细节"></a>堆的一些细节</h4><p>所谓binary heap就是一种complete binary tree（完全二叉树），也就是说，整棵binary tree除了最底层的叶节点(s)之外，是填满的，而最底层的叶节点(s)由左至右又不得有空隙。</p>
<p>complete binary tree整棵树内没有任何节点漏洞，这带来一个极大好处：我们可以利用array来储存所有节点。假设动用一个小技巧，将array的**#0元素保留<strong>（或设为无限大值或无限小值），那么当complete binary tree中的某个节点位于array的 <strong>i</strong> 处，其左子节点必位于array 的 <strong>2i</strong> 处，其右子节点必位于 array的 <strong>2i+1 处</strong>，其父节点必位于「</strong>i&#x2F;2**」处（此处的「」权且代表高斯符号，取其整数）。通过这么简单的位置规则，array可以轻易实作出complete binary tree。这种以array表述tree的方式，我们称为隐式表述法（implicit representation）。</p>
<p>我们需要的工具就很简单了：一个array和一组heap算法（用来安插元素、删除元素、取极值、将某一整组数据排列成一个heap）。array的缺点是无法动态改变大小，而heap却需要这项功能，因此以vector代替 array是更好的选择。</p>
<p>根据元素排列方式，heap可分为<strong>max-heap</strong>和 <strong>min-heap</strong> （最大堆和最小堆）两种，前者每个节点的键值（<em>key</em>）都大于或等于其子节点键值，后者的每个节点键值（<em>key</em>）都小于或等于其子节点键值。因此，max-heap的最大值在根节点，并总是位于底层 array 或vector的起头处；min-heap的最小值在根节点，亦总是位于底层array或vector的起头处。STL 供应的是max-heap，因此以下说heap时，指的是max-heap。</p>
<h3 id="heap-算法"><a href="#heap-算法" class="headerlink" title="heap 算法"></a>heap 算法</h3><h4 id="push-heap-算法"><a href="#push-heap-算法" class="headerlink" title="push_heap 算法"></a>push_heap 算法</h4><p>插入元素首先插入到<strong>最后端</strong>，然后<strong>向上过滤</strong>。为满足 max-heap 的条件（每个节点的键值都大于或等于其子节点键值），我们执行一个所谓的percolate up（上溯）程序：将新节点拿来与其父节点比较，如果其键值（<em>key</em>）比父节点大，就父子对换位置。如此一直上溯，直到不需对换或直到根节点为止。 </p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/push_heap.png" alt="image-20220707145259201"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 注意，此函式被呼叫时，新元素应已置于底部容器的最尾端。</span></span><br><span class="line">__push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) &#123; </span><br><span class="line">__push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>))); </span><br><span class="line"><span class="comment">// 以上系根据 implicit representation heap的结构特性：新值必置于底部</span></span><br><span class="line"><span class="comment">// 容器的最尾端，此即第一个洞号：(last-first)–1。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 push_back()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">void__push_heap</span>(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) &#123; </span><br><span class="line"> Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//找出父节点</span></span><br><span class="line"> <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent)&lt; value) &#123; </span><br><span class="line"> <span class="comment">// 当尚未到达顶端，且父节点小于新值（于是不符合 heap 的次序特性）</span></span><br><span class="line"> <span class="comment">// 由于以上使用 operator&lt;，可知 STL heap 是一种 max-heap（大者为父）。</span></span><br><span class="line"> *(first + holeIndex) = *(first + parent);<span class="comment">//令洞值为父值</span></span><br><span class="line"> holeIndex = parent;<span class="comment">//percolate up：调整洞号，向上提升至父节点。</span></span><br><span class="line"> parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//新洞的父节点</span></span><br><span class="line"> &#125; <span class="comment">// 持续至顶端，或满足 heap 的次序特性为止。</span></span><br><span class="line"> *(first + holeIndex) = value;<span class="comment">//令洞值为新值，完成安插动作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop-heap-算法"><a href="#pop-heap-算法" class="headerlink" title="pop_heap 算法"></a>pop_heap 算法</h4><p>既然身为max-heap，最大值必然在根节点。pop动作取走根节点（其实是移至底部容器vector的最后一个元素）之后，为了满足 complete binary tree的条件，必须将最下一层最右边的叶节点拿掉，现在我们的任务是为这个被拿掉的节点找一个适当的位置。</p>
<p>为满足max-heap的条件（每个节点的键值都大于或等于其子节点键值），我们执行一个所谓的percolate down<strong>（向下过滤）</strong>程序：将根节点（最大值被取走后，形成一个<strong>「洞」</strong>）填入上述那个失去生存空间的叶节点值，再将它拿来和其两个子节点比较键值（<em>key</em>），并与较大子节点对调位置。如此一直下放，直到这个「洞」的键值大于左右两个子节点，或直到下放至叶节点为止。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/pop_heap.png" alt="image-20220707145736213"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line">__pop_heap_aux(first, last, <span class="built_in">value_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) &#123; </span><br><span class="line">__pop_heap(first, last<span class="number">-1</span>, last<span class="number">-1</span>, <span class="built_in">T</span>(*(last<span class="number">-1</span>)), <span class="built_in">distance_type</span>(first)); </span><br><span class="line"><span class="comment">// 以上，根据 implicit representation heap的次序特性，pop 动作的结果</span></span><br><span class="line"> <span class="comment">// 应为底部容器的第一个元素。因此，首先设定欲调整值为尾值，然后将首值调至</span></span><br><span class="line"> <span class="comment">// 尾节点（所以以上将迭代器 result 设为 last-1）。然后重整 [first, last-1)，</span></span><br><span class="line"> <span class="comment">// 使之重新成一个合格的 heap。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 __pop_heap() 不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last, RandomAccessIterator result, T value, Distance*) &#123; </span><br><span class="line"> *result = *first;<span class="comment">// 设定尾值为首值，于是尾值即为欲求结果，</span></span><br><span class="line"> <span class="comment">// 可由客端稍后再以底层容器之 pop_back() 取出尾值。</span></span><br><span class="line"> __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value); </span><br><span class="line"><span class="comment">// 以上欲重新调整 heap，洞号为 0（亦即树根处），欲调整值为 value（原尾值）。</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这个 __adjust_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="built_in">void__adjust_heap</span>(RandomAccessIterator first, Distance holeIndex, Distance len, T value) &#123; </span><br><span class="line"> Distance topIndex = holeIndex; </span><br><span class="line"> Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;<span class="comment">//洞节点之右子节点</span></span><br><span class="line"> <span class="keyword">while</span> (secondChild &lt; len) &#123; </span><br><span class="line"><span class="comment">// 比较洞节点之左右两个子值，然后以 secondChild代表较大子节点。</span></span><br><span class="line"> <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>))) </span><br><span class="line"> secondChild--; </span><br><span class="line"> <span class="comment">// Percolate down：令较大子值为洞值，再令洞号下移至较大子节点处。</span></span><br><span class="line"> *(first + holeIndex) = *(first + secondChild); </span><br><span class="line"> holeIndex = secondChild; </span><br><span class="line"><span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line"> secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (secondChild == len) &#123;<span class="comment">//没有右子节点，只有左子节点</span></span><br><span class="line"><span class="comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line"> *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>)); </span><br><span class="line"> holeIndex = secondChild - <span class="number">1</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 将欲调整值填入目前的洞号内。注意，此时肯定满足次序特性。</span></span><br><span class="line"> <span class="comment">// 依侯捷之见，下面直接改为 *(first + holeIndex) = value; 应该可以。</span></span><br><span class="line">__push_heap(first, holeIndex, topIndex, value); <span class="comment">//注：就是最后把原来last元素填好位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sort-heap-算法"><a href="#sort-heap-算法" class="headerlink" title="sort_heap 算法"></a>sort_heap 算法</h4><p>既然每次pop_heap可获得 heap之中键值最大的元素，如果持续对整个 heap做pop_heap动作，每次将操作范围从后向前缩减一个元素（因为 pop_heap 会把键值最大的元素放在底部容器的最尾端），当整个程序执行完毕，我们便有了一个递增序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下这个 sort_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 以下，每执行一次 pop_heap()，极值（在 STL heap 中为极大值）即被放在尾端。</span></span><br><span class="line"> <span class="comment">// 扣除尾端再执行一次 pop_heap()，次极值又被放在新尾端。一直下去，最后即得</span></span><br><span class="line"> <span class="comment">// 排序结果。</span></span><br><span class="line"> <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) </span><br><span class="line"> <span class="built_in">pop_heap</span>(first, last--);<span class="comment">//每执行 pop_heap() 一次，操作范围即退缩一格。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="make-heap-算法"><a href="#make-heap-算法" class="headerlink" title="make_heap 算法"></a>make_heap 算法</h4><p>这个算法用来将一段现有的数据转化为一个 heap。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 [first,last) 排列为一个 heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>&gt; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123; </span><br><span class="line"> __make_heap(first, last,<span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//以下这组 make_heap()不允许指定「大小比较标准」。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; </span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*) &#123; </span><br><span class="line"> <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;<span class="comment">//如果长度为 0或 1，不必重新排列。</span></span><br><span class="line"> Distance len = last - first; </span><br><span class="line"> <span class="comment">// 找出第一个需要重排的子树头部，以 parent 标示出。由于任何叶节点都不需执行</span></span><br><span class="line"> <span class="comment">// perlocate down，所以有以下计算。parent命名不佳，名为 holeIndex更好。</span></span><br><span class="line"> Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>; </span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">  <span class="comment">// 重排以 parent 为首的子树。len 是为了让 __adjust_heap()判断操作范围</span></span><br><span class="line">  __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent))); </span><br><span class="line">  <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//走完根节点，就结束。</span></span><br><span class="line">  parent--; <span class="comment">//（即将重排之子树的）头部向前一个节点</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="heap-没有迭代器"><a href="#heap-没有迭代器" class="headerlink" title="heap 没有迭代器"></a>heap 没有迭代器</h3><p>heap 的所有元素都必须遵循特别的（complete binary tree）排列规则，所以 heap不提供走访功能，也不提供迭代器。</p>
<h3 id="heap测试实例"><a href="#heap测试实例" class="headerlink" title="heap测试实例"></a>heap测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// heap algorithms </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// test heap (底层以 vector完成) </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(ia, ia+<span class="number">9</span>)</span></span>; </span><br><span class="line"> <span class="built_in">make_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 5 8 3 4 0 2 3 1 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ivec.<span class="built_in">push_back</span>(<span class="number">7</span>); </span><br><span class="line"> <span class="built_in">push_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 7 8 3 5 0 2 3 1 4 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">pop_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> cout &lt;&lt; ivec.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 9.return but no remove. </span></span><br><span class="line"> ivec.<span class="built_in">pop_back</span>(); <span class="comment">// remove last elem and no return </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 8 7 4 3 5 0 2 3 1 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">sort_heap</span>(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>()); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ivec.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ivec[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 3 4 5 7 8 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// test heap (底层以 array 完成) </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="built_in">make_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="comment">// array 无法动态改变大小，因此不可以对满载的 array 做 push_heap() 动作。</span></span><br><span class="line"> <span class="comment">// 因为那得先在 array尾端增加一个元素。</span></span><br><span class="line"> <span class="built_in">sort_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i) </span><br><span class="line"> cout &lt;&lt; ia[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 0 1 2 3 3 4 5 8 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="comment">// 经过排序之后的 heap，不再是个合法的 heap </span></span><br><span class="line"> <span class="comment">// 重新再做一个 heap </span></span><br><span class="line"> <span class="built_in">make_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> <span class="built_in">pop_heap</span>(ia, ia+<span class="number">9</span>); </span><br><span class="line"> cout &lt;&lt; ia[<span class="number">8</span>] &lt;&lt; endl; <span class="comment">// 9 </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="priority-queue-概述"><a href="#priority-queue-概述" class="headerlink" title="priority_queue 概述"></a>priority_queue 概述</h3><p>priority_queue是一个拥有权值观念的 queue，它允许加入新元素、移除旧元素，审视元素值等功能。由于这是一个queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外别无其它存取元素的途径。</p>
<p>priority_queue带有权值观念，其内的元素并非依照被推入的次序排列，而是自动依照元素的权值排列（通常权值以实值表示）。<strong>权值最高者，排在最前面</strong>。</p>
<p>预设情况下priority_queue系利用一个max-heap 完成，后者是一个以 vector 表现的 complete binary tree。max-heap 可以满足priority_queue所需要的「依权值高低自动递增排序」的特性。</p>
<h3 id="priority-queue-定义式完整列表"><a href="#priority-queue-定义式完整列表" class="headerlink" title="priority_queue 定义式完整列表"></a>priority_queue 定义式完整列表</h3><p>由于priority_queue完全以底部容器为根据，再加上heap处理规则，所以其实作非常简单。预设情况下是以vector为底部容器。源码很简短，此处完整列出。</p>
<p>STL priority_queue 也不被归类为container（容器），而被归类为container adapter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt; <span class="keyword">class</span> priority_queue &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference; </span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"> Sequence c; <span class="comment">//底层容器</span></span><br><span class="line"> Compare comp;<span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125; </span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : c(), comp(x) &#123;</span>&#125; </span><br><span class="line"><span class="comment">//以下用到的 make_heap(), push_heap(), pop_heap()都是泛型算法</span></span><br><span class="line"><span class="comment">//注意，任一个建构式都立刻于底层容器内产生一个 implicit representation heap。</span></span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"> <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="type">const</span> Compare&amp; x) : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123;<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt; </span><br><span class="line"> <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; </span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"><span class="comment">// push_heap是泛型算法，先利用底层容器的 push_back() 将新元素</span></span><br><span class="line">c.<span class="built_in">push_back</span>(x); <span class="comment">// 推入末端，再重排 heap。</span></span><br><span class="line"><span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);<span class="comment">// push_heap是泛型算法</span></span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(c.<span class="built_in">clear</span>()); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line"> <span class="comment">// pop_heap 是泛型算法，从 heap 内取出一个元素。它并不是真正将元素</span></span><br><span class="line"> <span class="comment">// 弹出，而是重排 heap，（首值被放在尾部）然后再以底层容器的 pop_back() 取得被弹出的元素</span></span><br><span class="line"> <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); </span><br><span class="line"> c.<span class="built_in">pop_back</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(c.<span class="built_in">clear</span>()); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="priority-queue-没有迭代器"><a href="#priority-queue-没有迭代器" class="headerlink" title="priority_queue 没有迭代器"></a>priority_queue 没有迭代器</h3><p>priority_queue 的所有元素，进出都有一定的规则，只有 queue 顶端的元素（权值最高者），才有机会被外界取用。priority_queue不提供走访功能，也不提供迭代器。</p>
<h3 id="priority-queue-测试实例"><a href="#priority-queue-测试实例" class="headerlink" title="priority_queue 测试实例"></a>priority_queue 测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="comment">// test priority queue... </span></span><br><span class="line"> <span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; </span><br><span class="line"> <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">ipq</span><span class="params">(ia, ia+<span class="number">9</span>)</span></span>; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; ipq.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=9 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ipq.<span class="built_in">size</span>(); ++i) </span><br><span class="line"> cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 9 9 9 9 9 9 9 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">while</span>(!ipq.<span class="built_in">empty</span>()) &#123; </span><br><span class="line"> cout &lt;&lt; ipq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 9 8 5 4 3 3 2 1 0 </span></span><br><span class="line"> ipq.<span class="built_in">pop</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><h3 id="slist-概述"><a href="#slist-概述" class="headerlink" title="slist 概述"></a>slist 概述</h3><p>STL list是个双向串行（double linked list）。SGI STL 另提供了一个单向串行（single linked list），名为slist。这个容器并不在标准规格之内，不过多做一 些剖析，多看多学一些实作技巧也不错。</p>
<p>slist和list的主要差别在于，前者的迭代器属于单向的 <em>Forward Iterator</em>，后者的迭代器属于双向的<em>Bidirectional Iterator</em>。为此，slist的功能自然也就受到许多限制。不过，单向串行所耗用的<strong>空间更小</strong>，<strong>某些动作更快</strong>，不失为另一种选择。</p>
<p>根据STL的习惯，安插动作会将新元素安插于指定位置之前，而非之后。然而做为一个单向串行，slist没有任何方便的办法可以回头定出前一个位置，因此它必须从头找起。换句话说，除了slist起始处附近的区域之外，在其它位置上采用insert 或erase 操作函式，都是不智之举。这便是 slist 相较于 list 之下的大缺点。为此，slist特别提供了 insert_after()和erase_after()供弹性运用。</p>
<p>基于同样的（效率）考虑，slist不提供 push_back()，只提供 <strong>push_front()<strong>。因此 slist的元素次序会和元素安插进来的次序</strong>相反</strong>。</p>
<h3 id="slist-的节点"><a href="#slist-的节点" class="headerlink" title="slist 的节点"></a>slist 的节点</h3><p>slist节点和其迭代器的设计，架构上比list复杂许多，运用了继承关系，因此在型别转换上有复杂的表现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向串行的节点基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node_base</span></span><br><span class="line">&#123; </span><br><span class="line"> __slist_node_base* next; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//单向串行的节点结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_node</span> : <span class="keyword">public</span> __slist_node_base </span><br><span class="line">&#123; </span><br><span class="line"> T data; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//全域函式：已知某一节点，安插新节点于其后。</span></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link( __slist_node_base* prev_node, __slist_node_base* new_node) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 令 new节点的下一节点为 prev节点的下一节点</span></span><br><span class="line"> new_node-&gt;next = prev_node-&gt;next; </span><br><span class="line"> prev_node-&gt;next = new_node;<span class="comment">//令 prev 节点的下一节点指向 new 节点</span></span><br><span class="line"> <span class="keyword">return</span> new_node; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//全域函式：单向串行的大小（元素个数）</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __slist_size(__slist_node_base* node) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">size_t</span> result = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> ( ; node != <span class="number">0</span>; node = node-&gt;next) </span><br><span class="line"> ++result; <span class="comment">//一个一个累计</span></span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/slist%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84.png" alt="image-20220707210631932"></p>
<h3 id="slist-的迭代器"><a href="#slist-的迭代器" class="headerlink" title="slist 的迭代器"></a>slist 的迭代器</h3><p>slist 迭代器可以下图表示：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/slist%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt="image-20220707210714470"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向串行的迭代器基本结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> forward_iterator_tag iterator_category;<span class="comment">//注意，单向</span></span><br><span class="line"> __slist_node_base* node;<span class="comment">//指向节点基本结构</span></span><br><span class="line">__slist_iterator_base(__slist_node_base* x) :<span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123; node = node-&gt;next; &#125;<span class="comment">// 前进一个节点</span></span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> node == x.node; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __slist_iterator_base&amp; x) <span class="type">const</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> node != x.node; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//单向串行的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator</span> : <span class="keyword">public</span> __slist_iterator_base </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, Ref, Ptr&gt; self; </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> Ptr pointer; </span><br><span class="line"> <span class="keyword">typedef</span> Ref reference; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node; </span><br><span class="line">__slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125; </span><br><span class="line"> <span class="comment">// 呼叫 slist&lt;T&gt;::end() 时会造成 __slist_iterator(0)，于是唤起上述函式。</span></span><br><span class="line">__slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125; </span><br><span class="line">__slist_iterator(<span class="type">const</span> iterator&amp;x) : __slist_iterator_base(x.node) &#123;&#125; </span><br><span class="line"> reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> ((list_node*) node)-&gt;data; &#125; </span><br><span class="line"> pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125; </span><br><span class="line"> self&amp; <span class="keyword">operator</span>++() </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">incr</span>();<span class="comment">//前进一个节点</span></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123; </span><br><span class="line"> self tmp = *<span class="keyword">this</span>; </span><br><span class="line"> <span class="built_in">incr</span>();<span class="comment">//前进一个节点</span></span><br><span class="line"> <span class="keyword">return</span> tmp; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//没有实作 operator--，因为这是一个 forward iterator </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="slist-的数据结构"><a href="#slist-的数据结构" class="headerlink" title="slist 的数据结构"></a>slist 的数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt; </span><br><span class="line"><span class="keyword">class</span> slist</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="keyword">typedef</span> T value_type; </span><br><span class="line"> <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> value_type* const_pointer; </span><br><span class="line"> <span class="keyword">typedef</span> value_type&amp; reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; const_reference; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">size_t</span> size_type; </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_node_base list_node_base; </span><br><span class="line"> <span class="keyword">typedef</span> __slist_iterator_base iterator_base; </span><br><span class="line"> <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt;list_node_allocator; </span><br><span class="line"> <span class="function"><span class="type">static</span> list_node* <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> list_node* node =list_node_allocator::<span class="built_in">allocate</span>();<span class="comment">//配置空间</span></span><br><span class="line"> __STL_TRY &#123; </span><br><span class="line">    <span class="built_in">construct</span>(&amp;node-&gt;data, x); <span class="comment">//建构元素</span></span><br><span class="line">	node-&gt;next = <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> __STL_UNWIND(list_node_allocator::<span class="built_in">deallocate</span>(node)); </span><br><span class="line"> <span class="keyword">return</span> node; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span> </span>&#123; </span><br><span class="line"> <span class="built_in">destroy</span>(&amp;node-&gt;data); <span class="comment">//将元素解构</span></span><br><span class="line"> list_node_allocator::<span class="built_in">deallocate</span>(node); <span class="comment">//释还空间</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> list_node_base head; <span class="comment">// 头部。注意，它不是指标，是实物。</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">slist</span>() &#123; head.next = <span class="number">0</span>; &#125; </span><br><span class="line"> ~<span class="built_in">slist</span>() &#123; <span class="built_in">clear</span>(); &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>((list_node*)head.next); &#125; </span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>); &#125; </span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __slist_size(head.next); &#125; </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> head.next == <span class="number">0</span>; &#125; </span><br><span class="line"> <span class="comment">// 两个 slist互换：只要将 head 交换互指即可。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(slist&amp; L)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line"> list_node_base* tmp = head.next; </span><br><span class="line"> head.next = L.head.next; </span><br><span class="line"> L.head.next = tmp; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// 取头部元素</span></span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ((list_node*)head.next)-&gt;data; &#125; </span><br><span class="line"> <span class="comment">// 从头部安插元素（新元素成为 slist 的第一个元素）</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; </span><br><span class="line"> __slist_make_link(&amp;head,<span class="built_in">create_node</span>(x)); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 注意，没有 push_back() </span></span><br><span class="line"> <span class="comment">// 从头部取走元素（删除之）。修改 head。</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> list_node* node = (list_node*) head.next; </span><br><span class="line"> head.next = node-&gt;next; </span><br><span class="line"> <span class="built_in">destroy_node</span>(node); </span><br><span class="line"> &#125; </span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="slist-的元素操作"><a href="#slist-的元素操作" class="headerlink" title="slist 的元素操作"></a>slist 的元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;slist&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> slist&lt;<span class="type">int</span>&gt; islist; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=0</span></span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">9</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">1</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">2</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">3</span>); </span><br><span class="line"> islist.<span class="built_in">push_front</span>(<span class="number">4</span>); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=5 </span></span><br><span class="line"> slist&lt;<span class="type">int</span>&gt;::iterator ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> slist&lt;<span class="type">int</span>&gt;::iterator ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 3 2 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite =<span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">1</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> islist.<span class="built_in">insert</span>(ite, <span class="number">99</span>); <span class="comment">//新元素会被安插在1的前面</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; islist.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// size=6 </span></span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; endl; <span class="comment">// 1 </span></span><br><span class="line"> ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 3 2 99 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line"> ite = <span class="built_in">find</span>(islist.<span class="built_in">begin</span>(), islist.<span class="built_in">end</span>(), <span class="number">3</span>); </span><br><span class="line"> <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line"> cout &lt;&lt; *(islist.<span class="built_in">erase</span>(ite)) &lt;&lt; endl; <span class="comment">// 2 </span></span><br><span class="line"> ite =islist.<span class="built_in">begin</span>(); </span><br><span class="line"> ite2=islist.<span class="built_in">end</span>(); </span><br><span class="line"> <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line"> cout &lt;&lt; *ite &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 4 2 99 1 9 </span></span><br><span class="line"> cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习程序中一再以循环巡访整个slist，并以迭代器是否等于slist.end() 做为循环结束条件，这其中有一些容易疏忽的地方。当我们呼叫end()企图做出一个指向尾端（下一位置）的迭代器，STL 源码是这么进行的：</p>
<p><code>iterator **end**() &#123; return iterator(0); &#125;</code></p>
<p>这会因为源码中如下的定义：</p>
<p><code>typedef __slist_iterator&lt;T, T&amp;, T*&gt; iterator; </code></p>
<p>而形成这样的结果：</p>
<p><code> __slist_iterator&lt;T, T&amp;, T*&gt;(0);//产生一个暂时对象，引发 ctor</code></p>
<p>从而因为源码中如下的定义：</p>
<p><code>__slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125; </code></p>
<p>而导致基础类别的建构：</p>
<p><code>__slist_iterator_base(0); </code></p>
<p>并因为源码中这样的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__slist_iterator_base</span></span><br><span class="line">&#123; </span><br><span class="line"> __slist_node_base* node;<span class="comment">//指向节点基本结构</span></span><br><span class="line">__slist_iterator_base(__slist_node_base* x) :<span class="built_in">node</span>(x) &#123;&#125; </span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而导致：</p>
<p><code>node(0);</code></p>
<h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B51.png" alt="image-20220708212926619"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B52.png" alt="image-20220708213202176"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B53.png" alt="image-20220708213324148"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B54.png" alt="image-20220708213425662"></p>
<h2 id="树的导览"><a href="#树的导览" class="headerlink" title="树的导览"></a>树的导览</h2><p>这里只作简单介绍。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%A0%911.png" alt="image-20220708213538944"></p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>首先需要是一棵二叉树：“任何节点最多只允许两个子节点。”</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%911.png" alt="image-20220708213849297"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912.png" alt="image-20220708213902871"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%913.png" alt="image-20220708213933983"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%914.png" alt="image-20220708214021195"></p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%911.png" alt="image-20220708214102679"></p>
<p><strong>这种不平衡状态会导致搜索的对数时间变为常数时间。</strong>尽量保持平衡能节省搜索时间。</p>
<p><strong>AVL树</strong>通过高度维护每个节点的平衡因子，以此来保持平衡。平衡破坏后具体的操作涉及<strong>RR、RL、LR、LL</strong>，即单旋转和双旋转，在数据结构已涉及，这里不详细展开了。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%912.png" alt="image-20220708214715999"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%B9%B3%E8%A1%A1%E6%A0%913.png" alt="image-20220708214804558"></p>
<h3 id="RB-tree（红黑树）"><a href="#RB-tree（红黑树）" class="headerlink" title="RB-tree（红黑树）"></a>RB-tree（红黑树）</h3><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%911.png" alt="image-20220708214854587"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%913.png" alt="image-20220708215232970"></p>
<h4 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%914.png" alt="image-20220708215346578"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%915.png" alt="image-20220708215523697"></p>
<h5 id="状况1"><a href="#状况1" class="headerlink" title="状况1"></a>状况1</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B51.png" alt="image-20220708215740628"></p>
<h5 id="状况2"><a href="#状况2" class="headerlink" title="状况2"></a>状况2</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B52.png" alt="image-20220708215952231"></p>
<p>第二次旋转是为了满足规则4，本身G(10)的左子树在不考虑ABC时是没有黑节点的，因此要再旋转一次，把8这个黑节点转上去。</p>
<h5 id="状况3"><a href="#状况3" class="headerlink" title="状况3"></a>状况3</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B53.png" alt="image-20220708220601431"></p>
<h5 id="状况4"><a href="#状况4" class="headerlink" title="状况4"></a>状况4</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%8A%B6%E5%86%B54.png" alt="image-20220708220714966"></p>
<p>因为前面考虑状况123时，X这个新节点都是带着子树考虑的（从真正的叶节点递归上来），那么此时就可以把P看成新的节点，子树看成AB，然后继续向上考虑，就回到状况123了。</p>
<h4 id="由上而下的程序"><a href="#由上而下的程序" class="headerlink" title="由上而下的程序"></a>由上而下的程序</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B1.png" alt="image-20220708220955571"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B2.png" alt="image-20220708221107493"></p>
<p><strong>P是红色，说明G是黑色。由于路径自上而下检查，因此S不会是红色，否则G这个节点就已经需要修改了。所以可以保证S是黑色，归类到状态1和2。</strong></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%94%B1%E4%B8%8A%E8%80%8C%E4%B8%8B3.png" alt="image-20220708221121614"></p>
<h4 id="节点设计"><a href="#节点设计" class="headerlink" title="节点设计"></a>节点设计</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B91.png" alt="image-20220708221455607"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A12.png" alt="image-20220708221727398"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%8A%82%E7%82%B9%E8%AE%BE%E8%AE%A13.png" alt="image-20220708221742592"></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><strong>关于双层结构</strong>：以后作补充。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A81.png" alt="image-20220708222113319"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A82.png" alt="image-20220708222145968"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A83.png" alt="image-20220708222335201"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A84.png" alt="image-20220708222354631"></p>
<p>header节点在后面图5-17。</p>
<p>注：对header节点的补充</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/sinat_41619762/article/details/115124653</span><br><span class="line"></span><br><span class="line">红黑树有一个特殊节点header。对于一棵空红黑树，header的left和right都指向自己，parent指向0。而红黑树不为空时，红黑树的根节点的parent指向header，header的parent指向根节点，header的left和right分别指向红黑树最左端和最右端的节点。于是可以方便地获得红黑树的根节点、最左节点和最右节点。</span><br><span class="line">header节点是红色的，root节点是黑色的，这用来对它们做出一定的区别。</span><br><span class="line">红黑树的begin()返回的迭代器指向的就是header的left节点，而end()返回的迭代器指向的是header自己。</span><br></pre></td></tr></table></figure>

<p>如果是根节点，则根节点（node&#x3D;&#x3D;root）的父节点是header（y），根据条件根节点右子节点是null，header的右子节点和父节点都是root，则执行一次while后：node会变为header，y会变为root。则此时不能直接把y返回，因为又回到root了，注意到此时node-&gt;right（header-&gt;right）==y，则可以用这个条件判断这个特殊状况，不加以判断的话得出的结果是有问题的。</p>
<p>decrement()也要结合header这一个节点理解。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A85.png" alt="image-20220708222409431"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A86.png" alt="image-20220708222453859"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A87.png" alt="image-20220708222512308"></p>
<p>这里的<strong>状况</strong>不是插入节点的状况。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A88.png" alt="image-20220708222524909"></p>
<h4 id="红黑树数据结构"><a href="#红黑树数据结构" class="headerlink" title="红黑树数据结构"></a>红黑树数据结构</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841.png" alt="image-20220709202843598"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png" alt="image-20220709202912338"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843.png" alt="image-20220709202929089"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844.png" alt="image-20220709202951320"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845.png" alt="image-20220709203006027"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846.png" alt="image-20220709203022344"></p>
<h4 id="红黑树的构造与内存管理"><a href="#红黑树的构造与内存管理" class="headerlink" title="红黑树的构造与内存管理"></a>红黑树的构造与内存管理</h4><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A01.png" alt="image-20220709204110637"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A02.png" alt="image-20220709204129927"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A03.png" alt="image-20220709204145642"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9E%84%E9%80%A04.png" alt="image-20220709204206488"></p>
<h4 id="红黑树元素操作"><a href="#红黑树元素操作" class="headerlink" title="红黑树元素操作"></a>红黑树元素操作</h4><h5 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C1.png" alt="image-20220709213914135"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C2.png" alt="image-20220709213927566"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C3.png" alt="image-20220709213956069"></p>
<p>对于insert_unique()，注意**j–**是找按大小顺序找前一个节点，下面是一些辅助理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/jmh1996/article/details/103466017</span><br><span class="line"></span><br><span class="line">while结束是，x为NULL也就是待插入点,而y为插入点的父节点。</span><br><span class="line">接下来初始化一个迭代器j.</span><br><span class="line">如果发现comp为true,这意味着x应该插入到y的左孩子，否则应该插入到右孩子。</span><br><span class="line"></span><br><span class="line">如果comp为true,而且刚好j又是整个树的最小值，这说明当前要插入的值比整个树的最小值还要小。于是就直接调用__insert(x, y, v) 函数进行插入。整个辅助函数，我们后面深入。</span><br><span class="line"></span><br><span class="line">如果comp为true,但是y不是指向最小值。那么就让 j 自减一下，此时 j 指向的元素,有关系：j.value&lt;y.value。 而且一定会有v&gt;=j.value。如果v&lt;j.value,那么在执行while循环的时候就应该找到是 j（或j的左子树，同时y不可能在j的左子树） 而不是 y。</span><br><span class="line"></span><br><span class="line">接下来：</span><br><span class="line">比较j.value和 v 之间那个大。</span><br><span class="line">如果条件为true,说明此时j.value&lt;v ,OK，说明v是一个全新的元素。执行正常的插入辅助程序。</span><br><span class="line">如果条件为false,意味着j.value&gt;=v，又因为v&gt;=j.value,联立这两个条件，必然有j.value==v，说明这个v就是一个重复的元素。</span><br><span class="line"></span><br><span class="line">如何在数学上证明x=y ？只需分别证明：x&gt;=y 且x&lt;=y 就可以了</span><br></pre></td></tr></table></figure>

<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C4.png" alt="image-20220709215727673"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C5.png" alt="image-20220709215759005"></p>
<p>__insert操作中，对于x这个节点，经过while循环后一定是null。</p>
<h5 id="平衡调整"><a href="#平衡调整" class="headerlink" title="平衡调整"></a>平衡调整</h5><p>树形和颜色的调整，与前面插入节点的四个状况相符，进行一次或两次单一的旋转，并且调整节点的颜色。左旋转和右旋转与AVL树的旋转是一样的道理，不过红黑树的节点有父节点，指针的操作有所不同。</p>
<p>这里首先判断父节点关于祖父节点的左右关系，从而正确获得伯父节点。可以得知新节点、父节点都是红的（因为这样才需要处理）。</p>
<ul>
<li>如果伯父节点为红，对应状况3和4，则根据前面“自上而下的程序”，改变相应节点颜色，x本身直接插入，而后检查x的祖父节点（也即while继续检查）。</li>
<li>如果伯父节点为黑，则是状况1和2，也即新插入的节点位于内侧和外侧的问题。进行一次判断是否多做一次旋转即可。</li>
</ul>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C6.png" alt="image-20220709215947662"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C7.png" alt="image-20220709220008411"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C8.png" alt="image-20220709220109772"></p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C10.png" alt="image-20220709220150211" style="zoom:110%;" />

<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C11.png" alt="image-20220709220251639"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C12.png" alt="image-20220709220318544"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C14.png" alt="image-20220709220450193"></p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C15.png" alt="image-20220709220520908"></p>
<h5 id="元素搜寻"><a href="#元素搜寻" class="headerlink" title="元素搜寻"></a>元素搜寻</h5><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C13.png" alt="image-20220709220420450"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/13/2022%E6%98%A5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B8%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/13/2022%E6%98%A5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E5%B8%96/" class="post-title-link" itemprop="url">期末复习帖</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-13 16:01:09" itemprop="dateCreated datePublished" datetime="2022-05-13T16:01:09+08:00">2022-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-26 20:26:26" itemprop="dateModified" datetime="2022-06-26T20:26:26+08:00">2022-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>总之就是非常痛苦 &gt;_&lt;</strong></p>
<p>这篇博客就当个帖，想记录一下复习期末考的过程，作为情绪抒发和进度整理等等（甚至类似于日记）。</p>
<h1 id="日程记录"><a href="#日程记录" class="headerlink" title="日程记录"></a>日程记录</h1><h2 id="Date-5-x2F-13"><a href="#Date-5-x2F-13" class="headerlink" title="Date 5&#x2F;13"></a>Date 5&#x2F;13</h2><p>这学期专业课学到了很多东西，但是很多知识点都不太深入，对考试不是很有信心，而且因为疫情估计要线上考试，也是很不方便不舒服的吧。剩下的还有20来天就考试周了，所以要现在开始复习了。首先是要规划一下，按考试的顺序应该是：</p>
<ul>
<li>操作系统（D类）</li>
<li>算法与复杂性</li>
<li>计算机组成</li>
<li>计算机科学中的数学基础</li>
<li>计算机系统结构（A类）</li>
<li>大学物理(A类）</li>
</ul>
<p>很庆幸把编译原理退了，实在折腾不起。其中毛概貌似改成了线上大作业的形式所以这里没有放出来，不过老师说还要等通知（虽然毛概这些课只是考前一天狂背）。我的习惯的从后往前复习，这样对第一门考试印象会清晰些。</p>
<ul>
<li>大学物理这学期是在上量子力学，老实说没学明白，老师的课件和讲解也比较混乱，猜想是应该不会考那么难。但是现在什么信息都不知道，甚至也没有教材，所以打算先不复习这个（感觉这门课没什么作用就是了）。</li>
<li>系统结构的话学得很烂，因为老师是选了几本书的内容来讲的，上课的时候没有结合书本来看，吸收得不是很到位。所以打算先再看看教材比较重点的章节，做做课后习题先。包括老师今天刚开放这学期的慕课，后面也可以看看慕课的视频讲得好不好（理论上慕课的成绩是课后题和模拟考试的成绩）。这门课的复习应该占的时间会比较多了。</li>
<li>数学基础讲的太难了，不过好在作业有认真做（当然是谷歌solution，因为太难了，据说作业对比考试是sss难度）。具体复习的话打算看看课件（也是没用教材来学习，全英的pdf太折磨了），把一些公式再好好看看推导再记一下（但是推导也太难了，不知道会考成啥样），然后复习做过的题目。</li>
<li>计组貌似期末是开卷（感觉开卷反而难一些），老师课讲得很好（太清晰明了了），知识点大都能理解，不过之前都没有复习导致都快忘了。所以一方面得再看看老师的ppt（老师上课很多手画的图没在ppt上，可能还得看视频了），一方面看看有没有题目做，感觉做起题目来还是很吃力。</li>
<li>算法课也难啊，图算法和几何算法讲了好几周了，属实是太难了。还没想好要咋复习，估计就看看写过的作业吧。笔记这些也没有，感觉有点难复习了，也是只能再看看ppt和书了，找不到对应能巩固的习题来做。</li>
<li>操作系统算是学得最明白的了，有一本中文教材太棒了。虽然课上用的是更新一版的英文版（中文版还没出），不过许多章节都能对应上。而且操作系统能出来考试的知识点比较明显吧，也做了相应的作业，感觉再看遍书，复习下作业题就好很多。当然还是希望能有题目做做巩固一下。</li>
</ul>
<p>时间方面的具体安排就还没想好，只能说学得不是很好，还没有<em>需要花多少时间复习</em>的自知。好在还有时间，走一步看一步先。</p>
<h2 id="Date-5-x2F-15"><a href="#Date-5-x2F-15" class="headerlink" title="Date 5&#x2F;15"></a>Date 5&#x2F;15</h2><p>现在是周日晚上十一点多，回顾一下这个周末，摸得多学得少。物理作业屯着先不打算做（做了怕又忘记了），所以周末都用来复习了。不过实际上复习的时间也就六七个小时，效率还是太低了。</p>
<p>也算是有个好的开端，两天复习了系统结构的处理器的章节和浮点数的章节。处理器部分比较多，浮点数讲的比较少，但是复习做了做题也巩固了不少，算是把薄弱的补了一些了。</p>
<p>之后打算每天看看慕课的ppt什么的，然后把课后习题做了（两天一篇吧，章节还挺多。）ppt不知道是不是和课上一样的，还没瞅瞅。然后就边复习数学基础了，看看公式什么的。</p>
<p>\ 周末都是在CIEL的歌下度过的，好听嘞 &#x2F;</p>
<img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/CIEL.png" alt="img"  />



<h2 id="Date-5-x2F-17"><a href="#Date-5-x2F-17" class="headerlink" title="Date 5&#x2F;17"></a>Date 5&#x2F;17</h2><p>跟预想的有些偏差，不知道是记错了还是怎么样，原来考试时间要倒着看的，下面是刚查到的考试信息，有点阴间，能堆的都堆了，中间又间隔挺久的。最后一周的周末貌似就用来线上考毛概，得重新计划一下复习节奏了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">大学物理：6-6   15：40——17：40</span><br><span class="line">系统结构：6-7   10：30——12：30</span><br><span class="line">数学基础：6-10  10：30——12：30</span><br><span class="line">计组    ：6-10  15：40——17：40</span><br><span class="line">算法    ：6-16  15：40——17：40</span><br><span class="line">操作系统：6-17  10：30——12：30</span><br></pre></td></tr></table></figure>

<p>至于这两天在干啥嘞，本来打算复习数学基础的，结果来了许多作业，算是最后为数不多的作业了。除了上课就是把 os 作业写了，然后补了物理作业（还差两题没写出来，这量子力学一点例题都没有，纯摸黑 ￣へ￣）。系统结构最后一次lab写了两个晚上了，现在还在等最后一题的程序出结果。</p>
<p>这两天在听re0的歌，下面两首强推（其他op和ed也都很好听）。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1832363905&auto=0&height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1475841363&auto=0&height=66"></iframe>

<h2 id="Date-5-x2F-19"><a href="#Date-5-x2F-19" class="headerlink" title="Date 5&#x2F;19"></a>Date 5&#x2F;19</h2><p>昨天肝了体育作业（该死的慕课），然后晚上写了算法课的作业就草草结束了。</p>
<p>今天复习了数学基础，先速通一遍，现在看了大概一半了。前面部分学的还是比较烂，所以看ppt的时候一边回放了视频，第二次看视频就觉得清晰多了，不过太难的证明还是不打算看了。明天打算把后面的部分也过完。</p>
<p>然后这几天看完了命运石之门，好看的嘞，胸针真男人。</p>
<h2 id="Date-5-x2F-26"><a href="#Date-5-x2F-26" class="headerlink" title="Date 5&#x2F;26"></a>Date 5&#x2F;26</h2><p>几天没更新了-。-</p>
<p>最近几天在复习完数学基础之后复习了操作系统的前面部分，本来周一是打算复习完后面部分的，结果计划了回家，买了票等等，就没心思复习下去了。</p>
<p>返乡要准备好多东西，不过一点点准备好也就可以了，回去还要先隔离14days，考试也要在酒店考，后面两门应该就能在家里了。会不会发生很麻烦的事情倒也还不知道，感觉一个人也能复习得下去一些。</p>
<p>周五的高铁，明天早上。心里不知道什么感觉，有种释放了吧。困了3个多月，从早晨起来就是对着电脑一直到晚上，不怎么出宿舍，也很久没有好好运动了……</p>
<p>倒不会很惨，学校各种措施和保障都做得很好，只是还是会有些压抑吧，虽然学业上的压力冲淡了这些压抑。</p>
<p>现在是周四的12点多一些，前两天把系统结构的慕课的测验做的差不多了，今天做完它，然后好好收拾一下行李（以及心情）。</p>
<p>回去最想做的一件事就是悠哉地吃点好的喝点好的</p>
<p>希望一切顺利，一路顺风</p>
<p>&#x2F; 最近喜欢听的歌，卡罗尔与星期二里的 After the fire</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1399996440&auto=0&height=66"></iframe>

<h2 id="Date-5-x2F-27"><a href="#Date-5-x2F-27" class="headerlink" title="Date 5&#x2F;27"></a>Date 5&#x2F;27</h2><p>跑路成功</p>
<p>5:00——22:00</p>
<p>好累- -</p>
<h2 id="Date-5-x2F-30"><a href="#Date-5-x2F-30" class="headerlink" title="Date 5&#x2F;30"></a>Date 5&#x2F;30</h2><p>最后的教学周了，今天在复习物理，好折磨嗷</p>
<p>越发感觉对知识的掌握程度并不足以应付考试</p>
<p>这周刚布置了形策的大作业，还没想好啥时候写。周末还有毛概的考试，复习时间好像不是很够…</p>
<p>在酒店隔离，条件还是很不错的，并且一个人可以开始自律生活</p>
<p>现在每天十二点睡，中午再午睡一下，慢慢变得早起些</p>
<p>然后每天保持半个小时左右的运动量，出出汗，毕竟之前在学校宿舍很久很久没有丝毫运动了，作为康复训练吧</p>
<p>压力还是很大，几门课程的平时分根据作业的打分情况看感觉也没有到预期，甚至还不知道错哪里了，答案也不公布…（唉）</p>
<p>不打算摆烂，但是也不打算太肝了。就像是在痛苦与快感中获得相对平衡</p>
<p>又也许只是，在虚无的快乐中寻求一些充实</p>
<h2 id="Date-6-x2F-1"><a href="#Date-6-x2F-1" class="headerlink" title="Date 6&#x2F;1"></a>Date 6&#x2F;1</h2><p>儿童节快乐</p>
<p>这两天一天整理+复习了计组，一天看了系统结构的题目，明天接着再看一遍系统结构的题目，以及把形策大作业over</p>
<p>然后是周五看os，因为周五晚上要os小测了</p>
<p>周六看大物，周天做毛概，下周一就开始考试了</p>
<p>选课遇到了点问题，选人工智能和要补修（因为转专业）的问求（问题求解与实践）时间冲突了，只能退选人工智能这门课，否则影响保研。实际上也不差人工智能这一门课，但是这又影响到后面学期的选方向，没选这门课就不能选AI的那个方向了，需要另修完一个方向的学分，我换了个计算机图形学，到时的方向应该是虚拟现实技术之类的。不过还是会继续学AI，因此那个方向是用来修学分的，AI方向的课还是可以选（据说），应该会继续选来上，就是课会比较多了……</p>
<p>不管怎么说，后面走一步算一步吧，加油</p>
<h2 id="Date-6-x2F-3"><a href="#Date-6-x2F-3" class="headerlink" title="Date 6&#x2F;3"></a>Date 6&#x2F;3</h2><p>端午节快乐</p>
<p>隔离酒店的早餐加了个粽子，挺开心的</p>
<p>晚上考了个os的小测，平均线之上吧，都是多选题，很难选</p>
<p>其他时间摆了挺久，期末考越来越近了</p>
<p>哈哈感觉期末考有些打boss的意思了</p>
<p>在酒店待了一个星期了，吃得挺好睡得挺好，都挺好的</p>
<p>日子很平淡，老实说就算放假了也没想着要干嘛——呃想得有些远了</p>
<p>最近喜欢听的歌，希望未来有一天</p>
<p>能明白许许多多的，非常遥远的，没有名字的，安静的孤单的，星星的愿望</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=437608325&auto=0&height=66"></iframe>



<h2 id="Date-6-x2F-5"><a href="#Date-6-x2F-5" class="headerlink" title="Date 6&#x2F;5"></a>Date 6&#x2F;5</h2><p>现在是下午，刚做完毛概的考试大作业，题目挺水的，逻辑搞对在书上找找，以及网上搜搜就能答。不过感觉大家的答案可能都一样了，官话都那个味道，不知道怎么批改。前天晚上刚做了os的小测，30道选择题，有95%的多选题，英文概念题，做起来挺恶心的，是题库的题目，但是老师有些都没有讲。不过还是老老实实自己做了，在平均分之上，换算下来平均分的话是平时分扣5分，我是平时分扣3分，这个结果对一门课程来说挺不应该的，不知道老师会不会调分，就算不调分我也能接受吧。</p>
<p>然后这个是最新的考试时间，为了不受早上做核酸的影响，教务把考试都安排到下午和晚上了，日期倒是没有变化，起码早上可以不用那么早起吧。</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E8%80%83%E8%AF%95%E6%97%B6%E9%97%B41.png" alt="1d2b82fbcba30c43fa8a29a03c36d1f"></p>
<p>晚上接着复习物理，说实话已经看了几天物理了，感觉还不如前面花多点时间复习别的科目。但是明天就要考物理了也不能不继续复习，感觉自己的状态不是很好，复习起来也是有气无力的，没有前几个学期那么沉得住气，线上教学影响还是蛮大的。</p>
<p>这个学期考个正常分平均分就立大功了，不是很抱期望考高分，暑假再收拾收拾心情。</p>
<p>接下来就好好打boss了</p>
<h2 id="Date-6-x2F-12"><a href="#Date-6-x2F-12" class="headerlink" title="Date 6&#x2F;12"></a>Date 6&#x2F;12</h2><p>现在是周日，周五考完计组后周六好好放松了一天。</p>
<p>这几门科目的考试确实比较难，感觉发挥的也不是那么好吧，不过应该也不会那么差（希望吧）</p>
<p>后面还有两科今天要开始复习了，先花两天时间看操作系统，再花两天时间看算法，老实说算法还不知道会怎么考，后面有机会再了解了解</p>
<p>早上在阳台吹了很久的风，没有在思考，纯粹的放松。以后的职业选择估计也要变了，等考完试再理一理</p>
<p>最近看虫师被惊艳到的一首纯音乐，很惬意很飘渺</p>
<p>很理想</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=469933&auto=0&height=66"></iframe>

<h2 id="Date-6-x2F-18"><a href="#Date-6-x2F-18" class="headerlink" title="Date 6&#x2F;18"></a>Date 6&#x2F;18</h2><p>今天是周六，出去和朋友玩了。昨天考完os累坏啦，周末好好放松一下，然后下周又要开始小学期了。</p>
<p>明天再规划一下暑假安排，等分数出来再给这个贴子来一个终结啦。</p>
<h2 id="Date-6-x2F-26"><a href="#Date-6-x2F-26" class="headerlink" title="Date 6&#x2F;26"></a>Date 6&#x2F;26</h2><p> 今天成绩算是全部出来了，一般般比较正常。因为有很多同学缓考和重考，所以也不知道真实的排名，也就不说了。</p>
<p>整个过程算是很辛苦了，不过过去就好啦。</p>
<p>最近重新深入学c++，也感觉挺有意思的（虽然很难）。</p>
<p>这篇就到此为止啦，谢谢陪伴</p>
<p>（最后推一首歌</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="https://music.163.com/outchain/player?type=2&id=1811129844&auto=0&height=66"></iframe>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%993/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%993/" class="post-title-link" itemprop="url">自动登录学校网站（终：优化）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 15:56:47" itemprop="dateCreated datePublished" datetime="2022-05-12T15:56:47+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 08:27:27" itemprop="dateModified" datetime="2022-05-26T08:27:27+08:00">2022-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h1><p>对于原来的代码，尽管能够成功登录学校的网站，但依旧有很多地方可以优化。</p>
<ul>
<li><p>模型加载较慢，python加载本地训练好的模型还是太慢了，并且要打包成exe文件的话，torch这个库太大了，不可能再用自己的模型来完成项目。所以这里可以再用到之前的验证码识别库ddddocr来代替自己的识别模型。</p>
</li>
<li><p>考虑到项目迁移的方便，每次都下载一个chromedriver.exe文件是比较麻烦的，禁用谷歌浏览器自动升级是个好的选择，但是有更好的替代方法。可以使用<code>webdriver-manager</code>这个库，它会自动下载对应的driver到缓存里。具体的使用方式是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-logging&#x27;</span>])<span class="comment">#忽略dirver的信息打印</span></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install(),options=options)<span class="comment">#可以在缓存里下载最新的driver</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面两个解决方式分别能够优化程序的<strong>运行速度</strong>和<strong>项目迁移性</strong>，但直接打包成.exe文件还是会产生其他的问题。</p>
</li>
</ul>
<h1 id="可执行文件优化"><a href="#可执行文件优化" class="headerlink" title="可执行文件优化"></a>可执行文件优化</h1><ul>
<li><p>程序正常运行的情况下会在结束时关闭浏览器，除非我们在程序末尾sleep一个很长的时间等待。然而我们希望程序进程在打开浏览器后就可以退出，而不必等待我们将浏览器关闭。可以使用<code>options.add_experimental_option(&quot;detach&quot;, True)</code>，这个语句使程序结束后浏览器不会关闭，不需要程序一直等待。</p>
</li>
<li><p>我们打包的文件会调用chromedriver.exe，尽管我们可以设置我们的可执行文件（.exe）运行时不出现cmd窗口，但chromedriver.exe依然会出现自己的窗口展示运行信息，而这会影响简结，我们希望这个窗口不出现。解决方法是修改<strong>selenium</strong>包中的<strong>service.py</strong>（selenium-&gt;webdriver-&gt;common-&gt;service.py）源码。如下图，注意数字必须相同。</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/selenium%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9.png" alt="image-20220512161629179" style="zoom:80%;" />
</li>
<li><p>最后的问题是，我们的程序自动退出了，因为不将浏览器关掉，所以chromedriver.exe这个进程会一直留在内存里。如果我们多次打开我们的.exe文件，就会有很多个chromedriver.exe进程，尽管占用的空间很小，我们也希望能在程序结束后终止掉这个进程，这并不会导致我们的网页关闭。</p>
<ul>
<li><p>我们可以用<code>&quot;taskkill /im chromedriver.exe /F&quot;</code>这个命令来杀死这个进程，一种容易想到的方式是用os.system(command)来执行这条命令，但是这个方式会在执行时闪现出cmd执行窗口，不是我们希望的方式。</p>
</li>
<li><p>更好的方式是使用python的另一个标准库<strong>subprocess</strong>的subprocess.call(command, creationflags&#x3D;0x08000000)。因此就可以写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.call(<span class="string">&quot;taskkill /im chromedriver.exe /F&quot;</span>, creationflags=<span class="number">0x08000000</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>以上就把代码优化完毕了，两个代码文件如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#captcha_fast.py</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_snap</span>(<span class="params">driver</span>):  <span class="comment"># 对目标网页进行截屏。这里截的是全屏</span></span><br><span class="line">    driver.save_screenshot(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    page_snap_obj=Image.<span class="built_in">open</span>(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> page_snap_obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">driver</span>): <span class="comment"># 对验证码所在位置进行定位，然后截取验证码图片</span></span><br><span class="line">    scaling_ratio=<span class="number">1</span><span class="comment">#系统显示的缩放比例</span></span><br><span class="line">    img = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;captcha-img&quot;]&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.10</span>)</span><br><span class="line">    location = img.location</span><br><span class="line">    size = img.size</span><br><span class="line">    left = location[<span class="string">&#x27;x&#x27;</span>]*scaling_ratio</span><br><span class="line">    top = location[<span class="string">&#x27;y&#x27;</span>]*scaling_ratio</span><br><span class="line">    right = left + size[<span class="string">&#x27;width&#x27;</span>]*scaling_ratio</span><br><span class="line">    bottom = top + size[<span class="string">&#x27;height&#x27;</span>]*scaling_ratio</span><br><span class="line">    page_snap_obj = get_snap(driver)</span><br><span class="line">    image_obj = page_snap_obj.crop((left, top, right, bottom))</span><br><span class="line">    image_obj.save(<span class="string">&#x27;captcha.png&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#login_oc.py</span></span><br><span class="line"><span class="keyword">from</span> captcha_fast <span class="keyword">import</span> get_image</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line"></span><br><span class="line">ocr = ddddocr.DdddOcr(use_gpu=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;detach&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-logging&#x27;</span>])</span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install(),options=options)</span><br><span class="line">driver.maximize_window()<span class="comment">#最大化</span></span><br><span class="line"></span><br><span class="line">captcha_path=<span class="string">&#x27;./captcha.png&#x27;</span></span><br><span class="line">snap_path=<span class="string">&#x27;./full_snap.png&#x27;</span></span><br><span class="line">url=<span class="string">&#x27;https://oc.sjtu.edu.cn/login/openid_connect&#x27;</span></span><br><span class="line"><span class="comment"># 构造请求头</span></span><br><span class="line"></span><br><span class="line">driver.get(url) <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line">cur_title=driver.title</span><br><span class="line"><span class="keyword">while</span>(driver.title==cur_title):<span class="comment">#失败则一直试</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)  <span class="comment"># 加载等待</span></span><br><span class="line">    get_image(driver)</span><br><span class="line">    <span class="comment">#print(&quot;推理验证码......&quot;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(captcha_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img_bytes = f.read()</span><br><span class="line">    captcha_res = ocr.classification(img_bytes)</span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;user&#x27;</span>).send_keys(<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 填入用户名</span></span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;pass&#x27;</span>).send_keys(<span class="string">&#x27;password&#x27;</span>)  <span class="comment"># 填入密码</span></span><br><span class="line">    driver.find_element(By.NAME,<span class="string">&#x27;captcha&#x27;</span>).send_keys(captcha_res)  <span class="comment"># 填入验证码</span></span><br><span class="line">    driver.find_element(By.ID,<span class="string">&quot;submit-button&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">os.remove(captcha_path)</span><br><span class="line">os.remove(snap_path)</span><br><span class="line">subprocess.call(<span class="string">&quot;taskkill /im chromedriver.exe /F&quot;</span>, creationflags=<span class="number">0x08000000</span>)<span class="comment">#杀死进程，用os.system会有黑窗口闪现</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ending......&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><p>最后进行项目的打包，我使用<strong>pyinstaller</strong>库来打包项目，用得比较习惯。首先在cmd窗口切换目录到python文件的目录，打包的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -w -i icon.ico login_oc.py</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-w</strong>表明取消程序执行的命令行窗口</li>
<li><strong>-i</strong> 表示添加打包文件的图标，后面的icon.ico就是我们使用的图标，要放在目录下，或者把路径写全。注意不能用其他后缀的图片，可以先去在线转换网站把图片转换成.ico格式，还需要注意的是，这个icon大小必须是<strong>16×16</strong>的。</li>
<li>最后想说这里不使用 <strong>-F</strong> 这个参数打包的原因。<ul>
<li>我们希望程序响应快一些，-F会把所有的项目依赖的文件打包在一起，获得一个比较大的.exe文件，这会导致文件的加载速度变慢。而不用 -F 会导出一个文件夹，放置项目依赖的文件。</li>
<li>ddddocr这个库在打包的过程中，没有被打包进去。因此不使用 -F 恰好能让我们手动把这个库添加到工作目录下（所有的库和我们的.exe文件都在这个文件夹中，还包括很多其他的.dll文件等）。</li>
<li>如果我们想做多个.exe文件登录不同的网站（我做了两个），程序使用的库基本都是一样的，仅仅是代码有一些修改，甚至只是url修改了以下。因此我们可以把多个.exe文件都放到一个工作目录下，共享这些项目依赖文件，这样就能很大地降低内存开销。</li>
</ul>
</li>
</ul>
<h1 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h1><p>在项目打包后，注意.exe文件不能移动到别的地方，要创建一个<strong>快捷方式</strong>，把这个快捷方式移动就可以在桌面或者其他地方使用了。</p>
<p>整个项目到此就结束了，有任何问题欢迎评论</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/头像.png" style="zoom: 15%;" />
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%992/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%992/" class="post-title-link" itemprop="url">自动登录学校网站（续）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 09:36:43" itemprop="dateCreated datePublished" datetime="2022-05-12T09:36:43+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 08:27:07" itemprop="dateModified" datetime="2022-05-26T08:27:07+08:00">2022-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="解析登录网址"><a href="#解析登录网址" class="headerlink" title="解析登录网址"></a>解析登录网址</h1><p>首先我们要定位到登录的网址以便driver访问。</p>
<p>将浏览器打开到登录页面，可以看到对应的网址为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://jaccount.sjtu.edu.cn/jaccount/jalogin?sid=jaoauth220160718&amp;client=CAzoSoajfvlBJKYW7q11rIlS5ucaE%2FIWcLi2eNuNEJDa&amp;returl=CPDcg4bZMUVfWbZWFi2BIAB%2BzZprZ2JnKxq%2Bd6MsjeS0nMw73qkvsCxG47FeRZmpnkzSb7Gf%2FCPIbwa%2BNH267zBN%2BexUD2RL%2BhgfQzpYNJ96UJUYoajLq%2Fqgx6g%2BL2Ol6i3p5RWYYIcKoV28CmbnNbPia3K1RfdgUgktPh4yNrgYsIciWlBvtMDF%2FLrJfK4rGV9Z%2BbdiXK6EFaQJId4mZXj45XlS2pmQtR5P6qOeSj3nvLDaxZ6bablX7cNO5IhPAmaj%2BMOH%2Fx5F7YpIbYoZg3R01iV6Rd7oO8pSmHFTFkvhJFWPTWI1C01nBDaKato1IDv%2BP0%2FF8C6e%2BTDf6MOGmge0SAXgweU0o4I2v06Xb5nDWAGGTAtyB2Vm0qxD7RB6C74n77jiGIGju4y13a%2Fi10RO4pmfPcik9st2unhTWfVMqDtYd%2BJ9jCjl8UOoel8G99qS7ET%2FVN%2FbP%2BfUkBJb7I8%3D&amp;se=CBZz3nk3K70uQiJvss5rVxhD4A5GYffm65sDqZ6Zh2PbEFVqISnzjU2JVjCO1VYIYuNZMv%2F8W6s3</span><br></pre></td></tr></table></figure>

<p>很明显这是拼接了随机数的网址而不是真正应该访问的，为了得到真正的登录页面的网址，需要动态解析。</p>
<p>打开一开始的登录选项，要点击校内用户登录才会加载出真正的登录页面，因此可以猜测这是一个动态加载的页面。所以我们打开页面控制台，点击<strong>Network</strong>选项，一开始是空白的，等待新加载的信息。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%901.png" alt="image-20220512114437557"></p>
<p>然后点击登录按钮，会跳转到登录页面。左边的控制台已经加载了许多信息，要在这些信息中找到加载网址的信息，一般来说我们查看第一条条目即可。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%902.png" alt="image-20220512114740458"></p>
<p>选中第一条，可以看到请求的url，这就是真正的登录页面的网址，这里可以复制这个地址打开看看是不是正确的，如果不是就继续找。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E7%99%BB%E5%BD%95%E7%BD%91%E5%9D%80%E8%A7%A3%E6%9E%903.png" alt="image-20220512114923472"></p>
<h1 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h1><p>得到网址后，可以进行登录。登录一般来说有两种方式，一种是用requests库的post请求，一种是用selenium的driver直接进行网页模拟登录。这里选择用driver的方式主要基于以下两个方面：</p>
<ul>
<li>目的上看，我们想要自动登录后还能够操纵我们的网页干其他事情，用driver的话刚刚好</li>
<li>从可行性的角度上看，登录过程我们需要验证码识别，如果用requests库抓取，前面提到抓取下来的验证码是不一样的，每次抓取都会改变内容。因此我能想到的解决方法就是用driver的页面进行静态的截图，实际上这符合我们人眼识别的过程。</li>
</ul>
<p>因此，我们对于验证码的识别就是根据截图来进行的。同样，这里使用我们之前训练的模型，因此要把模型先放到model.py里面。下面给出处理验证码的代码文件。首先定义验证码信息参数，如长度、大小等。然后我们要把模型初始化，加载参数的过程会比较慢（推理很快），我们不想浪费这段时间，由于用driver打开网页也需要一段时间，因此就可以开一个线程来加载参数，与此同时打开网页，可以节省一些时间。</p>
<p>然后定义了截图操作，先截全屏再截下验证码。这里验证码的位置信息通过网页源代码（html）的信息获取，用xpath、class、id定位都行，在webdriver都定义了相关的操作。需要注意的是<strong>scaling_ratio</strong>这一变量，要截下正确的验证码位置与我们屏幕的缩放比例有关。可以在桌面上右键点击显示设置，然后查看屏幕的缩放与布局，根据缩放的比例设置变量。</p>
<img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E5%B1%8F%E5%B9%95%E7%BC%A9%E6%94%BE%E6%AF%94%E4%BE%8B.png" alt="image-20220512121304774" style="zoom:80%;" />

<p>最后还有一个验证码解码的方法，实际上这跟前面predict.py的操作类似。所有代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># captcha.py</span></span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> CNN_sjtu</span><br><span class="line"><span class="keyword">import</span> torch.nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> Compose, ToTensor, Resize,Normalize</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="comment">#pytorch版本关系，会有warning，实际上可以忽略</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码信息参数</span></span><br><span class="line">numchar = <span class="number">4</span></span><br><span class="line">alphabet = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">width = <span class="number">100</span></span><br><span class="line">height = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模型初始化</span></span><br><span class="line">model_net = CNN_sjtu(num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), width=width, height=height)</span><br><span class="line">model_net = model_net.cuda()</span><br><span class="line">model_net.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_net</span>():<span class="comment">#load参数 比较慢，用一个额外的线程先load</span></span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;load net......&quot;</span>)</span><br><span class="line">    model_net.load_state_dict(torch.load(<span class="string">r&#x27;C:\Users\14242\PycharmProjects&#x27;</span></span><br><span class="line">                                         <span class="string">r&#x27;\DL\Pytorch_project\captcha-CNN-验证码识别\weights/model_sjtu_4.path&#x27;</span>))<span class="comment">#参数位置</span></span><br><span class="line"></span><br><span class="line">thread_load= Thread(target=load_net)</span><br><span class="line">thread_load.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_captcha</span>(<span class="params">img_path</span>):</span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        img=Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        transforms = Compose([Resize((height, width)), ToTensor(), Normalize(<span class="number">0</span>, <span class="number">1</span>)])</span><br><span class="line">        img = transforms(img)</span><br><span class="line">        img = img.view(<span class="number">1</span>, <span class="number">3</span>, height, width).cuda()</span><br><span class="line">        output = model_net(img)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, <span class="built_in">len</span>(alphabet))</span><br><span class="line">        output = torch.nn.functional.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = torch.argmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, numchar)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([alphabet[i] <span class="keyword">for</span> i <span class="keyword">in</span> output.cpu().detach().numpy()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_snap</span>(<span class="params">driver</span>):  <span class="comment"># 对目标网页进行截屏。这里截的是全屏</span></span><br><span class="line">    driver.save_screenshot(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    page_snap_obj=Image.<span class="built_in">open</span>(<span class="string">&#x27;full_snap.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> page_snap_obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">driver</span>): <span class="comment"># 对验证码所在位置进行定位，然后截取验证码图片</span></span><br><span class="line">    scaling_ratio=<span class="number">1</span><span class="comment">#系统显示的缩放比例</span></span><br><span class="line">    img = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;captcha-img&quot;]&#x27;</span>)<span class="comment">#获取验证码在网页中的位置信息</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)<span class="comment">#等待一会</span></span><br><span class="line">    location = img.location<span class="comment">#位置</span></span><br><span class="line">    size = img.size<span class="comment">#大小</span></span><br><span class="line">    left = location[<span class="string">&#x27;x&#x27;</span>]*scaling_ratio</span><br><span class="line">    top = location[<span class="string">&#x27;y&#x27;</span>]*scaling_ratio</span><br><span class="line">    right = left + size[<span class="string">&#x27;width&#x27;</span>]*scaling_ratio</span><br><span class="line">    bottom = top + size[<span class="string">&#x27;height&#x27;</span>]*scaling_ratio</span><br><span class="line">    page_snap_obj = get_snap(driver)<span class="comment">#获取整个页面截图</span></span><br><span class="line">    image_obj = page_snap_obj.crop((left, top, right, bottom))<span class="comment">#截下验证码</span></span><br><span class="line">    image_obj.save(<span class="string">&#x27;captcha.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>下面是我们登录的主程序，注意这种方式要先下载对应于谷歌浏览器版本号的chromedriver.exe放到当前的目录下。</p>
<p>通过<code>send_keys()</code>方法填入用户名、密码、验证码；接着通过<code>click()</code>方法自动点击登录按钮即可，注意操作网页的过程一定要适当地等待加载（sleep）。</p>
<p>由于验证码可能识别错误，因此要循环判断是否成功登录，直到成功再停止。我的方法是判断当前页面的<strong>title</strong>是否发生了改变，这是一个比较简单方便的方式。</p>
<p>最后，由于一开始我们生成了两个截图，可以用<code>os.remove()</code>将其删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># login.py</span></span><br><span class="line"><span class="keyword">from</span> captcha <span class="keyword">import</span> decode_captcha <span class="keyword">as</span> decode_c</span><br><span class="line"><span class="keyword">from</span> captcha <span class="keyword">import</span> get_image</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用谷歌driver的基本操作</span></span><br><span class="line">options = Options()</span><br><span class="line">driver = webdriver.Chrome(options=options)<span class="comment">#调用当前路径下的chromedriver.exe</span></span><br><span class="line">driver.maximize_window()<span class="comment">#最大化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#截图的保存地址</span></span><br><span class="line">captcha_path=<span class="string">&#x27;./captcha.png&#x27;</span></span><br><span class="line">snap_path=<span class="string">&#x27;./full_snap.png&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#两个地址链接</span></span><br><span class="line">url = <span class="string">&#x27;https://i.sjtu.edu.cn/jaccountlogin&#x27;</span></span><br><span class="line">url =<span class="string">&#x27;https://oc.sjtu.edu.cn/login/openid_connect&#x27;</span></span><br><span class="line"></span><br><span class="line">driver.get(url) <span class="comment">#打开网页</span></span><br><span class="line"></span><br><span class="line">cur_title=driver.title</span><br><span class="line"><span class="keyword">while</span>(driver.title==cur_title):<span class="comment">#失败则一直试，因为验证码可能错误，两次应该就能成功</span></span><br><span class="line">    time.sleep(<span class="number">0.10</span>)  <span class="comment"># 加载等待</span></span><br><span class="line">    get_image(driver)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;推理验证码......&quot;</span>)</span><br><span class="line">    captcha_res=decode_c(captcha_path)</span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;user&#x27;</span>).send_keys(<span class="string">&#x27;username&#x27;</span>)  <span class="comment"># 填入用户名</span></span><br><span class="line">    driver.find_element(By.NAME, <span class="string">&#x27;pass&#x27;</span>).send_keys(<span class="string">&#x27;password&#x27;</span>)  <span class="comment"># 填入密码</span></span><br><span class="line">    driver.find_element(By.NAME,<span class="string">&#x27;captcha&#x27;</span>).send_keys(captcha_res)  <span class="comment"># 填入验证码</span></span><br><span class="line">    driver.find_element(By.ID,<span class="string">&quot;submit-button&quot;</span>).click()</span><br><span class="line"></span><br><span class="line">os.remove(captcha_path)</span><br><span class="line">os.remove(snap_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ending......&quot;</span>)</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/10/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%991/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E7%BD%91%E7%AB%991/" class="post-title-link" itemprop="url">验证码识别+自动登录学校网站</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 14:28:55" itemprop="dateCreated datePublished" datetime="2022-05-10T14:28:55+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-26 08:44:09" itemprop="dateModified" datetime="2022-05-26T08:44:09+08:00">2022-05-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前段时间打算用谷歌driver自动登录学校的网站，方便后面继续开发脚本，主要还是想着以后也许会用到爬虫爬取图像等数据用来训练。</p>
<p>这个项目从最开始使用 pytorch 搭模型、爬验证码数据、以及训练改进，到后来觉得登录学校网站不用手打验证码挺方便的，就不断优化程序最后完成了一个快速登录的可执行文件，下面是一个demo演示。</p>
<p>这里打算开个坑写写训练的过程和用谷歌driver登录网站的设计思路，以及最后的一些优化日志。</p>
<p><video src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/haha.mp4" controls></video></p>
<h1 id="验证码数据集获取"><a href="#验证码数据集获取" class="headerlink" title="验证码数据集获取"></a>验证码数据集获取</h1><h2 id="解析验证码网址"><a href="#解析验证码网址" class="headerlink" title="解析验证码网址"></a>解析验证码网址</h2><p>我们打开网址的登录页面，检查页面源代码，定位到验证码的位置，可以看到一个验证码的网页。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E6%9E%901.png" alt="验证码网址解析1"></p>
<p>打开这个网页，显示的就是验证码的图片，但这个验证码不是原来的验证码，说明验证码是动态加载的，尽管网址一样但是内容是不相同的。可以使用爬虫工具下载这个图片，为了观察这个网址以便批量下载，我们刷新登录页面，并再次打开一个新的验证码网址。可以看到唯一的变化就是网址后缀上的 <strong>uuid</strong> 变化了。uuid 是一种标识码，后端算法会根据这个 uuid 生成一个验证码。</p>
<p>所以可以先随机生成一个 uuid 标识，然后拼接成完整的验证码网址，通过爬虫下载图片。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E6%9E%902.png" alt="验证码解析2"></p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%A7%A3%E6%9E%903.png" alt="验证码解析3"></p>
<h2 id="批量下载验证码"><a href="#批量下载验证码" class="headerlink" title="批量下载验证码"></a>批量下载验证码</h2><p>使用python（环境：python3.7）提供一系列的操作：</p>
<ul>
<li><p>生成uuid并拼接网址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid <span class="comment">#该库用于生成uuid，有多种方式</span></span><br><span class="line">uuidx=<span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">url = <span class="string">&#x27;https://jaccount.sjtu.edu.cn/jaccount/captcha?uuid=&#x27;</span>+uuidx</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过爬虫下载验证码图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">origin_path=<span class="string">&#x27;captcha-sjtu/origin.jpg&#x27;</span></span><br><span class="line"><span class="comment"># 构造请求头</span></span><br><span class="line">headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.57&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 发送请求</span></span><br><span class="line">res = requests.get(url=url,headers=headers)</span><br><span class="line"><span class="comment"># 把获取的二进制写成图片</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(res.content)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得了一张图片后，我们需要将它命名为它的验证码识别结果，作为训练数据和测试数据的标签。但我们不可能人眼去识别和手动修改，这样工作量太大了，因此可以选择外接库来帮我们识别（本意不是识别出验证码，而是学习自己搭网络来训练，因此尽管有外接库，还是希望自己能完成一个网络）。这里选择ddddocr这个库，用法很简单</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">ocr = ddddocr.DdddOcr(use_gpu=<span class="literal">True</span>)		<span class="comment">#实例化一个识别器，使用gpu</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    img_bytes = f.read()	<span class="comment">#读入二进制数据</span></span><br><span class="line"><span class="keyword">try</span>:	<span class="comment">#可能上面的uuid拼接的url弄的不是一个验证码</span></span><br><span class="line">    res = ocr.classification(img_bytes)		<span class="comment">#识别的结果</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">continue</span>	<span class="comment">#如果url不是验证码就跳过，无所谓。不用try语句的话会中断</span></span><br><span class="line">newname=<span class="string">&#x27;captcha-sjtu/train/&#x27;</span>+res+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.rename(origin_path, newname)	<span class="comment">#可能已经有一个同名的了，为了不让程序中断，还是使用try</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>至此就处理完了一张图片，下面为批量处理的完整代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line">ocr = ddddocr.DdddOcr(use_gpu=<span class="literal">True</span>)</span><br><span class="line">origin_path=<span class="string">&#x27;captcha-sjtu/origin.jpg&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">    <span class="comment"># 每爬取500个，歇1秒，确保服务器不会受影响</span></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----&quot;</span>,i/<span class="number">1000</span>,<span class="string">&#x27;组-----------&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 生成随机数</span></span><br><span class="line">    uuidx=<span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    url = <span class="string">&#x27;https://jaccount.sjtu.edu.cn/jaccount/captcha?uuid=&#x27;</span>+uuidx</span><br><span class="line">    <span class="comment"># 构造请求头</span></span><br><span class="line">    headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &#x27;</span></span><br><span class="line">                          <span class="string">&#x27;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.57&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    res = requests.get(url=url,headers=headers)</span><br><span class="line">    <span class="comment"># 把获取的二进制写成图片</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line">    <span class="comment"># 再读取回来</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img_bytes = f.read()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = ocr.classification(img_bytes)<span class="comment">#可能上面的uuid拼接的url弄的不是一个验证码</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    newname=<span class="string">&#x27;captcha-sjtu/train/&#x27;</span>+res+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.rename(origin_path, newname)<span class="comment">#可能已经有一个同名的了</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="pytorch-模型搭建"><a href="#pytorch-模型搭建" class="headerlink" title="pytorch 模型搭建"></a>pytorch 模型搭建</h1><h2 id="构建-Dataset"><a href="#构建-Dataset" class="headerlink" title="构建 Dataset"></a>构建 Dataset</h2><p>将数据集分成9:1，并预留一些数据用于验证。首先定义一些参数设置，写在setting.py内。通过观察验证码，可以得到图片的宽度和高度，以及内容和长度。这里验证码的内容都是小写字母，因此我们只需要小写字母的字母表；而验证码长度是4或者5，对于CNN网络来说，需要接受一个固定大小的输入，然后输出一个固定大小的标签等等。</p>
<p>因此我们没办法同时识别长度为4和长度为5的验证码，但根据观察发现这两种长度的验证码出现的频率几乎是1：1的，那么在登录验证时只需要不断 try 尝试即可，而且并不会造成很多的时间浪费。以下为setting的内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  setting.py </span></span><br><span class="line">width_sjtu=<span class="number">100</span>	<span class="comment">#图片尺寸</span></span><br><span class="line">height_sjtu=<span class="number">40</span></span><br><span class="line">alphabet_sjtu=<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><span class="comment">#全是小写字母</span></span><br><span class="line"><span class="comment">#验证码长度</span></span><br><span class="line">numchar=<span class="number">4</span></span><br><span class="line"><span class="comment">#train:</span></span><br><span class="line"><span class="comment">#  遍历数据集训练的次数</span></span><br><span class="line">max_epoch=<span class="number">100</span></span><br><span class="line"><span class="comment">#  批处理数量</span></span><br><span class="line">batch_size=<span class="number">128</span></span><br><span class="line"><span class="comment">#  学习率</span></span><br><span class="line">base_lr=<span class="number">0.0003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  训练数据存放路径</span></span><br><span class="line">train_data_path_sjtu=<span class="string">&#x27;./captcha-sjtu/train&#x27;</span></span><br><span class="line"><span class="comment">#  测试数据存放路径</span></span><br><span class="line">test_data_path_sjtu= <span class="string">&#x27;./captcha-sjtu/test&#x27;</span></span><br><span class="line"><span class="comment">#  预测数据</span></span><br><span class="line">samples_path_sjtu = <span class="string">&#x27;./captcha-sjtu/predict&#x27;</span></span><br><span class="line"><span class="comment">#  是否使用gpu</span></span><br><span class="line">use_gpu= <span class="literal">True</span></span><br><span class="line"><span class="comment">#  gpu并行处理进程数</span></span><br><span class="line">num_workers= <span class="number">0</span></span><br><span class="line"><span class="comment">#  训练后的模型输出的路径</span></span><br><span class="line">model_path=<span class="string">&#x27;./weights&#x27;</span></span><br></pre></td></tr></table></figure>

<p>随后，我们要重写Dataset，大部分工作在重写_<em>getitem</em>_()方法，返回处理后的图像和标签，于是我们需要先考虑这个标签的形式。我们似乎可以使用一个字母表大小（里面也可以包括数字等等）的一维向量，比如全是小写字母那么我的向量长度就为26，然后将验证码图片出现的字母映射在向量对应的索引处：如果字母出现则为1，不出现则为0。但这种方法，一方面没办法表示验证码的顺序，一方面没办法识别有重复字母的验证码。</p>
<p>因此考虑对每个字母都建立一个长度为26的向量进行映射，因此向量的总长度就是<strong>验证码长度×字母表长度</strong>。</p>
<p>对于一个图片，前面使用了它的名称作为验证码结果，因为我们下载的时候并没有区别长度，因此这里长度不一致的数据要剔除，执行一次continue即可。然后，我们把验证码字符串的每一个字符都映射到一个向量上，在python中可以使用str.find()，这里的str即为我们的字母表。然后我们把这些向量都拼接起来，就构成了label。</p>
<p>make_dataset()函数会返回图片路径、图片label，最后我们Dataset中使用它重写_<em>getitem</em>_()方法。对应的dataset.py文件如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># datasets.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">img_loader</span>(<span class="params">img_path</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">    <span class="comment"># 将图像转换为 RGB</span></span><br><span class="line">    <span class="keyword">return</span> img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理数据集所在文件夹下的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_dataset</span>(<span class="params">data_path, alphabet, num_class, num_char</span>):</span><br><span class="line">    <span class="comment"># 获取数据集所在文件夹的所有文件名</span></span><br><span class="line">    img_names = os.listdir(data_path)</span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_names:</span><br><span class="line">        <span class="comment"># 拼接每个图像数据集的路径</span></span><br><span class="line">        img_path = os.path.join(data_path, img_name)</span><br><span class="line">        <span class="comment"># 找出该图像的label</span></span><br><span class="line">        target_str = img_name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 判断lable和结果的长度是否一致</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(target_str) != num_char:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        target = []</span><br><span class="line">        <span class="comment"># 创建每个数据的target数组 4 * alphabet，这里使用one hot</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target_str:</span><br><span class="line">            <span class="comment">#------如果只看小写要映射成小写-------------------</span></span><br><span class="line">            <span class="comment"># if ord(char)&gt;=65 or ord(char)&lt;=90:</span></span><br><span class="line">            <span class="comment">#     char=chr(ord(char)+32)</span></span><br><span class="line">            <span class="comment">#---------------------------------</span></span><br><span class="line"></span><br><span class="line">            vec = [<span class="number">0</span>] * num_class</span><br><span class="line">            vec[alphabet.find(char)] = <span class="number">1</span></span><br><span class="line">            target += vec<span class="comment">#要四个数组，如果写在一个数组内，重复的表示不出来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加入数据集</span></span><br><span class="line">        samples.append((img_path, target))</span><br><span class="line">    <span class="comment"># 返回数据集</span></span><br><span class="line">    <span class="keyword">return</span> samples</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaptchaData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_path, num_class=<span class="number">62</span>, num_char=<span class="number">4</span>, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 alphabet=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Dataset, self).__init__();</span><br><span class="line">        self.data_path = data_path</span><br><span class="line">        self.num_class = num_class</span><br><span class="line">        self.num_char = num_char</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line">        self.alphabet = alphabet</span><br><span class="line">        self.samples = make_dataset(self.data_path, self.alphabet,</span><br><span class="line">                                    self.num_class, self.num_char)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.samples)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        img_path, target = self.samples[index]</span><br><span class="line">        img = img_loader(img_path)</span><br><span class="line">        <span class="comment"># 如果有传入预处理函数，就预处理数据集</span></span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            target = self.target_transform(target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img, torch.Tensor(target)</span><br></pre></td></tr></table></figure>

<h2 id="构建CNN-model"><a href="#构建CNN-model" class="headerlink" title="构建CNN model"></a>构建CNN model</h2><p>接着，我们搭建一个CNN网络，这个网络不能太大，因为我们的标签向量本身很大，如果只是用自己机器训练的话，gpu内存可能不够用（全连接层的参数尤其多）。要查看gpu的占用，可以在任务管理器–性能–GPU1处实时监控专用GPU内存利用率（GPU0一般是处理器的而非显卡），如下图</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/GPU%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%9B%91%E6%8E%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="GPU内存占用监控示意图"></p>
<p>我最后选择了一个可以训练的模型，使用四层卷积和两层全连接层，每次卷积后使用一个2×2的最大池化，接着批归一化，最后使用ReLU激活函数。因为学校网址的验证码本身不是很复杂，训练后可以针对长度4和长度5的验证码都可以达到96%的准确率。</p>
<p>实际上，并不需要多高的准确率，因为try一次的时间甚至不到1秒钟（当然调整网络结构优化识别性能是一件很有趣的事情）。model.py的代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  model.py</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNN_sjtu</span>(nn.Module):<span class="comment">#4长度和5长度准确率都在96%左右，验证都是正确的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_class=<span class="number">36</span>, num_char=<span class="number">4</span>, width=<span class="number">100</span>, height=<span class="number">40</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(CNN_sjtu, self).__init__()</span><br><span class="line">        self.num_class = num_class</span><br><span class="line">        self.num_char = num_char</span><br><span class="line">        <span class="comment"># 卷积层后，全连接层的一维数组输入长度</span></span><br><span class="line">        <span class="comment"># 512是卷积处理后图片的通道数，长度和宽度各除以16是因为图像经过了四次2*2池化层（MaxPool2d）</span></span><br><span class="line">        self.line_size = <span class="built_in">int</span>(<span class="number">512</span> * (width // <span class="number">2</span> // <span class="number">2</span> // <span class="number">2</span> // <span class="number">2</span>) * (height // <span class="number">2</span> // <span class="number">2</span> // <span class="number">2</span> // <span class="number">2</span>))</span><br><span class="line">        self.conv1 = nn.Sequential(</span><br><span class="line">            <span class="comment"># 输入的是RGB图像，所以是3通道。</span></span><br><span class="line">            <span class="comment"># 这里设置该层有16个卷积核，所以输出是16通道</span></span><br><span class="line">            <span class="comment"># padding（1，1）表示在图像上下左右各加1行、1列，保证在卷积后图像大小不变</span></span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, <span class="number">3</span>, padding=(<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            <span class="comment"># 池化层，保留图像每2*2片段像素的最大值</span></span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="comment"># 对每个通道的图像都归一化，防止梯度爆炸</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            <span class="comment"># 激活函数</span></span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">16</span>, <span class="number">64</span>, <span class="number">3</span>, padding=(<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.conv3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">512</span>, <span class="number">3</span>, padding=(<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        self.conv4 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, <span class="number">3</span>, padding=(<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">            nn.ReLU()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 全连接层</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(self.line_size, self.line_size),</span><br><span class="line">            <span class="comment"># nn.Identity(),</span></span><br><span class="line">            <span class="comment"># 输出应为 验证码长度*字符的分类数</span></span><br><span class="line">            nn.Linear(self.line_size, self.num_char * self.num_class)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = self.conv4(x)</span><br><span class="line">        <span class="comment"># resize输入数组的尺寸，相当于flatten</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, self.line_size)</span><br><span class="line">        x = self.fc(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>训练代码如下，每一轮迭代都会保存模型参数到给定文件夹。最终观察表现最好的参数模型，手动删除其他不好的，并可以修改一下命名，以防之后重新训练覆盖了这个参数模型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#train.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> CaptchaData</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> Compose, ToTensor, Resize,Normalize</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> setting <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入设定参数</span></span><br><span class="line">alphabet=alphabet_sjtu</span><br><span class="line">width=width_sjtu</span><br><span class="line">height=height_sjtu</span><br><span class="line"></span><br><span class="line"><span class="comment">#  训练数据存放路径</span></span><br><span class="line">train_data_path=train_data_path_sjtu</span><br><span class="line"><span class="comment">#  测试数据存放路径</span></span><br><span class="line">test_data_path=test_data_path_sjtu</span><br><span class="line"><span class="comment">#  预测数据</span></span><br><span class="line">samples_path=samples_path_sjtu</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_path):</span><br><span class="line">    os.makedirs(model_path)</span><br><span class="line"></span><br><span class="line">device =torch.device(<span class="string">&quot;cuda&quot;</span>)<span class="comment">#设置gpu</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculat_acc</span>(<span class="params">output, target</span>):</span><br><span class="line">    output, target = output.view(-<span class="number">1</span>, <span class="built_in">len</span>(alphabet)), target.view(-<span class="number">1</span>, <span class="built_in">len</span>(alphabet)) <span class="comment">#字母有26个就是26列</span></span><br><span class="line">    output = nn.functional.softmax(output, dim=<span class="number">1</span>) <span class="comment">#缩放到0-1区间，所有元素和为1</span></span><br><span class="line">    output = torch.argmax(output, dim=<span class="number">1</span>)    <span class="comment">#返回每一列得分最高的索引值，说明预测的是这个位置的字母</span></span><br><span class="line">    target = torch.argmax(target, dim=<span class="number">1</span>)    <span class="comment">#然后dim=1这个维度会消失</span></span><br><span class="line">    output, target = output.view(-<span class="number">1</span>, <span class="built_in">int</span>(numchar)), target.view(-<span class="number">1</span>, <span class="built_in">int</span>(numchar))</span><br><span class="line">    correct_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(target, output):</span><br><span class="line">        <span class="keyword">if</span> torch.equal(i, j):   <span class="comment">#如果两个列表相等（相同大小和元素）</span></span><br><span class="line">            correct_list.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            correct_list.append(<span class="number">0</span>)</span><br><span class="line">    acc = <span class="built_in">sum</span>(correct_list) / <span class="built_in">len</span>(correct_list)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>():</span><br><span class="line">    <span class="comment"># 数据shape的预处理，缩放、转tensor，以及图像处理基本都要使用归一化</span></span><br><span class="line">    transforms = Compose([Resize((height, width)), ToTensor(),Normalize(<span class="number">0</span>, <span class="number">1</span>)])</span><br><span class="line">    <span class="comment"># 创建训练数据集对象</span></span><br><span class="line">    train_dataset = CaptchaData(train_data_path, num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), transform=transforms, alphabet=alphabet)</span><br><span class="line">    <span class="comment"># 初始化DataLoader，之后训练的数据由它按照我们的要求如batch_size等提供</span></span><br><span class="line">    train_data_loader = DataLoader(train_dataset, batch_size=batch_size, num_workers=num_workers,</span><br><span class="line">                                   shuffle=<span class="literal">True</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 创建测试数据集对象</span></span><br><span class="line">    test_dataset = CaptchaData(test_data_path, num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), transform=transforms, alphabet=alphabet)</span><br><span class="line">    test_data_loader = DataLoader(test_dataset, batch_size=batch_size,</span><br><span class="line">                                  num_workers=num_workers,drop_last=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;训练数据量：&quot;</span>,train_dataset.__len__(),<span class="string">&#x27;\t测试数据量：&#x27;</span>,test_dataset.__len__())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化模型</span></span><br><span class="line">    cnn = CNN_sjtu(num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), width=width, height=height)</span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        cnn=cnn.to(device)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">#----------------损失函数及优化方法---------------------</span></span><br><span class="line">    <span class="comment"># 使用Adam优化方法</span></span><br><span class="line">    optimizer = torch.optim.Adam(cnn.parameters(), lr=base_lr)</span><br><span class="line">    <span class="comment"># 使用多标签分类的损失函数</span></span><br><span class="line">    criterion = nn.MultiLabelSoftMarginLoss()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#----------------开始迭代训练-------------------------</span></span><br><span class="line">    <span class="comment"># 训练我们指定的epoch次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始训练...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(max_epoch):</span><br><span class="line">        start_ = time.time()</span><br><span class="line">        loss_history = []</span><br><span class="line">        acc_history = []</span><br><span class="line">        <span class="comment"># 切换到训练模式</span></span><br><span class="line">        cnn.train()</span><br><span class="line">        <span class="keyword">for</span> img, target <span class="keyword">in</span> train_data_loader:</span><br><span class="line">            <span class="keyword">if</span> use_gpu:</span><br><span class="line">                img = img.to(device)</span><br><span class="line">                target = target.to(device)</span><br><span class="line">            <span class="comment"># 获取神经网络的输出</span></span><br><span class="line">            output = cnn(img)</span><br><span class="line">            <span class="comment"># 计算损失函数</span></span><br><span class="line">            loss = criterion(output, target)</span><br><span class="line">            <span class="comment"># 初始化梯度</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            <span class="comment"># 反向传播计算梯度</span></span><br><span class="line">            loss.backward()</span><br><span class="line">            <span class="comment"># 优化参数</span></span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="comment"># 计算准确度</span></span><br><span class="line">            acc = calculat_acc(output, target)</span><br><span class="line">            acc_history.append(<span class="built_in">float</span>(acc))</span><br><span class="line">            loss_history.append(<span class="built_in">float</span>(loss))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#123;&#125;,train_loss: &#123;:.4&#125;|train_acc: &#123;:.4&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            epoch,</span><br><span class="line">            torch.mean(torch.Tensor(loss_history)),</span><br><span class="line">            torch.mean(torch.Tensor(acc_history)),</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            loss_history = []</span><br><span class="line">            acc_history = []</span><br><span class="line">            <span class="comment"># 切换到测试模式</span></span><br><span class="line">            cnn.<span class="built_in">eval</span>()</span><br><span class="line">            <span class="keyword">for</span> img, target <span class="keyword">in</span> test_data_loader:</span><br><span class="line">                <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                    img = img.to(device)</span><br><span class="line">                    target = target.to(device)</span><br><span class="line">                output = cnn(img)</span><br><span class="line"></span><br><span class="line">                acc = calculat_acc(output, target)</span><br><span class="line">                acc_history.append(<span class="built_in">float</span>(acc))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;test_loss: &#123;:.4&#125;|test_acc: &#123;:.4&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                torch.mean(torch.Tensor(loss_history)),</span><br><span class="line">                torch.mean(torch.Tensor(acc_history)),</span><br><span class="line">            ))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch: &#123;&#125;|time: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(epoch, time.time() - start_))</span><br><span class="line">        torch.save(cnn.state_dict(), os.path.join(model_path, <span class="string">&quot;model_&#123;&#125;.path&quot;</span>.<span class="built_in">format</span>(epoch)))<span class="comment">#每个epoch保存一次参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train()</span><br></pre></td></tr></table></figure>

<h2 id="模型效果测试"><a href="#模型效果测试" class="headerlink" title="模型效果测试"></a>模型效果测试</h2><p>最后我们可以看看我们模型的效果，下面是一些预测的示例。</p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B1.png" alt="验证码识别示例1"></p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B2.png" alt="验证码识别示例2"></p>
<p><img src="https://cdn.staticaly.com/gh/Chen-Jin-yuan/blogSources@master/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%A4%BA%E4%BE%8B3.png" alt="验证码识别示例3"></p>
<p>预测部分的代码如下，至此，整个模型训练部分就完成了，登录网站的部分见下一篇博客。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#predict.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> Compose, ToTensor, Resize,Normalize</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> setting <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------参数设定-------------</span></span><br><span class="line">model_net = CNN_sjtu()</span><br><span class="line">alphabet=alphabet_sjtu</span><br><span class="line">width=width_sjtu</span><br><span class="line">height=height_sjtu</span><br><span class="line">samples_path=samples_path_sjtu+<span class="string">&#x27;/4&#x27;</span></span><br><span class="line">numchar=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_net</span>():</span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="comment"># 初始化模型</span></span><br><span class="line">    model_net = CNN_sjtu(num_class=<span class="built_in">len</span>(alphabet), num_char=<span class="built_in">int</span>(numchar), width=width, height=height)</span><br><span class="line">    <span class="comment"># 读取参数模型</span></span><br><span class="line">    <span class="keyword">if</span> use_gpu:</span><br><span class="line">        model_net = model_net.cuda()</span><br><span class="line">        model_net.<span class="built_in">eval</span>()</span><br><span class="line">        model_net.load_state_dict(torch.load(<span class="string">&#x27;./weights/model_sjtu_4.path&#x27;</span>))    <span class="comment">#加载参数模型</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model_net.<span class="built_in">eval</span>()</span><br><span class="line">        model_net.load_state_dict(torch.load(model_path, map_location=<span class="string">&#x27;cpu&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测验证码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict_image</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="keyword">global</span> model_net</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        transforms = Compose([Resize((height, width)), ToTensor(),Normalize(<span class="number">0</span>, <span class="number">1</span>)]) <span class="comment">#图像变换</span></span><br><span class="line">        img = transforms(img)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> use_gpu:</span><br><span class="line">            img = img.view(<span class="number">1</span>, <span class="number">3</span>, height, width).cuda()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            img = img.view(<span class="number">1</span>, <span class="number">3</span>, height, width)</span><br><span class="line">        output = model_net(img) <span class="comment">#推理</span></span><br><span class="line"></span><br><span class="line">        output = output.view(-<span class="number">1</span>, <span class="built_in">len</span>(alphabet))</span><br><span class="line">        output = nn.functional.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = torch.argmax(output, dim=<span class="number">1</span>)</span><br><span class="line">        output = output.view(-<span class="number">1</span>, numchar)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([alphabet[i] <span class="keyword">for</span> i <span class="keyword">in</span> output.cpu().detach().numpy()])  <span class="comment">#转换成numpy类型需要先从gpu加载到cpu，然后可以获得字母表的索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    load_net()</span><br><span class="line">    <span class="comment"># 枚举数据所在文件夹</span></span><br><span class="line">    img_names = os.listdir(samples_path)</span><br><span class="line">    random.shuffle(img_names)</span><br><span class="line">    samples = []</span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_names:</span><br><span class="line">        <span class="comment"># 拼接每个数据的路径</span></span><br><span class="line">        img_path = os.path.join(samples_path, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        v_code = predict_image(img)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.title(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(v_code))</span><br><span class="line">        plt.imshow(img)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/05/10/zero/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/zero/" class="post-title-link" itemprop="url">Re：从零开始</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 13:35:37" itemprop="dateCreated datePublished" datetime="2022-05-10T13:35:37+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 22:45:14" itemprop="dateModified" datetime="2022-05-11T22:45:14+08:00">2022-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>​	这里是 <em>Jy</em> 的博客，会follow一些项目的过程，作为学习和记录，以及一些个人的学期总结和年度总结~</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>​	这里是我的GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/Chen-Jin-yuan">https://github.com/Chen-Jin-yuan</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
