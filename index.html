<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Re：从零开始的写博客生活">
<meta property="og:type" content="website">
<meta property="og:title" content="JySama">
<meta property="og:url" content="https://jysama.cn/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="Re：从零开始的写博客生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/28/websever%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/28/websever%E6%A8%A1%E5%9D%97%E5%8C%96%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">WebServer模块单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-28 19:49:06" itemprop="dateCreated datePublished" datetime="2022-09-28T19:49:06+08:00">2022-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-30 23:13:49" itemprop="dateModified" datetime="2022-09-30T23:13:49+08:00">2022-09-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看完了webserver的c++11（14）的写法并添加了大量注释后，也要开始自己手写一个了。整体的逻辑还没有研究透彻，虽然在写完注释后对思路已经挺清楚了，但是细节上还是很欠缺。</p>
<p>这一篇博客是为动手撸一个服务器而准备的，在这篇博客里，会动手写一些基本的模块，并进行正确性验证。</p>
<p>变量命名没有很规范，因为有时想随意一点，有时又觉得想认真点，(●’◡’●)</p>
<p>环境：ubuntu20.04，c++11及以上（14更好，c++11的话编译器会对lambda表达式按值捕获发出警告，尽管代码还是能正确运行）</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池是最简单的，就先从这入手。</p>
<p>考虑整体的思路：</p>
<ul>
<li>首先有一个池初始化若干个线程，每个线程配备一个运行的work函数，这个work函数要循环取任务去执行。</li>
<li>取任务就有个任务队列，在设计任务队列前，我们想一下任务的形式是什么，要传什么样的什么类型的任务进来。<ul>
<li>一种选择是传入一个类对象，然后调用类对象的一些工作处理函数，并且还能根据类对象的一些参数来进行不同的处理。</li>
<li>上面的方式也许是传统的c98的模式，它并不是那么的具有鲁棒性，因为尽管可以通过模板传入不同的类对象，但是类对象必须拥有一个处理函数。如果只是运行这些处理函数，为什么不直接传入一个函数进来呢，这样就可以执行任意的工作了。</li>
<li>c++11开始，std::function&lt;&gt;就提供了我们想要的功能，无论是函数指针还是函数对象等，都可以使用一个function对象保存然后传入。而那些细节处理交由上层，函数执行所需要的参数由std::bind来绑定给function对象，function本身不需要额外参数，更有灵活性。</li>
</ul>
</li>
<li>因此，我们的任务队列的元素就是std::function。然后，在取队列元素时和加入队列元素时，都需要互斥。队列是一个无界生产者，当队列大小为0时，一般用一个信号量阻塞即可，但我们也知道可以用条件变量来完成这件事，因此这里会用条件变量。<ul>
<li>在取任务时，首先互斥锁住（判断是否非空前就要锁），然后如果队列非空就取一个任务，解锁，执行任务。如果没有任务，就阻塞，这里用条件变量阻塞。因为要锁和解锁以及给条件变量使用，所以用unique_lock好，但unique_lock不要写在while内，这样会重复定义。</li>
</ul>
</li>
<li>这里先不考虑左值右值，因为本身项目中就不需要用到，从理论上讲考虑的话就更灵活，但没有实例还是不好理解，就先不用了。</li>
</ul>
<p>现在，我们可以开始写代码了，这里提一下头文件（注意标准库一般都是std命名空间）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mutex&gt;:互斥锁等</span><br><span class="line">&lt;thread&gt;:线程</span><br><span class="line">&lt;condition_variable&gt;:条件变量</span><br><span class="line">&lt;functional&gt;:std::function</span><br><span class="line">&lt;queue&gt;:队列</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">    std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([&amp;]&#123;<span class="comment">//lambda表达式，按引用捕获变量（确保同一地址），无参数无返回值</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>上面的版本基本上已经写好了一个线程池，但还有析构函数没有写。析构函数要析构什么呢，这里好像并没有要手动释放的东西——没有手动使用堆空间，不需要delete。但别忘了，我们的线程是分离的，这里没有去join回收，线程使用的全局变量会产生所谓的detch陷进。</p>
<p>当进程要退出时，不会再添加任务了，我们更希望线程把这些已有任务都做完再退出，但是主进程退出了会把队列、互斥锁、条件变量都析构掉，使得线程调用这些资源会出错，这就是detch()带来的陷进。在讨论解决方案前，我们再想想为什么要使用detch()：其实就是为了把已有的任务都做完。</p>
<p>为了做完这些任务，我们就得把线程访问的资源放在堆空间上，这样才不会在进程退出时析构掉资源。因为每个线程都访问这三个资源，因此再用一个结构体封装，线程捕获结构体指针就可以了。为了控制堆上的资源，我们还可以使用共享指针（共享很显然，因为这些线程用的是同一个）。</p>
<ul>
<li>创建共享指针的方式有两种，一种是用new，一种是用make_shared函数。尽量使用make_shared，因为new本质上会分配两次内存，一个是new的对象，一个是shared_ptr本身new的计数器（控制块）。而使用make_shared申请一个单独的内存块来存放对象和控制块，更高效，且因为没有顺序是同一时间开辟空间的，具有异常安全。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/03eea8262c11">C++11 make_shared - 简书 (jianshu.com)</a></li>
<li>使用make_shared函数要显式指出类型，因为返回值是<code>shared_ptr&lt;T&gt;</code>，返回值类型无法推导，要<code>make_shared&lt;T&gt;</code>指出。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改良版threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pool</span><span class="comment">//封装三个资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">        std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;pool&gt; pool_;<span class="comment">//共享指针，pool_是一个指针指向pool结构体，这个指针用于线程池操作资源</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>):<span class="built_in">pool_</span>(std::<span class="built_in">make_shared</span>&lt;pool&gt;())<span class="comment">//以make_shared的方式new一个对象给pool_指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([<span class="type">pool_t</span> = pool_]&#123;<span class="comment">//现在要按值捕获，相当于拷贝构造共享指针，计数+1，且指向相同内容</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(<span class="type">pool_t</span>-&gt;mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         <span class="type">pool_t</span>-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        pool_-&gt;taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>现在，我们已经解决了detch陷进，只要线程执行完任务，我们就退出线程，那么我们的析构函数只需要传递一个信号，让线程得知主进程已经退出了，线程根据信号作出反应即可。注意，因为线程要把工作做完再退出，所以优先级是!empty()，如果没有任务，我们是先看要不要退出，再进行等待，所以在if-else中插入一个else if判断即可。</p>
<p>注意，线程有可能卡在条件变量的wait处，所以析构函数还要唤醒所有的线程，让它们处理任务（如果有）并退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终版threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span><span class="comment">//使用assert函数</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pool</span><span class="comment">//封装三个资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;<span class="comment">//互斥锁</span></span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; taskQueue;<span class="comment">//任务队列，无参数的function，调用时不用传参</span></span><br><span class="line">        std::condition_variable cond;<span class="comment">//条件变量</span></span><br><span class="line">        <span class="type">bool</span> isclose = <span class="literal">false</span>;<span class="comment">//默认值是false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;pool&gt; pool_;<span class="comment">//共享指针，pool_是一个指针指向pool结构体，这个指针用于线程池操作资源</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> threadnum = <span class="number">8</span>):<span class="built_in">pool_</span>(std::<span class="built_in">make_shared</span>&lt;pool&gt;())<span class="comment">//以make_shared的方式new一个对象给pool_指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(threadnum &gt; <span class="number">0</span>);<span class="comment">//没有线程就报错</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;threadnum;i++)<span class="comment">//创建线程池</span></span><br><span class="line">    		std::<span class="built_in">thread</span>([<span class="type">pool_t</span> = pool_]&#123;<span class="comment">//现在要按值捕获，相当于拷贝构造共享指针，计数+1，且指向相同内容</span></span><br><span class="line">    			std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(<span class="type">pool_t</span>-&gt;mtx);<span class="comment">//定义一个locker对象，现在已经锁住了</span></span><br><span class="line">                 <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="keyword">if</span>(!<span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">empty</span>())<span class="comment">//如果有任务</span></span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="keyword">auto</span> task = <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">front</span>();</span><br><span class="line">                         <span class="type">pool_t</span>-&gt;taskQueue.<span class="built_in">pop</span>();</span><br><span class="line">                         locker.<span class="built_in">unlock</span>();</span><br><span class="line">                       	 <span class="comment">//解锁后再执行</span></span><br><span class="line">                         <span class="built_in">task</span>();</span><br><span class="line">                         <span class="comment">//执行完了，进入下一轮循环，注意要锁住</span></span><br><span class="line">                         locker.<span class="built_in">lock</span>();<span class="comment">//抢占锁</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">pool_t</span>-&gt;isclose)</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">else</span><span class="comment">//如果没有任务</span></span><br><span class="line">                         <span class="type">pool_t</span>-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//解锁并等待，唤醒后会抢占互斥锁</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;).<span class="built_in">detach</span>();<span class="comment">//把thread分离，不用手动join，结束自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; task)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;<span class="comment">//定义一个locker对象</span></span><br><span class="line">        pool_-&gt;taskQueue.<span class="built_in">emplace</span>(task);<span class="comment">//这种方式，使用emplace和push没啥区别，task本身就是临时对象</span></span><br><span class="line">        <span class="comment">//如果要真正使用到emplace调用构造函数，还要配合std::forward完美转发，此时无论构造函数是不是explicit（不能隐式转换），都可以正常工作</span></span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//插入一个元素唤醒一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">threadpool</span>()<span class="comment">//析构函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        pool_-&gt;isclose = <span class="literal">true</span>;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>以上基本就大功告成了，现在，我们来写一个test函数。</p>
<p>为了确认线程是否正确退出，我们在else if那打印退出信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">pool_t</span>-&gt;isclose)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;thread exit!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test_threadpool.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span><span class="comment">//使用sleep</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostraem&gt;</span><span class="comment">//cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//pthread_exit</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is [&quot;</span>&lt;&lt;id&lt;&lt;<span class="string">&quot;] task&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(id);<span class="comment">//睡眠id秒</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;id&lt;&lt;<span class="string">&quot;] task quit！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">threadpool <span class="title">threadp</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//十个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    	threadp.<span class="built_in">addTask</span>(<span class="built_in">bind</span>(task,i));<span class="comment">//bind 绑定task函数，并赋参数i，返回一个function对象</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//告知系统不用回收进程所有资源，等待子线程退出</span></span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不能直接return！会把所有线程都回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意std::thread内部调用了pthread，linux不一定把pthread作为默认库，所以编译时候要链接，编译的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++14 -o test_threadpool test_threadpool.cpp -lpthread</span><br></pre></td></tr></table></figure>

<p>再者，当主进程return后，即使子线程是detch的，也会被系统回收资源。在 《UNIX 网络编程》卷一 第 537 页，有这么一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果进程的main函数返回或者任何线程调用了 exit， 整个进程就终止，其中包括它的任何线程。</span><br></pre></td></tr></table></figure>

<p>程序return，间接调用了exit()函数，因为一个线程调用exit函数，导致整个进程的退出。要想系统并不回收进程的所有资源，可以调用pthread_exit()；然后等其他线程终止退出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行结果，数一下线程有没有正常退出</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test$ g++ -std=c++<span class="number">14</span> -o test_threadpool test_threadpool.cpp -lpthread</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test$ ./test_threadpool</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">5</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">6</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">7</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">8</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">9</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">10</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">11</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">12</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">13</span>] task</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">14</span>] task</span><br><span class="line">[<span class="number">5</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">15</span>] task</span><br><span class="line">[<span class="number">6</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">16</span>] task</span><br><span class="line">[<span class="number">7</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">17</span>] task</span><br><span class="line">[<span class="number">8</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">18</span>] task</span><br><span class="line">[<span class="number">9</span>] task quit！</span><br><span class="line"><span class="keyword">this</span> is [<span class="number">19</span>] task</span><br><span class="line">[<span class="number">10</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//1</span></span><br><span class="line">[<span class="number">11</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//2</span></span><br><span class="line">[<span class="number">12</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//3</span></span><br><span class="line">[<span class="number">13</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//4</span></span><br><span class="line">[<span class="number">14</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//5</span></span><br><span class="line">[<span class="number">15</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//6</span></span><br><span class="line">[<span class="number">16</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//7</span></span><br><span class="line">[<span class="number">17</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//8</span></span><br><span class="line">[<span class="number">18</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//9</span></span><br><span class="line">[<span class="number">19</span>] task quit！</span><br><span class="line">thread exit!	<span class="comment">//10</span></span><br><span class="line"><span class="comment">//test成功</span></span><br></pre></td></tr></table></figure>

<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>这一块比较复杂，分解知识点，一点点细学。</p>
<h2 id="时间类chrono"><a href="#时间类chrono" class="headerlink" title="时间类chrono"></a>时间类chrono</h2><p>这个在日志系统用了一点，不过也可以用来输出时间，就在这里学习了。</p>
<h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔，duration的原型是：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt; <span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">//第一个模板参数Rep是一个数值类型，表示时钟个数；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</span></span><br><span class="line"><span class="keyword">template</span>&lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Denom = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<p>ratio表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如ratio&lt;2&gt;代表一个时钟周期是两秒，ratio&lt;60&gt;代表了一分钟，ratio&lt;60*60&gt;代表一个小时，ratio&lt;60*60*24&gt;代表一天。而ratio&lt;1, 1000&gt;代表的则是1&#x2F;1000秒即一毫秒，ratio&lt;1, 1000000&gt;代表一微秒，ratio&lt;1, 1000000000&gt;代表一纳秒。标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">3600</span>,<span class="number">1</span>&gt;&gt; hours;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt; minutes;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt; seconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000</span>&gt;&gt; milliseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000000</span>&gt;&gt; microseconds;</span><br><span class="line"><span class="keyword">typedef</span> duration &lt;Rep, ratio&lt;<span class="number">1</span>,<span class="number">1000000000</span>&gt;&gt; nanoseconds;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠：</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">//休眠三秒</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono:: <span class="built_in">milliseconds</span> (<span class="number">100</span>)); <span class="comment">//休眠100毫秒</span></span><br></pre></td></tr></table></figure>

<p> chrono还提供了获取时间间隔的时钟周期个数的方法count() ，count()返回的间隔要向0取整，可以为负数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::milliseconds ms&#123;<span class="number">3</span>&#125;; <span class="comment">// 3 毫秒</span></span><br><span class="line">    <span class="comment">// 6000 microseconds constructed from 3 milliseconds</span></span><br><span class="line">    std::chrono::microseconds us = <span class="number">2</span>*ms; <span class="comment">//6000微秒</span></span><br><span class="line">    <span class="comment">// 30Hz clock using fractional ticks</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">30</span>&gt;&gt; <span class="built_in">hz30</span>(<span class="number">3.5</span>);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;3 ms duration has &quot;</span> &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span>&lt;&lt;  <span class="string">&quot;6000 us duration has &quot;</span> &lt;&lt; us.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ticks\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> ms duration has <span class="number">3</span> ticks</span><br><span class="line"><span class="number">6000</span> us duration has <span class="number">6000</span> ticks</span><br></pre></td></tr></table></figure>

<p>时间间隔之间可以做运算，比如下面的例子中计算两端时间间隔的差值： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//都是duration类型</span></span><br><span class="line">std::<span class="function">chrono::minutes <span class="title">t1</span><span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">std::<span class="function">chrono::seconds <span class="title">t2</span><span class="params">( <span class="number">60</span> )</span></span>;</span><br><span class="line">std::chrono::seconds t3 = t1 - t2;</span><br><span class="line">std::cout &lt;&lt; t3.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; second&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>其中，t1 是代表 10 分钟、t2 是代表 60 秒，t3 则是 t1 減去 t2，也就是 600 - 60 &#x3D; 540 秒。通过t1-t2的count输出差值为540个时钟周期即540秒（因为每个时钟周期为一秒）。</p>
<p>还可以通过**duration_cast&lt;&gt;()**来将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; chrono::<span class="built_in">duration_cast</span>&lt;chrono::minutes&gt;( t3 ).<span class="built_in">count</span>() &lt;&lt;” minutes”&lt;&lt; endl;</span><br><span class="line">将会输出:</span><br><span class="line"><span class="number">9</span> minutes</span><br></pre></td></tr></table></figure>

<p>使用转型后，数值就不一定是整数个tick()了，比如t2&#x3D;30s时，转型后就是9分半，这时使用count()会向下取整，只取到9。</p>
<h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p>谈到时间，总需要找一个时钟作为参照。clock就是这个时钟，在计算机中一般都会有一套或多套时钟系统供程序使用。在std::chrono库中，有3种时钟：</p>
<ul>
<li>system_clock</li>
<li>steady_clock</li>
<li>hight_definition_clock</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">system_clock</span></span><br><span class="line">&#123;	<span class="comment">// wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> rep;</span><br><span class="line"><span class="keyword">typedef</span> ratio_multiply&lt;ratio&lt;_XTIME_NSECS_PER_TICK, <span class="number">1</span>&gt;, nano&gt; period;</span><br><span class="line"><span class="keyword">typedef</span> chrono::duration&lt;rep, period&gt; duration;</span><br><span class="line"><span class="keyword">typedef</span> chrono::time_point&lt;system_clock&gt; time_point;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> is_steady = <span class="literal">false</span>;<span class="comment">//steady_clock是true</span></span><br><span class="line"><span class="comment">//函数定义，注意都是静态成员函数，使用时用system_clock::func()调用</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，他们3个没有太大的区别，hight_definition_clock、steady_clock仅仅是system_clock的typedef，但是有为什么要区分呢，因为在有些情况下，他们是存在差异的。</p>
<ul>
<li>情况1：system_clock和steady_clock的差异<ul>
<li>比如windows系统可以提供时钟，如果认为时间不准，我们还可以进行调整。在没有调整时间前，system_clock和steady_clck是一样的，他们的读数都是单调匀速增加的；但是如果调整时间后，它们两者的读数就会出现差异，system_clock的读数就会出现跳变，而steady_clock依然保持线性单调递增，不受clock调整的影响，这个特点非常方便我们统计时间耗时（duration）。</li>
</ul>
</li>
<li>情况2：system_clock与hight_definition_clock的差异<ul>
<li>如果系统提供的时钟（clock）不止一种，有的时钟精度高（分辨率），有的精度低，hight_definition_clock使用时精度最高的clock，但是system_clock就不一定了。</li>
</ul>
</li>
</ul>
<p>clock主要用于获取当前的时间，通过now()方法获取，返回一个time_point，方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::system_clock::time_point current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>

<p>还有两个函数方法：to_time_t()：参数是time_point，转换到time_t；from_time_t()：从time_t转换过来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system_clock example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::chrono::duration&lt;<span class="type">int</span>, std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; <span class="built_in">one_day</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据时钟得到现在时间</span></span><br><span class="line">    std::chrono::system_clock::time_point today = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="type">time_t</span> time_t_today = std::chrono::system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;now time stamp is &quot;</span> &lt;&lt; time_t_today &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;now time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_today) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看明天的时间，time_point支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减</span></span><br><span class="line">    std::chrono::system_clock::time_point tomorrow = today + one_day;</span><br><span class="line">    std::<span class="type">time_t</span> time_t_tomorrow = std::chrono::system_clock::<span class="built_in">to_time_t</span>(tomorrow);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time stamp is &quot;</span> &lt;&lt; time_t_tomorrow &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_tomorrow) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下个小时时间</span></span><br><span class="line">    std::chrono::system_clock::time_point next_hour = today + std::chrono::<span class="built_in">hours</span>(<span class="number">1</span>);</span><br><span class="line">    std::<span class="type">time_t</span> time_t_next_hour = std::chrono::system_clock::<span class="built_in">to_time_t</span>(next_hour);</span><br><span class="line">    std::chrono::system_clock::time_point next_hour2 = std::chrono::system_clock::<span class="built_in">from_time_t</span>(time_t_next_hour);</span><br><span class="line"></span><br><span class="line">    std::<span class="type">time_t</span> time_t_next_hour2 = std::chrono::system_clock::<span class="built_in">to_time_t</span>(next_hour2);</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time stamp is &quot;</span> &lt;&lt; time_t_next_hour2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt;  <span class="string">&quot;tomorrow time is &quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;time_t_next_hour2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">now time stamp is <span class="number">1586662332</span></span><br><span class="line">now time is Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586748732</span></span><br><span class="line">tomorrow time is Mon Apr <span class="number">13</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586665932</span></span><br><span class="line">tomorrow time is Sun Apr <span class="number">12</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>

<h3 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h3><p>time_point是具体的时间，比如某年某月某日几点几分几秒，time_point依赖于clock的计时，可以用clock内部定义的time_point，也可以用自己定义的time_point。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个模板是时钟类型clock，一个是计时间隔duration</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;  <span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure>

<p>time_point有一个函数time_from_epoch()用来获得1970年1月1日到time_point时间经过的duration。举个例子，如果timepoint以天为单位，函数返回的duration就以天为单位。</p>
<p>由于各种time_point表示方式不同，chrono也提供了相应的转换函数 time_point_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ToDuration</span>, <span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span>&gt;</span><br><span class="line"><span class="function">time_point&lt;Clock,ToDuration&gt; <span class="title">time_point_cast</span> <span class="params">(<span class="type">const</span> time_point&lt;Clock,Duration&gt;&amp; tp)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算当前时间距离1970年1月一日有多少天:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">  <span class="keyword">typedef</span> duration&lt;<span class="type">int</span>,std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; days_type;</span><br><span class="line">  <span class="comment">//now获取后返回的是system_clock类的timepoint类型，转型为天，给用户定义的timepoint</span></span><br><span class="line">  time_point&lt;system_clock,days_type&gt; today = <span class="built_in">time_point_cast</span>&lt;days_type&gt;(system_clock::<span class="built_in">now</span>());</span><br><span class="line">  <span class="comment">//调用epoch获得duration，调用count()计数</span></span><br><span class="line">  std::cout &lt;&lt; today.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; days since epoch&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这部分主要是三种类型穿插，让人比较迷糊。一般的用法就是：</p>
<ul>
<li>使用一个时钟的time_point，通过now()方法获取</li>
<li>要想直接输出就把获取的time_point通过to_time_t()转换后输出，这里还可以进一步用ctime函数格式化（返回char*）。注意time_point不能直接输出。</li>
<li>如果要继续处理，有两种运算方式<ul>
<li>定义duration，与time_point进行运算（一般是求和），运算后又是一个time_point，time_point之间本身可以大小比较</li>
<li>time_point之间作差，返回一个duration，可以用duration_cast转换类型，调用count()计算有多少tick。如果不转类型，system_clock的time_point一般是纳秒，用count的话很大。</li>
</ul>
</li>
</ul>
<h3 id="test-1"><a href="#test-1" class="headerlink" title="test"></a>test</h3><p>主要实现几个实例吧：</p>
<ul>
<li>实现时间格式化输出：<ul>
<li>当前时间</li>
<li>两小时后</li>
<li>两天后</li>
</ul>
</li>
<li>实现时间点大小比较</li>
<li>实现时间点运算count。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间类demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printft</span><span class="params">(chrono::system_clock::time_point time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> tt = chrono::system_clock::<span class="built_in">to_time_t</span>(time);</span><br><span class="line">    <span class="comment">//timepoint不能直接输出</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;timepoint&quot;&lt;&lt; time &lt;&lt;endl &lt;&lt; &quot;time:&quot; &lt;&lt; tt &lt;&lt;endl &lt;&lt; &quot;ctime:&quot;&lt;&lt;ctime(&amp;tt)&lt;&lt;endl&lt;&lt;endl;</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;time:&quot;</span> &lt;&lt; tt &lt;&lt;endl &lt;&lt; <span class="string">&quot;ctime:&quot;</span>&lt;&lt;<span class="built_in">ctime</span>(&amp;tt)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//now</span></span><br><span class="line">    chrono::system_clock::time_point nowtime = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------now time----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(nowtime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义duration</span></span><br><span class="line">    <span class="function">chrono::hours <span class="title">twoh</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    chrono::time_point&lt;chrono::system_clock&gt; twohtime = nowtime+twoh;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------two hours after----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(twohtime);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义一天的间隔，一天的秒数是60*60*24</span></span><br><span class="line">    <span class="keyword">typedef</span> chrono::duration&lt;<span class="type">int</span>, std::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; day;</span><br><span class="line">    <span class="function">day <span class="title">twod</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    chrono::time_point&lt;chrono::system_clock&gt; twodtime = nowtime+twod;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------two days after----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">printft</span>(twodtime);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------time_point之间比较大小----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = (twodtime&gt;nowtime)?<span class="string">&quot;大&quot;</span> : <span class="string">&quot;小&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;两天后时间比两天前要&quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------timepoint之间作差转型查看时间点间隔tick----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;两天后和两天前间隔 &quot;</span>&lt;&lt;chrono::<span class="built_in">duration_cast</span>&lt;chrono::hours&gt;(twodtime-nowtime).<span class="built_in">count</span>()&lt;&lt;<span class="string">&quot; 小时&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;system_clock time_point不转换类型tick：&quot;</span>&lt;&lt;(twodtime-nowtime).<span class="built_in">count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译命令</span></span><br><span class="line">g++ -std=c++<span class="number">14</span> -o chrono_test chrono_test.cpp</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/chrono_test$ ./chrono_test</span><br><span class="line">--------------now time----------------------</span><br><span class="line">time:<span class="number">1664526100</span></span><br><span class="line">ctime:Fri Sep <span class="number">30</span> <span class="number">01</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------two hours after----------------------</span><br><span class="line">time:<span class="number">1664533300</span></span><br><span class="line">ctime:Fri Sep <span class="number">30</span> <span class="number">03</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------two days after----------------------</span><br><span class="line">time:<span class="number">1664698900</span></span><br><span class="line">ctime:Sun Oct  <span class="number">2</span> <span class="number">01</span>:<span class="number">21</span>:<span class="number">40</span> <span class="number">2022</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------time_point之间比较大小----------------------</span><br><span class="line">两天后时间比两天前要大</span><br><span class="line">--------------timepoint之间作差转型查看时间点间隔tick----------------------</span><br><span class="line">两天后和两天前间隔 <span class="number">48</span> 小时</span><br><span class="line">system_clock time_point不转换类型tick：<span class="number">172800000000000</span><span class="comment">//这里可以看出是纳秒</span></span><br></pre></td></tr></table></figure>

<h2 id="可变参宏va-list"><a href="#可变参宏va-list" class="headerlink" title="可变参宏va_list"></a>可变参宏va_list</h2><h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>在无法给出所有传递给函数的参数的类型和数目时，可以使用省略号（…）指定函数参数表。有如下几种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b, ...)</span></span>; <span class="comment">//给出确定的几个参数，其他用省略号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a ...)</span></span>;            <span class="comment">//省略号前有或者没有逗号都是可以的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(...)</span></span>;                  <span class="comment">//也可以不确定任何参数，但和没有参数是不一样的</span></span><br></pre></td></tr></table></figure>

<p>最典型的应用就是printf函数，printf的声明和调用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *format [,argument]... )</span></span>;    <span class="comment">//官方声明</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My name is %s, age %d.&quot;</span>, <span class="string">&quot;AnnieKim&quot;</span>, <span class="number">24</span>);   <span class="comment">//调用</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，第一个参数是必不可少的，因为它可以得到函数参数的地址入口，这样就可以取之后的参数。</p>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">可变参数是由宏实现的，但是由于硬件平台的不同，编译器的不同，宏的定义也不相同</span><br><span class="line">头文件&lt;stdarg.h&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * va_list;     <span class="comment">// TC中定义为void*</span></span><br><span class="line"><span class="comment">//为了满足需要内存对齐的系统</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n)    ((sizeof(n)+sizeof(int)-1)&amp;~(sizeof(int) - 1) ) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ap指向第一个变参的位置，即将第一个变参的地址赋予ap</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap,v)    ( ap = (va_list)&amp;v + _INTSIZEOF(v) )</span></span><br><span class="line"><span class="comment">/*获取变参的具体内容，t为变参的类型，如有多个参数，则通过移动ap的指针来获得变参的地址，从而获得内容*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap,t)       ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )   </span></span><br><span class="line"><span class="comment">//清空va_list，即结束变参的获取</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) ( ap = (va_list)0 )   </span></span><br></pre></td></tr></table></figure>

<p>基本使用步骤：</p>
<ul>
<li>定义一个va_list类型的变量，变量是指向参数的指针。</li>
<li>va_start初始化刚定义的变量，第二个参数是<strong>最后一个</strong>显式声明的参数。</li>
<li>va_arg返回变长参数的值，第二个参数是该变长参数的<strong>类型</strong>。</li>
<li>va_end将第一步定义的va_list变量重置为NULL。</li>
</ul>
<p>注意问题：</p>
<p>（1）可变参数的类型和个数完全由程序代码控制,它并不能智能地识别不同参数的个数和类型；</p>
<p>（2）如果我们不需要一一详解每个参数，只需要将可变列表拷贝至某个缓冲，可用vsprintf函数；</p>
<p>（3）因为编译器对可变参数的函数的原型检查不够严格,对编程查错不利.不利于我们写出高质量的代码；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C 库函数 int vsprintf(char *str, const char *format, va_list arg) 使用参数列表发送格式化输出到字符串。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list arg)</span></span></span><br><span class="line"><span class="function"><span class="comment">//即把参数列表中遍历到的一个一个参数，根据format格式写到str里。</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">//例子</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">char</span> buffer[80]</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vspfunc</span><span class="params">(<span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   va_list aptr;</span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">va_start</span>(aptr, format);</span><br><span class="line">   ret = <span class="built_in">vsprintf</span>(buffer, format, aptr);</span><br><span class="line">   <span class="built_in">va_end</span>(aptr);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">   <span class="type">float</span> f = <span class="number">27.0</span>;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">50</span>] = <span class="string">&quot;runoob.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">vspfunc</span>(<span class="string">&quot;%d %f %s&quot;</span>, i, f, str);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">5</span> <span class="number">27.000000</span> runoob.com</span><br></pre></td></tr></table></figure>

<p>还有vsnprintf，多了个size，size说明了str最多可写的字节，防止越界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="test-2"><a href="#test-2" class="headerlink" title="test"></a>test</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试va_arg，va_arg不会自动结束，不会有=&quot;&quot;返回</span></span><br><span class="line"><span class="comment">/*错误代码，va_arg读完还读下去会内存错误</span></span><br><span class="line"><span class="comment">void valist(const char* str1,...)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    va_list vaList;</span></span><br><span class="line"><span class="comment">    va_start(vaList,str1);</span></span><br><span class="line"><span class="comment">    std::string str;</span></span><br><span class="line"><span class="comment">    while((str = va_arg(vaList,const char*))!=&quot;&quot;)</span></span><br><span class="line"><span class="comment">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">    va_end(vaList);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遵循古老的传统，要么加个结束元判断结束，要么让第一个参数指明参数个数手动结束</span></span><br><span class="line"><span class="comment">//加结束元</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valist1</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,str1);</span><br><span class="line">    std::string str = str1;<span class="comment">//va_arg从str1的下一个参数开始，str1这个参数自己获取</span></span><br><span class="line">    <span class="keyword">while</span>(str!=<span class="string">&quot;break&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">        str = <span class="built_in">va_arg</span>(vaList, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//获取下一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//结束     </span></span><br><span class="line">   <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">valist2</span><span class="params">(<span class="type">int</span> arglen ,<span class="type">const</span> <span class="type">char</span>* str1,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,str1);</span><br><span class="line">    std::string str = str1;<span class="comment">//va_arg从str1的下一个参数开始，str1这个参数自己获取</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arglen;i++)<span class="comment">//i=1开始是因为第一个已经获取</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;str&lt;&lt;std::endl;</span><br><span class="line">        str = <span class="built_in">va_arg</span>(vaList, <span class="type">const</span> <span class="type">char</span>*);<span class="comment">//获取下一个参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;str&lt;&lt;std::endl;<span class="comment">//这里要多打印一次，因为最后一次取到参数没打印就退出了</span></span><br><span class="line">   <span class="comment">//结束     </span></span><br><span class="line">   <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">valist1</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;myfriend&quot;</span>,<span class="string">&quot;nihaoya&quot;</span>,<span class="string">&quot;break&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">valist2</span>(<span class="number">5</span>,<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;wish you&quot;</span>,<span class="string">&quot;happy&quot;</span>,<span class="string">&quot;health&quot;</span>,<span class="string">&quot;every day&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行情况</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ g++ -std=c++<span class="number">14</span> -o valist_test valist_test.cpp</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ ./valist_test</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">myfriend</span><br><span class="line">nihaoya</span><br><span class="line"></span><br><span class="line">hi</span><br><span class="line">wish you</span><br><span class="line">happy</span><br><span class="line">health</span><br><span class="line">every day</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vsprintf使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vsptest</span><span class="params">(<span class="type">char</span>* buffer,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="comment">//解析format这个格式，把后面的参数按照格式填入，格式中暗示了参数的类型</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(buffer,format,vaList);</span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vsnptest</span><span class="params">(<span class="type">char</span>* buffer,<span class="type">size_t</span> size,<span class="type">const</span> <span class="type">char</span>* format,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list vaList;</span><br><span class="line">    <span class="built_in">va_start</span>(vaList,format);</span><br><span class="line">    <span class="comment">//解析format这个格式，把后面的参数按照格式填入，格式中暗示了参数的类型</span></span><br><span class="line">    <span class="built_in">vsnprintf</span>(buffer,size,format,vaList);<span class="comment">//测试一下这个size，看看会怎么样</span></span><br><span class="line">    <span class="built_in">va_end</span>(vaList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsprintf-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer1[<span class="number">50</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *format1 = <span class="string">&quot;%s is %d years old, %s&quot;</span>;</span><br><span class="line">    <span class="built_in">vsptest</span>(buffer1,format1,<span class="string">&quot;jy&quot;</span>,<span class="number">20</span>,<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">    std::cout&lt;&lt;buffer1&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsnprintf-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer2[<span class="number">50</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *format2 = <span class="string">&quot;%s is %d years old, %s&quot;</span>;</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer2,<span class="number">10</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//只有10的size</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;只有10的buffer size： &quot;</span>&lt;&lt;buffer2&lt;&lt;std::endl;</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer2,<span class="number">50</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//50</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;拥有50的buffer size： &quot;</span>&lt;&lt;buffer2&lt;&lt;std::endl&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果size超出了buffer的大小会怎么样呢</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;----------测试vsnprintf，并且size超出了buffer的大小-------------&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">char</span> buffer3[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">vsnptest</span>(buffer3,<span class="number">50</span>,format2,<span class="string">&quot;xuepi&quot;</span>,<span class="number">20</span>,<span class="string">&quot;nice!&quot;</span>);<span class="comment">//有50的size</span></span><br><span class="line">    std::cout&lt;&lt;buffer3&lt;&lt;std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ g++ -std=c++<span class="number">14</span> -o vstest  vstest.cpp</span><br><span class="line">sun2@ubuntu:~/Desktop/websever_test/valist$ ./vstest</span><br><span class="line">----------测试vsprintf-------------</span><br><span class="line">jy is <span class="number">20</span> years old, good!</span><br><span class="line"></span><br><span class="line">----------测试vsnprintf-------------</span><br><span class="line">只有<span class="number">10</span>的buffer size： xuepi is </span><br><span class="line">拥有<span class="number">50</span>的buffer size： xuepi is <span class="number">20</span> years old, nice!</span><br><span class="line"></span><br><span class="line">----------测试vsnprintf，并且size超出了buffer的大小-------------</span><br><span class="line">xuepi is <span class="number">20</span> years old, nice!</span><br><span class="line"><span class="comment">//可以看出即使超出了buffer的size也不会报错，而是继续向buffer拷贝，打印时因为首地址的关系会全打印出来</span></span><br><span class="line"><span class="comment">//这个size参数是给vsnprintf的，告诉它最多写多少进buffer，可以与buffer本身的大小无关，但一般会关联到buffer的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>四部曲，其中va_arg和vsprintf互相替换，看要哪个。va_arg就只能传一样的参数类型，可以做运算，vsprintf可以传不同的类型但是最后要写入一个char*的buffer。</p>
<p>也可以两个同时用，取完va_arg的参数，剩下的给vsprintf。</p>
<p>vsprintf和vsnprintf返回写入的字节数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/21/websever-c++11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/websever-c++11/" class="post-title-link" itemprop="url">TinyWebServer-C++11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-21 09:56:36" itemprop="dateCreated datePublished" datetime="2022-09-21T09:56:36+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-26 15:23:39" itemprop="dateModified" datetime="2022-09-26T15:23:39+08:00">2022-09-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天follow完了tinywebsever的项目，分析了很多代码，最后也能跑起来。不过感觉整体的代码框架有些杂乱，代码也有冗余、不清晰的地方，比如互斥锁在c++11已经有专门的实现，不需要自己实现了。</p>
<p>作者也推荐了另一个c++11写的更简洁更优雅的项目实现：<a target="_blank" rel="noopener" href="https://github.com/markparticle/WebServer">markparticle&#x2F;WebServer: C++ Linux WebServer服务器 (github.com)</a></p>
<p>上一个项目最大的好处是作者专门写了一系列分析的文章，而这个项目没有教程也没什么注释，因此打算再写篇博客分析一下代码，写下注释，更重要的是把代码框架、逻辑理清楚，以及看看c++11实现的方便之处。</p>
<hr>
<p>另外，在这里说一下size_t，很多c系的程序员对这个类型用的比较少，但这个项目里经常出现。</p>
<p>可以参考下：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24773728">(24 封私信 &#x2F; 80 条消息) size_t 这个类型的意义是什么？ - 知乎 (zhihu.com)</a>。</p>
<p>主要还是为了可移植性，不同平台对于size_t的大小不同，64位系统是8字节，32位系统是4字节。为了方便移植，许多库函数的参数、返回值都是size_t。当换了个平台时，可以不改动代码而传入、接收更大或更小的值；并且系统不会使用更大的类型，从而加快速度。注意这些都是相对只用int、unsigned int、unsigned long作为类型对比的结果，用size_t有弹性。</p>
<p>但是，一个size_t类型的参数的用途却是用户定义的，比如可以把size_t就当int用，用来数组寻址等等，也可以用它来接收函数返回的参数然后作为一些长度，这些长度表示字节、还是两个字节都是用户决定的，它本身的值是多少就是多少。</p>
<p>一般用于作索引和表示单字节长度：</p>
<ul>
<li>size_t传达了语义：您立即知道它表示一个以字节为单位的大小或一个索引，而不仅仅是另一个整数。</li>
<li>std::size_t是任何sizeof表达式的类型，并且保证能够表达C ++中任何对象(包括任何数组)的最大大小。通过扩展，它也保证对任何数组索引都足够大，因此它是数组上逐个索引循环的自然类型。</li>
</ul>
<hr>
<p>C++11可以将{}初始化器用于任何类型（可以使用等号，也可以不使用），这是一种通用的初始化语法。</p>
<p>在C++11中，集合（列表）的初始化已经成为C++的一个基本功能，被称为“初始化列表（initializer list）”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;            <span class="comment">//C++98支持，C++11支持</span></span><br><span class="line"><span class="type">int</span> b[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;        <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; d = &#123;&#123; <span class="number">1</span>, <span class="number">1.0f</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2.0f</span> &#125;, &#123; <span class="number">3</span>, <span class="number">3.0f</span> &#125; &#125;;<span class="comment">//C++98不支持，C++11支持</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>应用了很多新特性，比较难理解，要耐心一点。</p>
<p>右值引用可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">C++11右值引用（一看即懂） (biancheng.net)</a></p>
<p>std::move()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7863.html">C++11 move()函数：将左值强制转换为右值 (biancheng.net)</a></p>
<p>std::forward()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7868.html">C++11完美转发及实现方法详解 (biancheng.net)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;<span class="comment">//线程创建后就开始运行，顶层只用往线程池插入任务即可</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span><span class="comment">//初始化一个pool</span></span><br><span class="line">            <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;<span class="comment">//创建count个线程，每个线程绑定工作函数并detach分离</span></span><br><span class="line">                <span class="comment">//lambda匿名函数，按值捕获pool_，本身是个指针，指向同一个实例。没有参数，省略“（）”</span></span><br><span class="line">                std::<span class="built_in">thread</span>([pool = pool_] &#123;<span class="comment">//接下来是函数体</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);<span class="comment">//灵活锁，因为要取一个元素。不放while可以避免重复定义</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//有元素就取，这里一定要先锁再判断</span></span><br><span class="line">                            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());<span class="comment">//左值转右值，转移task内存的所有权，把function取出来，调用移动构造函数</span></span><br><span class="line">                            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                            locker.<span class="built_in">unlock</span>();<span class="comment">//取完可以解锁了</span></span><br><span class="line">                            <span class="built_in">task</span>();<span class="comment">//工作</span></span><br><span class="line">                            locker.<span class="built_in">lock</span>();<span class="comment">//工作完因为是while，再锁，接下来再取元素。</span></span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;<span class="comment">//结束线程</span></span><br><span class="line">                        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//没有元素，解锁并等待唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();<span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;<span class="comment">//强制转型，pool_有指向的话就是true，那么就准备让线程退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">                pool_-&gt;isClosed = <span class="literal">true</span>;<span class="comment">//退出标识</span></span><br><span class="line">            &#125;</span><br><span class="line">            pool_-&gt;cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有线程，要把工作都做完才退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;<span class="comment">//以模板定义的&amp;&amp;既能接受左值也能接受右值，但注意，task作为参数，有名且能寻址，成为了左值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;<span class="comment">//添加一个task，右值传入，使得传入的对象的所有权被task获取，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            <span class="comment">//c++11新特性，emplace使对象在内存中调用构造函数，push会先构造再拷贝构造</span></span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));<span class="comment">//完美转发，保留传入的左右值属性，</span></span><br><span class="line">            	<span class="comment">//直接传task是个左值，如果F是一个function&lt;&gt;类型，这会导致移动构造和拷贝构造的区别。如果F是一个普通函数或指针等，一律调用普通构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//唤醒等待队列中的第一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;<span class="comment">//线程池结构体，相当于在类里再封装一层</span></span><br><span class="line">        std::mutex mtx;</span><br><span class="line">        std::condition_variable cond;</span><br><span class="line">        <span class="type">bool</span> isClosed;</span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列，元素是一个函数，执行任务，没有返回值。没有参数是因为bind绑定好了参数，不需要外部传</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_;<span class="comment">//使用共享指针，能自动销毁pool实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>先介绍下std::mutex：头文件<code>&lt;mutex&gt; </code>，实际上跟linux中pthread的互斥锁差不多，手动上锁和解锁。</p>
<ul>
<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
<li>unlock()， 解锁，释放对互斥量的所有权。</li>
<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
<p>真正好用的是std::lock_guard：头文件<code>&lt;mutex&gt; </code>，使用RAII机制，退出作用域就解锁。</p>
<ul>
<li><pre><code class="c++">template &lt;class _Mutex&gt;
class lock_guard &#123; // class with destructor that unlocks a mutex
public:
    using mutex_type = _Mutex;
    //无adopt_lock参数，构造时加锁
    explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) &#123; // construct and lock
        _MyMutex.lock();
    &#125;
    //有adopt_lock参数，构造时不加锁
    lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) &#123;&#125; // construct but don&#39;t lock
    //析构解锁
    ~lock_guard() noexcept &#123;
        _MyMutex.unlock();
    &#125;
    //屏蔽拷贝构造
    lock_guard(const lock_guard&amp;) = delete; 
    lock_guard&amp; operator=(const lock_guard&amp;) = delete; 

private:
    _Mutex&amp; _MyMutex;
&#125;;
</code></pre>
</li>
<li><p>lock_guard具有两种构造方法：</p>
<ol>
<li><code>lock_guard(mutex&amp; m)</code></li>
<li><code>lock_guard(mutex&amp; m, adopt_lock)</code>其中<code>mutex&amp; m</code>是互斥量，参数<code>adopt_lock</code>表示假定调用线程已经获得互斥体所有权并对其进行管理了。</li>
</ol>
</li>
</ul>
<p>再说下std::unique_lock：头文件<code>&lt;mutex&gt;</code>，也是使用RAII机制，定义和lock_guard相同。</p>
<p>主要还是说下二者的对比：</p>
<ul>
<li>std::unique_lock 与std::lock_guard都能实现自动加锁与解锁功能，但是std::unique_lock要比std::lock_guard更灵活，但是更灵活的代价是占用空间相对更大一点且相对更慢一点。</li>
<li>它提供了<code>lock()</code>和<code>unlock()</code>接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁。而lock_guard一锁就锁住一个作用域，直到退出才解锁，没有lock和unlock接口，有时只想锁住一段代码，用unique_lock就更灵活。</li>
<li><code>unique_lock</code>和<code>lock_guard</code>都不能复制，<code>lock_guard</code>不能移动，但是<code>unique_lock</code>可以</li>
<li>可以参考[<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/34d219380d90">c++11]多线程编程(五)——unique_lock - 简书 (jianshu.com)</a></li>
</ul>
<hr>
<p>条件变量std::condition_variable：头文件<code> &lt;condition_variable&gt;</code>，和linux的差不多了，可以看下<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38210354/article/details/107168532">(29条消息) C++11多线程条件变量std::condition_variable详解（转 ）_山城盛夏的博客-CSDN博客_std::condition_variable 详解</a>，当然不看也可以，无非是等待和唤醒。</p>
<hr>
<p>关于std::function，主要是用来包装函数的，像函数一样调用，具体可以参考之前的博客：<a href="https://jysama.cn/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">lambda表达式 | JySama</a></p>
<p>std::function是一个函数包装器，该函数包装器模板能包装任何类型的可调用实体，如普通函数，函数对象，lamda表达式等。包装器可拷贝，移动等，并且包装器类型仅仅依赖于调用特征，而不依赖于可调用元素自身的类型。std::function是C++11的新特性，包含在头文件<code>&lt;functional&gt;</code>中。</p>
<p>一个std::function类型对象实例可以包装下列这几种可调用实体：函数、函数指针、成员函数、静态函数、lamda表达式和函数对象。std::function对象实例可被拷贝和移动，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象实例未包含任何实际可调用实体时，调用该std::function对象实例将抛出std::bad_function_call异常。</p>
<hr>
<p>std::forward()：完美转发 </p>
<p>当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个<strong>左值</strong>。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。</p>
<p>std::forward必须配合T&amp;&amp;来使用。例如T&amp;&amp;接受左值int&amp;时，T会被推断为int&amp;，而T&amp;&amp;接受右值int&amp;&amp;时，T被推断为int。</p>
<hr>
<p>std::thread：头文件<code>&lt;thread&gt;</code>，可移动不可复制</p>
<ul>
<li>默认构造函数，创建一个空的 <code>std::thread</code> 执行对象： thread() noexcept;</li>
<li>初始化构造函数，创建一个 <code>std::thread</code> 对象，该 <code>std::thread</code> 对象可被 <code>joinable</code>，新产生的线程会调用 <code>fn</code> 函数，该函数的参数由 <code>args</code> 给出。<ul>
<li>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args);</li>
</ul>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库如出一辙，很好理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnPool</span> &#123;<span class="comment">//创建全局唯一的数据库连接池，维护多个与数据库的连接</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SqlConnPool *<span class="title">Instance</span><span class="params">()</span></span>;<span class="comment">//单例，静态成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MYSQL *<span class="title">GetConn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FreeConn</span><span class="params">(MYSQL * conn)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFreeConnCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connSize)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClosePool</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SqlConnPool</span>();</span><br><span class="line">    ~<span class="built_in">SqlConnPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_CONN_;</span><br><span class="line">    <span class="type">int</span> useCount_;</span><br><span class="line">    <span class="type">int</span> freeCount_;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;MYSQL *&gt; connQue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    <span class="type">sem_t</span> semId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SQLCONNPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">SqlConnPool::<span class="built_in">SqlConnPool</span>() &#123;<span class="comment">//放init也行，或者init放这</span></span><br><span class="line">    useCount_ = <span class="number">0</span>;</span><br><span class="line">    freeCount_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例模式</span></span><br><span class="line">    <span class="type">static</span> SqlConnPool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, <span class="type">const</span> <span class="type">char</span>* dbName,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>);<span class="comment">//条件判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connSize; i++) &#123;</span><br><span class="line">        MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//定义一个sql指针</span></span><br><span class="line">        sql = <span class="built_in">mysql_init</span>(sql);<span class="comment">//用这个指针初始化一个sql结构体，返回一个指向这个结构体的指针</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;<span class="comment">//错误判断，写日志</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);</span><br><span class="line">            <span class="built_in">assert</span>(sql);<span class="comment">//报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        sql = <span class="built_in">mysql_real_connect</span>(sql, host,</span><br><span class="line">                                 user, pwd,</span><br><span class="line">                                 dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);<span class="comment">//init后就connect，连接数据库，返回一个可用连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connQue_.<span class="built_in">push</span>(sql);<span class="comment">//放入队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    MAX_CONN_ = connSize;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);<span class="comment">//初始化信号量的值，这个0表示只能在当前进程的所有线程之间共享</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取一个可用连接</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//句柄</span></span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为什么前面判断了空这里还要用信号量呢？原因是线程可能在队列非空时纷涌而至，但实际上没有那么多连接可用，因此还是要信号量阻塞buffer</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);</span><br><span class="line">    &#123;<span class="comment">//lock的作用域</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//如果能取，要互斥</span></span><br><span class="line">        sql = connQue_.<span class="built_in">front</span>();</span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放一个连接，放回队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* sql)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sql);<span class="comment">//判空，不能放回虚假的连接</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//互斥放回</span></span><br><span class="line">    connQue_.<span class="built_in">push</span>(sql);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);<span class="comment">//post</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//锁住先，避免在close时被使用</span></span><br><span class="line">    <span class="keyword">while</span>(!connQue_.<span class="built_in">empty</span>()) &#123;<span class="comment">//循环取</span></span><br><span class="line">        <span class="keyword">auto</span> item = connQue_.<span class="built_in">front</span>();<span class="comment">//auto真给力...</span></span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">mysql_close</span>(item);<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免在使用库完成应用程序后发生内存泄漏(例如，在关闭与服务器的连接之后)，</span></span><br><span class="line">    <span class="comment">//可以显式调用mysql_library_end()。这样可以执行内存 Management 以清理和释放库使用的资源。</span></span><br><span class="line">    <span class="built_in">mysql_library_end</span>();        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前可用连接大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">SqlConnPool::~<span class="built_in">SqlConnPool</span>() &#123;</span><br><span class="line">    <span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-19</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源在对象构造初始化 资源在对象析构时释放*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span> &#123;<span class="comment">//以参数形式获取一个数据库连接</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool *connpool) &#123;<span class="comment">//双指针修改sql，为了获取连接，传入connpool</span></span><br><span class="line">        <span class="built_in">assert</span>(connpool);</span><br><span class="line">        *sql = connpool-&gt;<span class="built_in">GetConn</span>();<span class="comment">//获取连接</span></span><br><span class="line">        sql_ = *sql;<span class="comment">//记录</span></span><br><span class="line">        connpool_ = connpool;<span class="comment">//为了释放，需要记录sql和connpool</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(sql_) &#123; connpool_-&gt;<span class="built_in">FreeConn</span>(sql_); &#125;<span class="comment">//析构释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *sql_;</span><br><span class="line">    SqlConnPool* connpool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SQLCONNRAII_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>阻塞队列，用互斥锁再封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockDeque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockDeque</span><span class="params">(<span class="type">size_t</span> MaxCapacity = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BlockDeque</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; deq_;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity_;     </span><br><span class="line"></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condConsumer_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condProducer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::<span class="built_in">BlockDeque</span>(<span class="type">size_t</span> MaxCapacity) :<span class="built_in">capacity_</span>(MaxCapacity) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(MaxCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::~<span class="built_in">BlockDeque</span>() &#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">Close</span>() &#123;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        deq_.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">        isClose_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者，准备退出</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者，准备退出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//刷新，唤醒一个线程，准备工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有问题，前面close唤醒了线程，这里没有根据isclose变量直接退出，在pop那是退出了的，这里可能会卡住，一旦wait的太多，就可能一直写然后一直while。</span></span><br><span class="line"><span class="comment">//除非线程数严格小于容量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;<span class="comment">//条件变量的等待方式</span></span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);<span class="comment">//阻塞，等待唤醒，但唤醒后还是需要while看条件，因为有多个生产者在竞争</span></span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">full</span>()&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//如果close了就return了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout) &#123;<span class="comment">//增加了超时处理，push没有超时处理</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout)) </span><br><span class="line">                == std::cv_status::timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻塞超时就结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//关了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BLOCKQUEUE_H</span></span></span><br></pre></td></tr></table></figure>

<p>std::chrono::seconds：一个类，获取多少时间，这里以临时变量的形式传给wait_for，持续…seconds，超时结果就是timeout，和cv_status的timeout相等，借此判断是否超时。</p>
<p>std::cv_status：定义于头文件 <code>&lt;condition_variable&gt;</code>，带作用域枚举 <code>std::cv_status</code> 描述定时等待是否因时限返回。成员：</p>
<ul>
<li><code>no_timeout</code>：条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒</li>
<li><code>timeout</code>：条件变量因时限耗尽被唤醒</li>
</ul>
<p>wait_for：</p>
<p>返回值：若经过 <code>rel_time</code> 所指定的关联时限则为 std::cv_status::timeout，否则为 std::cv_status::no_timeout 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>           <span class="comment">// vastart va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">//mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* suffix =<span class="string">&quot;.log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;<span class="comment">//单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>;<span class="comment">//异步线程的回调函数，需要是staic，没有this隐藏参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isOpen_; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;<span class="comment">//互斥写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineCount_;</span><br><span class="line">    <span class="type">int</span> toDay_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isOpen_;</span><br><span class="line"> </span><br><span class="line">    Buffer buff_;<span class="comment">//一个日志仅有一个buffer，因为write被互斥锁锁住了</span></span><br><span class="line">    <span class="type">int</span> level_;</span><br><span class="line">    <span class="type">bool</span> isAsync_;</span><br><span class="line"></span><br><span class="line">    FILE* fp_;</span><br><span class="line">    std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_; <span class="comment">//智能指针，还没有实例</span></span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;<span class="comment">//指向一个thread，还没有实例</span></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以宏的形式，感觉写个string形式也行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>() &#123;</span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line">    isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    writeThread_ = <span class="literal">nullptr</span>;</span><br><span class="line">    deque_ = <span class="literal">nullptr</span>;</span><br><span class="line">    toDay_ = <span class="number">0</span>;</span><br><span class="line">    fp_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>()) &#123;<span class="comment">//如果写线程存在且需要join，就需要join</span></span><br><span class="line">        <span class="keyword">while</span>(!deque_-&gt;<span class="built_in">empty</span>()) &#123;<span class="comment">//不断唤醒消费者线程，把日志写完</span></span><br><span class="line">            deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        deque_-&gt;<span class="built_in">Close</span>();<span class="comment">//关掉</span></span><br><span class="line">        writeThread_-&gt;<span class="built_in">join</span>();<span class="comment">//join</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp_) &#123;<span class="comment">//如果文件打开了</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">flush</span>();<span class="comment">//刷新fp的缓冲区，还有唤醒线程的功能，这里没用</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);<span class="comment">//关掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;<span class="comment">//日志系统级别，越高级能写的类型越多，日志系统没到对应级别不能写</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level = <span class="number">1</span>, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    isOpen_ = <span class="literal">true</span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">    <span class="keyword">if</span>(maxQueueSize &gt; <span class="number">0</span>) &#123;<span class="comment">//如果设置了阻塞队列大小，就是异步</span></span><br><span class="line">        isAsync_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!deque_) &#123;</span><br><span class="line">            unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; <span class="built_in">newDeque</span>(<span class="keyword">new</span> BlockDeque&lt;std::string&gt;);<span class="comment">//创建一个实例</span></span><br><span class="line">            deque_ = <span class="built_in">move</span>(newDeque);<span class="comment">//unique指针只能移动构造</span></span><br><span class="line">            </span><br><span class="line">            <span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">NewThread</span><span class="params">(<span class="keyword">new</span> thread(FlushLogThread))</span></span>;<span class="comment">//异步同时要实例化一个写线程</span></span><br><span class="line">            writeThread_ = <span class="built_in">move</span>(NewThread);<span class="comment">//因为是单独线程，所以用unique指针，转移所有权用move</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    path_ = path;</span><br><span class="line">    suffix_ = suffix;</span><br><span class="line">    <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, </span><br><span class="line">            path_, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);<span class="comment">//日志文件名写到名称缓冲区</span></span><br><span class="line">    toDay_ = t.tm_mday;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">//互斥锁作用域，感觉没必要，init就主线程调用</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">        <span class="keyword">if</span>(fp_) &#123; <span class="comment">//如果文本打开了，就关了重新开</span></span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">            <span class="built_in">fclose</span>(fp_); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据名称创建or打开</span></span><br><span class="line">        <span class="keyword">if</span>(fp_ == <span class="literal">nullptr</span>) &#123;<span class="comment">//打开失败，没有目标文件夹，要先创建</span></span><br><span class="line">            <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);<span class="comment">//0777是最大的访问权</span></span><br><span class="line">            fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    <span class="comment">//宏参数初始化</span></span><br><span class="line">    va_list vaList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志日期 日志行数 */</span></span><br><span class="line">    <span class="keyword">if</span> (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_  %  MAX_LINES == <span class="number">0</span>)))<span class="comment">//如果日志行数太多写满了，或着换了一天，要重新创建一个文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//这个锁感觉放if外好一点，因为让一个线程进来创建好新文件更新day喝line就可以了，这样就会很多线程一起进这个if</span></span><br><span class="line">        locker.<span class="built_in">unlock</span>();<span class="comment">//等下要用一个锁，先创建好，解锁。这对于同步写有用，因为同步的话有很多线程会调用</span></span><br><span class="line">        <span class="comment">//把lock锁if外，然后处理完，更新day和line，打开新文件，再解锁，其他线程就不会进if了</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toDay_ != t.tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;<span class="comment">//-72是什么鬼，不需要那么长吗？</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);</span><br><span class="line">            toDay_ = t.tm_mday;<span class="comment">//给天赋值</span></span><br><span class="line">            lineCount_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_  / MAX_LINES), suffix_);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        locker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">flush</span>();</span><br><span class="line">        <span class="built_in">fclose</span>(fp_);</span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(newFile, <span class="string">&quot;a&quot;</span>);<span class="comment">//重新打开</span></span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后正常写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        lineCount_++;<span class="comment">//写一行</span></span><br><span class="line">        <span class="comment">//buffer不只是为日志系统写的，而且感觉这里不用buffer更好</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">                    t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">                    t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);<span class="comment">//向buffer写时间信息，n是写入的长度</span></span><br><span class="line">                    </span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(n);<span class="comment">//移动指针，前n个写时间信息</span></span><br><span class="line">        <span class="built_in">AppendLogLevelTitle_</span>(level);<span class="comment">//然后添加等级</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">va_start</span>(vaList, format);<span class="comment">//遍历参数</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);<span class="comment">//不断向buffer写，返回写入长度</span></span><br><span class="line">        <span class="built_in">va_end</span>(vaList);<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(m);<span class="comment">//移动指针</span></span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);<span class="comment">//加换行和终止</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>()) &#123;<span class="comment">//如果是异步的，放阻塞队列</span></span><br><span class="line">            deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果是同步的，开写</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);</span><br><span class="line">        &#125;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;<span class="comment">//添加信息头</span></span><br><span class="line">    <span class="keyword">switch</span>(level) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span> </span>&#123;<span class="comment">//刷新缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(isAsync_) &#123; </span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(fp_);<span class="comment">//刷新文本的缓冲区，强制写完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数的运行函数</span></span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">pop</span>(str)) &#123;<span class="comment">//不断取str，写进文本</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Log* <span class="title">Log::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例函数</span></span><br><span class="line">    <span class="type">static</span> Log inst;</span><br><span class="line">    <span class="keyword">return</span> &amp;inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数，调用运行函数</span></span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize = <span class="number">1024</span>);</span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;       </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;<span class="comment">//buffer是一个vector...new一个得了，取地址比较简明</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_;<span class="comment">//原子类型，感觉还是用个互斥锁吧...资料太少了，查不到。不过操作buffer在顶层是被互斥锁锁住的，也许不用互斥</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BUFFER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize) : <span class="built_in">buffer_</span>(initBuffSize), <span class="built_in">readPos_</span>(<span class="number">0</span>), <span class="built_in">writePos_</span>(<span class="number">0</span>) &#123;&#125;<span class="comment">//初始化列表，使用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//准备好的字节数</span></span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;<span class="comment">//原子地相减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//可写入的字节数</span></span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//已读字节数</span></span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回readpos之后的字符串/位置，即准备好但没有取出的数据的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + readPos_;<span class="comment">//定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//buffer被取出了多少字节</span></span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    readPos_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span> </span>&#123;<span class="comment">//过滤到end之后</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end );<span class="comment">//已读的记录比已取出的小，地址的比较</span></span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>());<span class="comment">//被出去了这么多字节（地址）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出，清空</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());</span><br><span class="line">    readPos_ = <span class="number">0</span>;</span><br><span class="line">    writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出并转字string</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(), ReadableBytes())</span></span>;</span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回写到的位置之后的字符串，有何意义？后面不是没写到吗</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个能写的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//已写入多少个字节</span></span><br><span class="line">    writePos_ += len;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;<span class="comment">//重载函数</span></span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//任何指针类型data</span></span><br><span class="line">    <span class="built_in">assert</span>(data);</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);<span class="comment">//其他类型，就强制转型为char*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//char*优先匹配</span></span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);<span class="comment">//确保空间足够</span></span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());</span><br><span class="line">    <span class="built_in">HasWritten</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加另一个buff的数据</span></span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//确保这么大的长度能写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() &lt; len) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">WritableBytes</span>() &gt;= len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//接收</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];<span class="comment">//如果第一个缓冲区填不满，就用到这个缓冲区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">WritableBytes</span>();</span><br><span class="line">    <span class="comment">/* 分散读， 保证数据全部读完 */</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginPtr_</span>() + writePos_;<span class="comment">//定位可写的地方，不就是beginwrite()吗</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);<span class="comment">//2是指iovec结构的个数，返回值是有符号整型</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writable) &#123;<span class="comment">//转为无符号整型，长度是一样的</span></span><br><span class="line">        writePos_ += len;<span class="comment">//小于可写的地方就更新当前的buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//写的超出了buffer可写的空间</span></span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>();<span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">Append</span>(buff, len - writable);<span class="comment">//添加buff的数据，会扩大buffer的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//写出</span></span><br><span class="line">    <span class="type">size_t</span> readSize = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd, <span class="built_in">Peek</span>(), readSize);<span class="comment">//从当前开始（peek），写入准备好的数据</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125; </span><br><span class="line">    readPos_ += len;<span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char* 返回指向的字符串的首地址、也可以返回第一个字符、也可以返回整个字符串</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个char的地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();<span class="comment">//*begin()取第一个字符，&amp;取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//区别是返回值要不要当常量处理</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//扩容函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len) &#123;<span class="comment">//如果可写和已读都小于len，就必须重新开辟空间</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>);<span class="comment">//resize</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//否则，可以把已读的覆盖</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();<span class="comment">//准备好的数据大小</span></span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>());<span class="comment">//把中间未读的，从头开始覆盖</span></span><br><span class="line">        readPos_ = <span class="number">0</span>;<span class="comment">//已读为0</span></span><br><span class="line">        writePos_ = readPos_ + readable;<span class="comment">//写的位置是准备好的数据的位置</span></span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>注意：这里没有加锁，上层的调用要加锁</p>
<p>chrono可以稍微参考下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oncealong/article/details/28599655">(29条消息) C++11的chrono库，可实现毫秒微秒级定时_oncealong的博客-CSDN博客_chrono sleep</a>。里面提了三种类型，虽然不详细。</p>
<ul>
<li>std::chrono::high_resolution_clock：high_resolution_clock只不过是system_clock或者steady_clock的typedef。用于获取时间点。<ul>
<li>std::chrono::system_clock 它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</li>
<li>std::chrono::steady_clock 为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大。用在需要得到时间间隔，并且这个时间间隔不会因为修改系统时间而受影响的场景；它是单调的时钟，相当于教练手中的秒表；只会增长，适合用于记录程序耗时，他表示的时钟是不能设置的。</li>
<li>可以使用now()方法取得时间，是一个纳秒，相对系统启动的时间多少。一般用time_point：<code>std::chrono::high_resolution_clock::time_point t1=std::chrono::high_resolution_clock::now()</code>;或者<code>auto t1=std::chrono::high_resolution_clock::now();</code></li>
</ul>
</li>
<li>std::chrono::milliseconds：表示毫秒，是一个时间间隔。</li>
<li>在代码里面，now()+MS(timeout)被赋值到high_resolution_clock的time_point上，毫秒会转换为纳秒加上去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;<span class="comment">//时钟</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;<span class="comment">//时间间隔</span></span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;<span class="comment">//时钟内的时间点，获取now()方法结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;<span class="comment">//时间结构</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//这个id用来给哈希表映射，这样查找时间是O(1)，通过id映射到位置。</span></span><br><span class="line">    TimeStamp expires;<span class="comment">//时间点</span></span><br><span class="line">    TimeoutCallBack cb;<span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;</span><br><span class="line">        <span class="keyword">return</span> expires &lt; t.expires;<span class="comment">//比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;<span class="comment">//先指定vector有64个空间，其他情况下会两倍两倍的扩容</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//用size_t作为索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;TimerNode&gt; heap_;<span class="comment">//用vector实现堆，是一个小顶堆</span></span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;<span class="comment">//哈希表，i-&gt;size_t</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAP_TIMER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;<span class="comment">//向上过滤，用于插入节点</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[j] &lt; heap_[i]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;<span class="comment">//交换节点的辅助函数</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">swap</span>(heap_[i], heap_[j]);<span class="comment">//交换vector元素</span></span><br><span class="line">    ref_[heap_[i].id] = i;<span class="comment">//更改哈希表的映射</span></span><br><span class="line">    ref_[heap_[j].id] = j;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span> </span>&#123;<span class="comment">//向下过滤，用于建堆和删除顶点。这里是左闭右开的，n是取不到的右边界</span></span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; heap_[j + <span class="number">1</span>] &lt; heap_[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(heap_[i] &lt; heap_[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt; index;<span class="comment">//如果向下过滤了就返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;<span class="comment">//插入节点，关联回调函数</span></span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 新节点：堆尾插入，调整堆 */</span></span><br><span class="line">        i = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = i;<span class="comment">//先放i处</span></span><br><span class="line">        <span class="comment">//结构体可以struct A = &#123;...&#125;，调用默认构造函数，但必须把所有成员都赋值。常见的是struct A; A.x = ...逐个赋值</span></span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout), cb&#125;);<span class="comment">//放i处，调用默认构造函数</span></span><br><span class="line">        <span class="built_in">siftup_</span>(i);<span class="comment">//向上过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果原来就有这个节点，说明没到时，重设时间，调整一下即可</span></span><br><span class="line">        <span class="comment">/* 已有结点：调整堆 */</span></span><br><span class="line">        i = ref_[id];<span class="comment">//获得位置</span></span><br><span class="line">        heap_[i].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);<span class="comment">//调整</span></span><br><span class="line">        heap_[i].cb = cb;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>())) &#123;<span class="comment">//调整之后看看向上还是向下，如果不用向下过滤，那就向上过滤；如果向下过滤了，就不用向上了</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定id结点，并触发回调函数 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    TimerNode node = heap_[i];<span class="comment">//拷贝节点，如果是串行的话，是不是不需要拷贝，反正是调用完再删除</span></span><br><span class="line">    node.<span class="built_in">cb</span>();<span class="comment">//调用回调函数</span></span><br><span class="line">    <span class="built_in">del_</span>(i);<span class="comment">//删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定位置的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">/* 将要删除的结点换到队尾，然后调整堆 */</span></span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//下标=大小-1</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt;= n);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;<span class="comment">//删的不是最后一个元素就交换</span></span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, n);<span class="comment">//把目前最后的元素换到前面去，此时要删的元素放到了最后</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, n)) &#123;<span class="comment">//然后要调整这个元素的位置，先试一下向下过滤</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);<span class="comment">//不向下过滤的话就向上过滤。这里为什么要向上过滤呢？因为堆的兄弟之间没有关系，大堆有两个子堆，如果交换到另一个子堆就可能要向上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 队尾元素删除 */</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 调整指定id的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id) &gt; <span class="number">0</span>);</span><br><span class="line">    heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);</span><br><span class="line">    <span class="built_in">siftdown_</span>(ref_[id], heap_.<span class="built_in">size</span>());<span class="comment">//调整只可能更大，向下过滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;<span class="comment">//这里的tick()时间复杂度要比链表形式的高</span></span><br><span class="line">    <span class="comment">/* 清除超时结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();<span class="comment">//取顶</span></span><br><span class="line">        <span class="comment">//这里先用预设时间-当前时间，结果是一个纳秒级的时间间隔，用间隔转换转到毫秒级，调用count()，它的作用是返回当前级别还有多少ticks（单位时间）</span></span><br><span class="line">        <span class="comment">//比如3ms就有3ticks（在毫秒级下），因此这里是忽略毫秒级以下的数，只有剩余1毫秒及以上才不算超时。这是因为设定的超时时间是毫秒的，当然只看毫秒</span></span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123; <span class="comment">//等于0或小于0都超时</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="built_in">cb</span>();<span class="comment">//超时，调用回调函数</span></span><br><span class="line">        <span class="built_in">pop</span>();<span class="comment">//删除顶部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);<span class="comment">//删除0号位置的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清除</span></span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;<span class="comment">//看未超时的顶点剩下多少ticks</span></span><br><span class="line">    <span class="built_in">tick</span>();<span class="comment">//处理完超时的节点</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果非空</span></span><br><span class="line">        res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();<span class="comment">//看顶点还剩多少ticks（毫秒级别下）</span></span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; res = <span class="number">0</span>; &#125;<span class="comment">//负数说明预设时间小于当前时间，也就是时间间隔是负的，说明超时了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//-1说明空了，0说明超时了，大于0说明剩下的ticks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h2><p>涉及到一个string.data()，看到比较好的文章里面提到了一点：</p>
<p>为什么C语言风格的字符串要以’\0’结尾，C++（string）可以不要？</p>
<p>c语言用char*指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而c++语言则是面向对象的（string），长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。</p>
<hr>
<ul>
<li>首先会尝试把文件信息写入stat结构体，根据文件找不找得到、文件权限，得到对应的状态码。stat结构体主要是获得文件size</li>
<li>如果状态码是404那些，就把路径和stat结构体修改为404那些html文件的路径，如果是200OK，就再不修改。</li>
<li>然后添加状态行、头部信息</li>
<li>最后添加文件内容信息：<ul>
<li>先根据文件路径打开文件，可能是404那些html，也可能是真的文件。如果打开失败，会返回一个file not found的html</li>
<li>打开成功的话会尝试去内存映射，stat结构体的size在这有用。如果映射失败，也会返回一个file not found的html</li>
<li>如果打开成功，会添加文件的长度信息，把内存地址指针保存，可通过接口调用。因为不会真正写入文件内容</li>
<li>在添加文件长度信息后，顺便添加一个空行。</li>
</ul>
</li>
<li>没有写入内容，等待外部写入。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-25</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// mmap, munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();</span><br><span class="line">    ~<span class="built_in">HttpResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code_;<span class="comment">//响应状态码</span></span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;</span><br><span class="line"></span><br><span class="line">    std::string path_;<span class="comment">//资源路径</span></span><br><span class="line">    std::string srcDir_;<span class="comment">//资源文件夹路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* mmFile_; <span class="comment">//指向内存映射后的文件的内存空间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;<span class="comment">//存储文件信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的且不允许修改</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;<span class="comment">//把后缀类型映射到http的文件类型</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;<span class="comment">//把响应码映射到响应字符串</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;<span class="comment">//把响应码映射到响应需要发送的html文件的路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_RESPONSE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-27</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员定义，用&#123;&#125;构造整体，用&#123;key,value&#125;构造元素</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123; <span class="number">200</span>, <span class="string">&quot;OK&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    code_ = <span class="number">-1</span>;</span><br><span class="line">    path_ = srcDir_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();<span class="comment">//解除内存映射，不用参数，用mmFile_指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> string&amp; srcDir, string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123; <span class="built_in">UnmapFile</span>(); &#125;<span class="comment">//一个上层实例由一个线程控制，那么一个类实例可以多次init，多次的话就要把原来的映射解除</span></span><br><span class="line">    code_ = code;<span class="comment">//传入的状态，会根据之后的文件打开/访问成功与否改变</span></span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    <span class="comment">//访问的文件路径</span></span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向buff写入响应信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//传入一个buff，没有真正写入文件内容（file not found除外，自定义返回了一个html）</span></span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="comment">//stat函数，向stat结构体中写入path指定的文件信息，成功返回0，失败返回-1</span></span><br><span class="line">    <span class="comment">//S_ISDIR()函数的作用是判断一个路径是不是目录，st_mode表示了文件对应的模式：文件，目录等。函数返回0表示是文件，返回1是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;<span class="comment">//如果请求的文件不存在或者是文件夹，就404not found</span></span><br><span class="line">        code_ = <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//st_mode是个32位的整型变量，不过现在的linux操作系统只用了低16位（估计是鉴于以后拓展的考虑）</span></span><br><span class="line">    <span class="comment">//最低9位代表了文件的许可权限，它标识了文件所有者（owner）、组用户（group）、其他用户（other）的读（r）、写（w）、执行（x）权限。</span></span><br><span class="line">    <span class="comment">//S_IROTH：00004（无符号八进制数）：others have read permission</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;<span class="comment">//也即，如果其他用户没有读权限的话就返回403forbidden</span></span><br><span class="line">        code_ = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>) &#123; <span class="comment">//如果上面都没有，且没有被init为400，那就是初始值-1，表示ok</span></span><br><span class="line">        code_ = <span class="number">200</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();<span class="comment">//如果是error状态，会把对应的html页面文件信息添加到stat结构体中，把路径改了，成功就不做任何事情</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);<span class="comment">//添加状态行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);<span class="comment">//添加头部信息</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);<span class="comment">//返回文件内容，会尝试真正地打开文件，映射到内存，但是没有写入buff，会把内存指针放到mmFile_，File()接口调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;<span class="comment">//返回文件映射到内存的位置</span></span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回文件的大小</span></span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;<span class="comment">//如果是200OK，就不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span>(CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有响应码对应的html文件，count找到返回1，否则0</span></span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//find返回一个迭代器，first是key，second是value。</span></span><br><span class="line">        <span class="comment">//感觉可以用CODE_PATH[code_]，因为前面已经找到了才执行，虽说内部也会遍历去find。另外，如果直接用[]，没有这个元素会插入</span></span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);<span class="comment">//把这个错误页面文件信息保存到stat中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//向buff添加状态头部</span></span><br><span class="line">    string status;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有code_对应的状态</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//获取状态字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//上面处理了200，404，403，如果code_不知道被赋值成什么了，就400</span></span><br><span class="line">        code_ = <span class="number">400</span>;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(<span class="number">400</span>)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + <span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加头部信息</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(isKeepAlive_) &#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加返回内容</span></span><br><span class="line">    <span class="comment">//打开文件，string.data()返回c式字符串指针，c++11后与c_str()等价，结尾加&#x27;\0&#x27;。</span></span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);<span class="comment">//O_RDONLY表示只读</span></span><br><span class="line">    <span class="keyword">if</span>(srcFd &lt; <span class="number">0</span>) &#123; <span class="comment">//打开失败</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射到内存提高文件的访问速度 </span></span><br><span class="line"><span class="comment">        MAP_PRIVATE 建立一个写入时拷贝的私有映射*/</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成功返回创建的映射区的首地址；失败返回宏MAP_FAILED，这个宏就是-1。mmap返回一个void*</span></span><br><span class="line">    <span class="comment">//返回值用mmret指向，表示指向一个int类型，解指针时以int类型解析，找4个字节</span></span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*mmRet == <span class="number">-1</span>) &#123;<span class="comment">//取int，如果是-1表示失败了</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);<span class="comment">//这里的notfound，实际上打开了文件了，但是写进内存出错了</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取地址，修改指向的类型，两个指针指向的地址起始相同，但现在解指针按照char的解析类型解析，找一个字节。</span></span><br><span class="line">    <span class="comment">//多少个字节都无妨，因为munmap传入的地址参数类型是void*指针，只要首地址正确就好</span></span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;</span><br><span class="line">    <span class="built_in">close</span>(srcFd);<span class="comment">//关闭文件</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//只添加内容长度，两个\r\n，后面那个表示空行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size);<span class="comment">//解除映射</span></span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 判断文件类型 */</span></span><br><span class="line">    <span class="comment">//find_last_of返回最后一个.的位置，就是后缀类型前面那个.。逆向查找，返回的是下标</span></span><br><span class="line">    <span class="comment">//size_type是string的长度表示方式，不同的机器大小不同，为了匹配机器上string的最大长度。因此找位置、长度这些要用size_type</span></span><br><span class="line">    string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);<span class="comment">//找不到返回string::npos，表示不存在位置，值是-1</span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string suffix = path_.<span class="built_in">substr</span>(idx);<span class="comment">//从.开始返回后缀</span></span><br><span class="line">    <span class="keyword">if</span>(SUFFIX_TYPE.<span class="built_in">count</span>(suffix) == <span class="number">1</span>) &#123;<span class="comment">//有相应的类型就返回</span></span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;<span class="comment">//没有相应类型就返回这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, string message)</span> <span class="comment">//自定义错误信息，在添加内容时遇到错误就返回这个html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string body;</span><br><span class="line">    string status;</span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    body += <span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status  + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>用到正则，语法：<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 – 语法 | 菜鸟教程 (runoob.com)</a></p>
<p>几种用法：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sgdd123/p/7778599.html">C++ regex库的三种正则表达式操作 - 上官栋 - 博客园 (cnblogs.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-25</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_REQUEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_REQUEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span>  <span class="comment">//mysql</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PARSE_STATE</span> &#123;<span class="comment">//解析状态</span></span><br><span class="line">        REQUEST_LINE,</span><br><span class="line">        HEADERS,</span><br><span class="line">        BODY,</span><br><span class="line">        FINISH,        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">HTTP_CODE</span> &#123;</span><br><span class="line">        NO_REQUEST = <span class="number">0</span>,</span><br><span class="line">        GET_REQUEST,</span><br><span class="line">        BAD_REQUEST,</span><br><span class="line">        NO_RESOURSE,</span><br><span class="line">        FORBIDDENT_REQUEST,</span><br><span class="line">        FILE_REQUEST,</span><br><span class="line">        INTERNAL_ERROR,</span><br><span class="line">        CLOSED_CONNECTION,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HttpRequest</span>() &#123; <span class="built_in">Init</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">HttpRequest</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">path</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">method</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">version</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    todo </span></span><br><span class="line"><span class="comment">    void HttpConn::ParseFormData() &#123;&#125;</span></span><br><span class="line"><span class="comment">    void HttpConn::ParseJson() &#123;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ParseRequestLine_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseHeader_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseBody_</span><span class="params">(<span class="type">const</span> std::string&amp; line)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePath_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParsePost_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParseFromUrlencoded_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">UserVerify</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; pwd, <span class="type">bool</span> isLogin)</span></span>;</span><br><span class="line"></span><br><span class="line">    PARSE_STATE state_;<span class="comment">//描述目前的解析状态</span></span><br><span class="line">    std::string method_, path_, version_, body_;</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; header_;<span class="comment">//保存信息，描述-&gt;参数</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; post_;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_set&lt;std::string&gt; DEFAULT_HTML;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">int</span>&gt; DEFAULT_HTML_TAG;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ConverHex</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_REQUEST_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_set&lt;string&gt; HttpRequest::DEFAULT_HTML&#123;</span><br><span class="line">            <span class="string">&quot;/index&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>,</span><br><span class="line">             <span class="string">&quot;/welcome&quot;</span>, <span class="string">&quot;/video&quot;</span>, <span class="string">&quot;/picture&quot;</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, <span class="type">int</span>&gt; HttpRequest::DEFAULT_HTML_TAG &#123;</span><br><span class="line">            &#123;<span class="string">&quot;/register.html&quot;</span>, <span class="number">0</span>&#125;, &#123;<span class="string">&quot;/login.html&quot;</span>, <span class="number">1</span>&#125;,  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    method_ = path_ = version_ = body_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    state_ = REQUEST_LINE;</span><br><span class="line">    header_.<span class="built_in">clear</span>();</span><br><span class="line">    post_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(header_.<span class="built_in">count</span>(<span class="string">&quot;Connection&quot;</span>) == <span class="number">1</span>) &#123;<span class="comment">//如果有头部有这个参数，就去找要不要keep</span></span><br><span class="line">        <span class="keyword">return</span> header_.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>)-&gt;second == <span class="string">&quot;keep-alive&quot;</span> &amp;&amp; version_ == <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::parse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> CRLF[] = <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(buff.<span class="built_in">ReadableBytes</span>() &amp;&amp; state_ != FINISH) &#123;</span><br><span class="line">        <span class="comment">//search：查找 [first1, last1) 范围内第一个 [first2, last2) 子序列，返回指向first2的首地址。未找到就返回last1，请求数据就没/r/n</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* lineEnd = <span class="built_in">search</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">BeginWriteConst</span>(), CRLF, CRLF + <span class="number">2</span>);<span class="comment">//每次获取一行</span></span><br><span class="line">        <span class="function">std::string <span class="title">line</span><span class="params">(buff.Peek(), lineEnd)</span></span>;<span class="comment">//拷贝一行，左闭右开</span></span><br><span class="line">        <span class="keyword">switch</span>(state_)<span class="comment">//看看现在是在解析什么</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_LINE:<span class="comment">//请求行</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">ParseRequestLine_</span>(line)) &#123;<span class="comment">//会根据要访问什么资源把path弄好</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有数据但是请求行都没准备好</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ParsePath_</span>();<span class="comment">//解析path</span></span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> HEADERS:</span><br><span class="line">            <span class="built_in">ParseHeader_</span>(line);<span class="comment">//不断解析头部</span></span><br><span class="line">            <span class="keyword">if</span>(buff.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">2</span>) &#123;<span class="comment">//解析完一个头部后会判断是不是/r/n，两个字节就是空行，没有请求数据，就结束</span></span><br><span class="line">                state_ = FINISH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BODY:</span><br><span class="line">            <span class="built_in">ParseBody_</span>(line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lineEnd == buff.<span class="built_in">BeginWrite</span>()) &#123; <span class="keyword">break</span>; &#125;<span class="comment">//空了，提前结束，避免buff出错，因为请求数据可能没有/r/n</span></span><br><span class="line">        buff.<span class="built_in">RetrieveUntil</span>(lineEnd + <span class="number">2</span>);<span class="comment">//过滤/r/n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;[%s], [%s], [%s]&quot;</span>, method_.<span class="built_in">c_str</span>(), path_.<span class="built_in">c_str</span>(), version_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求文件路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePath_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path_ == <span class="string">&quot;/&quot;</span>) &#123;<span class="comment">//输入ip地址最后只有一个/，返回的就是主页面</span></span><br><span class="line">        path_ = <span class="string">&quot;/index.html&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item: DEFAULT_HTML) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item == path_) &#123;<span class="comment">//遍历集合</span></span><br><span class="line">                path_ += <span class="string">&quot;.html&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//看一个请求行的实例：GET /562f25980001b1b106000338.jpg HTTP/1.1</span></span><br><span class="line"><span class="comment">//第一个^表示开始，匹配的字符串开始必须是[^ ]*，这个表示匹配除了空格的所有，遇到空格结束。然后会跟一个空格，再匹配下一个连续的串，遇到空格为止</span></span><br><span class="line"><span class="comment">//然后匹配一个空格，匹配HTTP/，再匹配除了空格的内容，如果有/r/n，也会匹配。最后$表示结束，后面不再匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::ParseRequestLine_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^ ]*) ([^ ]*) HTTP/([^ ]*)$&quot;</span>)</span></span>;<span class="comment">//匹配模式</span></span><br><span class="line">    smatch subMatch;<span class="comment">//存储结果，每个()中是一个子表达式，第0个参数是完整结果，1-n是()中的结果</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;<span class="comment">//严格要求各参数之间只有一个空格</span></span><br><span class="line">        method_ = subMatch[<span class="number">1</span>];</span><br><span class="line">        path_ = subMatch[<span class="number">2</span>];</span><br><span class="line">        version_ = subMatch[<span class="number">3</span>];<span class="comment">//说明传进来的line的/r/n被去掉了</span></span><br><span class="line">        state_ = HEADERS;<span class="comment">//接下来解析请求头</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;RequestLine Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求头，比如host: ... 或者host:...</span></span><br><span class="line"><span class="comment">//首先匹配冒号前面的，到冒号停下，然后匹配冒号，然后是一个空格，问号表示这个空格可以匹配0次或1次，因为报文中空格可以0次或多次</span></span><br><span class="line"><span class="comment">//然后匹配剩下的除换行符之外的所有字符，.相当于[^\n\r]。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseHeader_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    <span class="function">regex <span class="title">patten</span><span class="params">(<span class="string">&quot;^([^:]*): ?(.*)$&quot;</span>)</span></span>;</span><br><span class="line">    smatch subMatch;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">regex_match</span>(line, subMatch, patten)) &#123;<span class="comment">//匹配成功</span></span><br><span class="line">        header_[subMatch[<span class="number">1</span>]] = subMatch[<span class="number">2</span>];<span class="comment">//添加头部信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//失败就是到空行了，准备解析请求体。上层会判断是否有请求体，没有就结束</span></span><br><span class="line">        state_ = BODY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析请求体，就是post的请求数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseBody_</span><span class="params">(<span class="type">const</span> string&amp; line)</span> </span>&#123;</span><br><span class="line">    body_ = line;<span class="comment">//拷贝</span></span><br><span class="line">    <span class="built_in">ParsePost_</span>();<span class="comment">//调用解析post</span></span><br><span class="line">    state_ = FINISH;<span class="comment">//结束咯</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Body:%s, len:%d&quot;</span>, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpRequest::ConverHex</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;<span class="comment">//把一个十六进制的字符转为int数字</span></span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;F&#x27;</span>) <span class="keyword">return</span> ch -<span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;<span class="comment">//+10是因为A本身在十六进制代表10</span></span><br><span class="line">    <span class="keyword">if</span>(ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;f&#x27;</span>) <span class="keyword">return</span> ch -<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;<span class="comment">//是不是忘了-&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParsePost_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//application/x-www-form-urlencoded是最常见的 POST 提交数据方式。这里只解析这种格式</span></span><br><span class="line">    <span class="comment">//请求数据实例：name=Professional%20Ajax&amp;publisher=Wiley</span></span><br><span class="line">    <span class="keyword">if</span>(method_ == <span class="string">&quot;POST&quot;</span> &amp;&amp; header_[<span class="string">&quot;Content-Type&quot;</span>] == <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">ParseFromUrlencoded_</span>();<span class="comment">//把body解码</span></span><br><span class="line">        <span class="keyword">if</span>(DEFAULT_HTML_TAG.<span class="built_in">count</span>(path_)) &#123;<span class="comment">//login的话，post的url就是当前请求的页面，就能解析到是/login.html，得到对应tag</span></span><br><span class="line">            <span class="type">int</span> tag = DEFAULT_HTML_TAG.<span class="built_in">find</span>(path_)-&gt;second;</span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Tag:%d&quot;</span>, tag);</span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span> || tag == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> isLogin = (tag == <span class="number">1</span>);<span class="comment">//看是登录还是注册</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">UserVerify</span>(post_[<span class="string">&quot;username&quot;</span>], post_[<span class="string">&quot;password&quot;</span>], isLogin)) &#123;<span class="comment">//处理登录和处理注册</span></span><br><span class="line">                    path_ = <span class="string">&quot;/welcome.html&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    path_ = <span class="string">&quot;/error.html&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name1=value1&amp;name2=value2&amp;name3=value3&amp;.....&amp;nameN=valueN</span></span><br><span class="line"><span class="comment">//用&quot;+&quot;取代空字符</span></span><br><span class="line"><span class="comment">//非数字, 字母用%HH格式进行替换, 其中HH是两位16进制数字, 表示被替换字符的ASCII码(例如&quot;?&quot;会被替换成&quot;%3F&quot;, 对应十进制数是63,也就是问号对应的ASCII值)</span></span><br><span class="line"><span class="comment">//换行符用CR LF字符对表示, 对应的值是&quot;%0D%0A&quot;;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpRequest::ParseFromUrlencoded_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(body_.<span class="built_in">size</span>() == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    string key, value;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = body_.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;<span class="comment">//逐个解析</span></span><br><span class="line">        <span class="type">char</span> ch = body_[i];</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:<span class="comment">//如果是等号，key就是j-i-1这一段，</span></span><br><span class="line">            key = body_.<span class="built_in">substr</span>(j, i - j);<span class="comment">//长度是i-j</span></span><br><span class="line">            j = i + <span class="number">1</span>;<span class="comment">//下一个str起始</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="comment">//如果是+，换回空格</span></span><br><span class="line">            body_[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:<span class="comment">//后面跟两个十六进制的字符</span></span><br><span class="line">            num = <span class="built_in">ConverHex</span>(body_[i + <span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">ConverHex</span>(body_[i + <span class="number">2</span>]);<span class="comment">//转化为对应的ascii码</span></span><br><span class="line">            body_[i + <span class="number">2</span>] = num % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            body_[i + <span class="number">1</span>] = num / <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;<span class="comment">//并不是转换为ascii对应的符号，转换为数字对应的字符形式而已，就是16进制转十进制</span></span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:<span class="comment">//如果是&amp;，就得到value</span></span><br><span class="line">            value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            post_[key] = value;<span class="comment">//存储</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s = %s&quot;</span>, key.<span class="built_in">c_str</span>(), value.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(j &lt;= i);<span class="comment">//处理最后一个value，它没有&amp;</span></span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">0</span> &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        value = body_.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">        post_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpRequest::UserVerify</span><span class="params">(<span class="type">const</span> string &amp;name, <span class="type">const</span> string &amp;pwd, <span class="type">bool</span> isLogin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name == <span class="string">&quot;&quot;</span> || pwd == <span class="string">&quot;&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;<span class="comment">//空的话返回错误</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Verify name:%s pwd:%s&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());<span class="comment">//否则就记录</span></span><br><span class="line">    MYSQL* sql;</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(&amp;sql,  SqlConnPool::<span class="built_in">Instance</span>());<span class="comment">//初始化连接数据库，返回全局的静态的连接池</span></span><br><span class="line">    <span class="built_in">assert</span>(sql);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> order[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MYSQL_FIELD *fields = <span class="literal">nullptr</span>;</span><br><span class="line">    MYSQL_RES *res = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!isLogin) &#123; flag = <span class="literal">true</span>; &#125;<span class="comment">//如果是注册</span></span><br><span class="line">    <span class="comment">/* 查询用户及密码 */</span></span><br><span class="line">    <span class="built_in">snprintf</span>(order, <span class="number">256</span>, <span class="string">&quot;SELECT username, password FROM user WHERE username=&#x27;%s&#x27; LIMIT 1&quot;</span>, name.<span class="built_in">c_str</span>());<span class="comment">//sql语句，查一个</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; <span class="comment">//执行语句，成功返回0，错误返回非0</span></span><br><span class="line">        <span class="built_in">mysql_free_result</span>(res);<span class="comment">//错误的话释放结果集并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">mysql_store_result</span>(sql);<span class="comment">//完整的结果集</span></span><br><span class="line">    j = <span class="built_in">mysql_num_fields</span>(res); <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    fields = <span class="built_in">mysql_fetch_fields</span>(res);<span class="comment">//返回所有字段结构的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(res)) &#123;<span class="comment">//遍历行，实际上只有一行，但这样可以取出行</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;MYSQL ROW: %s %s&quot;</span>, row[<span class="number">0</span>], row[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">string <span class="title">password</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        <span class="comment">// 能select到说明又对应的username，看是登录还是注册</span></span><br><span class="line">        <span class="keyword">if</span>(isLogin) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pwd == password) &#123; flag = <span class="literal">true</span>; &#125;<span class="comment">//标记成功，可以直接return的</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;pwd error!&quot;</span>);</span><br><span class="line">                <span class="comment">//可以直接return的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//如果是注册，注意能进到这个while说明取出了row，就说明前面res select到了一个username，重名了</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;user used!&quot;</span>);</span><br><span class="line">            <span class="comment">//可以直接return的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_free_result</span>(res);<span class="comment">//释放结果集使用的内存，store后要释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册行为 且 用户名未被使用*/</span></span><br><span class="line">    <span class="keyword">if</span>(!isLogin &amp;&amp; flag == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;regirster!&quot;</span>);</span><br><span class="line">        <span class="built_in">bzero</span>(order, <span class="number">256</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(order, <span class="number">256</span>,<span class="string">&quot;INSERT INTO user(username, password) VALUES(&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>, name.<span class="built_in">c_str</span>(), pwd.<span class="built_in">c_str</span>());<span class="comment">//插入表</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;%s&quot;</span>, order);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mysql_query</span>(sql, order)) &#123; </span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;Insert error!&quot;</span>);</span><br><span class="line">            flag = <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">FreeConn</span>(sql);<span class="comment">//这行不用，使用了RAII机制了</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>( <span class="string">&quot;UserVerify success!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::path</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">HttpRequest::path</span><span class="params">()</span></span>&#123;<span class="comment">//外部可修改path_</span></span><br><span class="line">    <span class="keyword">return</span> path_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::method</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::version</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> version_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口函数，供外部使用，用于获取解析请求体后获得的参数</span></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">HttpRequest::GetPost</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(key != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(post_.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> post_.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上层调用"><a href="#上层调用" class="headerlink" title="上层调用"></a>上层调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_CONN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_CONN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span>     <span class="comment">// readv/writev</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// atoi()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>      </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httprequest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HttpConn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockFd, <span class="type">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span>* saveErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetFd</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetIP</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">sockaddr_in <span class="title">GetAddr</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ToWriteBytes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsKeepAlive</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request_.<span class="built_in">IsKeepAlive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isET;<span class="comment">//是否是ET触发模式</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* srcDir;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int</span>&gt; userCount;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> fd_;</span><br><span class="line">    <span class="keyword">struct</span>  <span class="title class_">sockaddr_in</span> addr_;<span class="comment">//internet环境下套接字的地址形式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> iovCnt_;<span class="comment">//根据有没有文件要传，有的话就是两个。打开文件失败的话，会返回自定义的html，这个html是写到buff的，此时没有文件要传</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov_[<span class="number">2</span>];<span class="comment">//0发送响应报文，1发送响应文件</span></span><br><span class="line">    </span><br><span class="line">    Buffer readBuff_; <span class="comment">// 读缓冲区</span></span><br><span class="line">    Buffer writeBuff_; <span class="comment">// 写缓冲区</span></span><br><span class="line"></span><br><span class="line">    HttpRequest request_;</span><br><span class="line">    HttpResponse response_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_CONN_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpconn.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* HttpConn::srcDir;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; HttpConn::userCount;</span><br><span class="line"><span class="type">bool</span> HttpConn::isET;</span><br><span class="line"></span><br><span class="line">HttpConn::<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    fd_ = <span class="number">-1</span>;</span><br><span class="line">    addr_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpConn::~<span class="built_in">HttpConn</span>() &#123; </span><br><span class="line">    <span class="built_in">Close</span>(); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::init</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> sockaddr_in&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    userCount++;</span><br><span class="line">    addr_ = addr;</span><br><span class="line">    fd_ = fd;</span><br><span class="line">    writeBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    readBuff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) in, userCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpConn::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    response_.<span class="built_in">UnmapFile</span>();</span><br><span class="line">    <span class="keyword">if</span>(isClose_ == <span class="literal">false</span>)&#123;</span><br><span class="line">        isClose_ = <span class="literal">true</span>; </span><br><span class="line">        userCount--;</span><br><span class="line">        <span class="built_in">close</span>(fd_);</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d](%s:%d) quit, UserCount:%d&quot;</span>, fd_, <span class="built_in">GetIP</span>(), <span class="built_in">GetPort</span>(), (<span class="type">int</span>)userCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> HttpConn::<span class="built_in">GetAddr</span>() <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addr_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ntoa：network to ascii，将网络地址转换成“.”点隔的字符串格式</span></span><br><span class="line"><span class="comment">//&lt;arpa/inet.h&gt;，char *inet_ntoa (struct in_addr);参数是结构体</span></span><br><span class="line"><span class="comment">//相反的函数是inet_addr，讲ip转换为长整型，参数是ip字符串，如addr_.sin_addr.s_addr = inet_addr(&quot;132.241.5.10&quot;);</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">HttpConn::GetIP</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">inet_ntoa</span>(addr_.sin_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HttpConn::GetPort</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr_.sin_port;<span class="comment">//sin_port存储端口号（使用网络字节顺序）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::read</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//读数据到自己的缓冲区</span></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = readBuff_.<span class="built_in">ReadFd</span>(fd_, saveErrno);<span class="comment">//调用读缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (isET);<span class="comment">//如果是ET模式就一直读取直到len==0，LT模式就读一次就结束</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">HttpConn::write</span><span class="params">(<span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//iov里的数据写出去</span></span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = <span class="built_in">writev</span>(fd_, iov_, iovCnt_);<span class="comment">//写多个非连续缓冲区（聚集写），成功返回字节数，失败返回-1，因此用ssize_t，是signed的</span></span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            *saveErrno = errno;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len + iov_[<span class="number">1</span>].iov_len  == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125; <span class="comment">/* 传输结束 */</span><span class="comment">//也就是TuWriteBytes()==0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &gt; iov_[<span class="number">0</span>].iov_len) &#123;<span class="comment">//第一个缓冲区以写完</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_base = (<span class="type">uint8_t</span>*) iov_[<span class="number">1</span>].iov_base + (len - iov_[<span class="number">0</span>].iov_len);<span class="comment">//更新第二个缓冲区剩下的</span></span><br><span class="line">            iov_[<span class="number">1</span>].iov_len -= (len - iov_[<span class="number">0</span>].iov_len);</span><br><span class="line">            <span class="keyword">if</span>(iov_[<span class="number">0</span>].iov_len) &#123;<span class="comment">//然后更新第一个缓冲区为0</span></span><br><span class="line">                writeBuff_.<span class="built_in">RetrieveAll</span>();<span class="comment">//写缓冲区已经发送完毕</span></span><br><span class="line">                iov_[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//c++中指针相互赋值要显式转换，void*可接受任意类型的赋值（不必转换）；反过来不行，void*要给其他变量赋值要显示转换</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_base = (<span class="type">uint8_t</span>*)iov_[<span class="number">0</span>].iov_base + len;<span class="comment">//typedef unsigned char  uint8_t;</span></span><br><span class="line">            iov_[<span class="number">0</span>].iov_len -= len; </span><br><span class="line">            writeBuff_.<span class="built_in">Retrieve</span>(len);<span class="comment">//已经发送了len长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(isET || <span class="built_in">ToWriteBytes</span>() &gt; <span class="number">10240</span>);<span class="comment">//ET模式一直写，或者有太多字节要写了，就多写几次</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HttpConn::process</span><span class="params">()</span> </span>&#123;<span class="comment">//解析请求数据，并把响应数据放到iovec结构体</span></span><br><span class="line">    request_.<span class="built_in">Init</span>();<span class="comment">//处理请求初始化</span></span><br><span class="line">    <span class="keyword">if</span>(readBuff_.<span class="built_in">ReadableBytes</span>() &lt;= <span class="number">0</span>) &#123;<span class="comment">//如果一点数据都没接收到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(request_.<span class="built_in">parse</span>(readBuff_)) &#123;<span class="comment">//有数据就处理，如果解析请求行错误就false</span></span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;%s&quot;</span>, request_.<span class="built_in">path</span>().<span class="built_in">c_str</span>());<span class="comment">//解析请求行成功，后面数据有无无所谓。get的话请求行就有路径，post的话会检查请求体，没有就返回error</span></span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), request_.<span class="built_in">IsKeepAlive</span>(), <span class="number">200</span>);<span class="comment">//然后初始化响应</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response_.<span class="built_in">Init</span>(srcDir, request_.<span class="built_in">path</span>(), <span class="literal">false</span>, <span class="number">400</span>);<span class="comment">//请求错误，返回400 bad request</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response_.<span class="built_in">MakeResponse</span>(writeBuff_);<span class="comment">//响应数据写到缓冲区</span></span><br><span class="line">    <span class="comment">/* 响应头 */</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_base = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(writeBuff_.<span class="built_in">Peek</span>());<span class="comment">//赋予内存起始地址，用const_cast消去const</span></span><br><span class="line">    iov_[<span class="number">0</span>].iov_len = writeBuff_.<span class="built_in">ReadableBytes</span>();<span class="comment">//大小</span></span><br><span class="line">    iovCnt_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件 */</span></span><br><span class="line">    <span class="keyword">if</span>(response_.<span class="built_in">FileLen</span>() &gt; <span class="number">0</span>  &amp;&amp; response_.<span class="built_in">File</span>()) &#123;<span class="comment">//文件不写到缓冲区，直接返回文件内存映射的指针，给iov1</span></span><br><span class="line">        iov_[<span class="number">1</span>].iov_base = response_.<span class="built_in">File</span>();</span><br><span class="line">        iov_[<span class="number">1</span>].iov_len = response_.<span class="built_in">FileLen</span>();</span><br><span class="line">        iovCnt_ = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;filesize:%d, %d  to %d&quot;</span>, response_.<span class="built_in">FileLen</span>() , iovCnt_, <span class="built_in">ToWriteBytes</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务器顶层"><a href="#服务器顶层" class="headerlink" title="服务器顶层"></a>服务器顶层</h1><h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span> <span class="comment">//epoll_ctl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Epoller</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Epoller</span><span class="params">(<span class="type">int</span> maxEvent = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Epoller</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelFd</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Wait</span><span class="params">(<span class="type">int</span> timeoutMs = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> epollFd_;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; events_;<span class="comment">//存放监听到的事件 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//EPOLLER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-19</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Epoller::<span class="built_in">Epoller</span>(<span class="type">int</span> maxEvent):<span class="built_in">epollFd_</span>(<span class="built_in">epoll_create</span>(<span class="number">512</span>)), <span class="built_in">events_</span>(maxEvent)&#123;<span class="comment">//构造内核事件表描述符，以及事件集合</span></span><br><span class="line">    <span class="built_in">assert</span>(epollFd_ &gt;= <span class="number">0</span> &amp;&amp; events_.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Epoller::~<span class="built_in">Epoller</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(epollFd_);<span class="comment">//关闭句柄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::AddFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;<span class="comment">//创建一个epoll_event，前面的vector存放事件，这里是为了描述事件的类型，关联fd。不初始化也可以：epoll_event ev;</span></span><br><span class="line">    ev.data.fd = fd;<span class="comment">//关联fd</span></span><br><span class="line">    ev.events = events;<span class="comment">//上层设置好类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_ADD, fd, &amp;ev);<span class="comment">//add，成功返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::ModFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">uint32_t</span> events)</span> </span>&#123;<span class="comment">//和add差不多</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    ev.events = events;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_MOD, fd, &amp;ev);<span class="comment">//mod</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Epoller::DelFd</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    epoll_event ev = &#123;<span class="number">0</span>&#125;;<span class="comment">//可以不创建，epoll_ctl(epollFd_, EPOLL_CTL_DEL, fd, 0)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">epoll_ctl</span>(epollFd_, EPOLL_CTL_DEL, fd, &amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于timeout：-1：永远等待；0：不等待直接返回，执行下面的代码；其他：在超时时间内没有事件发生，返回0，如果有事件发生立即返回</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::Wait</span><span class="params">(<span class="type">int</span> timeoutMs)</span> </span>&#123;<span class="comment">//成功返回多少事件就绪，超时返回0，出错返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">epoll_wait</span>(epollFd_, &amp;events_[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()), timeoutMs);</span><br><span class="line">&#125;<span class="comment">//&amp;events_[0]等价于events；vector.size()返回类型是size_t，unsigned int转int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Epoller::GetEventFd</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;<span class="comment">//调用wait后，从events事件集合中取出对应的可io的文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].data.fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Epoller::GetEvents</span><span class="params">(<span class="type">size_t</span> i)</span> <span class="type">const</span> </span>&#123;<span class="comment">//调用wait后，从events事件集合中取出对应的事件的类型描述</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt; events_.<span class="built_in">size</span>() &amp;&amp; i &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> events_[i].events;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顶层调用"><a href="#顶层调用" class="headerlink" title="顶层调用"></a>顶层调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// fcntl()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;epoller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../timer/heaptimer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../pool/sqlconnRAII.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/httpconn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>(</span><br><span class="line">        <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger, </span><br><span class="line">        <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span>  <span class="type">char</span>* sqlPwd, </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">        <span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InitSocket_</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealListen_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DealRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>*info)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ExtentTime_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CloseConn_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnRead_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnWrite_</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnProcess</span><span class="params">(HttpConn* client)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">    <span class="type">bool</span> openLinger_;</span><br><span class="line">    <span class="type">int</span> timeoutMS_;  <span class="comment">/* 毫秒MS */</span></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line">    <span class="type">int</span> listenFd_;<span class="comment">//fd是socket</span></span><br><span class="line">    <span class="type">char</span>* srcDir_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听是接受tcp连接，所谓的连接是指维护客户与服务器之间的数据交换</span></span><br><span class="line">    <span class="type">uint32_t</span> listenEvent_;<span class="comment">//监听模式，维护服务器的监听事件的类型</span></span><br><span class="line">    <span class="type">uint32_t</span> connEvent_;<span class="comment">//连接模式，维护客户端与服务器之间的连接事件的类型</span></span><br><span class="line">   <span class="comment">//动态创建的，都用智能指针</span></span><br><span class="line">    std::unique_ptr&lt;HeapTimer&gt; timer_;</span><br><span class="line">    std::unique_ptr&lt;ThreadPool&gt; threadpool_;</span><br><span class="line">    std::unique_ptr&lt;Epoller&gt; epoller_;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, HttpConn&gt; users_;<span class="comment">//一个用户的socket匹配一个连接</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//WEBSERVER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>(</span><br><span class="line">            <span class="type">int</span> port, <span class="type">int</span> trigMode, <span class="type">int</span> timeoutMS, <span class="type">bool</span> OptLinger,</span><br><span class="line">            <span class="type">int</span> sqlPort, <span class="type">const</span> <span class="type">char</span>* sqlUser, <span class="type">const</span>  <span class="type">char</span>* sqlPwd,</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* dbName, <span class="type">int</span> connPoolNum, <span class="type">int</span> threadNum,</span><br><span class="line">            <span class="type">bool</span> openLog, <span class="type">int</span> logLevel, <span class="type">int</span> logQueSize):</span><br><span class="line">            <span class="built_in">port_</span>(port), <span class="built_in">openLinger_</span>(OptLinger), <span class="built_in">timeoutMS_</span>(timeoutMS), <span class="built_in">isClose_</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="built_in">timer_</span>(<span class="keyword">new</span> <span class="built_in">HeapTimer</span>()), <span class="built_in">threadpool_</span>(<span class="keyword">new</span> <span class="built_in">ThreadPool</span>(threadNum)), <span class="built_in">epoller_</span>(<span class="keyword">new</span> <span class="built_in">Epoller</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    srcDir_ = <span class="built_in">getcwd</span>(<span class="literal">nullptr</span>, <span class="number">256</span>);<span class="comment">//获取当前路径</span></span><br><span class="line">    <span class="built_in">assert</span>(srcDir_);</span><br><span class="line">    <span class="built_in">strncat</span>(srcDir_, <span class="string">&quot;/resources/&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    HttpConn::userCount = <span class="number">0</span>;</span><br><span class="line">    HttpConn::srcDir = srcDir_;</span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">Init</span>(<span class="string">&quot;localhost&quot;</span>, sqlPort, sqlUser, sqlPwd, dbName, connPoolNum);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitEventMode_</span>(trigMode);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">InitSocket_</span>()) &#123; isClose_ = <span class="literal">true</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(openLog) &#123;</span><br><span class="line">        Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">init</span>(logLevel, <span class="string">&quot;./log&quot;</span>, <span class="string">&quot;.log&quot;</span>, logQueSize);</span><br><span class="line">        <span class="keyword">if</span>(isClose_) &#123; <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;========== Server init error!==========&quot;</span>); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server init ==========&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Port:%d, OpenLinger: %s&quot;</span>, port_, OptLinger? <span class="string">&quot;true&quot;</span>:<span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Listen Mode: %s, OpenConn Mode: %s&quot;</span>,</span><br><span class="line">                            (listenEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span>: <span class="string">&quot;LT&quot;</span>),</span><br><span class="line">                            (connEvent_ &amp; EPOLLET ? <span class="string">&quot;ET&quot;</span>: <span class="string">&quot;LT&quot;</span>));</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;LogSys level: %d&quot;</span>, logLevel);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;srcDir: %s&quot;</span>, HttpConn::srcDir);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;SqlConnPool num: %d, ThreadPool num: %d&quot;</span>, connPoolNum, threadNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>() &#123;</span><br><span class="line">    <span class="built_in">close</span>(listenFd_);</span><br><span class="line">    isClose_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">free</span>(srcDir_);</span><br><span class="line">    SqlConnPool::<span class="built_in">Instance</span>()-&gt;<span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::InitEventMode_</span><span class="params">(<span class="type">int</span> trigMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对端正常断开连接（调用 close()），在服务器端会触发一个 epoll 事件，EPOLLRDHUP监听挂断事件，在底层完成</span></span><br><span class="line">    <span class="comment">//EPOLLRDHUP：https://blog.csdn.net/midion9/article/details/49883063</span></span><br><span class="line">    <span class="comment">//EPOLLHUP：https://blog.csdn.net/voidccc/article/details/8619632</span></span><br><span class="line">    listenEvent_ = EPOLLRDHUP;<span class="comment">//说明要监听对端是否挂断</span></span><br><span class="line">    connEvent_ = EPOLLONESHOT | EPOLLRDHUP;<span class="comment">//连接事务每次响应后要重新设置</span></span><br><span class="line">    <span class="keyword">switch</span> (trigMode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        listenEvent_ |= EPOLLET;</span><br><span class="line">        connEvent_ |= EPOLLET;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HttpConn::isET = (connEvent_ &amp; EPOLLET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> timeMS = <span class="number">-1</span>;  <span class="comment">/* epoll wait timeout == -1 无事件将阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(!isClose_) &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;========== Server start ==========&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(!isClose_) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;<span class="comment">//设置了超时处理的话，每轮都处理超时的事件</span></span><br><span class="line">            timeMS = timer_-&gt;<span class="built_in">GetNextTick</span>();<span class="comment">//获取下一个定时器超时的剩余时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> eventCnt = epoller_-&gt;<span class="built_in">Wait</span>(timeMS);<span class="comment">//等待事件触发，有事件触发立即返回，没有会等timeMS的时间</span></span><br><span class="line">        <span class="comment">//等待的事件包括监听事件和读写事件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCnt; i++) &#123;</span><br><span class="line">            <span class="comment">/* 处理事件 */</span></span><br><span class="line">            <span class="type">int</span> fd = epoller_-&gt;<span class="built_in">GetEventFd</span>(i);<span class="comment">//获取fd描述符</span></span><br><span class="line">            <span class="type">uint32_t</span> events = epoller_-&gt;<span class="built_in">GetEvents</span>(i);<span class="comment">//获取时间的类型</span></span><br><span class="line">            <span class="keyword">if</span>(fd == listenFd_) &#123;<span class="comment">//如果监听到一个新连接</span></span><br><span class="line">                <span class="built_in">DealListen_</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是触发的事件是对端断开或者对端异常（ERR通常是服务器读写（自身采取行动）发现对方异常触发）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;<span class="comment">//异常事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);<span class="comment">//确定user内保存了这个描述符</span></span><br><span class="line">                <span class="built_in">CloseConn_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLIN) &#123;<span class="comment">//如果是读事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">DealRead_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events &amp; EPOLLOUT) &#123;<span class="comment">//如果是写事件</span></span><br><span class="line">                <span class="built_in">assert</span>(users_.<span class="built_in">count</span>(fd) &gt; <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">DealWrite_</span>(&amp;users_[fd]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//非预期事件</span></span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Unexpected event&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::SendError_</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span>*info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">send</span>(fd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);<span class="comment">//向某个socket发生信息，送到对方的socket由对方处理这个信息</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;send error to client[%d] error!&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::CloseConn_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//关闭连接</span></span><br><span class="line">    <span class="built_in">assert</span>(client);<span class="comment">//首先会有一个连接类维护这个连接</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] quit!&quot;</span>, client-&gt;<span class="built_in">GetFd</span>());</span><br><span class="line">    epoller_-&gt;<span class="built_in">DelFd</span>(client-&gt;<span class="built_in">GetFd</span>());<span class="comment">//获取连接类维护的socket并从事件表中删除，并不关闭</span></span><br><span class="line">    client-&gt;<span class="built_in">Close</span>();<span class="comment">//关闭连接，这个会关闭fd。实际上连接类的析构也会close()，但在使用过程中要手动释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::AddClient_</span><span class="params">(<span class="type">int</span> fd, sockaddr_in addr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建http连接</span></span><br><span class="line">    users_[fd].<span class="built_in">init</span>(fd, addr);<span class="comment">//不指定value的写法，会讲value以0初始化，然后这里再调用init</span></span><br><span class="line">    <span class="comment">//创建计时器关联http连接</span></span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123;<span class="comment">//有超时处理的话，就绑定一个定时器，回调函数用来关闭连接。这种形式的回调函数不再需要是static</span></span><br><span class="line">        timer_-&gt;<span class="built_in">add</span>(fd, timeoutMS_, std::<span class="built_in">bind</span>(&amp;WebServer::CloseConn_, <span class="keyword">this</span>, &amp;users_[fd]));<span class="comment">//绑定参数，this是第一个参数，client是</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向内核事件表注册</span></span><br><span class="line">    epoller_-&gt;<span class="built_in">AddFd</span>(fd, EPOLLIN | connEvent_);</span><br><span class="line">    <span class="comment">//设置非阻塞</span></span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(fd);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Client[%d] in!&quot;</span>, users_[fd].<span class="built_in">GetFd</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealListen_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">accept</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);<span class="comment">//尝试通过listen socket连接，获取地址</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span>;&#125;<span class="comment">//连接失败，即没有数据了，返回</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(HttpConn::userCount &gt;= MAX_FD) &#123;<span class="comment">//请求过多，无法连接</span></span><br><span class="line">            <span class="built_in">SendError_</span>(fd, <span class="string">&quot;Server busy!&quot;</span>);<span class="comment">//向socket发送错误信息</span></span><br><span class="line">            <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Clients is full!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AddClient_</span>(fd, addr);<span class="comment">//添加连接</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(listenEvent_ &amp; EPOLLET);<span class="comment">//ET模式要把事件全部处理，应该就是把socket缓冲区的地址全部读完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//处理读事件</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);<span class="comment">//有响应就刷新时间</span></span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client));<span class="comment">//唤醒一个线程处理读事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::DealWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//处理写事件</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="built_in">ExtentTime_</span>(client);</span><br><span class="line">    threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnWrite_, <span class="keyword">this</span>, client));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::ExtentTime_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//重新设置时间</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="keyword">if</span>(timeoutMS_ &gt; <span class="number">0</span>) &#123; timer_-&gt;<span class="built_in">adjust</span>(client-&gt;<span class="built_in">GetFd</span>(), timeoutMS_); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnRead_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//调用读</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> readErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">read</span>(&amp;readErrno);<span class="comment">//读取数据，把数据读到缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> &amp;&amp; readErrno != EAGAIN) &#123;<span class="comment">//如果读不到数据且不是因为缓冲区空了，那么就异常，关闭连接</span></span><br><span class="line">        <span class="built_in">CloseConn_</span>(client);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OnProcess</span>(client);<span class="comment">//读完了就解析请求数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnProcess</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//解析数据</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">process</span>()) &#123;<span class="comment">//如果解析成功了，无论是正常请求还是bad请求，通知内核事件输出，即修改成out</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//缓冲区一点数据都没收到，，继续读</span></span><br><span class="line">        epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::OnWrite_</span><span class="params">(HttpConn* client)</span> </span>&#123;<span class="comment">//调用写</span></span><br><span class="line">    <span class="built_in">assert</span>(client);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> writeErrno = <span class="number">0</span>;</span><br><span class="line">    ret = client-&gt;<span class="built_in">write</span>(&amp;writeErrno);<span class="comment">//传输数据</span></span><br><span class="line">    <span class="keyword">if</span>(client-&gt;<span class="built_in">ToWriteBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 传输完成 */</span></span><br><span class="line">        <span class="keyword">if</span>(client-&gt;<span class="built_in">IsKeepAlive</span>()) &#123;<span class="comment">//如果是keep</span></span><br><span class="line">            <span class="built_in">OnProcess</span>(client);<span class="comment">//改成in</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;<span class="comment">//传输数据小于0</span></span><br><span class="line">        <span class="keyword">if</span>(writeErrno == EAGAIN) &#123;<span class="comment">//如果是socket的发送缓存被占满，要继续写</span></span><br><span class="line">            <span class="comment">/* 继续传输 */</span></span><br><span class="line">            epoller_-&gt;<span class="built_in">ModFd</span>(client-&gt;<span class="built_in">GetFd</span>(), connEvent_ | EPOLLOUT);<span class="comment">//总是告知继续写，除非写完</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseConn_</span>(client);<span class="comment">//成功且不keep就关掉连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create listenFd */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::InitSocket_</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化监听窗口，注入内核事件表</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="keyword">if</span>(port_ &gt; <span class="number">65535</span> || port_ &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Port:%d error!&quot;</span>,  port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr.sin_family = AF_INET;<span class="comment">//AF_INET 表示 IPv4 地址</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//本函数将一个32位数从主机字节顺序转换成网络字节顺序，ANY泛指本机，监听所有网卡</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(port_);<span class="comment">////将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linger</span> optLinger = &#123; <span class="number">0</span> &#125;;<span class="comment">//设置tcp连接断开方式，默认是优雅退出即全0</span></span><br><span class="line">    <span class="keyword">if</span>(openLinger_) &#123;</span><br><span class="line">        <span class="comment">/* 优雅关闭: 直到所剩数据发送完毕或超时 */</span></span><br><span class="line">        optLinger.l_onoff = <span class="number">1</span>;</span><br><span class="line">        optLinger.l_linger = <span class="number">1</span>;<span class="comment">//在close前延迟linger的时间，这段时间是优雅退出时间，超时则返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenFd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//开启一个连接，返回描述符，SOCK_STREAM基于TCP</span></span><br><span class="line">    <span class="keyword">if</span>(listenFd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create socket error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_LINGER, &amp;optLinger, <span class="built_in">sizeof</span>(optLinger));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Init linger error!&quot;</span>, port_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 端口复用 */</span></span><br><span class="line">    <span class="comment">/* 只有最后一个套接字会正常接收数据。 */</span></span><br><span class="line">    <span class="comment">//打开地址复用功能，允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</span></span><br><span class="line">    <span class="comment">//optval=true：如果在已经处于 ESTABLISHED状态下的socket调用closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket</span></span><br><span class="line">    <span class="comment">//参考：https://blog.csdn.net/c_base_jin/article/details/94353956</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(listenFd_, SOL_SOCKET, SO_REUSEADDR, (<span class="type">const</span> <span class="type">void</span>*)&amp;optval, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;set socket setsockopt error !&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(listenFd_, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));<span class="comment">//设置完就可以bind一个地址了，监听所有网卡</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Bind Port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。</span></span><br><span class="line">    <span class="comment">//socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenFd_, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Listen port:%d error!&quot;</span>, port_);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = epoller_-&gt;<span class="built_in">AddFd</span>(listenFd_,  listenEvent_ | EPOLLIN);<span class="comment">//添加事件</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Add listen error!&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(listenFd_);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当 listenfd 设置成阻塞模式（默认行为，无需额外设置）时，如果连接 pending 队列中有需要处理的连接，accept 函数会立即返回，</span></span><br><span class="line"><span class="comment">    	否则会一直阻塞下去，直到有新的连接到来。</span></span><br><span class="line"><span class="comment">	当 listenfd 设置成非阻塞模式，无论连接 pending 队列中是否有需要处理的连接，accept 都会立即返回，不会阻塞。</span></span><br><span class="line"><span class="comment">		如果有连接，则 accept 返回一个大于 0 的值，这个返回值即是我们上文所说的 clientfd；如果没有连接，accept 返回值小于 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">SetFdNonblock</span>(listenFd_);<span class="comment">//设置为非阻塞</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Server port:%d&quot;</span>, port_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为</span></span><br><span class="line"><span class="comment">的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，</span></span><br><span class="line"><span class="comment">或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span></span><br><span class="line"><span class="comment">//F_GETFL：获取文件打开方式的标志，标志值含义与open调用一致，然后或上非阻塞标志</span></span><br><span class="line"><span class="comment">//F_SETFL：设置文件打开方式标志为arg指定方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WebServer::SetFdNonblock</span><span class="params">(<span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(fd &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fcntl</span>(fd, F_SETFL, <span class="built_in">fcntl</span>(fd, F_GETFL, <span class="number">0</span>) | O_NONBLOCK);<span class="comment">//这里感觉是F_GETFL不是F_GETFD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>config里啥东西没有，主要也没啥好配的，就直接main里面启动。服务器顶层的isclose没作用，ctrl+c终止进程，资源由操作系统自动回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-18</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;server/webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 守护进程 后台运行 */</span></span><br><span class="line">    <span class="comment">//daemon(1, 0); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器端口1316，监听和连接事件都是ET模式，连接1分钟无动作就关闭，linger全0是优雅退出</span></span><br><span class="line">    <span class="comment">//mysql端口3306，用户名、密码、数据库名称</span></span><br><span class="line">    <span class="comment">//连接池数量（同时维持连接的个数）、...</span></span><br><span class="line">    <span class="function">WebServer <span class="title">server</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">1316</span>, <span class="number">3</span>, <span class="number">60000</span>, <span class="literal">false</span>,             <span class="comment">/* 端口 ET模式 timeoutMs 优雅退出  */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">3306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;webserver&quot;</span>, <span class="comment">/* Mysql配置 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="number">12</span>, <span class="number">6</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="number">1024</span>)</span></span>;             <span class="comment">/* 连接池数量 线程池数量 日志开关 日志等级 日志异步队列容量 */</span></span><br><span class="line">    server.<span class="built_in">Start</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="压力测试截图"><a href="#压力测试截图" class="headerlink" title="压力测试截图"></a>压力测试截图</h1><p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%953.png" alt="image-20220925220717478"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/09/TinyWebServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/09/TinyWebServer/" class="post-title-link" itemprop="url">Follow-TinyWebServer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-09 10:00:04" itemprop="dateCreated datePublished" datetime="2022-09-09T10:00:04+08:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-23 16:18:49" itemprop="dateModified" datetime="2022-09-23T16:18:49+08:00">2022-09-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GitHub上的项目：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)</a>，这篇博客记录一下follow的日程和更详细的注解和逻辑思考。整个工程作者没有透露完成顺序，我就根据自己的理解从一个部分开始逐步往下。</p>
<h1 id="第一站"><a href="#第一站" class="headerlink" title="第一站"></a>第一站</h1><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>服务器需要一些互斥操作，因为一些共享资源（如数据库连接池、线程池）被同时访问时会出现错误，需要互斥访问。因此互斥作为一个小的辅助功能，在前面这里先进行分析。</p>
<p>locker.h代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//for mutex</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span><span class="comment">//for sem</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem</span>(<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//阻塞等待资源，资源获取后往下执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//执行完毕，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;<span class="comment">//信号量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span><span class="comment">//取类私有成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁对象，注意它本身不是指针，当参数时要用引用传入地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pthread_mutex_destroy(&amp;m_mutex);</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">timewait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex, <span class="keyword">struct</span> timespec t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//static pthread_mutex_t m_mutex;</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;<span class="comment">//条件变量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h3><p>互斥锁主要是让一个资源锁起来，同一时间只能有一个活动在使用这个资源，其他的请求全部被卡住。项目中具体的实现不是用零散的mutex类的函数操作，而是用一个locker类封装好，构造和析构函数分别执行初始化和注销，这使得用户不需要手动去做（RAII思想，同时可以简化API较长的函数名，其他两个类也是这样的思想）。</p>
<ul>
<li>int pthread_mutex_init(<strong>pthread_mutex_t</strong> *restrict mutex,const <strong>pthread_mutexattr_t</strong> *restrict attr);<ul>
<li><strong>pthread_mutex_init</strong>() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空(<strong>NULL</strong>)，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</li>
<li><strong>pthread_mutexattr_init</strong>() 函数成功完成之后会返回零，其他任何返回值都表示出现了错误。函数成功执行后，互斥锁被初始化为未锁住态。</li>
</ul>
</li>
<li>*<em>pthread_mutex_destroy()*<em>用于注销一个互斥锁，API定义如下：int <strong>pthread_mutex_destroy(pthread_mutex_t</strong> *<em>mute</em>x*</em>)*</em><ul>
<li>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。</li>
</ul>
</li>
<li>int pthread_mutex_lock(pthread_mutex_t *mutex)：锁住，返回值为0成功；</li>
<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)：解锁，返回值为0成功；</li>
</ul>
<p>简单来说：</p>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
<h3 id="信号量sem"><a href="#信号量sem" class="headerlink" title="信号量sem"></a>信号量sem</h3><p>信号量有数值大小，主要用来管理一个buffer，写入和读出都要满足buffer的边界，同样的取用资源也要在资源池满足的情况下进行。</p>
<ul>
<li>int sem_init(sem_t *sem, int pshared, unsigned int value);<ul>
<li>该函数初始化由 sem 指向的信号对象，并给它一个初始的整数值 value。pshared 控制信号量的类型，值为 0 代表该信号量用于多线程间的同步，值如果大于 0 表示可以共享，用于多个相关进程间的同步：参数 pshared &gt; 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量</li>
</ul>
</li>
<li>int sem_destroy(sem_t *sem);<ul>
<li>该函数用于对用完的信号量的清理。</li>
</ul>
</li>
<li>int sem_wait(sem_t *sem); <ul>
<li>sem_wait 是一个阻塞的函数，测试所指定信号量的值，它的操作是原子的。若 sem value &gt; 0，则该信号量值减去 1 并立即返回。若sem value &#x3D; 0，则阻塞直到 sem value &gt; 0，此时立即减去 1，然后返回。函数成功返回0，错误的话信号量的值不改动，返回-1。</li>
<li>还有另一个函数：sem_trywait 函数是非阻塞的函数，它会尝试获取获取 sem value 值，如果 sem value &#x3D; 0，不是阻塞住，而是直接返回一个错误 EAGAIN。</li>
</ul>
</li>
<li>int sem_post(sem_t *sem);<ul>
<li>把指定的信号量 sem 的值加 1，唤醒正在等待该信号量的任意线程。成功时返回 0；错误时，信号量的值没有更改，-1 被返回。</li>
</ul>
</li>
</ul>
<p>简单来说:</p>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
<h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><ul>
<li><p>int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。</li>
</ul>
</li>
<li><p>int pthread_cond_destroy(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。释放条件变量。需要注意的是只有在没有线程在该条件变量上等待时，才可以注销条件变量，否则会返回EBUSY。同时Linux在实现条件变量时，并没有为条件变量分配资源，所以在销毁一个条件变量时，只要注意该变量是否仍有等待线程即可。</li>
</ul>
</li>
<li><p>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);</p>
<ul>
<li><p>返回值：函数成功返回0；任何其他返回值都表示错误。</p>
</li>
<li><p>为什么要关联一个mutex呢？无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。</p>
<ul>
<li>pthread_cond_wait(cond, mutex)的功能有3个：<ul>
<li>调用者线程首先释放mutex</li>
<li>然后阻塞，等待被别的线程唤醒</li>
<li>当调用者线程被唤醒后，调用者线程会再次获取mutex</li>
</ul>
</li>
<li>pthread_cond_wait(cond)的功能只有1个：<ul>
<li>调用者线程阻塞，等待被别的线程唤醒。</li>
</ul>
</li>
</ul>
<p>这里首先给一个简洁的回答：</p>
<ul>
<li><strong>通常的应用场景下，当前线程执行pthread_cond_wait时，处于临界区访问共享资源，存在一个mutex与该临界区相关联，这是理解pthread_cond_wait带有mutex参数的关键</strong></li>
<li>当前线程执行pthread_cond_wait前，已经获得了和临界区相关联的mutex；<strong>因为缺少其他条件</strong>，执行pthread_cond_wait会阻塞，但是在进入阻塞状态前，必须释放已经获得的mutex，让其它线程能够进入临界区</li>
<li>当前线程执行pthread_cond_wait后，阻塞等待的条件满足，条件满足时会被唤醒；被唤醒后，仍然处于临界区，因此被唤醒后必须再次获得和临界区相关联的mutex</li>
</ul>
<p>综上，调用pthread_cond_wait时，线程总是位于某个临界区，该临界区与mutex相关，pthread_cond_wait需要带有一个参数mutex，用于释放和再次获取mutex。</p>
</li>
</ul>
</li>
<li><p>int pthread_cond_timedwait(pthread_cond_t *cv,pthread_mutex_t *mp, const struct timespec * abstime);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>pthread_cond_timedwait()用于等待一个条件变量，等待条件变量的同时可以设置等待超时。这是一个非常有用的功能，如果不想一直等待某一条件变量，就可以使用这个函数。函数到了一定的时间，即使条件未发生也会解除阻塞。</li>
<li>条件变量默认使用的时间是CLOCK_REALTIME。通过clock_gettime()接口获取时间。</li>
</ul>
</li>
<li><p>int pthread_cond_signal(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态，继续执行。如果没有线程处在阻塞等待状态，pthread_cond_signal也会成功返回。</li>
</ul>
</li>
<li><p>int pthread_cond_broadcast(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cv被用来指定这个条件变量。当没有线程阻塞在这个条件变量上时，pthread_cond_broadcast函数无效。</li>
</ul>
</li>
</ul>
<h2 id="线程池threadpool"><a href="#线程池threadpool" class="headerlink" title="线程池threadpool"></a>线程池threadpool</h2><p>使用线程有动态方法和静态方法，动态方法是当一个工作需要完成时创建一个线程，当工作做完后释放线程。这种方式对资源的利用率高一些，但是耗费时间，因为要新创建、销毁线程。静态方法是使用线程池先创建好一系列等待请求的线程，当一个工作到来时直接分配空闲线程，工作完成后放回线程池。</p>
<p>线程池的代码放在threadpool.h中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../CGImysql/sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T *request, <span class="type">int</span> state)</span></span>;<span class="comment">//两种append，应该对应了不同的T的操作，实际上感觉重载就可以了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append_p</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;<span class="comment">//静态成员函数，是一个回调函数，后面会说明为什么要设置成静态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number;        <span class="comment">//线程池中的线程数，即可同时工作的数量</span></span><br><span class="line">    <span class="type">int</span> m_max_requests;         <span class="comment">//请求队列中允许的最大请求数，即最多同时等待的数量</span></span><br><span class="line">    <span class="type">pthread_t</span> *m_threads;       <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">    std::list&lt;T *&gt; m_workqueue; <span class="comment">//请求队列</span></span><br><span class="line">    locker m_queuelocker;       <span class="comment">//保护请求队列的互斥锁</span></span><br><span class="line">    sem m_queuestat;            <span class="comment">//是否有任务需要处理</span></span><br><span class="line">    connection_pool *m_connPool;  <span class="comment">//数据库</span></span><br><span class="line">    <span class="type">int</span> m_actor_model;          <span class="comment">//模型切换</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( <span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : <span class="built_in">m_actor_model</span>(actor_model),<span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>),<span class="built_in">m_connPool</span>(connPool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_number &lt;= <span class="number">0</span> || max_requests &lt;= <span class="number">0</span>)    <span class="comment">//一些不合理请求的判断</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];	<span class="comment">//线程池的实作是一个线程数组</span></span><br><span class="line">    <span class="keyword">if</span> (!m_threads)	<span class="comment">//请求失败则m_threads是一个nullptr</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i)</span><br><span class="line">    &#123;	<span class="comment">//初始化线程池里的线程，返回值不为0说明失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>)<span class="comment">//m_threads+i与m_threads[i]没区别</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源，具体在后面有写</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(m_threads[i]))<span class="comment">//感觉这个if和上面那个if的风格好不一样...</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>()<span class="comment">//析构，new出来的delete掉</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向请求队列添加请求</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T *request, <span class="type">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//多线程状态下工作，要互斥，否则request和list的修改会出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)<span class="comment">//超出最大请求，非阻塞返回。如果要阻塞的话，可以用一个full信号量控制</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    request-&gt;m_state = state;<span class="comment">//赋予状态，指读还是写</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);<span class="comment">//添加队列</span></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();<span class="comment">//信号量加一，告知线程池有任务在等待处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和上面一样</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append_p</span>(T *request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//worker函数，传递参数给线程，然后调用真正的run函数工作。静态成员类外定义不用static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> *threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span> *arg)<span class="comment">//void 指针可以指向任意类型的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    threadpool *pool = (threadpool *)arg;<span class="comment">//arg = this，将参数强转为线程池类，调用成员方法</span></span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();<span class="comment">//调用实例的run函数</span></span><br><span class="line">    <span class="keyword">return</span> pool;<span class="comment">//实际上run一直运行，估计不会return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//为什么是while呢？因为每个线程其实在不断的运行，如果有任务就取出来做，没有就wait阻塞</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();<span class="comment">//阻塞，要等有任务即前面post信号量了，才往下做</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//取出任务，要对list操作，那么要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_workqueue.<span class="built_in">empty</span>())<span class="comment">//感觉没必要，前面用wait其实已经判断了工作池buffer了，有任务才会往下</span></span><br><span class="line">        &#123;<span class="comment">//m_workqueue的大小应该和m_queuestat信号量的大小绑定了（根据append函数来看）</span></span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T *request = m_workqueue.<span class="built_in">front</span>();<span class="comment">//取第一个请求</span></span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();<span class="comment">//pop</span></span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁，让下一个线程可以操作list</span></span><br><span class="line">        <span class="keyword">if</span> (!request)<span class="comment">//如果请求实际上是null</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//切换模式，reactor==1，proactor==0</span></span><br><span class="line">        <span class="comment">//非阻塞同步工作模式，读写均需要在线程里工作，调用read和write，并且进行最后的process业务逻辑处理。</span></span><br><span class="line">        <span class="comment">//非阻塞是指有数据才进行，但数据处理过程仍在线程里执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_actor_model)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == request-&gt;m_state)<span class="comment">//读</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">read_once</span>())<span class="comment">//如果成功则不关闭定时器，不用关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;request-&gt;mysql, m_connPool)</span></span>;</span><br><span class="line">                    request-&gt;<span class="built_in">process</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//不成功要关闭连接和定时器</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//写</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">write</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//模拟proactor模式的IO在主循环处理（是同步的），线程只需要处理业务逻辑即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            connectionRAII <span class="built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);</span><br><span class="line">            request-&gt;<span class="built_in">process</span>();<span class="comment">//处理业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>线程池类使用模板，目前还没看出作用，猜测是后面会用于多种不同资源的分配使用，如处理http连接、处理数据库请求等等。</li>
<li>int<code> </code>pthread_create(pthread_t *tidp,<code> </code>const<code> </code>pthread_attr_t *attr,(<code> </code>void<code> </code>*)(*start_rtn)(<code> </code>void<code> </code>*),<code> </code>void<code> </code>*arg);<ul>
<li>第一个参数为指向线程 标识符的指针。</li>
<li>第二个参数用来设置线程属性。</li>
<li>第三个参数是线程运行函数的起始地址（函数指针）。</li>
<li>最后一个参数是运行函数的参数。</li>
<li>若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</li>
</ul>
</li>
<li>int pthread_detach(pthread_t thread);  成功：0；失败：错误号<ul>
<li>使用pthread_create创建的线程有两种状态：joinable和unjoinable。默认是joinable 状态。</li>
<li>线程创建后在线程中调用 pthread_detach, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。</li>
<li>pthread_detach()和pthread_join()就是控制子线程回收资源的两种不同的方式。同一进程间的线程具有共享和独立的资源，其中共享的资源有堆、全局变量、静态变量、文件等公用资源。而独享的资源有栈和寄存器，这两种方式就是决定子线程结束时如何回收独享的资源。<ul>
<li>如果是joinable状态，则该线程结束后（通过pthread_exit结束或者线程执行体任务执行完毕）不会释放线程所占用堆栈和线程描述符（总计8K多）等资源，除非在主线程调用了pthread_join函数之后才会释放。pthread_join函数一般应用在主线程需要等待子线程结束后才继续执行的场景。(pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。 )</li>
<li>如果是unjoinable状态，则该线程结束后会自动释放占用资源。实现方式是在创建时指定属性，或者在线程执行体的最开始处添加一行：pthread_detach(pthread_self())；不会阻塞，调用它后，线程运行结束后会自动释放资源,后者非常方便。</li>
</ul>
</li>
<li>总结<ul>
<li>pthread_detach()即主线程与子线程分离，两者相互不干涉，子线程结束同时子线程的资源自动回收。</li>
<li>pthread_join()即是子线程合入主线程，主线程会一直阻塞，直到子线程执行结束，然后回收子线程资源，并继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作流程</strong>：<ul>
<li>构造函数初始化线程池：创建线程和分离线程状态</li>
<li>析构函数销毁线程池</li>
<li>append函数互斥地向list添加请求，并post信号量</li>
<li>一个线程对应一个worker，worker函数调用run。</li>
<li>run函数从list互斥地获得请求并工作，不断循环</li>
</ul>
</li>
<li>worker函数是一个成员函数，那么必须是一个静态的。它是一个回调函数，回调函数是通过指针调用的函数，最常使用的回调函数就是在创建线程时（pthread_create），以一个函数指针以及传递给这个函数多个参数来调用线程函数来创建线程。那么一般的类成员函数是不能用作回调函数的，因为在使用回调函数时，会传递指定的符合回调函数声明的的参数给回调函数，而类成员函数隐式包含一个this指针参数，所以把类成员函数当作回调函数编译时会因为参数不匹配会出错（回调后多了个this，与声明不一致）。<ul>
<li>静态成员函数就没有这个问题，里面没有this指针。</li>
</ul>
</li>
<li>那么为什么要用worker间接调用run函数呢？run设计成静态的直接调用不行吗？<ul>
<li>答案是不太方便，因为静态成员函数只能访问静态成员数据、其他静态成员和类外部的函数，因为没有this指针。不过我们这里手动传入了this指针使得它可以调用run成员函数。</li>
<li>this指针只能在类内部使用而不能在外部使用。可以访问类中所有public、private、protect的成员函数和变量。this指针是指向对象的实例，所以只有当对象被创建时this指针才有效。</li>
<li>同一个模板类的不同实例共享静态成员函数，不同实例有不同的资源，这导致静态成员函数不能访问那些实例各有的资源，因为不知道要访问哪个。而run要操作不同实例的list等等资源，通过共享的worker使用从线程传入的this指针操作各个实例的run函数，run就能操作自己这个实例的资源了。但如果run是静态的，即使通过手动传入this参数，run里面所有的资源都要this-&gt;一下，太不方便了。</li>
<li>因此，最好的方式就是静态成员函数通过this指针调用成员函数，这个成员函数就可以很方便地访问类实例的资源了（说白了就是使用资源不用this-&gt;了）。</li>
</ul>
</li>
</ul>
<h1 id="第二站"><a href="#第二站" class="headerlink" title="第二站"></a>第二站</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>后面会用到单例模式，这里先详解一下，参考了许多文章。</p>
<h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式。</p>
<h3 id="为什么要用单例模式"><a href="#为什么要用单例模式" class="headerlink" title="为什么要用单例模式?"></a>为什么要用单例模式?</h3><p><strong>1、单例模式节省公共资源</strong></p>
<p>比如：大家都要喝水，但是没必要每人家里都打一口井是吧，通常的做法是整个村里打一个井就够了，大家都从这个井里面打水喝。</p>
<p>对应到我们计算机里面，像日志管理、打印机、<strong>数据库连接池</strong>、应用配置。</p>
<p><strong>2、单例模式方便控制</strong></p>
<p>就像日志管理，如果多个人同时来写日志，你一笔我一笔那整个日志文件都乱七八糟，如果想要控制日志的正确性，那么必须要对关键的代码进行上锁，只能一个一个按照顺序来写，而单例模式只有一个人来向日志里写入信息方便控制，避免了这种多人干扰的问题出现。</p>
<h3 id="实现单例模式的思路"><a href="#实现单例模式的思路" class="headerlink" title="实现单例模式的思路"></a>实现单例模式的思路</h3><p><strong>1.</strong> <strong>构造私有:</strong></p>
<p>如果要保证一个类不能多次被实例化，那么我肯定要<strong>阻止对象被new</strong> 出来，所以需要把<strong>类的所有构造方法私有化</strong>。</p>
<p><strong>2.以静态方法返回实例</strong>。</p>
<p>因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</p>
<p><strong>3.确保对象实例只有一个</strong>。</p>
<p>只对类进行一次实例化，以后都直接获取第一次实例化的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">//确保对象实例只有一个。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="comment">//构造方法私有</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//以静态方法返回实例</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里类的实例在类初始化的时候已经生成，不再进行第二次实例化了，而外界只能通过SingleCase.getInstance()方法来获取SingleCase对象， 所以这样就保证整个系统只能获取一个类的对象实例。</p>
<h3 id="单例模式的两种实现模式"><a href="#单例模式的两种实现模式" class="headerlink" title="单例模式的两种实现模式"></a>单例模式的两种实现模式</h3><p>饿汉模式：就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：简单</span><br><span class="line">缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// C++98 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="comment">// or</span></span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">// 在程序入口之前就完成单例对象的初始化</span></span><br></pre></td></tr></table></figure>

<p>如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。</p>
<hr>
<p>懒汉模式：等到用的的时候程序再创建实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</span><br><span class="line">缺点：复杂 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意多线程环境下一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">			m_mtx.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">				m_pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			m_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CGarbo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CGarbo</span>()&#123;</span><br><span class="line">			<span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">				<span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">	<span class="type">static</span> CGarbo Garbo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="type">static</span> Singleton* m_pInstance; <span class="comment">// 单例对象指针</span></span><br><span class="line">	<span class="type">static</span> mutex m_mtx; <span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">Singleton::CGarbo Garbo;</span><br><span class="line">mutex Singleton::m_mtx;</span><br></pre></td></tr></table></figure>

<p>添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">CSingleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton &amp;);</span><br><span class="line">    CSingleton &amp; <span class="keyword">operator</span> = (<span class="type">const</span> CSingleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> CSingleton instance;   <span class="comment">//局部静态变量，在这个局部静态函数销毁才销毁，也就是当程序结束才销毁</span></span><br><span class="line">		<span class="keyword">return</span> &amp;instance;<span class="comment">//不管怎么getinstance，都只定义一次instance，返回的都是同一个实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用局部静态变量是非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。</p>
<h2 id="sql数据库连接"><a href="#sql数据库连接" class="headerlink" title="sql数据库连接"></a>sql数据库连接</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>数据库连接的头文件声明了很多信息，我们先分析头文件的逻辑，再去看定义的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CONNECTION_POOL_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONNECTION_POOL_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">MYSQL *<span class="title">GetConnection</span><span class="params">()</span></span>;				 <span class="comment">//获取数据库连接</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ReleaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">//释放连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>;					 <span class="comment">//获取空闲连接数目</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>;					 <span class="comment">//销毁所有连接</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">connection_pool</span>();</span><br><span class="line">	~<span class="built_in">connection_pool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_MaxConn;  <span class="comment">//最大连接数</span></span><br><span class="line">	<span class="type">int</span> m_CurConn;  <span class="comment">//当前已使用的连接数</span></span><br><span class="line">	<span class="type">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">	locker lock;<span class="comment">//互斥锁</span></span><br><span class="line">	list&lt;MYSQL *&gt; connList; <span class="comment">//连接池</span></span><br><span class="line">	sem reserve;<span class="comment">//信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_url;			 <span class="comment">//主机地址</span></span><br><span class="line">	string m_Port;		 <span class="comment">//数据库端口号</span></span><br><span class="line">	string m_User;		 <span class="comment">//登陆数据库用户名</span></span><br><span class="line">	string m_PassWord;	 <span class="comment">//登陆数据库密码</span></span><br><span class="line">	string m_DatabaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">	<span class="type">int</span> m_close_log;	<span class="comment">//日志开关</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connectionRAII</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双指针对MYSQL *con修改。数据库连接本身是指针类型，所以参数需要通过双指针才能对其进行修改。</span></span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;<span class="comment">//这个RAII类拥有一个MYSQL连接</span></span><br><span class="line">	connection_pool *poolRAII;<span class="comment">//且要有一个连接池指针指向那个单例对象，调用释放函数把MYSQL连接释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件里主要是对connection_pool这个类的功能进行了声明：</p>
<ul>
<li>四种主要功能：获取数据库连接、获取空闲连接数目、释放连接、销毁所有连接。四个功能函数实际上从返回值就可以看出区别和要做什么事。</li>
<li>数据库初始化init函数，它通过地址、端口、用户名密码、使用的数据库名称来进行数据库的连接。</li>
<li>单例模式，把构造函数放private，使得只能用静态成员函数在类中创建类对象；把析构函数放private，使得无法在外部delete类对象，只能用内部的成员函数delete this，因为内部成员函数才能访问私有的析构函数。不过这里的单例模式不用new，因此也就没有对应的delete函数。</li>
</ul>
<p>还有一个connectionRAII类，这个类对连接池对象进行RAII式的管理，前面可以看到有个释放连接的功能，我们不想手动释放，就可以在这个类的析构函数里释放，具体看实现就好了。</p>
<ul>
<li>为什么con是双指针，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/bin510729392/article/details/51476327">c&#x2F;c++向函数传递指针并修改其指向的问题_AlanChaw292的博客-CSDN博客_c++改变指针指向</a>。大概的意思就是，如果是单指针传进来，编译器也会为形参做一个备份，如传入一个p，会备份一个p1（我们实际上使用的是p1，跟值传递是一个意思），p和p1的值相同，都指向对象的地址。我们当然可以使用p1来修改指向的值，但无法通过修改p1修改p（就像形参无法影响实参），也就是说传入的指针不能修改指针本身的地址（不能修改指针的指向，不是不允许，而是没意义）。这种时候，就需要用双指针，指向我们想修改的指针的地址，这样就行了，那篇博客讲的很清楚。</li>
</ul>
<h3 id="cpp实现"><a href="#cpp实现" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>话不多说，先上源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">connection_pool::<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;	<span class="comment">//类内成员初始化</span></span><br><span class="line">	m_CurConn = <span class="number">0</span>;<span class="comment">//已使用的是0</span></span><br><span class="line">	m_FreeConn = <span class="number">0</span>;<span class="comment">//空闲的还不知道，但是没有init时就是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span><span class="comment">//静态成员函数，单例模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> connection_pool connPool;<span class="comment">//创建静态的连接池对象，只定义一次，每次调用都返回它</span></span><br><span class="line">	<span class="keyword">return</span> &amp;connPool;<span class="comment">//且是通过指针（地址）返回，不会导致拷贝构造</span></span><br><span class="line">    <span class="comment">//这个静态对象销毁是在静态成员函数销毁时销毁，而这个函数在程序结束才销毁...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">//给类成员赋值，这些类成员是为了以后访问连接池对象可以获取信息</span></span><br><span class="line"></span><br><span class="line">	m_url = url;</span><br><span class="line">	m_Port = Port;</span><br><span class="line">	m_User = User;</span><br><span class="line">	m_PassWord = PassWord;</span><br><span class="line">	m_DatabaseName = DBName;</span><br><span class="line">	m_close_log = close_log;</span><br><span class="line">    m_MaxConn = m_FreeConn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)<span class="comment">//一共（最多）可以有maxconn个连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">		con = <span class="built_in">mysql_init</span>(con);<span class="comment">//分配并初始化一个新对象</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//NULL说明没有足够的内存分配</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//前面的init初始化了一个mysql的数据结构，现在real connect进行真正的连接</span></span><br><span class="line">		con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//连接失败返回NULL</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		connList.<span class="built_in">push_back</span>(con);<span class="comment">//成功则在连接池(list)里添加</span></span><br><span class="line">		++m_FreeConn;<span class="comment">//空闲连接+1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reserve = <span class="built_in">sem</span>(m_FreeConn);<span class="comment">//给这个信号量赋值，实际上可以在for循环里post，不过逻辑有点怪就是了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">connection_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL *con = <span class="literal">NULL</span>;<span class="comment">//创建一个指针，将要指向连接池已经创建的连接</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())<span class="comment">//没有就没有了，不阻塞</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">wait</span>();<span class="comment">//有的话就让信号量减一，不过既然前面return了，不阻塞了还有信号量干啥嘞</span></span><br><span class="line">	</span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//互斥访问这个连接，修改连接池（连接池是共享的），以及互斥修改一些表示buffer大小数据</span></span><br><span class="line"></span><br><span class="line">	con = connList.<span class="built_in">front</span>();</span><br><span class="line">	connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">	--m_FreeConn;<span class="comment">//连接池容量buffer-1</span></span><br><span class="line">	++m_CurConn;<span class="comment">//连接池buffer使用+1</span></span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection_pool::ReleaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//回收连接，放回连接池，既然访问连接池这个公共资源，要互斥锁住</span></span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);<span class="comment">//放回</span></span><br><span class="line">	++m_FreeConn;</span><br><span class="line">	--m_CurConn;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">post</span>();<span class="comment">//信号量+1，越发感觉信号量和freeconn是一个东西？以及connlist.size()...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//主线程要关闭连接池，要等连接池操作完再说，不然在销毁过程中可能又同时放回，会混乱</span></span><br><span class="line">    			<span class="comment">//且其他线程在获取连接时，也要等连接池销毁的操作，不然连接池都销毁了还拿到了一个连接</span></span><br><span class="line">	<span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			MYSQL *con = *it;</span><br><span class="line">			<span class="built_in">mysql_close</span>(con);<span class="comment">//一个一个关闭掉，但mysql对象、结构还在list里</span></span><br><span class="line">		&#125;</span><br><span class="line">		m_CurConn = <span class="number">0</span>;<span class="comment">//这些遍历的修改也要在临界区嘛</span></span><br><span class="line">		m_FreeConn = <span class="number">0</span>;</span><br><span class="line">		connList.<span class="built_in">clear</span>();<span class="comment">//移除所有元素，把那些关闭了的连接都删掉</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前空闲的连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connection_pool::GetFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_FreeConn;<span class="comment">//这个就不锁了，没什么意义，就放回“当下”的值就好了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection_pool::~<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestroyPool</span>();<span class="comment">//析构连接池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个RAII类是针对单个sql连接的，具体怎么使用还要看实际代码，</span></span><br><span class="line"><span class="comment">//注意这个双指针修改sql连接本身的值（指向连接的地址），使这个连接可以更改指向，（可能从null）指向连接池的可用的连接。</span></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">	*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">	</span><br><span class="line">	conRAII = *SQL;<span class="comment">//这个RAII类本身也要存一个备份，使得调用析构函数释放连接时知道要释放的连接的地址</span></span><br><span class="line">	poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">	poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);<span class="comment">//析构函数：释放连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL *mysql_init(MYSQL *mysql)<ul>
<li>分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。</li>
<li>返回值：初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。</li>
</ul>
</li>
<li>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)<ul>
<li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。</li>
<li>参数：<ul>
<li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。</li>
<li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP&#x2F;IP连接到服务器。</li>
<li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。</li>
<li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li>
<li>“db”是数据库名称。如果db为NULL，连接会将默认的数据库设为该值。</li>
<li>如果“port”不是0，其值将用作TCP&#x2F;IP连接的端口号。注意，“host”参数决定了连接的类型。</li>
<li>如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。</li>
<li>client_flag的值通常为0，其他标志可以实现特定的功能</li>
</ul>
</li>
<li>返回值：如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。</li>
</ul>
</li>
<li>void mysql_close(MYSQL *mysql)<ul>
<li>关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。</li>
</ul>
</li>
<li>string.c_str()：<ul>
<li>const char *c_str();</li>
<li>c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同。</li>
<li>这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。</li>
</ul>
</li>
</ul>
<h1 id="第三站"><a href="#第三站" class="headerlink" title="第三站"></a>第三站</h1><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>这里可以看看作者的讲解先理解一下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg">最新版Web服务器项目详解 - 09 日志系统（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/f-ujwFyCe1LZa3EB561ehA">最新版Web服务器项目详解 - 10 日志系统（下） (qq.com)</a></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>写入日志有同步的写入和异步的写入方式，同步的方式是当产生日志时就写入，主线程工作推迟；异步的写入方式是使用一个日志线程来管理，“写入日志”这个任务就需要有地方放，因此就要用一个阻塞队列来存放任务。为什么是阻塞的呢，日志线程有多个吗？实际上日志线程只有一个，但其他线程可以有多个，这就是一个多生产者–单消费者的模型。因此常规的解法就是用互斥锁+buffer信号量的组合。但这个阻塞队列还添加了超时处理的功能，信号量就需要改成条件变量，条件变量我没怎么使用过，之后回过头再整理一下，不过具体的功能在lock那章中写了。</p>
<p>下面是阻塞队列的代码，在头文件block_queue.h中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*循环数组实现的阻塞队列，m_back = (m_back + 1) % m_max_size;  </span></span><br><span class="line"><span class="comment">*线程安全，每个操作前都要先加互斥锁，操作完后，再解锁</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCK_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="type">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[max_size];</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//剩下的操作，涉及对队列内部元素的操作（插入删除）、对队列变量的访问（size，头尾指针等），都需要互斥访问</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">block_queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array != <span class="literal">NULL</span>)<span class="comment">//少见...不过健壮（也许多余？）</span></span><br><span class="line">            <span class="keyword">delete</span> [] m_array;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否满了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">front</span><span class="params">(T &amp;value)</span><span class="comment">//以参数形式返回 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_front];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">back</span><span class="params">(T &amp;value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_back];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;<span class="comment">//不直接return，因为要加锁，return不能放锁里</span></span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_max_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往队列添加元素，需要将所有使用队列的线程先唤醒，这些线程除了等待锁，还要等待任务出现以pop，因此push要唤醒它们</span></span><br><span class="line">    <span class="comment">//在应用上，调用pop的就一个日志线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当有元素push进队列,相当于生产者生产了一个元素</span></span><br><span class="line">    <span class="comment">//若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)<span class="comment">//队列满了，赶紧让pop线程做事</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒所有在wait的线程</span></span><br><span class="line">            <span class="comment">//在wait说明之前队列空了，但怎么会从空-&gt;满呢？可能是一直被push抢了互斥锁</span></span><br><span class="line">            <span class="comment">//因此这个唤醒让那些卡在while的pop从wait解放，然后一个一个等待抢占互斥锁做事（和pop抢也和push抢）</span></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line"></span><br><span class="line">        m_size++;</span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//条件变量在临界区用，wait自身会解锁-等待唤醒-抢占锁</span></span><br><span class="line">        <span class="comment">//pop被多个线程调用，前面push都唤醒了那么这里会竞争任务，可能只有一部分线程执行了这个m_size就=0了</span></span><br><span class="line">        <span class="comment">//那么此时就要继续等待，因此用while而不是用if，if只能wait一次（这种情况是虚假唤醒）</span></span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))<span class="comment">//等待唤醒</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//wait出错就return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//条件变量被唤醒，抢到了互斥锁，且whlie正常退出，开始做事</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了超时处理</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> ms_timeout)</span><span class="comment">//可以超时多少毫秒</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//时间类下面介绍</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个纳秒</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//获取系统当前时间</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//如果要等待的话，就进去wait，注意这里不是一直等到可以调用，所以不用while</span></span><br><span class="line">        <span class="comment">//如果超时就到下面的if返回，如果没超时就被唤醒，那么会有虚假唤醒的情况，</span></span><br><span class="line">        <span class="comment">//因此下面还要if判断一下，虚假唤醒就直接返回，所以这里超时就不做、虚假唤醒也不做</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//t是前面获取的时间加上超时的时间</span></span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;<span class="comment">//取秒位</span></span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;<span class="comment">//剩下没取到的毫秒（余数）弄成纳秒（为什么是*1000）</span></span><br><span class="line">            <span class="comment">//整体时间计算是秒+纳秒</span></span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t))<span class="comment">//时间到了就不等待唤醒了，直接润</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上面润完就到这里，注意因为抢了锁，所以不可能有push，这里一定是返回的</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//正常干活</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    cond m_cond;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line">    T *m_array;<span class="comment">//队列空间</span></span><br><span class="line">    <span class="type">int</span> m_size;<span class="comment">//队列目前大小</span></span><br><span class="line">    <span class="type">int</span> m_max_size;<span class="comment">//队列大小，使用这个变量就无需额外留一个空间</span></span><br><span class="line">    <span class="type">int</span> m_front;<span class="comment">//队列头部</span></span><br><span class="line">    <span class="type">int</span> m_back;<span class="comment">//队列尾部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在C语言中可以使用函数gettimeofday()函数来得到精确时间。它的精度可以达到微妙，是C标准库的函数。</p>
<p>在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体。</p>
<p>函数执行成功后返回0，失败后返回-1，错误代码存于errno中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span>  timeval*tv,<span class="keyword">struct</span>  timezone *tz )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span>  timeval</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_sec;  <span class="comment">/*秒*/</span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_usec; <span class="comment">/*微妙*/</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">timezone</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_minuteswest;<span class="comment">/*和greenwich 时间差了多少分钟*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_dsttime;    <span class="comment">/*type of DST correction*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：在使用gettimeofday()函数时，第二个参数一般都为空，因为我们一般都只是为了获得当前时间，而不用获得timezone的数值。</p>
<h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>定义了Log类，其中使用宏来为其他程序提供接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span><span class="comment">//与宏有关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="type">void</span> *args)</span><span class="comment">//是一个worker函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();<span class="comment">//静态成员函数的调用：A::func()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size = <span class="number">8192</span>, <span class="type">int</span> split_lines = <span class="number">5000000</span>, <span class="type">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">async_write_log</span><span class="params">()</span><span class="comment">//write_log执行push任务的功能，这个函数只取任务写到文件</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line">        <span class="comment">//从阻塞队列中取出一个日志string，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))<span class="comment">//取是互斥的，写也是互斥的，但是两个锁并不相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();<span class="comment">//写入m_fp中，共享的文件空间的要锁一下</span></span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> dir_name[<span class="number">128</span>]; <span class="comment">//路径名</span></span><br><span class="line">    <span class="type">char</span> log_name[<span class="number">128</span>]; <span class="comment">//log文件名</span></span><br><span class="line">    <span class="type">int</span> m_split_lines;  <span class="comment">//日志最大行数</span></span><br><span class="line">    <span class="type">int</span> m_log_buf_size; <span class="comment">//日志缓冲区大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_count;  <span class="comment">//日志行数记录</span></span><br><span class="line">    <span class="type">int</span> m_today;        <span class="comment">//因为按天分类,记录当前时间是那一天</span></span><br><span class="line">    FILE *m_fp;         <span class="comment">//打开log的文件指针</span></span><br><span class="line">    <span class="type">char</span> *m_buf;</span><br><span class="line">    block_queue&lt;string&gt; *m_log_queue; <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="type">bool</span> m_is_async;                  <span class="comment">//是否同步标志位</span></span><br><span class="line">    locker m_mutex;</span><br><span class="line">    <span class="type">int</span> m_close_log; <span class="comment">//关闭日志</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏接口，调用write_log和flush</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="cpp实现-1"><a href="#cpp实现-1" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>主要是一些string的操作，因为写日志就是把字符写入文件嘛</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_count = <span class="number">0</span>;<span class="comment">//每次行数重置为0，包括天数的记录也会重置，所以如果关闭了的话前面的记录就不存在，重复写一个日志文件就可能出错，因此如果关掉程序再打开的话，最好换一个文件重新开始写</span></span><br><span class="line">    m_is_async = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Log::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size, <span class="type">int</span> split_lines, <span class="type">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果设置了max_queue_size,则设置为异步，只有一个线程在取任务处理</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;<span class="comment">//设置写入方式flag</span></span><br><span class="line">        m_log_queue = <span class="keyword">new</span> <span class="built_in">block_queue</span>&lt;string&gt;(max_queue_size);<span class="comment">//创建并设置阻塞队列长度</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">//flush_log_thread为回调函数,这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员初始化</span></span><br><span class="line">    m_close_log = close_log;<span class="comment">//1的话关闭日志功能</span></span><br><span class="line">    m_log_buf_size = log_buf_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="type">char</span>[m_log_buf_size];<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);<span class="comment">//缓冲区数值初始化</span></span><br><span class="line">    m_split_lines = split_lines;<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//见后面，实际上就是得到具体的本地的时间，年月日时分秒等等</span></span><br><span class="line">    <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后往前找到第一个/的位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//该函数见后面</span></span><br><span class="line">    <span class="type">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//接下来要生成一个具体的日志文件名</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来相当于自定义日志名</span></span><br><span class="line">    <span class="comment">//若输入的文件名没有/，则直接将时间+文件名作为日志名</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);<span class="comment">//该函数见后面</span></span><br><span class="line">        <span class="comment">//下面两行是我自己分析觉得要加上的地方，否则创建新日志的名字可能不协同</span></span><br><span class="line">        dir_name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        log_name = file_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有的话，就是一个路径了，就要从/后面开始添加时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将/的位置向后移动一个位置，然后复制到logname中</span></span><br><span class="line">   	    <span class="comment">//p - file_name + 1是文件所在路径文件夹的长度</span></span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);<span class="comment">//存一下log_name</span></span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);<span class="comment">//dirname相当于./，这里就比上面多一个路径名，不过把filename拆分为dirname和logname，补个时间</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    m_today = my_tm.tm_mday;<span class="comment">//更新日期</span></span><br><span class="line">    </span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据上面的一系列操作获得的名称打开文件或创建文件</span></span><br><span class="line">    <span class="comment">//a表示追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</span></span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">//可变参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取具体时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//返回当前距离1970年的秒数和微妙数</span></span><br><span class="line">    <span class="type">time_t</span> t = now.tv_sec;<span class="comment">//取得从1970年1月1日至今的秒数。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//将time_t表示的时间转换为经过时区转换的UTC时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志类型标头</span></span><br><span class="line">    <span class="keyword">switch</span> (level)<span class="comment">//日志分级</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入一个log，对m_count++</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//m_count和m_fp是共享的，要用锁修改，这就表明上面的时间是调用的时间而不是写的时间，因为锁要阻塞耗时</span></span><br><span class="line">    m_count++;<span class="comment">//先++，因为是从0开始的，++后判断是否到最大行数了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//日志不是今天或写入的日志行数是最大行的倍数，这个时候要新换一个日志文件</span></span><br><span class="line">    <span class="comment">//m_split_lines为最大行数</span></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志内容</span></span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);<span class="comment">//把缓冲区的内容强制写入文件，准备换新文件了</span></span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);<span class="comment">//关闭</span></span><br><span class="line">        <span class="type">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//时间信息</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);<span class="comment">//02表示月份和日期以两位数的形式呈现</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)<span class="comment">//新的一天，换一个文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);<span class="comment">//这里可能有点问题，因为dirname和logname不一定有，如果前面p是NULL的话，那么新的文件就只有日期了，前面最好更新一个logname</span></span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//这一天的日志行数太多了，要分文件，m_count / m_split_lines表示这是第几份</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);<span class="comment">//打开新文件，把日志系统当前写入的文件更换</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;<span class="comment">//解决变参问题的宏，下面介绍</span></span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);<span class="comment">//初始化，指向第一个参数地址</span></span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    <span class="comment">//接下来开始写内容</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//写缓冲区，要锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入的具体时间内容格式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);<span class="comment">//前面分级的s在这里出现，它是内容开头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时间、级别都写进缓冲区之后，把内容写入，内容就是可变参数，通过valst写入</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - <span class="number">1</span>, format, valst);<span class="comment">//该函数后面介绍</span></span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//添加一个换行</span></span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//这一个缓冲区字符串结束</span></span><br><span class="line">    log_str = m_buf;<span class="comment">//变成string</span></span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())<span class="comment">//如果是异步的且阻塞队列有空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);<span class="comment">//把写的任务推入队列，参数就是要写的全部内容，不执行写的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//同步的话或者阻塞队列已经满了就直接写</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//互斥写入文件中</span></span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);<span class="comment">//清空参数列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//强制刷新写入流缓冲区</span></span><br><span class="line">    <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的与时间类相关的知识：</p>
<ul>
<li><p>struct tm *localtime(const time_t *timer)</p>
</li>
<li><p>timer – 这是指向表示日历时间的 time_t 值的指针。</p>
</li>
<li><p>C 库函数 <strong>struct tm *localtime(const time_t *timer)</strong> 使用 timer 的值来填充 <strong>tm</strong> 结构。<strong>timer</strong> 的值被分解为 <strong>tm</strong> 结构，并用本地时区表示。</p>
</li>
<li><p>该函数返回指向 <strong>tm</strong> 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">   <span class="type">int</span> tm_sec;         <span class="comment">/* 秒，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_min;         <span class="comment">/* 分，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_hour;        <span class="comment">/* 小时，范围从 0 到 23                */</span></span><br><span class="line">   <span class="type">int</span> tm_mday;        <span class="comment">/* 一月中的第几天，范围从 1 到 31                    */</span></span><br><span class="line">   <span class="type">int</span> tm_mon;         <span class="comment">/* 月份，范围从 0 到 11                */</span></span><br><span class="line">   <span class="type">int</span> tm_year;        <span class="comment">/* 自 1900 起的年数                */</span></span><br><span class="line">   <span class="type">int</span> tm_wday;        <span class="comment">/* 一周中的第几天，范围从 0 到 6                */</span></span><br><span class="line">   <span class="type">int</span> tm_yday;        <span class="comment">/* 一年中的第几天，范围从 0 到 365                    */</span></span><br><span class="line">   <span class="type">int</span> tm_isdst;       <span class="comment">/* 夏令时                        */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>char *strrchr(const char *str, int c)</p>
</li>
<li><p>C 库函数 <strong>char *strrchr(const char *str, int c)</strong> 在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</li>
<li><p>该函数返回 str 中最后一次出现字符 c 的位置。如果未找到该值，则函数返回一个空指针。</p>
</li>
<li><p>int snprintf ( char * str, size_t size, const char * format, … );</p>
</li>
<li><p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数**(…)<strong>按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，</strong>size** 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断。</p>
</li>
<li><p>返回值</p>
<ul>
<li>1、如果格式化后的字符串长度小于 <strong>size</strong>，则会把字符串全部复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>；</li>
<li>2、如果格式化后的字符串长度大于等于 <strong>size</strong>，超过 <strong>size</strong> 的部分会被截断，只将其中的 <strong>(size-1)</strong> 个字符复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>，返回值为欲写入的字符串长度。</li>
</ul>
</li>
<li><p>VA_LIST 解决变参问题的一组宏，所在头文件：<code>#include &lt;stdarg.h&gt;</code>，用于获取不确定个数的参数，这种获取是根据参数类型对应的大小，找到对应的内存地址，然后获取参数来实现的</p>
</li>
<li><pre><code>typedef char *va_list;

获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）
#define va_start(list,param1) 

获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）
#define va_arg(list,mode)

清空va_list可变参数列表
#define va_end(list)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  va_list的使用方法：</span><br><span class="line">  a)  首先在函数中定义一个具有va_list型的变量，这个变量是指向参数的指针。</span><br><span class="line">  b)  然后用va_start宏初始化变量刚定义的va_list变量，使其指向第一个可变参数的地址。</span><br><span class="line">  c)  然后va_arg返回可变参数，va_arg的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用va_arg获取各个参数）。</span><br><span class="line">  d)  最后使用va_end宏结束可变参数的获取。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>int vsnprintf (char * s, size_t n, const char * format, va_list arg );</p>
</li>
<li><p>将格式化的数据从变量参数列表写入大小已设置的缓冲区</p>
</li>
<li><p>参数</p>
<ul>
<li><p>s</p>
<p>指向存储结果C-string的缓冲区的指针。 缓冲区的大小至少应为<em>n</em>字符。</p>
</li>
<li><p>n</p>
<p>缓冲区中要使用的最大字节数。 生成的字符串的长度最大为<code>n-1</code>，为其他终止空字符留出空间。</p>
</li>
<li><p>format</p>
<p>包含格式字符串的C字符串，其格式与prinf相同。</p>
</li>
<li><p>arg</p>
<p>一个值，该值标识用初始化的变量参数列表。</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功打印到sbuf中的字符的个数，不包括末尾追加的\0。如果格式化解析失败，则返回负数。</li>
</ul>
</li>
</ul>
<h1 id="第四站"><a href="#第四站" class="headerlink" title="第四站"></a>第四站</h1><h2 id="http——前置知识"><a href="#http——前置知识" class="headerlink" title="http——前置知识"></a>http——前置知识</h2><p>这部分内容很多，耐心些，别急</p>
<p>作者写的三篇介绍：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BfnNl-3jc_x5WPrWEJGdzQ">最新版Web服务器项目详解 - 04 http连接处理（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wAQHU-QZiRt1VACMZZjNlw">最新版Web服务器项目详解 - 05 http连接处理（中） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/451xNaSFHxcxfKlPBV3OCg">最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com)</a></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是linux新内核中替换select来做事件触发的机制，效率非常高，底层使用红黑树实现。这篇博客讲的非常清楚，强烈推荐：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljx0305/article/details/4065058">epoll使用详解（精髓）_ljx0305的博客-CSDN博客_epoll</a>。下面简单介绍下API，头文件<code>#include &lt;sys/epoll.h&gt;</code>。</p>
<ul>
<li><p>int epoll_create(int size)</p>
<ul>
<li>创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。(从Linux 2.6.8开始，max_size参数将被忽略，但必须大于零。)</li>
</ul>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p>
<ul>
<li><p>该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
</li>
<li><p>epfd：为epoll_creat的句柄</p>
</li>
<li><p>op：表示动作，用3个宏来表示：</p>
</li>
<li><ul>
<li>EPOLL_CTL_ADD (注册新的fd到epfd)，相当于把fd加到epfd这棵红黑树上</li>
<li>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</li>
<li>EPOLL_CTL_DEL (从epfd删除一个fd)；</li>
</ul>
</li>
<li><p>fd：文件描述符</p>
</li>
<li><p>event：告诉内核需要监听的事件，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events，是一串比特，设置类型时把类型或起来 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>events描述事件类型，其中epoll事件类型有以下几种</p>
</li>
<li><ul>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</p>
<ul>
<li><p>该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</p>
<ul>
<li><p>events：用来存内核得到事件的集合，</p>
</li>
<li><p>maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</p>
</li>
<li><p>timeout：是超时时间</p>
</li>
<li><ul>
<li>-1：阻塞</li>
<li>0：立即返回，非阻塞</li>
<li>&gt;0：指定毫秒</li>
</ul>
</li>
<li><p>返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发模式：</p>
<ul>
<li><p>LT水平触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll还会再次向应用程序通知此事件，直到该事件被处理完毕。</li>
</ul>
</li>
<li><p>ET边缘触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</li>
<li>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain</li>
</ul>
</li>
<li><p>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，故效率要比LT模式高。LT模式是epoll的默认工作模式</p>
</li>
<li><p>EPOLLONESHOT</p>
</li>
<li><ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<p>项目中epoll相关代码部分包括非阻塞模式、内核事件表注册事件、删除事件、重置EPOLLONESHOT事件四种。</p>
<ul>
<li><p>非阻塞模式</p>
</li>
<li><pre><code class="c++">//对文件描述符设置非阻塞
int setnonblocking(int fd)
&#123;
    int old_option = fcntl(fd, F_GETFL);//返回fd的状态标志，是一串比特位
    int new_option = old_option | O_NONBLOCK;//设置非阻塞的比特位，把前面获得的flag和它或起来就可以了
    fcntl(fd, F_SETFL, new_option);//重新设置
    return old_option;
&#125;
/*
阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为
的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .
 
如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，
或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.
*/
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd);</span><br><span class="line">int fcntl(int fd, int cmd, long arg);</span><br><span class="line">int fcntl(int fd, int cmd ,struct flock* lock);</span><br></pre></td></tr></table></figure>

fcntl函数功能依据cmd的值的不同而不同。参数对应功能如下：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">（1）F_DUPFD</span><br><span class="line">与dup函数功能一样，复制由fd指向的文件描述符，调用成功后返回新的文件描述符，与旧的文件描述符共同指向同一个文件。</span><br><span class="line"></span><br><span class="line">（2）F_GETFD</span><br><span class="line">读取文件描述符close-on-exec标志。</span><br><span class="line">close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特位代表一个打开的文件描述符，用于确定在调用系统调用execve()时需要关闭的文件句柄（参见include/fcntl.h）。当一个程序使用fork()函数创建了一个子进程时，通常会在该子进程中调用execve()函数加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中开始执行新程序。若一个文件描述符在close_on_exec中的对应比特位被设置，那么在执行execve()时该描述符将被关闭，否则该描述符将始终处于打开状态。</span><br><span class="line">试想一下这样的场景：在Webserver中，首先会使用root权限启动，以此打开root权限才能打开的端口、日志等文件。然后降权到普通用户，fork出一些worker进程，这些进程中再进行解析脚本、写日志、输出结果等进一步操作。</span><br><span class="line">然而这里，就会发现隐含一个安全问题：子进程中既然继承了父进程的FD，那么子进程中运行的脚本只需要继续操作这些FD，就能够使用普通权限“越权”操作root用户才能操作的文件。</span><br><span class="line"></span><br><span class="line">（3）F_SETFD</span><br><span class="line">将文件描述符close-on-exec标志设置为第三个参数arg的最后一位</span><br><span class="line"></span><br><span class="line">（4）F_GETFL</span><br><span class="line">获取文件打开方式的标志，标志值含义与open调用一致</span><br><span class="line"></span><br><span class="line">（5）F_SETFL</span><br><span class="line">设置文件打开方式标志为arg指定方式</span><br><span class="line"></span><br><span class="line">(6)F_SETLK</span><br><span class="line">此时fcntl函数用来设置或释放锁。当short_l_type为F_RDLCK为读锁，F_WDLCK为写锁，F_UNLCK为解锁。</span><br><span class="line">如果锁被其他进程占用，则返回-1;</span><br><span class="line">这种情况设的锁遇到锁被其他进程占用时，会立刻停止进程。</span><br><span class="line"></span><br><span class="line">(7)F_SETLKW</span><br><span class="line">此时也是给文件上锁，不同于F_SETLK的是，该上锁是阻塞方式。当希望设置的锁因为其他锁而被阻止设置时，该命令会等待相冲突的锁被释放。</span><br><span class="line"></span><br><span class="line">(8)F_GETLK</span><br><span class="line">第3个参数lock指向一个希望设置的锁的属性结构，如果锁能被设置，该命令并不真的设置锁，而是只修改lock的l_type为F_UNLCK,然后返回该结构体。如果存在一个或多个锁与希望设置的锁相互冲突，则fcntl返回其中的一个锁的flock结构。</span><br></pre></td></tr></table></figure>

返回值：与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。下列三个命令有特定返回值：F_DUPFD,F_GETFD,F_GETFL以及F_GETOWN。第一个返回新的文件描述符，第二个返回相应标志，最后一个返回一个正的进程ID或负的进程组ID。

</code></pre>
</li>
<li><p>内核事件表注册新事件，开启EPOLLONESHOT，针对客户端连接的描述符，listenfd不用开启</p>
</li>
<li><pre><code class="c++"> void addfd(int epollfd, int fd, bool one_shot)
 &#123;
     epoll_event event;
     event.data.fd = fd;
 
 #ifdef ET
     event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;//告知要监听可读事件、文件描述符被挂断事件
 #endif
 
#ifdef LT
    event.events = EPOLLIN | EPOLLRDHUP;//可读、文件描述符被挂断
#endif

    if (one_shot)
        event.events |= EPOLLONESHOT;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);//处理好描述的事件类型后，添加进内核事件表的文件描述符epfd
    setnonblocking(fd);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 内核事件表删除事件</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  void removefd(int epollfd, int fd)</span><br><span class="line">  &#123;</span><br><span class="line">      epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);//标志是delete，删除这个fd</span><br><span class="line">      close(fd);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>重置EPOLLONESHOT事件</p>
</li>
<li><p>&#96;&#96;&#96;c++<br> void modfd(int epollfd, int fd, int ev)<br> {<br> epoll_event event;<br> event.data.fd &#x3D; fd;<br> #ifdef ET<br> event.events &#x3D; ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<br> #endif</p>
<p>#ifdef LT<br>event.events &#x3D; ev | EPOLLONESHOT | EPOLLRDHUP;<br>#endif</p>
<pre><code>epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### http细节</span><br><span class="line"></span><br><span class="line">请求报文：get和post，报文的请求头部不一定全部都有，但可以有：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  GET &#x2F;562f25980001b1b106000338.jpg HTTP&#x2F;1.1<br>  Host:img.mukewang.com<br>  User-Agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64)<br>  AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36<br>  Accept:image&#x2F;webp,image&#x2F;<em>,</em>&#x2F;*;q&#x3D;0.8<br>  Referer:<a target="_blank" rel="noopener" href="http://www.imooc.com/">http://www.imooc.com/</a><br>  Accept-Encoding:gzip, deflate, sdch<br>  Accept-Language:zh-CN,zh;q&#x3D;0.8<br>  空行<br>  请求数据为空</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive
空行
name=Professional%20Ajax&amp;publisher=Wiley
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **请求行**，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</span><br><span class="line">  GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</span><br><span class="line"></span><br><span class="line">- **请求头部**，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</span><br><span class="line"></span><br><span class="line">- - HOST，给出请求资源所在服务器的域名。</span><br><span class="line">  - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</span><br><span class="line">  - Accept，说明用户代理可处理的媒体类型。</span><br><span class="line">  - Accept-Encoding，说明用户代理支持的内容编码。</span><br><span class="line">  - Accept-Language，说明用户代理能够处理的自然语言集。</span><br><span class="line">  - Content-Type，说明实现主体的媒体类型。</span><br><span class="line">  - Content-Length，说明实现主体的大小。</span><br><span class="line">  - Connection，连接管理，可以是Keep-Alive或close。</span><br><span class="line"></span><br><span class="line">- **空行**，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。</span><br><span class="line"></span><br><span class="line">- **请求数据**也叫主体，可以添加任意的其他数据。</span><br><span class="line"></span><br><span class="line">响应报文：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HTTP&#x2F;1.1 200 OK<br>Date: Fri, 22 May 2009 06:07:21 GMT<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8<br> 空行</p>
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</span><br><span class="line">  第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。</span><br><span class="line">- 消息报头，用来说明客户端要使用的一些附加信息。</span><br><span class="line">  第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。</span><br><span class="line">- 空行，消息报头后面的空行是必须的。</span><br><span class="line">- 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</span><br><span class="line"></span><br><span class="line">状态码：</span><br><span class="line"></span><br><span class="line">HTTP有5种类型的状态码，具体的：</span><br><span class="line"></span><br><span class="line">- 1xx：指示信息--表示请求已接收，继续处理。</span><br><span class="line"></span><br><span class="line">- 2xx：成功--表示请求正常处理完毕。</span><br><span class="line"></span><br><span class="line">- - 200 OK：客户端请求被正常处理。</span><br><span class="line">  - 206 Partial content：客户端进行了范围请求。</span><br><span class="line"></span><br><span class="line">- 3xx：重定向--要完成请求必须进行更进一步的操作。</span><br><span class="line"></span><br><span class="line">- - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</span><br><span class="line">  - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。</span><br><span class="line"></span><br><span class="line">- 4xx：客户端错误--请求有语法错误，服务器无法处理请求。</span><br><span class="line"></span><br><span class="line">- - 400 Bad Request：请求报文存在语法错误。</span><br><span class="line">  - 403 Forbidden：请求被服务器拒绝。</span><br><span class="line">  - 404 Not Found：请求不存在，服务器上找不到请求的资源。</span><br><span class="line"></span><br><span class="line">- 5xx：服务器端错误--服务器处理请求出错。</span><br><span class="line"></span><br><span class="line">- - 500 Internal Server Error：服务器在执行请求时出现错误。</span><br><span class="line"></span><br><span class="line">http报文处理流程：</span><br><span class="line"></span><br><span class="line">- 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</span><br><span class="line">- 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</span><br><span class="line">- 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</span><br><span class="line"></span><br><span class="line">### http类</span><br><span class="line"></span><br><span class="line">这一部分代码在TinyWebServer/http/http_conn.h中，主要是http类的定义。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef HTTPCONNECTION_H</span><br><span class="line">#define HTTPCONNECTION_H</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;//存储错误</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;../lock/locker.h&quot;</span><br><span class="line">#include &quot;../CGImysql/sql_connection_pool.h&quot;</span><br><span class="line">#include &quot;../timer/lst_timer.h&quot;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">class http_conn</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //设置读取文件的名称m_real_file大小</span><br><span class="line">    static const int FILENAME_LEN = 200;</span><br><span class="line">    //设置读缓冲区m_read_buf大小</span><br><span class="line">    static const int READ_BUFFER_SIZE = 2048;</span><br><span class="line">    //设置写缓冲区m_write_buf大小</span><br><span class="line">    static const int WRITE_BUFFER_SIZE = 1024;</span><br><span class="line">    </span><br><span class="line">    //报文的请求方法，本项目只用到GET和POST</span><br><span class="line">    enum METHOD</span><br><span class="line">    &#123;</span><br><span class="line">        GET = 0,</span><br><span class="line">        POST,</span><br><span class="line">        HEAD,</span><br><span class="line">        PUT,</span><br><span class="line">        DELETE,</span><br><span class="line">        TRACE,</span><br><span class="line">        OPTIONS,</span><br><span class="line">        CONNECT,</span><br><span class="line">        PATH</span><br><span class="line">    &#125;;</span><br><span class="line">    //主状态机的状态</span><br><span class="line">    enum CHECK_STATE</span><br><span class="line">    &#123;</span><br><span class="line">        CHECK_STATE_REQUESTLINE = 0,</span><br><span class="line">        CHECK_STATE_HEADER,</span><br><span class="line">        CHECK_STATE_CONTENT</span><br><span class="line">    &#125;;</span><br><span class="line">    //报文解析的结果</span><br><span class="line">    enum HTTP_CODE</span><br><span class="line">    &#123;</span><br><span class="line">        NO_REQUEST,</span><br><span class="line">        GET_REQUEST,</span><br><span class="line">        BAD_REQUEST,</span><br><span class="line">        NO_RESOURCE,</span><br><span class="line">        FORBIDDEN_REQUEST,</span><br><span class="line">        FILE_REQUEST,</span><br><span class="line">        INTERNAL_ERROR,</span><br><span class="line">        CLOSED_CONNECTION</span><br><span class="line">    &#125;;</span><br><span class="line">    //从状态机的状态</span><br><span class="line">    enum LINE_STATUS</span><br><span class="line">    &#123;</span><br><span class="line">        LINE_OK = 0,</span><br><span class="line">        LINE_BAD,</span><br><span class="line">        LINE_OPEN</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    http_conn() &#123;&#125;</span><br><span class="line">    ~http_conn() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //初始化套接字地址，函数内部会调用私有方法init</span><br><span class="line">    void init(int sockfd, const sockaddr_in &amp;addr, char *, int, int, string user, string passwd, string sqlname);</span><br><span class="line">    //关闭http连接</span><br><span class="line">    void close_conn(bool real_close = true);</span><br><span class="line">    </span><br><span class="line">    void process();</span><br><span class="line">    </span><br><span class="line">    //读取浏览器端发来的全部数据</span><br><span class="line">    bool read_once();</span><br><span class="line">    //响应报文写入函数</span><br><span class="line">    bool write();</span><br><span class="line">    </span><br><span class="line">    sockaddr_in *get_address()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;m_address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //同步线程初始化数据库读取表</span><br><span class="line">    void initmysql_result(connection_pool *connPool);</span><br><span class="line">    </span><br><span class="line">    int timer_flag;</span><br><span class="line">    int improv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void init();</span><br><span class="line">    //从m_read_buf读取，并处理请求报文</span><br><span class="line">    HTTP_CODE process_read();</span><br><span class="line">    //向m_write_buf写入响应报文数据</span><br><span class="line">    bool process_write(HTTP_CODE ret);</span><br><span class="line">    //主状态机解析报文中的请求行数据</span><br><span class="line">    HTTP_CODE parse_request_line(char *text);</span><br><span class="line">    //主状态机解析报文中的请求头数据</span><br><span class="line">    HTTP_CODE parse_headers(char *text);</span><br><span class="line">    //主状态机解析报文中的请求内容</span><br><span class="line">    HTTP_CODE parse_content(char *text);</span><br><span class="line">    //生成响应报文</span><br><span class="line">    HTTP_CODE do_request();</span><br><span class="line">    </span><br><span class="line">    //m_start_line是已经解析的字符</span><br><span class="line">    //get_line用于将指针向后偏移，指向未处理的字符</span><br><span class="line">    char *get_line() &#123; return m_read_buf + m_start_line; &#125;;</span><br><span class="line">    </span><br><span class="line">    //从状态机读取一行，分析是请求报文的哪一部分</span><br><span class="line">    LINE_STATUS parse_line();</span><br><span class="line">    void unmap();</span><br><span class="line">    </span><br><span class="line">    //根据响应报文格式，生成对应8个部分，以下函数均由do_request调用</span><br><span class="line">    bool add_response(const char *format, ...);</span><br><span class="line">    bool add_content(const char *content);</span><br><span class="line">    bool add_status_line(int status, const char *title);</span><br><span class="line">    bool add_headers(int content_length);</span><br><span class="line">    bool add_content_type();</span><br><span class="line">    bool add_content_length(int content_length);</span><br><span class="line">    bool add_linger();</span><br><span class="line">    bool add_blank_line();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int m_epollfd;//内核事件表，类共享的</span><br><span class="line">    static int m_user_count;//记录总数，静态变量的形式</span><br><span class="line">    MYSQL *mysql;</span><br><span class="line">    int m_state;  //读为0, 写为1</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_sockfd;</span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    </span><br><span class="line">    //存储读取的请求报文数据</span><br><span class="line">    char m_read_buf[READ_BUFFER_SIZE];</span><br><span class="line">    //缓冲区中m_read_buf中数据的最后一个字节的下一个位置</span><br><span class="line">    int m_read_idx;</span><br><span class="line">    //m_read_buf读取的位置m_checked_idx</span><br><span class="line">    int m_checked_idx;</span><br><span class="line">    //m_read_buf中已经解析的字符个数</span><br><span class="line">    int m_start_line;</span><br><span class="line">    </span><br><span class="line">    //存储发出的响应报文数据</span><br><span class="line">    char m_write_buf[WRITE_BUFFER_SIZE];</span><br><span class="line">    //指示buffer中的长度</span><br><span class="line">    int m_write_idx;</span><br><span class="line">    </span><br><span class="line">    //主状态机的状态</span><br><span class="line">    CHECK_STATE m_check_state;</span><br><span class="line">    //请求方法</span><br><span class="line">    METHOD m_method;</span><br><span class="line">    </span><br><span class="line">    //以下为解析请求报文中对应的6个变量</span><br><span class="line">    //存储读取文件的名称</span><br><span class="line">    char m_real_file[FILENAME_LEN];</span><br><span class="line">    char *m_url;</span><br><span class="line">    char *m_version;</span><br><span class="line">    char *m_host;</span><br><span class="line">    int m_content_length;</span><br><span class="line">    bool m_linger;</span><br><span class="line">    </span><br><span class="line">    //读取服务器上的文件地址</span><br><span class="line">    char *m_file_address;</span><br><span class="line">    </span><br><span class="line">    //stat iovec后面介绍</span><br><span class="line">    struct stat m_file_stat;//获取文件的信息</span><br><span class="line">    //io向量机制iovec</span><br><span class="line">    struct iovec m_iv[2];</span><br><span class="line">    int m_iv_count;</span><br><span class="line">    int cgi;        //是否启用的POST</span><br><span class="line">    char *m_string; //存储请求头数据</span><br><span class="line">    int bytes_to_send;//剩余发送字节数</span><br><span class="line">    int bytes_have_send;//已发送字节数</span><br><span class="line">    char *doc_root;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; m_users;</span><br><span class="line">    int m_TRIGMode;</span><br><span class="line">    int m_close_log;</span><br><span class="line"></span><br><span class="line">    char sql_user[100];</span><br><span class="line">    char sql_passwd[100];</span><br><span class="line">    char sql_name[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在http请求接收部分，会涉及到init和read_once函数，但init仅仅是对私有成员变量进行初始化，不用过多讲解。</p>
<p>这里，对read_once进行介绍。read_once读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_idx。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m_read_idx&gt;=READ_BUFFER_SIZE)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> bytes_read=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从套接字接收数据，存储在m_read_buf缓冲区</span></span><br><span class="line">        bytes_read=<span class="built_in">recv</span>(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,<span class="number">0</span>);<span class="comment">//该函数后面介绍</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_read==<span class="number">-1</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//非阻塞ET模式下，需要一次性将数据读完</span></span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN||errno==EWOULDBLOCK)<span class="comment">//这种错误是系统告知要再尝试一次，可能是因为没有数据了，break返回true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bytes_read==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改m_read_idx的读取字节数</span></span><br><span class="line">        m_read_idx+=bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int recv(int sockfd, char * buf, int len, int flags);</p>
<ul>
<li>sockfd：连接的fd</li>
<li>buf：用于接收数据的缓冲区</li>
<li>len：缓冲区长度，一般是参数2的字节数-1，把<code>\0</code>字符串结尾留出来</li>
<li>flags：指定调用方式，一般设置为0</li>
<li>返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0 。</li>
</ul>
</li>
<li><p>在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。EAGAIN和 EWOULDBLOCK等效！</p>
<ul>
<li>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以O_NONBLOCK的标志打开文件&#x2F;socket&#x2F;FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</li>
<li>这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</li>
</ul>
</li>
<li><p>struct iovec 结构体定义了一个向量元素，通常这个 iovec 结构体用于一个多元素的数组，对于每一个元素，iovec 结构体的字段 iov_base 指向一个缓冲区，这个缓冲区存放的是网络接收的数据（read），或者网络将要发送的数据（write）。iovec 结构体的字段 iov_len 存放的是接收数据的最大长度（read），或者实际写入的数据长度（write）。</p>
<ul>
<li><pre><code class="c++">struct iovec &#123;
    /* Starting address (内存起始地址）*/
    void  *iov_base;   

    /* Number of bytes to transfer（这块内存长度） */
    size_t iov_len;  
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct stat  </span><br><span class="line">    &#123;   </span><br><span class="line">        dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">        ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">        mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">        nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">        uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">        gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">        dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">        off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">        blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">        blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">        time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">        time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">        time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="c++">//_stat函数用来获取指定路径的文件或者文件夹的信息。


//! 需要包含de头文件  
#include &lt;sys/types.h&gt;    
#include &lt;sys/stat.h&gt;   
int stat(
　　const char *filename    //文件或者文件夹的路径
　　, struct stat *buf      //获取的信息保存在内存中
); //! prototype,原型     

//正确——返回0
//错误——返回-1，具体错误码保存在errno中
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。</span><br><span class="line">  </span><br><span class="line">* #### mmap</span><br><span class="line"></span><br><span class="line">  * 用于将一个文件或其他对象映射到内存，提高文件的访问速度。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">    int munmap(void* start,size_t length);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址</p>
</li>
<li><p>length：映射区的长度</p>
</li>
<li><p>prot：期望的内存保护标志，不能与文件的打开模式冲突</p>
</li>
<li><ul>
<li>PROT_READ 表示页内容可以被读取</li>
</ul>
</li>
<li><p>flags：指定映射对象的类型，映射选项和映射页是否可以共享</p>
</li>
<li><ul>
<li>MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</li>
</ul>
</li>
<li><p>fd：有效的文件描述符，一般是由open()函数返回</p>
</li>
<li><p>off_toffset：被映射对象内容的起点</p>
</li>
<li><p>返回值：成功返回创建的映射区的首地址；失败返回<strong>宏MAP_FAILED。</strong></p>
</li>
</ul>
</li>
<li><h4 id="writev"><a href="#writev" class="headerlink" title="writev"></a>writev</h4><ul>
<li><p>writev函数用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;uio.h&gt;<br>ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * filedes表示文件描述符</span><br><span class="line"></span><br><span class="line">  * iov为前述io向量机制结构体iovec</span><br><span class="line"></span><br><span class="line">  * iovcnt为结构体的个数</span><br><span class="line"></span><br><span class="line">  * 若成功则返回已写的字节数，若出错则返回-1。`writev`以顺序`iov[0]`，`iov[1]`至`iov[iovcnt-1]`从缓冲区中聚集输出数据。`writev`返回输出的字节总数，通常，它应等于所有缓冲区长度之和。</span><br><span class="line"></span><br><span class="line">  * **特别注意：** 循环调用writev时，需要重新处理iovec中的指针和长度，该函数不会对这两个成员做任何处理。writev的返回值为已写的字节数，但这个返回值“实用性”并不高，因为参数传入的是iovec数组，计量单位是iovcnt，而不是字节数，我们仍然需要通过遍历iovec来计算新的基址，另外写入数据的“结束点”可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"></span><br><span class="line">Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。</span><br><span class="line"></span><br><span class="line">&gt; *PS: 只有当系统调用或者调用lib函数时出错，才会置位`errno`！*</span><br><span class="line"></span><br><span class="line">查看系统中所有的`errno`所代表的含义，可以采用如下的代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/* Function: obtain the errno string</span><br><span class="line">*   char *strerror(int errno)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;     //for strerror()</span><br><span class="line">//#include &lt;errno.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    for(tmp = 0; tmp &lt;=256; tmp++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;errno: %2d\t%s\n&quot;,tmp,strerror(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出信息如下：</span><br><span class="line">errno:  0       Success</span><br><span class="line">errno:  1       Operation not permitted</span><br><span class="line">errno:  2       No such file or directory</span><br><span class="line">errno:  3       No such process</span><br><span class="line">errno:  4       Interrupted system call</span><br><span class="line">errno:  5       Input/output error</span><br><span class="line">errno:  6       No such device or address</span><br><span class="line">errno:  7       Argument list too long</span><br><span class="line">errno:  8       Exec format error</span><br><span class="line">errno:  9       Bad file descriptor</span><br><span class="line">errno: 10       No child processes</span><br><span class="line">errno: 11       Resource temporarily unavailable</span><br><span class="line">errno: 12       Cannot allocate memory</span><br><span class="line">errno: 13       Permission denied</span><br><span class="line">errno: 14       Bad address</span><br><span class="line">errno: 15       Block device required</span><br><span class="line">errno: 16       Device or resource busy</span><br><span class="line">errno: 17       File exists</span><br><span class="line">errno: 18       Invalid cross-device link</span><br><span class="line">errno: 19       No such device</span><br><span class="line">errno: 20       Not a directory</span><br><span class="line">errno: 21       Is a directory</span><br><span class="line">errno: 22       Invalid argument</span><br><span class="line">errno: 23       Too many open files in system</span><br><span class="line">errno: 24       Too many open files</span><br><span class="line">errno: 25       Inappropriate ioctl for device</span><br><span class="line">errno: 26       Text file busy</span><br><span class="line">errno: 27       File too large</span><br><span class="line">errno: 28       No space left on device</span><br><span class="line">errno: 29       Illegal seek</span><br><span class="line">errno: 30       Read-only file system</span><br><span class="line">errno: 31       Too many links</span><br><span class="line">errno: 32       Broken pipe</span><br><span class="line">errno: 33       Numerical argument out of domain</span><br><span class="line">errno: 34       Numerical result out of range</span><br><span class="line">errno: 35       Resource deadlock avoided</span><br><span class="line">errno: 36       File name too long</span><br><span class="line">errno: 37       No locks available</span><br><span class="line">errno: 38       Function not implemented</span><br><span class="line">errno: 39       Directory not empty</span><br><span class="line">errno: 40       Too many levels of symbolic links</span><br><span class="line">errno: 41       Unknown error 41</span><br><span class="line">errno: 42       No message of desired type</span><br><span class="line">errno: 43       Identifier removed</span><br><span class="line">errno: 44       Channel number out of range</span><br><span class="line">errno: 45       Level 2 not synchronized</span><br><span class="line">errno: 46       Level 3 halted</span><br><span class="line">errno: 47       Level 3 reset</span><br><span class="line">errno: 48       Link number out of range</span><br><span class="line">errno: 49       Protocol driver not attached</span><br><span class="line">errno: 50       No CSI structure available</span><br><span class="line">errno: 51       Level 2 halted</span><br><span class="line">errno: 52       Invalid exchange</span><br><span class="line">errno: 53       Invalid request descriptor</span><br><span class="line">errno: 54       Exchange full</span><br><span class="line">errno: 55       No anode</span><br><span class="line">errno: 56       Invalid request code</span><br><span class="line">errno: 57       Invalid slot</span><br><span class="line">errno: 58       Unknown error 58</span><br><span class="line">errno: 59       Bad font file format</span><br><span class="line">errno: 60       Device not a stream</span><br><span class="line">errno: 61       No data available</span><br><span class="line">errno: 62       Timer expired</span><br><span class="line">errno: 63       Out of streams resources</span><br><span class="line">errno: 64       Machine is not on the network</span><br><span class="line">errno: 65       Package not installed</span><br><span class="line">errno: 66       Object is remote</span><br><span class="line">errno: 67       Link has been severed</span><br><span class="line">errno: 68       Advertise error</span><br><span class="line">errno: 69       Srmount error</span><br><span class="line">errno: 70       Communication error on send</span><br><span class="line">errno: 71       Protocol error</span><br><span class="line">errno: 72       Multihop attempted</span><br><span class="line">errno: 73       RFS specific error</span><br><span class="line">errno: 74       Bad message</span><br><span class="line">errno: 75       Value too large for defined data type</span><br><span class="line">errno: 76       Name not unique on network</span><br><span class="line">errno: 77       File descriptor in bad state</span><br><span class="line">errno: 78       Remote address changed</span><br><span class="line">errno: 79       Can not access a needed shared library</span><br><span class="line">errno: 80       Accessing a corrupted shared library</span><br><span class="line">errno: 81       .lib section in a.out corrupted</span><br><span class="line">errno: 82       Attempting to link in too many shared libraries</span><br><span class="line">errno: 83       Cannot exec a shared library directly</span><br><span class="line">errno: 84       Invalid or incomplete multibyte or wide character</span><br><span class="line">errno: 85       Interrupted system call should be restarted</span><br><span class="line">errno: 86       Streams pipe error</span><br><span class="line">errno: 87       Too many users</span><br><span class="line">errno: 88       Socket operation on non-socket</span><br><span class="line">errno: 89       Destination address required</span><br><span class="line">errno: 90       Message too long</span><br><span class="line">errno: 91       Protocol wrong type for socket</span><br><span class="line">errno: 92       Protocol not available</span><br><span class="line">errno: 93       Protocol not supported</span><br><span class="line">errno: 94       Socket type not supported</span><br><span class="line">errno: 95       Operation not supported</span><br><span class="line">errno: 96       Protocol family not supported</span><br><span class="line">errno: 97       Address family not supported by protocol</span><br><span class="line">errno: 98       Address already in use</span><br><span class="line">errno: 99       Cannot assign requested address</span><br><span class="line">errno: 100      Network is down</span><br><span class="line">errno: 101      Network is unreachable</span><br><span class="line">errno: 102      Network dropped connection on reset</span><br><span class="line">errno: 103      Software caused connection abort</span><br><span class="line">errno: 104      Connection reset by peer</span><br><span class="line">errno: 105      No buffer space available</span><br><span class="line">errno: 106      Transport endpoint is already connected</span><br><span class="line">errno: 107      Transport endpoint is not connected</span><br><span class="line">errno: 108      Cannot send after transport endpoint shutdown</span><br><span class="line">errno: 109      Too many references: cannot splice</span><br><span class="line">errno: 110      Connection timed out</span><br><span class="line">errno: 111      Connection refused</span><br><span class="line">errno: 112      Host is down</span><br><span class="line">errno: 113      No route to host</span><br><span class="line">errno: 114      Operation already in progress</span><br><span class="line">errno: 115      Operation now in progress</span><br><span class="line">errno: 116      Stale file handle</span><br><span class="line">errno: 117      Structure needs cleaning</span><br><span class="line">errno: 118      Not a XENIX named type file</span><br><span class="line">errno: 119      No XENIX semaphores available</span><br><span class="line">errno: 120      Is a named type file</span><br><span class="line">errno: 121      Remote I/O error</span><br><span class="line">errno: 122      Disk quota exceeded</span><br><span class="line">errno: 123      No medium found</span><br><span class="line">errno: 124      Wrong medium type</span><br><span class="line">errno: 125      Operation canceled</span><br><span class="line">errno: 126      Required key not available</span><br><span class="line">errno: 127      Key has expired</span><br><span class="line">errno: 128      Key has been revoked</span><br><span class="line">errno: 129      Key was rejected by service</span><br><span class="line">errno: 130      Owner died</span><br><span class="line">errno: 131      State not recoverable</span><br><span class="line">errno: 132      Operation not possible due to RF-kill</span><br><span class="line">errno: 133      Memory page has hardware error</span><br><span class="line">errno: 134~255  unknown error!</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Linux中，在头文件 <code>/usr/include/asm-generic/errno-base.h</code> 对基础常用errno进行了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPERM        1  <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOENT       2  <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRCH        3  <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINTR        4  <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIO      5  <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENXIO        6  <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E2BIG        7  <span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOEXEC      8  <span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADF        9  <span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHILD      10  <span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN      11  <span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEM      12  <span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACCES      13  <span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFAULT      14  <span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTBLK     15  <span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUSY       16  <span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEXIST      17  <span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDEV       18  <span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODEV      19  <span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTDIR     20  <span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISDIR      21  <span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINVAL      22  <span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENFILE      23  <span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMFILE      24  <span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTTY      25  <span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETXTBSY     26  <span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFBIG       27  <span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSPC      28  <span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESPIPE      29  <span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS       30  <span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMLINK      31  <span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPIPE       32  <span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM        33  <span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE      34  <span class="comment">/* Math result not representable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在 <code>/usr/include/asm-asm-generic/errno.h</code> 中，对剩余的errno做了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/errno-base.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLK     35  <span class="comment">/* Resource deadlock would occur */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAMETOOLONG    36  <span class="comment">/* File name too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLCK      37  <span class="comment">/* No record locks available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSYS      38  <span class="comment">/* Function not implemented */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTEMPTY   39  <span class="comment">/* Directory not empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELOOP       40  <span class="comment">/* Too many symbolic links encountered */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWOULDBLOCK EAGAIN  <span class="comment">/* Operation would block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMSG      42  <span class="comment">/* No message of desired type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIDRM       43  <span class="comment">/* Identifier removed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHRNG      44  <span class="comment">/* Channel number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2NSYNC    45  <span class="comment">/* Level 2 not synchronized */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3HLT      46  <span class="comment">/* Level 3 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3RST      47  <span class="comment">/* Level 3 reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELNRNG      48  <span class="comment">/* Link number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUNATCH     49  <span class="comment">/* Protocol driver not attached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOCSI      50  <span class="comment">/* No CSI structure available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2HLT      51  <span class="comment">/* Level 2 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADE       52  <span class="comment">/* Invalid exchange */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADR       53  <span class="comment">/* Invalid request descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXFULL      54  <span class="comment">/* Exchange full */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOANO      55  <span class="comment">/* No anode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADRQC     56  <span class="comment">/* Invalid request code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADSLT     57  <span class="comment">/* Invalid slot */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLOCK   EDEADLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBFONT      59  <span class="comment">/* Bad font file format */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSTR      60  <span class="comment">/* Device not a stream */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODATA     61  <span class="comment">/* No data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIME       62  <span class="comment">/* Timer expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSR       63  <span class="comment">/* Out of streams resources */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENONET      64  <span class="comment">/* Machine is not on the network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPKG      65  <span class="comment">/* Package not installed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTE     66  <span class="comment">/* Object is remote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLINK     67  <span class="comment">/* Link has been severed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADV        68  <span class="comment">/* Advertise error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRMNT      69  <span class="comment">/* Srmount error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECOMM       70  <span class="comment">/* Communication error on send */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTO      71  <span class="comment">/* Protocol error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMULTIHOP   72  <span class="comment">/* Multihop attempted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOTDOT     73  <span class="comment">/* RFS specific error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADMSG     74  <span class="comment">/* Not a data message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOVERFLOW   75  <span class="comment">/* Value too large for defined data type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTUNIQ    76  <span class="comment">/* Name not unique on network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADFD      77  <span class="comment">/* File descriptor in bad state */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMCHG     78  <span class="comment">/* Remote address changed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBACC     79  <span class="comment">/* Can not access a needed shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBBAD     80  <span class="comment">/* Accessing a corrupted shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBSCN     81  <span class="comment">/* .lib section in a.out corrupted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBMAX     82  <span class="comment">/* Attempting to link in too many shared libraries */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBEXEC    83  <span class="comment">/* Cannot exec a shared library directly */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EILSEQ      84  <span class="comment">/* Illegal byte sequence */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERESTART    85  <span class="comment">/* Interrupted system call should be restarted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTRPIPE    86  <span class="comment">/* Streams pipe error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUSERS      87  <span class="comment">/* Too many users */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTSOCK    88  <span class="comment">/* Socket operation on non-socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDESTADDRREQ    89  <span class="comment">/* Destination address required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSGSIZE    90  <span class="comment">/* Message too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTOTYPE  91  <span class="comment">/* Protocol wrong type for socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPROTOOPT 92  <span class="comment">/* Protocol not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTONOSUPPORT 93  <span class="comment">/* Protocol not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESOCKTNOSUPPORT 94  <span class="comment">/* Socket type not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOPNOTSUPP  95  <span class="comment">/* Operation not supported on transport endpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPFNOSUPPORT    96  <span class="comment">/* Protocol family not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAFNOSUPPORT    97  <span class="comment">/* Address family not supported by protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRINUSE  98  <span class="comment">/* Address already in use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRNOTAVAIL   99  <span class="comment">/* Cannot assign requested address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETDOWN    100 <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETUNREACH 101 <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETRESET   102 <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNABORTED    103 <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNRESET  104 <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOBUFS     105 <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISCONN     106 <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTCONN    107 <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESHUTDOWN   108 <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETOOMANYREFS    109 <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIMEDOUT   110 <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNREFUSED    111 <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTDOWN   112 <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTUNREACH    113 <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EALREADY    114 <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINPROGRESS 115 <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTALE      116 <span class="comment">/* Stale file handle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUCLEAN     117 <span class="comment">/* Structure needs cleaning */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTNAM     118 <span class="comment">/* Not a XENIX named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAVAIL     119 <span class="comment">/* No XENIX semaphores available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISNAM      120 <span class="comment">/* Is a named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTEIO   121 <span class="comment">/* Remote I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDQUOT      122 <span class="comment">/* Quota exceeded */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEDIUM   123 <span class="comment">/* No medium found */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMEDIUMTYPE 124 <span class="comment">/* Wrong medium type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECANCELED   125 <span class="comment">/* Operation Canceled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOKEY      126 <span class="comment">/* Required key not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYEXPIRED 127 <span class="comment">/* Key has expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREVOKED 128 <span class="comment">/* Key has been revoked */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREJECTED    129 <span class="comment">/* Key was rejected by service */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for robust mutexes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOWNERDEAD  130 <span class="comment">/* Owner died */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTRECOVERABLE 131 <span class="comment">/* State not recoverable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERFKILL     132 <span class="comment">/* Operation not possible due to RF-kill */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHWPOISON   133 <span class="comment">/* Memory page has hardware error */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="http的调用"><a href="#http的调用" class="headerlink" title="http的调用"></a>http的调用</h3><p>这不是http的实现，实现后面再说，这里是使用epoll调用的运行代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建MAX_FD个http类对象</span></span><br><span class="line"> http_conn* users=<span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建内核事件表</span></span><br><span class="line"> epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line"> <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//将listenfd放在epoll树上</span></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上述epollfd赋值给http类对象的m_epollfd属性</span></span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待所监控文件描述符上有事件的产生</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对所有就绪事件进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;<span class="comment">//通过epollfd监听到的就绪事件会放在events数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">//LT水平触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ET非阻塞边缘触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">            <span class="comment">//需要循环接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读入对应缓冲区</span></span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//服务器关闭连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="http实现"><a href="#http实现" class="headerlink" title="http实现"></a>http实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义http响应的一些状态信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to staisfy.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file form this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the request file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">locker m_lock;</span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::initmysql_result</span><span class="params">(connection_pool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))<span class="comment">//从mysql这个接口输入查询语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;SELECT error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(mysql));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="comment">//这可以把一个fd绑定在epollfd上，接下来对内核事件的操作（唤醒什么的）都是针对fd文件描述符的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)<span class="comment">//边缘触发模式</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<span class="comment">//add一个</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从内核时间表删除描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//从epollfd中删掉fd，然后关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件重置为EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<span class="comment">//修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态变量定义</span></span><br><span class="line"><span class="type">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接，关闭一个连接，客户总量减一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;close %d\n&quot;</span>, m_sockfd);</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化连接,外部调用初始化套接字地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr, <span class="type">char</span> *root, <span class="type">int</span> TRIGMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> close_log, string user, string passwd, string sqlname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>, m_TRIGMode);<span class="comment">//注册一个连接</span></span><br><span class="line">    m_user_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当浏览器出现连接重置时，可能是网站根目录出错或http响应格式出错或者访问的文件中内容完全为空</span></span><br><span class="line">    doc_root = root;</span><br><span class="line">    m_TRIGMode = TRIGMode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(sql_user, user.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_passwd, passwd.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_name, sqlname.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化新接受的连接</span></span><br><span class="line"><span class="comment">//check_state默认为分析请求行状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mysql = <span class="literal">NULL</span>;</span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">    m_linger = <span class="literal">false</span>;</span><br><span class="line">    m_method = GET;</span><br><span class="line">    m_url = <span class="number">0</span>;</span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line">    cgi = <span class="number">0</span>;</span><br><span class="line">    m_state = <span class="number">0</span>;</span><br><span class="line">    timer_flag = <span class="number">0</span>;</span><br><span class="line">    improv = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从状态机，用于分析出一行内容，见作者的分析中篇</span></span><br><span class="line"><span class="comment">//返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_read_buf[m_checked_idx];<span class="comment">//temp为将要分析的字节</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//如果当前是\r字符，则有可能会读取到完整行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx)<span class="comment">//下一个字符达到了buffer结尾，则接收不完整，需要继续接收</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//下一个字符是\n，将\r\n改为\0\0</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;<span class="comment">//如果都不符合，则返回语法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果当前字符是\n，也有可能读取到完整行</span></span><br><span class="line">        &#123;<span class="comment">//一般是上次读取到\r就到buffer末尾了，没有接收完整，再次接收时会出现这种情况</span></span><br><span class="line">            <span class="keyword">if</span> (m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//前一个字符是\r，则接收完整</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;<span class="comment">//并没有找到\r\n，需要继续接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"><span class="comment">//非阻塞ET工作模式下，需要一次性将数据读完</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LT读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET读数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//循环读取</span></span><br><span class="line">        &#123;</span><br><span class="line">            bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)<span class="comment">//这时说明读完了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_read_idx += bytes_read;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="comment">//在HTTP报文中，请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本，其中各个部分之间通过\t或空格分隔。</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//请求行中最先含有空格和\t任一字符的位置并返回</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//检索字符串 str1 中第一个匹配字符串 str2 中字符的字符</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url)<span class="comment">//如果没有空格或\t，则报文格式有误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将该位置改为\0，用于将前面数据取出</span></span><br><span class="line">    <span class="type">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)<span class="comment">//取出数据，并通过与GET和POST比较，以确定请求方式</span></span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标，该函数返回 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);<span class="comment">//因为报文后面可能还有空格，跳过这些空格</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用与判断请求方式的相同逻辑，判断HTTP版本号</span></span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)<span class="comment">//只支持1.1版本</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)<span class="comment">//对请求资源前7个字符进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//同样增加https情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)<span class="comment">//一般的不会带有上述两种符号，直接是单独的/或/后面带访问资源</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    <span class="comment">//当url为/时，显示判断界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;<span class="comment">//请求行处理完毕，将主状态机转移处理请求头</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//判断是空行还是请求头</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_content_length != <span class="number">0</span>)<span class="comment">//判断是GET还是POST请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;<span class="comment">//POST需要跳转到消息体处理状态</span></span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部连接字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//跳过空格和\t字符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>)<span class="comment">//如果是长连接，则将linger标志设置为true</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部内容长度字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部HOST字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;oop!unknow header: %s&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//判断http请求是否被完整读入</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主状态机</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;<span class="comment">//初始化从状态机状态、HTTP请求解析结果</span></span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="type">char</span> *text = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在GET请求报文中，每一行都是\r\n作为结束，所以对报文进行拆解时，仅用从状态机的状态line_status=parse_line())==LINE_OK语句即可。</span></span><br><span class="line">    <span class="comment">//在POST请求报文中，消息体的末尾没有任何字符，所以不能使用从状态机的状态，这里转而使用主状态机的状态作为循环入口条件。</span></span><br><span class="line">    <span class="comment">//解析完消息体后，报文的完整解析就完成了，但此时主状态机的状态还是CHECK_STATE_CONTENT，符合循环入口条件，还会再次进入循环，这并不是我们所希望的</span></span><br><span class="line">    <span class="comment">//为此，增加了该语句，并在完成消息体解析后，将line_status变量更改为LINE_OPEN，此时可以跳出循环，完成报文解析任务。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有当从状态机处理好了，主状态机才运行</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line">        <span class="comment">//m_start_line是每一个数据行在m_read_buf中的起始位置</span></span><br><span class="line">        <span class="comment">//m_checked_idx表示从状态机在m_read_buf中读取的位置</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">        <span class="keyword">switch</span> (m_check_state)<span class="comment">//主状态机的三种状态转移逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">        &#123;	<span class="comment">//解析请求行</span></span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">        &#123;	<span class="comment">//解析请求头</span></span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="comment">//完整解析GET请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">        &#123;	<span class="comment">//解析消息体</span></span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">            <span class="comment">//完整解析POST请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();<span class="comment">//正确的请求就转调用</span></span><br><span class="line">            line_status = LINE_OPEN;<span class="comment">//从状态机没处理好，退出循环，openline</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里跟html有关系</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file, doc_root);<span class="comment">//将初始化的m_real_file赋值为网站根目录</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//找到m_url中/的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理cgi</span></span><br><span class="line">    <span class="keyword">if</span> (cgi == <span class="number">1</span> &amp;&amp; (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))<span class="comment">//实现登录和注册校验</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据标志判断是登录检测还是注册检测</span></span><br><span class="line">        <span class="type">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">//user=123&amp;passwd=123</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = m_string[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">            <span class="comment">//没有重名的，进行增加数据</span></span><br><span class="line">            <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())<span class="comment">//没有这个名字</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_lock.<span class="built_in">lock</span>();<span class="comment">//操作数据库，互斥</span></span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);<span class="comment">//数据库，没有给mysql变量赋一个连接啊？</span></span><br><span class="line">                users.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(name, password));<span class="comment">//map</span></span><br><span class="line">                m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是登录，直接判断</span></span><br><span class="line">        <span class="comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果请求资源为/0，表示跳转注册界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/register.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)<span class="comment">//如果请求资源为/1，表示跳转登录界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/log.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果以上均不符合，即不是登录和注册，直接将url与网站目录拼接，这里的情况是welcome界面，请求服务器上的一个图片</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//通过stat获取请求资源文件信息，成功则将信息更新到m_file_stat结构体</span></span><br><span class="line">    <span class="comment">//失败返回NO_RESOURCE状态，表示资源不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件的权限，是否可读，不可读则返回FORBIDDEN_REQUEST状态</span></span><br><span class="line">    <span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件类型，如果是目录，则返回BAD_REQUEST，表示请求报文有误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只读方式获取文件描述符，通过mmap将该文件映射到内存中</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(m_real_file, O_RDONLY);</span><br><span class="line">    m_file_address = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//避免文件描述符的浪费和占用</span></span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;<span class="comment">//表示请求文件存在，且可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span><span class="comment">//解除内存映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_file_address)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(m_file_address, m_file_stat.st_size);</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//若要发送的数据长度为0</span></span><br><span class="line">    <span class="comment">//表示响应报文为空，一般不会出现这种情况</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将响应报文的状态行、消息头、空行和响应正文发送给浏览器端</span></span><br><span class="line">        temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)<span class="comment">//发送失败</span></span><br><span class="line">        &#123;	<span class="comment">//判断缓冲区是否满了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;	<span class="comment">//重新注册写事件</span></span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发送失败，但不是缓冲区问题，取消映射</span></span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	   <span class="comment">//正常发送，temp为发送的字节数</span></span><br><span class="line">        bytes_have_send += temp;<span class="comment">//更新已发送字节</span></span><br><span class="line">        bytes_to_send -= temp;<span class="comment">//偏移文件iovec的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个iovec头部信息的数据已发送完，发送第二个iovec数据</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;<span class="comment">//不再继续发送头部信息</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//继续发送第一个iovec头部信息的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断条件，数据已全部发送完</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//在epoll树上重置EPOLLONESHOT事件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)<span class="comment">//浏览器的请求为长连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();<span class="comment">//重新初始化HTTP对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE)<span class="comment">//如果写入内容超出m_write_buf大小则报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    va_list arg_list;<span class="comment">//定义可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_list, format);<span class="comment">//将变量arg_list初始化为传入参数</span></span><br><span class="line">    <span class="comment">//将数据format从可变参数列表写入缓冲区，返回写入数据的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">vsnprintf</span>(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line">    <span class="comment">//如果写入的数据长度超过缓冲区剩余空间，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;<span class="comment">//更新m_write_idx位置</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);<span class="comment">//清空可变参列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;request:%s&quot;</span>, m_write_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *title)</span><span class="comment">//添加状态行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加消息报头，具体的添加文本长度、连接状态和空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_content_length</span>(content_len) &amp;&amp; <span class="built_in">add_linger</span>() &amp;&amp;</span><br><span class="line">           <span class="built_in">add_blank_line</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加Content-Length，表示响应报文的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span><span class="comment">//添加文本类型，这里是html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span><span class="comment">//添加连接状态，通知浏览器端是保持连接还是关闭</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span><span class="comment">//添加空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content)</span><span class="comment">//添加文本content</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span><span class="comment">//逻辑上处理要写什么</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:<span class="comment">//内部错误，500</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);<span class="comment">//状态行</span></span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));<span class="comment">//消息报头</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:<span class="comment">//报文语法有误，404</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:<span class="comment">//资源没有访问权限，403</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:<span class="comment">//文件存在，200</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">        <span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>)<span class="comment">//如果请求的资源存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_headers</span>(m_file_stat.st_size);</span><br><span class="line">            <span class="comment">//第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx</span></span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">            <span class="comment">//第二个iovec指针指向mmap返回的文件指针，长度指向文件大小</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//发送的全部数据为响应报文头部信息和文件大小</span></span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;	<span class="comment">//如果请求的资源大小为0，则返回空白html文件</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除FILE_REQUEST状态外，其余状态只申请一个iovec，指向响应报文缓冲区</span></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span><span class="comment">//对读事件完成最终处理并发送响应报文</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)<span class="comment">//NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//注册并监听读事件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);<span class="comment">//调用process_write完成报文响应</span></span><br><span class="line">    <span class="keyword">if</span> (!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close_conn</span>();<span class="comment">//如果写错误就关闭连接，会把fd删除且关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//？都关闭了且没有注册怎么修改</span></span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);<span class="comment">//注册并监听写事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL_RES *mysql_store_result(MYSQL *mysql)<ul>
<li>对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result() 。</li>
<li>对于其他查询，不需要调用mysql_store_result()或mysql_use_result()，但是如果在任何情况下均调用了mysql_store_result()，它也不会导致任何伤害或性能降低。通过检查mysql_store_result()是否返回0，可检测查询是否没有结果集（以后会更多）。</li>
<li>如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。</li>
</ul>
</li>
<li>unsigned int mysql_field_count(MYSQL *mysql)<ul>
<li>返回作用在连接上的最近查询的列数。</li>
</ul>
</li>
<li>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)<ul>
<li>返回采用MYSQL_FIELD结构的结果集的列。重复调用该函数，以检索关于结果集中所有列的信息。</li>
</ul>
</li>
<li>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)<ul>
<li>检索结果集的下一行。在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL。在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL。行内值的数目由mysql_num_fields(result)给出。</li>
</ul>
</li>
<li>int munmap(void *start,size_t length);<ul>
<li>函数说明 munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。</li>
<li>返回值 如果解除映射成功则返回0，否则返回－1，错误原因存于errno中错误代码EINVAL参数 start或length 不合法。</li>
</ul>
</li>
</ul>
<h1 id="第五站"><a href="#第五站" class="headerlink" title="第五站"></a>第五站</h1><p>项目中使用的是<code>SIGALRM</code>信号，具体的，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计与定时任务的处理。</p>
<h2 id="定时器与信号API"><a href="#定时器与信号API" class="headerlink" title="定时器与信号API"></a>定时器与信号API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Linux中的信号是一种消息处理机制，它本质上是一个整数，不同的信号对应不同的值，信号在系统中的优先级是非常高的。</span><br><span class="line">- 项目中使用的信号</span><br><span class="line"> 	1. SIGALRM：定时器超时信号，超时的时间由系统调用alarm设置，默认终止进程。</span><br><span class="line"> 	2. SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</span><br><span class="line">- 两个特殊信号</span><br><span class="line">	1. SIGKILL：9号信号，无条件终止进程，不能被捕捉、阻塞和忽略。</span><br><span class="line">	2. SIGSTOP：19号信号，无条件暂停进程，不能被捕捉、阻塞和忽略。</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一个信号：SIGPIPE：当服务器close一个连接时，若client端接着发数据。根据TCP 协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。 <ul>
<li>TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown.</li>
<li>对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.</li>
<li>为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它, 给它设置SIG_IGN信号处理函数:signal(SIGPIPE, SIG_IGN);SIG_IGN表示忽略信号</li>
</ul>
</li>
</ul>
<ul>
<li>Linux中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略某些信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。</li>
<li>程序中的信号捕捉是一个注册的动作，提前告诉应用程序信号产生之后的处理动作，当进程中对应的信号产生了，这个处理动作也就被调用了。</li>
</ul>
<ul>
<li><p>sigaction结构体：</p>
<ul>
<li><pre><code class="c++">struct sigaction
&#123;
    void (*sa_handler)(int);                        // 函数指针，指向信号处理函数。
    void (*sa_sigaction)(int, siginfo_t *, void *); // 函数指针，指向信号处理函数，有三个参数。
    sigset_t sa_mask;                               // 在信号处理函数执行期间，临时屏蔽的信号。
    int sa_flags;                                   // 用于指定信号处理的行为
    void (*sa_restorer)(void);                      // 被废弃的成员，一般不使用
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * flag有以下几个：</span><br><span class="line"></span><br><span class="line">    * SA_RESTART，使被信号打断的系统调用自动重新发起</span><br><span class="line">    * SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号</span><br><span class="line">    * SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程</span><br><span class="line">    * SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号</span><br><span class="line">    * SA_RESETHAND，信号处理之后重新设置为默认的处理方式</span><br><span class="line"></span><br><span class="line">* sigaction函数：</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    int sigaction(</span><br><span class="line">        int signum,                  // 要捕捉的信号。</span><br><span class="line">        const struct sigaction *act, // 对信号设置新的处理方式。</span><br><span class="line">        struct sigaction *oldact     // 上一次信号处理方式，一般指定为NULL。</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>返回值，0 表示成功，-1 表示有错误发生。</p>
</li>
</ul>
</li>
<li><p>sigfillset函数：</p>
<ul>
<li>&#96;&#96;&#96;c++<br>int sigfillset(sigset_t * set);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里，即将所有的信号标志位置为1，屏蔽所有的信号。信号集是在执行信号处理程序时被阻塞的信号集。因此，当执行信号处理程序时，所有信号都被阻塞，不必担心另一个信号会中断信号处理程序。</span><br><span class="line"></span><br><span class="line">* SIGALRM、SIGTERM信号，是整形数</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #define SIGALRM  14     //由alarm系统调用产生timer时钟信号</span><br><span class="line">    #define SIGTERM  15     //终端发送的终止信号</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>alarm函数</p>
<ul>
<li><pre><code class="c++">#include&lt;unistd.h&gt;
unsigned int alarm（unsigned int seconds);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号。可以设置忽略或者不捕获此信号，如果采用默认方式其动作是终止调用该alarm函数的进程。</span><br><span class="line"></span><br><span class="line">  * 要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。需要注意的是，经过指定的秒数后，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一些时间。</span><br><span class="line"></span><br><span class="line">  * 返回值：成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</span><br><span class="line"></span><br><span class="line">* socketpair函数</span><br><span class="line"></span><br><span class="line">  * 在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。socketpair创建的描述符任意一端既可以读也可以写。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/socket.h&gt;</span><br><span class="line">    </span><br><span class="line">    int socketpair(int domain, int type, int protocol, int sv[2]);</span><br></pre></td></tr></table></figure>

* domain表示协议族，PF_UNIX或者AF_UNIX，AF = Address Family、PF = Protocol Family。PF_UNIX (也称作 PF_LOCAL ) 套接字族用来在同一机器上的提供有效的进程间通讯。AF\_和PF\_的值直接可以替换，没有其它区别。
* type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
* protocol表示类型，只能为0
* sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
</code></pre>
</li>
<li><p>返回结果， 0为创建成功，-1为创建失败</p>
</li>
</ul>
</li>
<li><p>send函数，当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * sockfd：指定发送端套接字描述符。</span><br><span class="line">    * buff： 存放要发送数据的缓冲区</span><br><span class="line">    * nbytes: 实际要改善的数据的字节数</span><br><span class="line">    * flags： 一般设置为0</span><br><span class="line"></span><br><span class="line">  * 1) send先比较发送数据的长度nbytes和套接字sockfd的发送缓冲区的长度，如果nbytes &gt; 套接字sockfd的发送缓冲区的长度, 该函数返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    2) 如果nbtyes &lt;= 套接字sockfd的发送缓冲区的长度，那么send先检查协议是否正在发送sockfd的发送缓冲区中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送sockfd的发送缓冲区中的数据或者sockfd的发送缓冲区中没有数据，那么send就比较sockfd的发送缓冲区的剩余空间和nbytes。</span><br><span class="line"></span><br><span class="line">    3) 如果 nbytes &gt; 套接字sockfd的发送缓冲区剩余空间的长度，send就一起等待协议把套接字sockfd的发送缓冲区中的数据发送完。</span><br><span class="line"></span><br><span class="line">    4) 如果 nbytes &lt; 套接字sockfd的发送缓冲区剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里(注意：并不是send把套接字sockfd的发送缓冲区中的数据传到连接的另一端的，而是协议传送的。send仅仅是把buf中的数据copy到套接字sockfd的发送缓冲区的剩余空间里)。</span><br><span class="line"></span><br><span class="line">    5) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    6) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    7) 在unix系统下，如果send在等待协议传送数据时网络断开，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的处理是进程终止。</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">## 头文件</span><br><span class="line"></span><br><span class="line">lst_timer.h</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef LST_TIMER</span><br><span class="line">#define LST_TIMER</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">//连接资源结构体成员需要用到定时器类</span><br><span class="line">//前向声明</span><br><span class="line">class util_timer;</span><br><span class="line"></span><br><span class="line">//连接资源</span><br><span class="line">struct client_data</span><br><span class="line">&#123;</span><br><span class="line">    //客户端socket地址，项目中未使用</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    int sockfd;//socket文件描述符</span><br><span class="line">    util_timer *timer;//定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器类</span><br><span class="line">class util_timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    util_timer() : prev(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    time_t expire;//超时时间</span><br><span class="line">    </span><br><span class="line">    void (* cb_func)(client_data *);//回调函数指针，这个回调函数会删除client_data的资源连接</span><br><span class="line">    client_data *user_data;//连接资源，嵌套类使用指针，相当于内部成员指针互相指向对方实例</span><br><span class="line">    util_timer *prev;//前向定时器</span><br><span class="line">    util_timer *next;//后继定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器容器类，双向链表</span><br><span class="line">class sort_timer_lst</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    sort_timer_lst();</span><br><span class="line">    ~sort_timer_lst();//常规销毁链表</span><br><span class="line"></span><br><span class="line">    void add_timer(util_timer *timer);//添加定时器，内部调用私有成员add_timer</span><br><span class="line">    void adjust_timer(util_timer *timer);//调整定时器，任务发生变化时，调整定时器在链表中的位置</span><br><span class="line">    void del_timer(util_timer *timer);//删除定时器</span><br><span class="line">    void tick();//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void add_timer(util_timer *timer, util_timer *lst_head);</span><br><span class="line"></span><br><span class="line">    //创建头尾指针，方便管理</span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Utils//资源管理类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Utils() &#123;&#125;</span><br><span class="line">    ~Utils() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void init(int timeslot);</span><br><span class="line"></span><br><span class="line">    //对文件描述符设置非阻塞</span><br><span class="line">    int setnonblocking(int fd);</span><br><span class="line"></span><br><span class="line">    //将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span><br><span class="line">    void addfd(int epollfd, int fd, bool one_shot, int TRIGMode);</span><br><span class="line"></span><br><span class="line">    //信号处理函数</span><br><span class="line">    static void sig_handler(int sig);</span><br><span class="line"></span><br><span class="line">    //设置信号函数</span><br><span class="line">    void addsig(int sig, void(handler)(int), bool restart = true);</span><br><span class="line"></span><br><span class="line">    //定时处理任务，重新定时以不断触发SIGALRM信号</span><br><span class="line">    void timer_handler();</span><br><span class="line"></span><br><span class="line">    void show_error(int connfd, const char *info);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int *u_pipefd;//管道描述符</span><br><span class="line">    sort_timer_lst m_timer_lst;//定时器容器</span><br><span class="line">    static int u_epollfd;//事务描述符</span><br><span class="line">    int m_TIMESLOT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void cb_func(client_data *user_data);//回调函数</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="cpp实现-2"><a href="#cpp实现-2" class="headerlink" title=".cpp实现"></a>.cpp实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lst_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sort_timer_lst::<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort_timer_lst::~<span class="built_in">sort_timer_lst</span>()<span class="comment">//常规销毁链表</span></span><br><span class="line">&#123;</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)<span class="comment">//没有timer要加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!head)<span class="comment">//链表中一个节点都没有</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = tail = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果新的定时器超时时间小于当前头部结点</span></span><br><span class="line">    <span class="comment">//直接将当前定时器结点作为头部结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire)</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;next = head;</span><br><span class="line">        head-&gt;prev = timer;</span><br><span class="line">        head = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则要插入链表中间或结尾，调用私有方法</span></span><br><span class="line">    <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    util_timer *tmp = timer-&gt;next;</span><br><span class="line">    <span class="comment">//被调整的定时器在链表尾部，不调整</span></span><br><span class="line">    <span class="comment">//定时器超时值仍然小于下一个定时器超时值，不调整（定时器刷新时间只可能更大，不用和前面的节点比较）</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, timer-&gt;next);<span class="comment">//因为timer要比next大，所以next当头节点往后add就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//删除定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::del_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line">    <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == tail)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前时间，定时器的超时时间是以前设置的时间+n个单位超时时间（成为未来时间），所以用当前时间来比较判断是否超时</span></span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="comment">//遍历定时器链表</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//链表容器为升序排列</span></span><br><span class="line">        <span class="comment">//当前时间小于定时器的超时时间，后面的定时器也没有到期</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">        <span class="comment">//将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员，被公有成员add_timer和adjust_time调用</span></span><br><span class="line"><span class="comment">//主要用于调整链表内部结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *prev = lst_head;</span><br><span class="line">    util_timer *tmp = prev-&gt;next;<span class="comment">//不可能比头节点小，所以比较后面的一个节点</span></span><br><span class="line">    <span class="comment">//遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire)<span class="comment">//可以插到tmp前面</span></span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;prev = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = timer;</span><br><span class="line">        timer-&gt;prev = prev;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::init</span><span class="params">(<span class="type">int</span> timeslot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TIMESLOT = timeslot;<span class="comment">//单位时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Utils::setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为保证函数的可重入性，保留原来的errno</span></span><br><span class="line">    <span class="comment">//可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="comment">//将信号值从管道写端写入，传输字符类型，而非整型</span></span><br><span class="line">    <span class="built_in">send</span>(u_pipefd[<span class="number">1</span>], (<span class="type">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置信号函数，信号是指SIGALRM这些信号，本质是一个int</span></span><br><span class="line"><span class="comment">//当超时时（比如alarm）会产生这个信号，这里的设置（注册）就是让这个信号的处理按照这里设置的方式，比如flag和处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(*handler)(<span class="type">int</span>), <span class="type">bool</span> restart)</span><span class="comment">//handler是sig_handler</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建sigaction结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//信号处理函数中仅仅发送信号值，不做对应逻辑处理</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="comment">//将所有信号添加到信号集sa_mask中，屏蔽所有信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">//执行sigaction函数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);<span class="comment">//这个sig信号会屏蔽其他的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(m_TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::show_error</span><span class="params">(<span class="type">int</span> connfd, <span class="type">const</span> <span class="type">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *Utils::u_pipefd = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Utils::u_epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span>;<span class="comment">//在这声明是什么意思？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器回调函数，tick函数调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除非活动连接在socket上的注册事件</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(Utils::u_epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line">    <span class="comment">//减少连接数</span></span><br><span class="line">    http_conn::m_user_count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用逻辑"><a href="#使用逻辑" class="headerlink" title="使用逻辑"></a>使用逻辑</h2><p>首先注册（设置）好信号，比如SIGALRM信号，这使得产生这个信号时，能有对应的方式和处理（默认是终止进程），这里的方式是restart、屏蔽其他信号，处理是通过管道向主循环发这个信号。产生的方式是alarm()，主循环中每次尝试从管道获取信号，如果有这个信号，则设置timeout为true说明有超时事件要处理，因为是非必须事件，在这轮循环读写完再进行处理。</p>
<p>处理会调用timer_handler()，首先调用tick()，把定时器超时的都关了（调用cb_func），然后重新alarm()。</p>
<p>关于SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</p>
<p>也就是：</p>
<ul>
<li><p>信号</p>
<ul>
<li><p>1.先知道有些动作会产生一些信号</p>
</li>
<li><p>2.设置（注册）这些信号产生后的动作——方式（flag）和处理函数（handler）</p>
</li>
<li><p>3.处理函数只是通知主循环有个信号产生，主循环要做对应的处理。</p>
</li>
</ul>
</li>
<li><p>主循环，我们看看会发生什么</p>
<ul>
<li>1.当一个连接到来时，要创建一个定时器给它，初始化时间和回调函数等变量；</li>
<li>2.如果连接有读写，更新时间；</li>
<li>3.无论有没有定时器超时，每隔timeslot（时隙）会alarm一次，触发信号后主循环得知信号产生，去查看有哪些连接的定时器超时了，超时就关闭连接，然后重新设置alarm，循环往复。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建定时器容器链表</span></span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接资源数组</span></span><br><span class="line">client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时默认为False</span></span><br><span class="line"><span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alarm定时触发SIGALRM信号</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化客户端连接地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该连接分配的文件描述符</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化该连接对应的连接资源</span></span><br><span class="line">            users_timer[connfd].address = client_address;</span><br><span class="line">            users_timer[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建定时器临时变量</span></span><br><span class="line">            util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">            <span class="comment">//设置定时器对应的连接资源</span></span><br><span class="line">            timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">            <span class="comment">//设置回调函数</span></span><br><span class="line">            timer-&gt;cb_func = cb_func;</span><br><span class="line"></span><br><span class="line">            <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置绝对超时时间</span></span><br><span class="line">            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">            <span class="comment">//创建该连接对应的定时器，初始化为前述临时变量</span></span><br><span class="line">            users_timer[connfd].timer = timer;</span><br><span class="line">            <span class="comment">//将该定时器添加到链表中</span></span><br><span class="line">            timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">            <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理定时器信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//接收到SIGALRM信号，timeout设置为True</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建定时器临时变量，将该连接对应的定时器取出来</span></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//对其在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">       &#123;</span><br><span class="line">           util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">           <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理定时器为非必须事件，收到信号并不是立马处理</span></span><br><span class="line">    <span class="comment">//完成读写事件后，再进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">timer_handler</span>();</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六站"><a href="#第六站" class="headerlink" title="第六站"></a>第六站</h1><p>内容比较少</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>头文件config.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Config</span>();</span><br><span class="line">    ~<span class="built_in">Config</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">    <span class="type">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式</span></span><br><span class="line">    <span class="type">int</span> LOGWrite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式</span></span><br><span class="line">    <span class="type">int</span> TRIGMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式</span></span><br><span class="line">    <span class="type">int</span> LISTENTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式</span></span><br><span class="line">    <span class="type">int</span> CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接</span></span><br><span class="line">    <span class="type">int</span> OPT_LINGER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量</span></span><br><span class="line">    <span class="type">int</span> sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量</span></span><br><span class="line">    <span class="type">int</span> thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> close_log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型选择</span></span><br><span class="line">    <span class="type">int</span> actor_model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Config::<span class="built_in">Config</span>()&#123;</span><br><span class="line">    <span class="comment">//端口号,默认9006</span></span><br><span class="line">    PORT = <span class="number">9006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式，默认同步</span></span><br><span class="line">    LOGWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式,默认listenfd LT + connfd LT</span></span><br><span class="line">    TRIGMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式，默认LT</span></span><br><span class="line">    LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式，默认LT</span></span><br><span class="line">    CONNTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接，默认不使用</span></span><br><span class="line">    OPT_LINGER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量,默认8</span></span><br><span class="line">    sql_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量,默认8</span></span><br><span class="line">    thread_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭日志,默认不关闭</span></span><br><span class="line">    close_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型,默认是proactor，这个后面介绍</span></span><br><span class="line">    actor_model = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Config::parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>&#123;<span class="comment">//命令行形式获取参数</span></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, str)) != <span class="number">-1</span>)<span class="comment">//这个函数下面介绍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)<span class="comment">//会重新排列参数顺序，所以要switch</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            PORT = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            LOGWrite = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            TRIGMode = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            OPT_LINGER = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sql_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            thread_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            close_log = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            actor_model = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 &lt;unistd.h&gt; 头文件中。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int getopt(int argc, char * const argv[], const char *optstring);<br>extern char *optarg;  &#x2F;&#x2F;选项的参数指针<br>extern int optind,   &#x2F;&#x2F;下一次调用getopt的时，从optind存储的位置处重新开始检查选项。<br>extern int opterr,  &#x2F;&#x2F;当opterr&#x3D;0时，getopt不向stderr输出错误信息。<br>extern int optopt;  &#x2F;&#x2F;当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回’？’、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * argc：通常由函数直接传入，表示参数的数量</span><br><span class="line"></span><br><span class="line">  * argv：通常也由函数直接传入，表示参数的字符串变量数组</span><br><span class="line"></span><br><span class="line">  * optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号</span><br><span class="line"></span><br><span class="line">    * 1.单个字符，表示选项，</span><br><span class="line">    * 2.单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</span><br><span class="line">    * 3 单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）。</span><br><span class="line"></span><br><span class="line">  * getopt处理以&#x27;-’开头的命令行参数，如optstring=&quot;ab:c::d::&quot;,命令行为getopt.exe -a -b host -ckeke -d haha</span><br><span class="line">    在这个命令行参数中，-a和-h就是选项元素，去掉&#x27;-&#x27;，a,b,c就是选项。host是b的参数，keke是c的参数。但haha并不是d的参数，因为它们中间有空格隔开。</span><br><span class="line"></span><br><span class="line">  * getopt()用来分析命令行参数。参数argc和argv是由main()传递的参数个数和内容。参数optstring 则代表欲处理的选项字符串。此函数会返回在argv 中下一个的选项字母（指针不断移动），此字母会对应参数optstring 中的字母。如果选项字符串里的字母后接着冒号“:”，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果getopt()找不到符合的参数则会印出错信息，并将全域变量optopt设为“?”字符，如果不希望getopt()印出错信息，则只要将全域变量opterr设为0即可。</span><br><span class="line"></span><br><span class="line">  * 还要注意的是默认情况下getopt会重新排列命令行参数的顺序，所以到最后所有不包含选项的命令行参数都排到最后。</span><br><span class="line">    如getopt.exe -a ima -b host -ckeke -d haha, 都最后命令行参数的顺序是： -a -b host -ckeke -d ima haha</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">关于proactor模式，小林coding的这篇分析写得很好，推荐看一看：[如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26943938)</span><br><span class="line"></span><br><span class="line">项目中用的是假reactor和模拟proactor（同步的）：[(29条消息) 两种高效的事件处理模式：Reactor模式和Proactor模式_ZY-JIMMY的博客-CSDN博客_reactor模式和proactor](https://blog.csdn.net/ZYZMZM_/article/details/98049471)</span><br><span class="line"></span><br><span class="line">## main</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //需要修改的数据库信息,登录名,密码,库名</span><br><span class="line">    string user = &quot;root&quot;;</span><br><span class="line">    string passwd = &quot;root&quot;;</span><br><span class="line">    string databasename = &quot;qgydb&quot;;</span><br><span class="line"></span><br><span class="line">    //命令行解析</span><br><span class="line">    Config config;</span><br><span class="line">    config.parse_arg(argc, argv);</span><br><span class="line"></span><br><span class="line">    WebServer server;//websever在config.h中导入了websever.h</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    server.init(config.PORT, user, passwd, databasename, config.LOGWrite, </span><br><span class="line">                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, </span><br><span class="line">                config.close_log, config.actor_model);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //日志</span><br><span class="line">    server.log_write();</span><br><span class="line"></span><br><span class="line">    //数据库</span><br><span class="line">    server.sql_pool();</span><br><span class="line"></span><br><span class="line">    //线程池</span><br><span class="line">    server.thread_pool();</span><br><span class="line"></span><br><span class="line">    //触发模式</span><br><span class="line">    server.trig_mode();</span><br><span class="line"></span><br><span class="line">    //监听</span><br><span class="line">    server.eventListen();</span><br><span class="line"></span><br><span class="line">    //运行</span><br><span class="line">    server.eventLoop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="makefile-amp-g"><a href="#makefile-amp-g" class="headerlink" title="makefile&amp;g++"></a>makefile&amp;g++</h2><p>先看这个入门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/82696682">(29条消息) Makefile 语法入门_阿飞__的博客-CSDN博客_makefile语法</a></p>
<p>再看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fangye945a/article/details/85039249">(29条消息) Makefile文件语法规则及用法总结_fangye945a的博客-CSDN博客_makefile语法规则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhaixue.cc/makefile/makefile-ifeq.html">Makefile 条件判断 - ifeq、ifneq、ifdef、ifndef - Makefile 简明教程 | 宅学部落 (zhaixue.cc)</a></p>
<p>g++参数：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104197249">C&#x2F;C++专题—gcc g++ 参数详解 - 知乎 (zhihu.com)</a></p>
<p>rm命令：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/744.html">Linux rm命令：删除文件或目录 (biancheng.net)</a></p>
<p>项目中的makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX ?= g++</span><br><span class="line"></span><br><span class="line">DEBUG ?= 1</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">    CXXFLAGS += -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CXXFLAGS += -O2</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">server: main.cpp  ./timer/lst_timer.cpp ./http/http_conn.cpp ./log/log.cpp ./CGImysql/sql_connection_pool.cpp  webserver.cpp config.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o server  <span class="variable">$^</span> <span class="variable">$(CXXFLAGS)</span> -lpthread -lmysqlclient</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm  -r server</span><br></pre></td></tr></table></figure>

<h1 id="第七站"><a href="#第七站" class="headerlink" title="第七站"></a>第七站</h1><h2 id="顶层实现"><a href="#顶层实现" class="headerlink" title="顶层实现"></a>顶层实现</h2><p>头文件websever.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./threadpool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;           <span class="comment">//最大文件描述符，即最大连接数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>; <span class="comment">//最大事件数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TIMESLOT = <span class="number">5</span>;             <span class="comment">//最小超时单位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>();</span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> port , string user, string passWord, string databaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> log_write , <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thread_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sql_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trig_mode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventListen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealclinetdata</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealwithsignal</span><span class="params">(<span class="type">bool</span>&amp; timeout, <span class="type">bool</span>&amp; stop_server)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//基础</span></span><br><span class="line">    <span class="type">int</span> m_port;<span class="comment">//端口</span></span><br><span class="line">    <span class="type">char</span> *m_root;<span class="comment">//根目录地址</span></span><br><span class="line">    <span class="type">int</span> m_log_write;<span class="comment">//是否要异步写日志，异步写用一个阻塞队列</span></span><br><span class="line">    <span class="type">int</span> m_close_log;<span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> m_actormodel;<span class="comment">//模型切换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_pipefd[<span class="number">2</span>];<span class="comment">//管道通信</span></span><br><span class="line">    <span class="type">int</span> m_epollfd;<span class="comment">//内核描述符</span></span><br><span class="line">    http_conn *users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库相关</span></span><br><span class="line">    connection_pool *m_connPool;</span><br><span class="line">    string m_user;         <span class="comment">//登陆数据库用户名</span></span><br><span class="line">    string m_passWord;     <span class="comment">//登陆数据库密码</span></span><br><span class="line">    string m_databaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">    <span class="type">int</span> m_sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池相关</span></span><br><span class="line">    threadpool&lt;http_conn&gt; *m_pool;</span><br><span class="line">    <span class="type">int</span> m_thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_event相关</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_listenfd;<span class="comment">//监听文件描述符</span></span><br><span class="line">    <span class="type">int</span> m_OPT_LINGER;</span><br><span class="line">    <span class="type">int</span> m_TRIGMode;<span class="comment">//控制连接和读写的触发模式</span></span><br><span class="line">    <span class="type">int</span> m_LISTENTrigmode;</span><br><span class="line">    <span class="type">int</span> m_CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器相关</span></span><br><span class="line">    client_data *users_timer;</span><br><span class="line">    Utils utils;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>.cpp实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//http_conn类对象</span></span><br><span class="line">    users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//root文件夹路径</span></span><br><span class="line">    <span class="type">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(server_path, <span class="number">200</span>);</span><br><span class="line">    <span class="type">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">    m_root = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">    <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    users_timer = <span class="keyword">new</span> client_data[MAX_FD];<span class="comment">//每个连接都对应一个定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">    <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">delete</span>[] users_timer;</span><br><span class="line">    <span class="keyword">delete</span> m_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::init</span><span class="params">(<span class="type">int</span> port, string user, string passWord, string databaseName, <span class="type">int</span> log_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num, <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_port = port;</span><br><span class="line">    m_user = user;</span><br><span class="line">    m_passWord = passWord;</span><br><span class="line">    m_databaseName = databaseName;</span><br><span class="line">    m_sql_num = sql_num;</span><br><span class="line">    m_thread_num = thread_num;</span><br><span class="line">    m_log_write = log_write;</span><br><span class="line">    m_OPT_LINGER = opt_linger;</span><br><span class="line">    m_TRIGMode = trigmode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_actormodel = actor_model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::trig_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//LT + LT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;<span class="comment">//读写的模式</span></span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;<span class="comment">//连接的模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LT + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + LT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::log_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_close_log)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_log_write)<span class="comment">//是否异步写日志</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">800</span>);<span class="comment">//800是阻塞队列长度</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::sql_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据库连接池</span></span><br><span class="line">    m_connPool = connection_pool::<span class="built_in">GetInstance</span>();</span><br><span class="line">    m_connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, m_user, m_passWord, m_databaseName, <span class="number">3306</span>, m_sql_num, m_close_log);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据库读取表</span></span><br><span class="line">    users-&gt;<span class="built_in">initmysql_result</span>(m_connPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::thread_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//线程池，前面创建了users一组http_conn对象，每个对象的工作处理由线程池调用</span></span><br><span class="line">    m_pool = <span class="keyword">new</span> <span class="built_in">threadpool</span>&lt;http_conn&gt;(m_actormodel, m_connPool, m_thread_num);<span class="comment">//只有这一个实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventListen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//网络编程基础步骤</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建一个套接字，监听套接口，socket函数看后面</span></span><br><span class="line">    <span class="built_in">assert</span>(m_listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">linger</span> tmp = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> linger tmp = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//地址配置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//本函数将一个32位数从主机字节顺序转换成网络字节顺序。INADDR_ANY见后面</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(m_port);<span class="comment">//将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，</span></span><br><span class="line"><span class="comment">	从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用big-endian排序方式。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//打开地址复用功能，允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    ret = <span class="built_in">bind</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address));<span class="comment">//见后面</span></span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line">    ret = <span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">init</span>(TIMESLOT);<span class="comment">//初始化资源管理类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll创建内核事件表</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];<span class="comment">//事件集合</span></span><br><span class="line">    m_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);<span class="comment">//事件表描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_listenfd, <span class="literal">false</span>, m_LISTENTrigmode);<span class="comment">//内核事件表注册读事件，监听socket</span></span><br><span class="line">    http_conn::m_epollfd = m_epollfd;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_pipefd);<span class="comment">//创建管道套接字</span></span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    utils.<span class="built_in">setnonblocking</span>(m_pipefd[<span class="number">1</span>]);<span class="comment">//信号写端，设置非阻塞，当缓冲区满了时候不阻塞，减少send执行时间</span></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_pipefd[<span class="number">0</span>], <span class="literal">false</span>, <span class="number">0</span>);<span class="comment">//设置管道读端为ET非阻塞</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传递给主循环的信号值，这里为信号注册处理函数，restart是false，在程序中手动重新设置</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);<span class="comment">//忽略连接断开信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//超时信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//终止信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);<span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具类,信号和描述符基础操作</span></span><br><span class="line">    Utils::u_pipefd = m_pipefd;</span><br><span class="line">    Utils::u_epollfd = m_epollfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span><span class="comment">//获取一个连接后，初始化计时器和用户数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    users[connfd].<span class="built_in">init</span>(connfd, client_address, m_root, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化client_data数据</span></span><br><span class="line">    <span class="comment">//创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span></span><br><span class="line">    users_timer[connfd].address = client_address;</span><br><span class="line">    users_timer[connfd].sockfd = connfd;</span><br><span class="line">    util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">    timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">    timer-&gt;cb_func = cb_func;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    users_timer[connfd].timer = timer;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"><span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;adjust timer once&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">    <span class="keyword">if</span> (timer)</span><br><span class="line">    &#123;</span><br><span class="line">        utils.m_timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;close fd %d&quot;</span>, users_timer[sockfd].sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealclinetdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_LISTENTrigmode)<span class="comment">//LT模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<span class="comment">//返回值是连接描述符</span></span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">timer</span>(connfd, client_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//ET模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//必须一次把监听到的连接读取完，因此循环读取、初始化，直至缓冲区为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">timer</span>(connfd, client_address);<span class="comment">//读取一个连接就初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealwithsignal</span><span class="params">(<span class="type">bool</span> &amp;timeout, <span class="type">bool</span> &amp;stop_server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    ret = <span class="built_in">recv</span>(m_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);<span class="comment">//从读管道读取信号，放到signals缓冲区</span></span><br><span class="line">    <span class="comment">//recv的作用，就是通过fdt找到这个缓冲区，并把数据复制到咱们的参数2指向的地址，复制参数3个</span></span><br><span class="line">    <span class="comment">//返回：读出来的字节大小；客户端下线，返回0；执行失败，返回-1</span></span><br><span class="line">    <span class="comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (signals[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            &#123;</span><br><span class="line">                timeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            &#123;</span><br><span class="line">                stop_server = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reactor，非阻塞同步</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若监测到读事件，将该事件放入请求队列（线程池的请求队列中），同步模式让线程处理整个读过程和相响应报文生成过程</span></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">0</span>);<span class="comment">//users[sockfd]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//一直等待这个读事件完成，很多评论说是作者偷懒了，</span></span><br><span class="line">        <span class="comment">//这不是reactor模式，这相当于阻塞了，最多只有一个http请求。完全没有发挥线程池的作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)<span class="comment">//完成标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)<span class="comment">//如果要关闭的话</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);<span class="comment">//关闭连接</span></span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//异步，主线程和内核执行IO，工作线程负责业务处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor，实际上这里是模拟proactor模式，是同步的模式，只有主线程串行IO</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())<span class="comment">//读数据成功的话（无论是LT还是ET），返回true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;deal with the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">            m_pool-&gt;<span class="built_in">append_p</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">    <span class="comment">//reactor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;send data to the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventLoop</span><span class="params">()</span><span class="comment">//主循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;epoll failure&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理新到的客户连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == m_listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealclinetdata</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">                <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理信号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == m_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealwithsignal</span>(timeout, stop_server);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;dealclientdata failure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithread</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithwrite</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">timer_handler</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;timer tick&quot;</span>);</span><br><span class="line"></span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c++">int socket(int af, int type, int protocol);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</span><br><span class="line">  * type 为数据传输方式/套接字类型，常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（数据报套接字/无连接的套接字）。</span><br><span class="line">  * protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</span><br><span class="line">  * 为什么还需要第三个参数呢？一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</span><br><span class="line"></span><br><span class="line">* 若无错误发生，socket()返回引用新套接口的描述字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
</li>
<li><p>成功返回0</p>
</li>
<li><pre><code class="c++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。</p>
</li>
<li><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为客户端协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
</li>
</ul>
<hr>
<ul>
<li><p>struct linger用法：</p>
</li>
<li><p>Linux下tcp连接断开的时候调用close()函数，有优雅断开和强制断开两种方式。那么如何设置断开连接的方式呢？是通过设置socket描述符一个linger结构体属性。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>struct linger {<br>　　int l_onoff;<br>　　int l_linger;<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 三种断开方式：</span><br><span class="line"></span><br><span class="line">  * 1. l_onoff = 0; l_linger忽略：close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</span><br><span class="line">    2. l_onoff != 0; l_linger = 0：close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。</span><br><span class="line">    3. l_onoff != 0; l_linger &gt; 0：close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则close()会直接返回值。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">使用完linger之后，就用setsockopt()设置</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int setsockopt( int socket, int level, int option_name,const void *option_value, size_t ，ption_len);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第一个参数socket是套接字描述符。第二个参数level是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。 option_name指定准备设置的选项，len是选项的长度。option_name可以有哪些取值，这取决于level，以linux 2.6内核为例（在不同的平台上，这种关系可能会有不同），在套接字级别上(SOL_SOCKET)，option_name可以有以下取值：</p>
<ul>
<li><p>SO_LINGER，如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后&gt;才会返回. 否则, 调用将立即返回。该选项的参数（option_value)是一个linger结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linger</span> &#123;</span><br><span class="line">      <span class="type">int</span>  l_onoff;</span><br><span class="line">      <span class="type">int</span>  l_linger; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果linger.l_onoff值为0(关闭），则清 sock-&gt;sk-&gt;sk_flag中的SOCK_LINGER位；</span></span><br><span class="line"><span class="comment">否则，置该位，并赋sk-&gt;sk_lingertime值为 linger.l_linger。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SO_DEBUG，打开或关闭调试信息。当option_value不等于0时，打开调试信息，否则，关闭调试信息。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置 SOCK_DBG(第10)位，或清SOCK_DBG位。</p>
</li>
<li><p>SO_REUSEADDR，打开或关闭地址复用功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是置sock-&gt;sk-&gt;sk_reuse为1或0。</p>
<ul>
<li>SO_REUSEADDR是一个很有用的选项，一般服务器的监听socket都应该打开它。它的大意是允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接，比如：<ul>
<li><p>服务器启动后，有客户端连接并已建立，如果服务器主动关闭，那么和客户端的连接会处于TIME_WAIT状态，此时再次启动服务器，就会bind不成功，报：Address already in use。</p>
</li>
<li><p>服务器父进程监听客户端，当和客户端建立链接后，fork一个子进程专门处理客户端的请求，如果父进程停止，因为子进程还和客户端有连接，所以再次启动父进程，也会报Address already in use。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SO_DONTROUTE，打开或关闭路由查找功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_LOCALROUTE位。</p>
</li>
<li><p>SO_BROADCAST，允许或禁止发送广播数据。当option_value不等于0时，允许，否则，禁止。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_BROADCAST位。</p>
</li>
<li><p>等等…太多了。</p>
</li>
</ul>
<hr>
<ul>
<li><p>sockaddr_in</p>
</li>
<li><pre><code class="c++">struct sockaddr_in &#123;
    __uint8_t sin_len;
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sin_family指代协议族，在socket编程中只能是AF_INET</span><br><span class="line">  * sin_port存储端口号（使用网络字节顺序）</span><br><span class="line">  * sin_addr存储IP地址，使用in_addr这个数据结构</span><br><span class="line">  * sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span><br><span class="line">  * addr.sin_len=sizeof(addr);//socket字节长度</span><br><span class="line"></span><br><span class="line">* sockaddr_in 结构体：struct sockaddr_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_INET地址族，非常地常用</span><br><span class="line"></span><br><span class="line">* sin_zero 初始值应该使用函数 bzero() 来全部置零。一般采用下面语句</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct sockaddr_in cliaddr; </span><br><span class="line">    bzero(&amp;cliaddr,sizeof(cliaddr)); </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>sockaddr_in结构体变量的基本配置</p>
<ul>
<li>&#96;&#96;&#96;c++<br>struct sockaddr_in ina;<br>bzero(&amp;ina,sizeof(ina));<br>ina.sin_family&#x3D;AF_INET;<br>ina.sin_port&#x3D;htons(23);<br>ina.sin_addr.s_addr &#x3D; inet_addr(“132.241.5.10”);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* sockaddr</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  struct sockaddr &#123;</span><br><span class="line">  unsigned short sa_family; /* address family, AF_xxx */</span><br><span class="line">  char sa_data[14]; /* 14字节，包含目标地址和端口信息 */</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了</p>
</li>
<li><p>sockaddr_in和sockaddr二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。二者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p>
</li>
<li><p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p>
</li>
<li><p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>
</li>
</ul>
<hr>
<ul>
<li>INADDR_ANY</li>
<li>转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。<br>比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢?</li>
<li>如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？</li>
<li>所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</li>
</ul>
<hr>
<ul>
<li><p>bind：服务端用于将把用于通信的地址和端口绑定到 socket上。</p>
</li>
<li><pre><code class="C++">int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
</code></pre>
<ul>
<li>参数 sockfd ，需要绑定的socket。</li>
<li>参数 addr ，存放了服务端用于通信的地址和端口。ip地址和端口号是放在 socketaddr_in 结构体里面的。</li>
<li>参数 addrlen ，表示 addr 结构体的大小。</li>
</ul>
</li>
<li><p>返回值：成功则返回0 ，失败返回-1，错误原因存于 errno 中。如果绑定的地址错误，或者端口已被占用，bind 函数一定会报错，否则一般不会返回错误</p>
</li>
</ul>
<h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>先安装依赖</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%951.png" alt="image-20220919164341581"></p>
<p>然后到webbench-1.5的目录下：make clean，再make。</p>
<p>测试：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%952.png" alt="image-20220919164437394"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E5%8A%9B%E6%89%A3/" class="post-title-link" itemprop="url">刷刷力扣</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 20:14:54" itemprop="dateCreated datePublished" datetime="2022-08-23T20:14:54+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-30 18:12:34" itemprop="dateModified" datetime="2022-09-30T18:12:34+08:00">2022-09-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>很简单的一道题，用哈希映射可以做出来，需要额外空间，另一种解法比较难想，是“原地交换”的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地交换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)</span><br><span class="line">                &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]]==nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="built_in">swap</span>(nums[nums[i]],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：24 ms, 在所有 C++ 提交中击败了96.40%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.4 MB, 在所有 C++ 提交中击败了66.33%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> array[n];<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            array[i]=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(array[nums[i]]==<span class="number">-1</span>)</span><br><span class="line">                array[nums[i]]=<span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时: 32 ms</span></span><br><span class="line"><span class="comment">内存消耗: 22.9 MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>蛮简单的，但是有些细节需要注意。从左下角看上去就类似是一个二叉搜索树。按照这个性质，从左下角开始比较，目标元素小就往上找，大就往右找，每次都能消去一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target = 20，返回 false。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意，必须先判断大小即数组合不合法，因为如果n=0.说明是空数组，这样取m就是错误的了，因为根本没有matrix[0]这个元素</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=m<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：20 ms, 在所有 C++ 提交中击败了79.82%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.7 MB, 在所有 C++ 提交中击败了51.61%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上上面的if判断有冗余，可以利用bool表达式的形式来简化代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>())<span class="comment">//一旦i&lt;0说明n&lt;=0，此时已经是false，不会判断后面的j，也就不会取matrix[0]</span></span><br><span class="line">            				<span class="comment">//这样一个n的if在while里判断了，一个m的if省略掉了</span></span><br><span class="line">            				<span class="comment">//不能写成j&lt;=matrix[0].size()-1，不造为啥，力扣编译器的问题？</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.12%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.8 MB, 在所有 C++ 提交中击败了5.28%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>这题主要是对string要有了解。首先需要一个更长的sting，这是我们替换字符（字符数变多）的前提。string可以原地腾出空间，即用resize弄出空位，这给了一个不用额外多一个辅助空间的条件。</p>
<p>所以首先要算出长度，即先遍历一遍sting看空格数，然后resize。</p>
<p>接着重点是，两个指针<strong>从尾向前遍历</strong>、替换。正是因为从后往前才不会影响到原有的元素（对尾部操作是由于尾部都是空的）。并且从后往前，当两个指针位置相等时就可以停止，因为不可能再替换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="comment">//变换大小，变换后是替换后的大小，尾部那些是空位</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len+count*<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从两个尾部开始，一个是原先的尾部，一个是现在的尾部</span></span><br><span class="line">        <span class="type">int</span> i = len<span class="number">-1</span>, j = len+count*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)<span class="comment">//不用换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=s[i];</span><br><span class="line">                i--;</span><br><span class="line">                j--;<span class="comment">//减了刚好进行下一个if判断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//要替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j-=<span class="number">3</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了83.37%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>因为是从尾到头，有种先进后出的意思，那么可以用一个辅助栈来存储。如果不允许额外的空间，则可以先反转链表，再顺序取出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助栈</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.6 MB, 在所有 C++ 提交中击败了35.04%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        ListNode* cur = head;<span class="comment">//当前指针</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;<span class="comment">//前向指针，注意head的next变为NULL，故pre初始化为nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.3 MB, 在所有 C++ 提交中击败了93.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>将栈分为一个主栈一个辅助栈，这样就能将插入和删除更具有目的性，因此插入就很简单，直接push主栈里，而不去考虑位置，这个问题留到删除来解决。</p>
<p>对于删除，主要是要删头部也就是第一个进来的，但在栈中它位于底部。因此要把主栈元素都倒出来，放辅助栈里，这样辅助栈就是一个按顺序的队列。因此：如果辅助栈不是空的，说明它被倒进来了，顶部元素就是第一个元素，删掉它；如果辅助栈是空的，则元素都在主栈里，如果主栈是空的，返回-1；如果主栈不是空的，就需要把元素倒出来给辅助栈，然后删顶部元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        smain.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!shelp.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=shelp.<span class="built_in">top</span>();</span><br><span class="line">            shelp.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smain.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!smain.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            shelp.<span class="built_in">push</span>(smain.<span class="built_in">top</span>());</span><br><span class="line">            smain.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = shelp.<span class="built_in">top</span>();</span><br><span class="line">        shelp.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; smain;<span class="comment">//主栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; shelp;<span class="comment">//辅助栈</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：248 ms, 在所有 C++ 提交中击败了76.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：101 MB, 在所有 C++ 提交中击败了72.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>简单的动态规划，注意要在运算过程中取模，不然会越界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.1%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><p>一次跳1或2，则到第n个台阶为从n-1或从n-2；因此f(n)&#x3D;f(n-1)+f(n-2)，本质也是斐波那契问题，用动态规划。不同的是初值不同，f(0)&#x3D;f(1)&#x3D;1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了93.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>这题的数组在某种程度上是有序的，因此用二分。但二分是用中间值和target比较，这里的target在哪呢？就用两个端点值，而且只能用右端点的值，这样才能缩小区间。为何要用右端点呢，是因为右端点是截断点，根据比较能缩小区间，左端点则不行。原则上将数组分成两个有序数组（左边段和右边段），就可以缩小区间了。</p>
<p>在比较之后，如果中间大于右端点，说明中间在左边段，而最小值一定在右边段，即在low之后，因此可以缩小区间，把low变成mid，而此时mid不可能是最小值，因此可以变成mid+1。并且必须这样，不然假如是5，1，那么low&#x3D;mid，一直死循环。</p>
<p>如果中间小于右端点，则中间点在右边段了，最小值位置在mid及mid以前，缩小区间high&#x3D;mid，因为mid也可能是最小值，因此high不能mid-1。</p>
<p>如果中间和右端点相等，这是因为这里的数组元素可以相等，此时high不能直接&#x3D;mid，因为左边段可以和右边段相等，如3，3，1，3。直接相等就越过了1。也不能让low&#x3D;mid，因为右段也可以和右端点相等。1，3，3的情况下，就越过了1。因此，直接将high-1就可以了，这样可以保证不越过又可以慢慢缩小区间，如果high是最小值，那么mid也是最小值，不会越过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span><br><span class="line"></span><br><span class="line">给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </span><br><span class="line"></span><br><span class="line">注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&lt;numbers[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[high]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了86.65%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.7 MB, 在所有 C++ 提交中击败了71.43%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>这道题找路径的，就可以用深度优先搜索（dfs），由于每个元素都可以当开头，因此要对每个元素都用一次dfs。然后考虑一下剪枝，在dfs的过程中每个位置都可以继续向上下左右出发（用逻辑或连接起来），因此第一个要考虑的部分就是越界问题；其次，每次dfs都向后探一个字符串单词的字母，如果正确才能继续，因此第二个要考虑的就是当这个位置的字母不正确就返回false。这样就可以保证找到所有的可能。</p>
<p>还要考虑标记的问题，因为矩阵的元素不能重复使用，当这个元素正确要向后dfs时，必须先把这个元素标记不可用，在c++中用’\0’就可以。在dfs之后，还要标记回来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</span><br><span class="line"></span><br><span class="line">单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//初始化行列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,word,i,j,<span class="number">0</span>))<span class="comment">//对每个位置都dfs，0表示单词开始，如果找到则直接返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//声明行列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=n||j&gt;=m||board[i][j]!=word[k]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//越界或不对应则剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(k==word.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没越界且对应，长度也对应，成功</span></span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//向上下左右出发，k+1</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>)||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, i<span class="number">-1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j<span class="number">-1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];<span class="comment">//标记回来</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：520 ms, 在所有 C++ 提交中击败了18.67%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了98.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="I-剪绳子"><a href="#I-剪绳子" class="headerlink" title="I-剪绳子"></a>I-剪绳子</h2><p>这种题首先是求最大值，然后因为乘积是可分解的，因此这个问题可以缩小规模，就可以考虑用动态规划，实际上有更简单的数学解法。对于动态规划，n是从2开始的，然后当长度是n的时候，可以将乘积分两段，要么直接乘，要么对前一段再分（也就是小规模的再动态规划），后一段的长度通过遍历解决，就不用动态规划了。因此长度n时有两种选择，两段乘或再分，然后还要继续遍历，因此要保存好前面求的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]\*k[1]\*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)<span class="comment">//i从3开始，到n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)<span class="comment">//j从1开始，长度到i-1（最简单的遍历方式），</span></span><br><span class="line">                <span class="comment">//这里j从2开始也可以，长度到i-2也可以，因为长度为1的划分没有意义</span></span><br><span class="line">                <span class="comment">//但不能同时，要确保能进入循环，才有dp的定义</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],<span class="built_in">max</span>((i-j)*j,dp[i-j]*j));<span class="comment">//首先要和之前遍历出来的dp[i]比较。然后看</span></span><br><span class="line">        									<span class="comment">//是直接乘更大还是继续划分，j不用dp，因为是遍历的</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><h2 id="II-剪绳子"><a href="#II-剪绳子" class="headerlink" title="II-剪绳子"></a>II-剪绳子</h2><p>这题就不方便用动态规划了，因为会溢出。这个问题出自我们是对结果取余，用动态规划max比较时，取余会造成max比较不正确，比如一个大的取余反而小了。因此不能在比较时候取余，那么在计算过程中就会溢出，即使用long long int也存在这个问题。</p>
<p>那么就可以用到数学的解法，因为数学的解法不需要比较，只需要一直运算就可以：</p>
<ul>
<li><p>根据几何不等式，等分时乘积最大；</p>
</li>
<li><p>等分为长x的a段有：x&#x3D;an，则乘积为$x^a$，由于 n 为常数，因此当 $x^{\frac{1}{x}}$ 取最大值时， 乘积达到最大值。因为$x^a&#x3D;x^{\frac{n}{x}}$</p>
</li>
<li><p>因此对$x^{\frac{1}{x}}$求极大值，取对数有lny &#x3D; lnx&#x2F;x，求导得x&#x3D;e。那么x可取2或3，代入一下2和3，同时取6次方发现3^2&#x3D;9大一些，因此最好分成长为3的。</p>
</li>
</ul>
<p>结论：</p>
<p>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。<br>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 $2 \times 2 &gt; 3 \times 1$。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]\*k[1]\*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;<span class="comment">//必须切分一次</span></span><br><span class="line">        <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="number">4</span>;<span class="comment">//最后的4变成2*2</span></span><br><span class="line">            n = n - <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            ret = <span class="number">2</span>;<span class="comment">//最后的2留着</span></span><br><span class="line">            n = n - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            ret = ret * <span class="number">3</span> % <span class="number">1000000007</span>;<span class="comment">//这里可以取模的原因是，跟max不同，ret是已经确定好的答案，只是一直没算完，</span></span><br><span class="line">            						<span class="comment">//先模后模的结果是一样的           </span></span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.22%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>第一种方法是逐位看是不是1，直接把1左移然后和n与运算那就好。也可以模2来做。</p>
<p>第二种方法是用n&amp;(n-1)，因为n-1会把第一个1右边的0变成1，且这个1变成0，那么再与n做与运算时，实际上就是把n的第一个1消去了（原来的0和1&amp;也是0，但原来的1由于变成了0，&amp;后也是0），因此每做一次这个操作，就有一个1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &#x27;1&#x27; 的个数（也被称为 [汉明重量]。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逐位比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1</span>&lt;&lt;i))<span class="comment">//不断将1左移i位，也就是和n的第i位对齐，然后取与运算</span></span><br><span class="line">                res++;<span class="comment">//如果结果非0，则是一个1</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了33.03%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n&amp;(n-1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n &amp;= n<span class="number">-1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.8 MB, 在所有 C++ 提交中击败了82.14%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h1><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>简单的快速幂+迭代，假如数值是x，次方的n，那么就是要分n是奇数还是偶数，这是因为如果是奇数要多一项，偶数则直接x平方。把n看成二进制的话，举个例子，如果n&#x3D;1000，则是$x^8$，把x的二次方再二次方再二次方，整个过程三次即可（因为有三个零），但如果是1001，则要先乘一个x，再乘$x^8$。</p>
<p>也就是说，如果n是奇数，则底数累乘一个“x”。为了循环计算，我们要把n每次除以2（其实就是一位一位看是不是1），然后再看是不是奇数。对应此，所谓的“x”就也是累成的，可以定义一个k存储中间结果。</p>
<p>再注意一下细节，如果n是负数，那么要把x取倒数，然后把n正过来。但是负数的n正过来可能会使int溢出，所以要用longlong来做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>)<span class="comment">//预处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            N=-N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> k = x;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                res *= k;<span class="comment">//如果最后一位是1，说明对应的k要乘</span></span><br><span class="line">            k = k*k;<span class="comment">//不管如何，因为N要右移了，k要平方一次</span></span><br><span class="line">            N/=<span class="number">2</span>;<span class="comment">//右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了82.47%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h1><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><p>这题之所以是简单题，是因为题目设计时不需要考虑大数问题，这类题目最好直接以大数的形式来写，这就需要string来辅助。</p>
<p>由于最后要返回vector，因此定义一个vector成员变量，这里面存int；同时使用两个辅助函数，一个用来递增数，一个用来将string转换为int存到vector里。</p>
<p>public内是主函数，由于定义string需要数的大小n，这是主函数的参数，因此string也要在主函数定义，所以辅助函数也需要传入string这个参数（用引用，递增函数要修改number），具体见代码。然后循环递增，每个数都转int放vector，最后返回就可以了。循环的结束判断利用递增函数的返回值来做，如果溢出则结束（溢出表明数已经大于给定的位数了）</p>
<p>对于转int函数，重点是把string前面多余的’0’去掉，从头开始遍历这些0，当不是0时就退出，然后用另一个string用+&#x3D;把剩下的都连接起来，最后用stoi函数转int。</p>
<p>对于递增函数，重点是进位。首先定义一个表示进位的变量，然后就能得出每个位置上应该变成的值了：<code>num = number[i]-&#39;0&#39;+takeOver;//当前位等于原来的加上进位的</code>，当然最低位因为递增要加一。takeOver初始化为0，因为最低位没有进位。然后要循环判断进位，因为有可能是…99999的情况。所以我们的循环从最低位开始，最低位的num得出后要num++，然后如果num&#x3D;&#x3D;10说明要进位，takerOver&#x3D;1，这一位变成0；同时如果是最高位了，就溢出了，返回false。如果没有进位，就到此为止了，设置这一位的string的值就可以了，最后返回true表示可以继续递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个能容纳最大值的字符数组，由于需要n，因此在函数里创建而不成为类成员，这导致辅助函数需要传入number这个参数</span></span><br><span class="line">        <span class="function">string <span class="title">number</span><span class="params">(n,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="comment">//初始全部设置为0，因为输出从1开始，后面就先增加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">increment</span>(number))<span class="comment">//在increment的过程中判断是否结束，因为increment既有到哪一位的信息、也有是否进位的信息</span></span><br><span class="line">            <span class="built_in">saveNum</span>(number);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//将string转int，放数组里</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increment</span><span class="params">(string &amp;number)</span><span class="comment">//运行一次就+1</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> takeOver = <span class="number">0</span>;<span class="comment">//最大的要点就是考虑进位，一开始的进位是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)<span class="comment">//i从最后开始，代表数从最低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = number[i]-<span class="string">&#x27;0&#x27;</span>+takeOver;<span class="comment">//当前位等于原来的加上进位的</span></span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">                num++;<span class="comment">//如果是最低位，则要+1，代表增加一个1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">10</span>)<span class="comment">//若要进位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最高位，且加上进位是10，溢出了，结束</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    number[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    takeOver = <span class="number">1</span>;<span class="comment">//不用再设回0，因为一旦不用进位就结束了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//不用进位就到此为止</span></span><br><span class="line">            &#123;</span><br><span class="line">                number[i] = num+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveNum</span><span class="params">(string &amp;number)</span><span class="comment">//这个函数主要是把number前面多余的0去掉</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> notzero = len;<span class="comment">//如果都为0则notzero不会被重新赋值，这会使后面那个循环直接跳过，使得s不变就是&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//找到第一个不为0的地方</span></span><br><span class="line">            &#123;</span><br><span class="line">                notzero = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=notzero;i&lt;len;i++)</span><br><span class="line">            s += number[i];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> resnum = <span class="built_in">stoi</span>(s);</span><br><span class="line">        res.<span class="built_in">push_back</span>(resnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了14.22%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.6 MB, 在所有 C++ 提交中击败了12.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h1><h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><p>简单的双指针应用，一个前一个后，cur指针来判定，pre指针要进行节点越过操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;<span class="comment">//现在head不是目标节点，从next开始</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val==val)<span class="comment">//如果找到</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;<span class="comment">//越过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则两个指针向后</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.51%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.9 MB, 在所有 C++ 提交中击败了84.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>简单的快排思想的应用，其实就是头尾双指针。这份代码我进行了一些小的细节上的优化，效果不错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> i&lt;j)<span class="comment">//这个过程要加i&lt;j的判断，一方面防止全是奇数时nums[i]的i越界了，一方面减少循环次数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> i&lt;j)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)<span class="comment">//减少不必要的交换和动作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="comment">//手动推进，可以减少大while或小while的一次判断</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了99.32%的用户</span></span><br><span class="line"><span class="comment">内存消耗：17.5 MB, 在所有 C++ 提交中击败了87.78%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h1><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p>用快慢双指针就很简单了，快指针先走k步（指向第k+1个节点），然后两个指针再一起走直至快指针为null，此时快指针又走了n-k步，慢指针也走了n-k步，倒数过来就是倒数第k个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</span><br><span class="line"></span><br><span class="line">例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *quick = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(quick)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了68.49%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.2 MB, 在所有 C++ 提交中击败了73.69%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>简单的双指针pre和cur，前面的从尾到头打印链表写过了。感觉也可以用辅助栈，不过不推荐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.85%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.9 MB, 在所有 C++ 提交中击败了93.81%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>简单题，大概是一个merge。使用一个非nullptr的伪头节点能减少代码重复（new一个），当然不用也行，这样还是得要一个head和一个cur，不过先比较l1和l2的头节点大小得出head和cur的指向，然后再进while循环。原因是while内要cur-&gt;next，如果cur没有指向节点而是null则它都没有next，只能在while里面再if判断是不是第一次进入，这样每次又多了一个if。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于一开始不知道是l1头小还是l2小，因此可以定义一个伪头节点(不是nullptr，所以用new构建一个)，这样可以</span></span><br><span class="line">        <span class="comment">//使头节点的比较也放在while里，和其他节点一样。这样减少了代码重复</span></span><br><span class="line">        ListNode *cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = cur;<span class="comment">//head用来保存，cur用来移动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;<span class="comment">//伪头节点后就是</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了92.19%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.6 MB, 在所有 C++ 提交中击败了78.85%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用伪头节点，先比较获得头节点，代码比较臃肿，但是性能不差</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置处理</span></span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *head;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.83%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了92.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>细节在要注意给的矩阵是不是空的，如果是空要直接返回了，否则会有些越界问题。然后我们先获得上下左右四个边界，然后进入一个大的while循环一遍不断地“绕圈”。然后在while内根据边界右、下、左、上遍历元素，同时更新边界，并判断是否越界，越界就可以退出了。总体下来就是根据“边界”，在while(true)里for循环，知道这个就比较简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>()<span class="number">-1</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(bottom==<span class="number">-1</span>)<span class="comment">//没有元素</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：9.6 MB, 在所有 C++ 提交中击败了73.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>使用双栈来简化操作，一个主栈就进行push、pop和top（不进行其他操作），另一个辅助栈维护min，这样设计就能明确要做什么。</p>
<p>为了维护min，辅助栈的每次push就需要比较，除了空的时候直接放入，后面的push都只放入不大于栈顶的值。因为大于栈顶的值必然不可能再成为最小值了，它会在最小值被pop之前pop（因为先后顺序的原因），同时相等的元素要放入，因为pop了一个最小值，剩下的也可以是最小值。对于pop，只有当主栈pop出去的是最小值时，辅助栈才pop，因此要判断相不相等。</p>
<p>这样，返回min就只用返回辅助栈的top。实际上，核心是将辅助栈设计成一个升序栈（从顶到底），原理是因为后来的更大的值不可能成为最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; xstack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; hstack;<span class="comment">//help stack，辅助栈维护升序栈</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        xstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(hstack.<span class="built_in">empty</span>())</span><br><span class="line">            hstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;=hstack.<span class="built_in">top</span>())</span><br><span class="line">                hstack.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="comment">//辅助栈维护最小值，因此只有更小的才放进去。大的不放是因为辅助栈的顶部一定是最小值，假如说这个最小值被pop出去不存在了</span></span><br><span class="line">    <span class="comment">//那么这个更大的值肯定也更早被pop出去（因为最小值更先存在，大的在更顶上），所以这个最大值不会成为最小值，没必要放进去。</span></span><br><span class="line">        <span class="comment">//使用等于判断是因为可能有多个最小值，pop出一个还有其他的也算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = xstack.<span class="built_in">top</span>();<span class="comment">//要看辅助栈的最小值要不要pop出去</span></span><br><span class="line">        xstack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==hstack.<span class="built_in">top</span>())</span><br><span class="line">            hstack.<span class="built_in">pop</span>();<span class="comment">//如果主栈pop出去的是一个最小值，那么这个最小值也要pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.07%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.6 MB, 在所有 C++ 提交中击败了86.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>这题主要用模拟，根据生活中“手动判断”的过程来模拟。这是怎么样的过程呢：我们一般会跟踪元素一个个push的过程，然后对比poped序列，一旦一个元素可以pop，那就pop并且把前面能pop的也pop。这是因为数字都是不同的，如果错过了pop时机，再有元素进来就不再能pop了，也就错了。</p>
<p>而这里给的两个序列都是vector，我们模拟要不断pop，这不太方便，所以用到一个辅助栈（这也就是我们手动模拟用到的容器）。这样模拟就是：把pushed一个一个放进辅助栈（pushed如同数组，所以用for循环放直观一些），每放进一个就查看poped序列（记录好上次查看的位置），如果相等就pop，然后poped序列向后继续比较看能不能pop（这就用while循环，因为while直接能进行比较判断，并且也不知道for的次数）。</p>
<p>辅助栈不断加入元素，并且在合适时pop，如果最后辅助栈是空的，那么就是正确的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 &#123;1,2,3,4,5&#125; 是某栈的压栈序列，序列 &#123;4,5,3,2,1&#125; 是该压栈序列对应的一个弹出序列，但 &#123;4,3,5,1,2&#125; 就不可能是该压栈序列的弹出序列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.<span class="built_in">size</span>()!=popped.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//先考虑大小，不同直接false</span></span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果大小为0就true</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//然后开始模拟，pushed和popped是不同排列，所以数字相同</span></span><br><span class="line">        <span class="comment">//如果直接对pushed栈模拟，不好操作，因为pushed是个vector，不对顶操作</span></span><br><span class="line">        <span class="comment">//所以用一个辅助栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> pop_j = <span class="number">0</span>;<span class="comment">//指向popped的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//注意pushed和popped是vector而不是stack，要以数组形式使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pushed[i]);<span class="comment">//不断按顺序放入元素</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() <span class="keyword">and</span> st.<span class="built_in">top</span>()==popped[pop_j])<span class="comment">//然后尝试倒出，如果能倒则一直倒出，</span></span><br><span class="line">                                         <span class="comment">//因为数字不同正确性是唯一的，能倒时不倒，下一个进来时就不可能再倒出了</span></span><br><span class="line">                <span class="comment">//!st.empty()不能漏，因为top()在没有元素时出错、popped[pop_j]可能会越界，也不能直接判断pop_j，</span></span><br><span class="line">                <span class="comment">//因为存在st空了但pop_j还没越界的情况，使用st一举两得</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                pop_j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了70.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.8 MB, 在所有 C++ 提交中击败了73.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>这题有难度，主要在于没见过不太好想。先从正常的复制开始，如果只是复制next，那么我们遍历一遍原来的链表就可以得到next的信息了。为什么不能得到random呢，原因是random指向的那个节点不知道在哪里，不可能再用一层遍历去找。你可能会想着先遍历复制next的信息，再遍历一遍得到random，这里的关键问题是，我们在第二遍遍历的时候，确实是可以知道原来链表的节点random指向的位置，假设为A，但新的链表的节点random指针要指向的节点在哪呢？假设这个节点叫B，我们的问题是不能从A来找到B，B还是未知的。</p>
<p>因此，重点就是解决这个问题。简单的方法是，就把每个新的节点先放在原来节点的后面，这样就可以用next来找到复制的节点。因此上面的B就是A-&gt;next。于是就建立好了关系：<code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</code>。然而random可以指向null，没有next，所以要判空。</p>
<p>最后执行两个链表的拆分即可。整个过程就是：原地拷贝延申、修改random、拆分。注意拷贝要用new。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置判空</span></span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原地拷贝延申</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newcur-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur;</span><br><span class="line">            cur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改random指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random)<span class="comment">//如果这个random不是null才有意义</span></span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<span class="comment">//cur-&gt;next表示那个新复制的节点，然后-&gt;random表示修改指向，</span></span><br><span class="line">                                                    <span class="comment">//指向的是cur-&gt;random这个节点的next，也就是对应的新复制的节点</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *newhead = head-&gt;next;<span class="comment">//记录下来，因为要用到next，所以head不能为null，因此前面要判断是否为null</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur-&gt;next;<span class="comment">//cur非null，那么newcur非null，但newcur-&gt;next可能是null，也即这是最后一对节点</span></span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next)<span class="comment">//如果不是null</span></span><br><span class="line">                newcur-&gt;next  =cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则直接是null，因为没有null-&gt;next</span></span><br><span class="line">                newcur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了73.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.9 MB, 在所有 C++ 提交中击败了90.72%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>挺难的一道题，我用的是“下一个排列”的方法。</p>
<p>下一个排列的方法很难理解，一共有四步：1.从后往前找到第一个（严格）升序的元素对，这个元素对的前一个是“较小数”，后面那一段都是降序（非严格，跳过相同的字符，这里面i和j的比较都加”&#x3D;”）的；2.从后往前找到第一个比“较小数”大的数，这个数是“较大数”；3.“较小数”和“较大数”交换；4.交换后，降序的那段依然降序，要反过来变成升序（用reverse函数或前后双指针swap）。在第一步中，我们用i和i+1判断元素对，如果字符串已经是最后一个排列了，或字符串是全相等的（或部分相等，不需要再排列了）时，i会变成-1（找不到），则此时要返回false了。</p>
<p>有了下一个排列，就可以慢慢获得所有排列了，首先就是要把原字符串sort变成最小的排列，然后do-while（因为第一个排列总是要放进去的），注意do-while的while有”;”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串，打印出该字符串中字符的所有排列。</span><br><span class="line"></span><br><span class="line">你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//因为是取下一个排列遍历，所以先排序得到最小排列</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">nextpermutation</span>(s));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">nextpermutation</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="comment">//加等号是因为字符串可能有相同字符，这里要加等号越过它们，表示重复的只有一种情况；</span></span><br><span class="line">        <span class="comment">//否则i会停在重复的字符，j会更向前，导致前面的情况又换回来，进入死循环</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;s[i]&gt;=s[i+<span class="number">1</span>])<span class="comment">//从右向左找到第一个非降序的，即突然凹下去的那里</span></span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果都是降序的，说明已经是最后一个排列了</span></span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]&gt;=s[j])</span><br><span class="line">            j--;<span class="comment">//从右向左找到第一个比a[i]大的</span></span><br><span class="line">        <span class="comment">//if(j&lt;0)</span></span><br><span class="line">            <span class="comment">//return false;//如果字符串都是相等的就可能一直往前走越界，但这种情况已经被i判断了，不用在j这考虑</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        <span class="comment">//现在后面i+1开始那一段是降序的，反转一下变成升序会更小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=i+<span class="number">1</span>,m=s.<span class="built_in">size</span>()<span class="number">-1</span>;n&lt;m;n++,m--)</span><br><span class="line">            <span class="built_in">swap</span>(s[n],s[m]);</span><br><span class="line">        <span class="comment">//可以调库reverse(s.begin() + i + 1, s.end());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.9 MB, 在所有 C++ 提交中击败了99.15%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>摩尔投票法，记住两个变量：候选者、投票数。如果没有计数就重置候选者，然后通过比较候选者和当前值看票数要加一还是减一。知道这个方法就很简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的组总是存在多数元素。</span><br></pre></td></tr></table></figure>

 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常逻辑版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">            &#123;</span><br><span class="line">                cand = num;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==cand)<span class="comment">//如果有计数说明有候选者，相等则计数++</span></span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//即有计数，也不相等</span></span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了65.56%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了66.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">                cand = num;</span><br><span class="line">            count+= num==cand?<span class="number">1</span>:<span class="number">-1</span>;<span class="comment">//无论如果都判断一次，这里把count是不是0的情况都包含了</span></span><br><span class="line">            				<span class="comment">//因为count是0也是count++</span></span><br><span class="line">           	<span class="comment">//这种方式也就是把上面的else if的else去掉了，变成两个独立的if而不是一个大if，会快一些。</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了97.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了85.24%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p>方法是快速排序，使用快排的思想，注释写了很多了，能达到O(n)的时间复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size == k)<span class="comment">//刚好就不用排了</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="built_in">quickSelect</span>(arr,k,<span class="number">0</span>,size<span class="number">-1</span>);<span class="comment">//快速选择：把最小的k个放在最前面</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr[i]);<span class="comment">//前k个都是小的了，拷贝一下</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l,j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)<span class="comment">//先快排</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[j]&gt;=arr[l])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[i]&lt;=arr[l])<span class="comment">//加等号使得相同元素相对位置不改变，稳定排序</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[l]);</span><br><span class="line">        <span class="comment">//快排要把arr[l]放在两段的中间，就需要保证arr[i]是一个不比arr[l]大的数；</span></span><br><span class="line">        <span class="comment">//因此那两个while必须先从j开始，因为当j停下时，要么是碰到了i（上一轮的i已经是小的了），这时全部结束，i是较小的</span></span><br><span class="line">        <span class="comment">//要么是等待置换，此时轮到i走，要结束只能碰到j，j在等待，是较小的</span></span><br><span class="line">        <span class="comment">//如果while先对i做，可以想到i可能停在上一轮的j处，此时j是大的</span></span><br><span class="line">        <span class="comment">//因此如果用左边界，则要从右开始，置换i；用右边界则从左开始，置换j</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时快排做完，i和i前的元素都是小的，前i+1个元素都是小的，且前i个元素小于第i+1个元素（i代表第i+1个元素）</span></span><br><span class="line">        <span class="comment">//与快排不相同的是，这里分情况再排，而不是两段直接排</span></span><br><span class="line">        <span class="keyword">if</span>(i==k||i==k<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//i=k或者i+1=k</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;k)  <span class="built_in">quickSelect</span>(arr,k,l,i<span class="number">-1</span>);<span class="comment">//i左边元素有些多，对左边再排，i本身不用排了，不可能是</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">quickSelect</span>(arr,k,i+<span class="number">1</span>,r);<span class="comment">//i&lt;k-1，这里只用排k-i-1个元素了，但为什么参数仍然是k呢？</span></span><br><span class="line">        							<span class="comment">//因为我们是从左边界i+1开始的</span></span><br><span class="line">                                      <span class="comment">//排序只对l-r之间的元素，但位置i仍是整体的，并不是从左边界开始从0算起，因此参数仍是k</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了52.99%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>动态规划，递推方程是：<code>dp[i] = max(dp[i-1],0)+nums[i];</code>。dp[i]的意思是前i个数的子数组的最大和，则dp[i]是前面的最大值加上nums[i]，其中如果前面的最大值是一个负数就从头开始，就是0+nums[i]。加上nums[i]才使得这样的递推的子数组是连续的，因为dp[i-1]也加上了nums[i-1]，如果大于0，那么使用它的话就是连续的子数组了。</p>
<p>这里面动态规划注意一个要点，如果递推式不利用历史信息的话，只利用前面一项或几项，那就可以用一个或几个变量代替dp数组，能把空间复杂度从O(n)变成O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</span><br><span class="line"></span><br><span class="line">要求时间复杂度为O(n)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划普通版本，使用dp数组递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],<span class="number">0</span>)+nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了81.76%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.8 MB, 在所有 C++ 提交中击败了27.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里面呢，实际上dp数组在遍历时只用到前面一项，更之前的信息完全不用，实际上就可以简化为两个变量cur和pre，一个代表dp[i]，一个代表dp[i-1]。更进一步，cur和pre只是前一轮和这一轮的关系，用一个变量完全足够了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            等价于：</span></span><br><span class="line"><span class="comment">            cur = max(pre,0)+nums[i];</span></span><br><span class="line"><span class="comment">            pre = cur;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pre = <span class="built_in">max</span>(pre,<span class="number">0</span>)+nums[i];<span class="comment">//其实就是pre = cur = max(pre,0)+nums[i]; cur完全不需要。</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了95.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.3 MB, 在所有 C++ 提交中击败了88.01%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p>这题是困难的，比较难想，不会就快排再算。这里考虑的是数据流，比较偏应用，就是要用一个合适的数据结构来做（也说了要选数据结构）。这里插入对于数据结构都好说，主要是中位数怎么找。根据中位数的性质可以把数据均分成较大的一组和较小的一组，然后只要找到两个数据组中“突出”的那一个就好了，也就是中位数或两个用于计算中位数的数。我们只要一个或两个数，这些数是较大组的最小值或较小组的最大值（这样才居中）。</p>
<p>因此就可以用堆，因为堆就是用来存最大值和最小值的，在c++中可以用优先级队列priority_queue来做。堆有两个，一个小顶堆存较大数据的最小值、一个大顶堆存较小数据的最大值。这里的重点是维护数据均分，如果是偶数则两个堆数据个数相同，如果是奇数则其中任意一个多一个数据，这里选大顶堆多一个元素。</p>
<p>因此就分两种情况插入数据，如果插入前两个堆大小相等，则要向大顶堆插入。但不知道这个数据多大，因此不能直接插入，而需要先插入小顶堆，再从小顶堆拿出（pop）顶部元素插入大顶堆。这个过程就是把新元素和较大元素比较，拿出最小的放入大顶堆，保证了大顶堆中的元素全都小于小顶堆。如果插入前大顶堆个数多（根据设计不可能小顶堆更多），则要向小顶堆插入，同样的要先插入大顶堆，然后拿出顶部元素插入小顶堆。</p>
<p>最后是取中位数，如果堆大小相等，则取两个堆顶部元素（即数据流大小最中间的两个元素）取平均；否则大顶堆多一个元素，根据大小关系直接返回大顶堆的顶部元素。注意这里取平均在除以2之前要*1.0转double。</p>
<p>这样插入时间复杂度是O(logn)，取中位数是O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line"></span><br><span class="line">[2,3,4] 的中位数是 3</span><br><span class="line"></span><br><span class="line">[2,3] 的中位数是 (2 + 3) / 2 = 2.5</span><br><span class="line"></span><br><span class="line">设计一个支持以下两种操作的数据结构：</span><br><span class="line"></span><br><span class="line">void addNum(int num) - 从数据流中添加一个整数到数据结构中。</span><br><span class="line">double findMedian() - 返回目前所有元素的中位数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大顶堆，存储较小的一半的数据，堆顶为最大值</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;<span class="comment">//less表示降序排序</span></span><br><span class="line">    <span class="comment">// 小顶堆， 存储较大的一半的数据，堆顶为最小值</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;<span class="comment">//greater表示升序排序</span></span><br><span class="line">    <span class="comment">//第一个参数是类型、第二个参数是底部容器（使用heap的算法）、第三个参数是比较方式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当两堆的数据个数相等时候，向大顶堆添加元素（也可以向小顶堆添加，指定一个堆放多的元素）。</span></span><br><span class="line"><span class="comment">         * 采用的方法不是直接将数据插入大顶堆，而是将数据先插入小顶堆（因为这个元素大小不好说），算法调整后</span></span><br><span class="line"><span class="comment">         * 将堆顶的数据（较大数中最小的）插入到大顶堆，这样保证大顶堆插入的元素始终比小顶堆的元素小。</span></span><br><span class="line"><span class="comment">         * 同理如果大顶堆数据多，往小顶堆添加数据的时候，先将数据放入大顶堆，选出最大值（top）放到小顶堆中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//这种添加方式是让奇数个数时多的那一个放到大顶堆中，实际上也可以放小顶堆中，方式是镜像的</span></span><br><span class="line">        <span class="comment">//但使用一种方式后，其他的操作要适应它。因为这些数据个数决定了中位数的取法。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(num);<span class="comment">//先放小顶堆</span></span><br><span class="line">            <span class="type">int</span> top = minHeap.<span class="built_in">top</span>();<span class="comment">//把较大的值中最小的那个拿出来</span></span><br><span class="line">            minHeap.<span class="built_in">pop</span>();<span class="comment">//pop</span></span><br><span class="line">            maxHeap.<span class="built_in">push</span>(top);<span class="comment">//给大顶堆</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="type">int</span> top = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            minHeap.<span class="built_in">push</span>(top);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) </span><br><span class="line">            <span class="keyword">return</span> (maxHeap.<span class="built_in">top</span>()+minHeap.<span class="built_in">top</span>())*<span class="number">1.0</span>/<span class="number">2</span>;<span class="comment">//转double</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>()*<span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：92 ms, 在所有 C++ 提交中击败了75.35%的用户</span></span><br><span class="line"><span class="comment">内存消耗：40.6 MB, 在所有 C++ 提交中击败了84.11%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h1><h2 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h2><p>本质是找规律的题目，个位数有9个（下标从0开始，序列算了0，相当于抵消）、个位数有90个、百位数有900个…根据这些规律就能得出n在那一个位数的阶段中，比如n&#x3D;11就在10~99这个两位数的段里。然后就能得出从这个段起始开始还要走多少个数字x（因为前面的总数字数肯定是知道的，这样才能得到在哪个段嘛），根据这个x和位数的关系又能得出是第几个数的第几位，然后转string取出来就好了。</p>
<p>注意这里当n比这一位数和前面位数的数字要多时，要算后面的位数的总个数，但是这样可能会越界，因为乘以了9，数没有那么多。那么就要有溢出判断，不应该乘以9时就不做了。</p>
<p>这种题还是用些实例来想过程，比如取11、12等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</span><br><span class="line"></span><br><span class="line">请写一个函数，求任意第n位对应的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> intmax = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//溢出判断，false是溢出</span></span><br><span class="line">        <span class="type">int</span> digit = <span class="number">1</span>;<span class="comment">//位数</span></span><br><span class="line">        <span class="type">int</span> total = <span class="number">9</span>;<span class="comment">//总数</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">1</span>;<span class="comment">//起始点，因为每个起始都是10、100、1000这样的，每次乘10就可以</span></span><br><span class="line">        <span class="comment">//因为下标也从0开始计数，所以n=9时对应的是9，因此total为9表示个位数</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;total)<span class="comment">//首先确定n代表的数在哪个位数中</span></span><br><span class="line">        &#123;</span><br><span class="line">            digit++;<span class="comment">//表示进入下一位数的范围</span></span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digit*start&gt;=intmax/<span class="number">9</span>)<span class="comment">//做乘法会溢出，不做了</span></span><br><span class="line">            &#123;   </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += digit*start*<span class="number">9</span>;<span class="comment">//下一位数有9*start个数，每个数有digit位，这就能算出下一位数的数字个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> x;<span class="comment">//x是从start开始的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="comment">//如果没溢出</span></span><br><span class="line">            x = n-total+digit*start*<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果要溢出，说明最后的total是没做的</span></span><br><span class="line">            x = n-total;<span class="comment">//前面有total个单个的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num = start + (x<span class="number">-1</span>)/digit;<span class="comment">//第num个数，x-1是因为start本身就是第一位，比如10的话应该是10+0/digit，但此时x是1</span></span><br><span class="line">        <span class="type">int</span> k = (x<span class="number">-1</span>)%digit;<span class="comment">//k是指第num个数的第k位，x要减一同理</span></span><br><span class="line"></span><br><span class="line">        string nums = <span class="built_in">to_string</span>(num);<span class="comment">//to_string函数把int转string</span></span><br><span class="line">        <span class="keyword">return</span> nums[k]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//这里nums[k]是char要转一下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了89.87%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p>这题也比较难想，一般直接去想会想成遍历或规划问题。实际上这题被做成了一道排序问题，假如有数字x，y，如果x+y&gt;y+x，那么x应该放在y前面（后面充要证明）。当x和y相邻时这很好理解，但当xy不相邻时，为什么x一定要在y前面呢？必要性：我们假设有一个最小的排列axyzb，我们很容易得到a&lt;x，x&lt;y，y&lt;z，z&lt;b，否则我们可以交换相邻的元素得到更小的排列，即假如z&gt;b我们可以交换z和b。充分性：如果a&lt;x，x&lt;y，y&lt;z，z&lt;b，那么按axyzb的排列一定最小，因为交换 a,b（表示任意交换两个元素）相当于依次交换 ax,ay,az，接着交换 zb,yb,xb 。每一次相邻交换都使得交换后的值更大。</p>
<p>因此，如果x+y&gt;y+x，那么x应该放在y前面。那么我们对这个数组进行排序就可以了，能够排序的原因是每两个元素都能得到明确的大小关系和可传递性（一旦x&gt;y，y&gt;z，那么x&gt;z，即如果x在y前面，y在z前面，根据前面的充要证明，x一定在z前面），这和正常的比大小一样。因此能使用快排来做，每次都和左边界标值比较，看x应该放在标值前还是后。</p>
<p>将数组转string的vector，然后排序，再拼接就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先转string</span></span><br><span class="line">        vector&lt;string&gt; str;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(nums[i]));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(str,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(string strs : str)</span><br><span class="line">            s += strs;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;string&gt;&amp; str,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//排序</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i=l, j = r;<span class="comment">//左边界右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j <span class="keyword">and</span> str[l]+str[j]&lt;=str[j]+str[l]) j--;</span><br><span class="line">            <span class="comment">//j--的情况是前+后的值小于后+前，前是标值l，后是值j，此时说明不用换</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j <span class="keyword">and</span> str[l]+str[i]&gt;=str[i]+str[l]) i++;</span><br><span class="line">            <span class="built_in">swap</span>(str[i],str[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(str[i],str[l]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(str,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(str,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了91.34%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11 MB, 在所有 C++ 提交中击败了53.92%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h1><h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><p>通过读题目可以发现，要么对一位数字直接翻译，要么对两位数字进行翻译，即1或2，这和动态规划的青蛙跳台阶很像。对于第i位结尾的数字，如果能知道第i-1位结尾时翻译总数和第i-2位结尾时的翻译总数，那么就有f(i)&#x3D;f(i-1)+f(i-2)。这个递推式是解释是，第i位要么单独翻译要么和i-1位一起翻译，能这么做的原因是这两种翻译出来的字符串肯定不一样。</p>
<p>然而还需要考虑的是，i和i-1位组成的数字不一定能够翻译（10–25之间），因此在不能翻译时，递推式退化成f(i)&#x3D;f(i-1)，这只是一个if的事情。</p>
<p>根据这个递推式，就可以使用动态规划，由于最多往前两项，那么用三个变量即可，不用用数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。</span><br><span class="line">一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//翻译范围是0-9，10-25</span></span><br><span class="line">        <span class="comment">//f(i) = f(i-1)+f(i-2)，其中i和i-1要能满足翻译范围，否则f(i) = f(i-1)</span></span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;<span class="comment">//f(i-1)</span></span><br><span class="line">        <span class="type">int</span> prepre = <span class="number">0</span>;<span class="comment">//f(i-2)</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            string s = str.<span class="built_in">substr</span>(i<span class="number">-1</span>,<span class="number">2</span>);<span class="comment">//拿出i和i-1</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * string substr (size_t pos = 0, size_t len = npos) const;</span></span><br><span class="line"><span class="comment">            * 在字符位置pos开始，跨越len个字符（或直到字符串的结尾，以先到者为准）对象的部分。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(s&lt;=<span class="string">&quot;25&quot;</span>&amp;&amp;s&gt;=<span class="string">&quot;10&quot;</span>)</span><br><span class="line">                cur = pre + prepre;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = pre;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了82.92%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h2><p>一眼动态规划。<code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])+gird[i][j]</code>，从左边或上边到来，选一个大的路径加上本身（价值大于0）。这里巧妙的地方是，不需要一个额外的dp[n][m]数组，可以直接修改grid，因为遍历到grid某处时的值只需要使用自身和前面的累加值，那么在使用了自身后就可以把自己修改成累加值，以后不用自身原来的值了：<code>grid[i][j] = max(grid[i-1][j],grid[i][j-1])+gird[i][j]</code>，简便写法：<code>grid[i][j] += max(grid[i-1][j],grid[i][j-1])</code>。最后，最大值一定是右下角元素，因为所有礼物最大值都大于0，路径一定会走到那里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。</span><br><span class="line">你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。</span><br><span class="line">给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//dp[i][j] = max(dp[i-1][j],dp[i][j-1])+gird[i][j]，从左边或上边到来，选一个大的路径加上本身（价值大于0）</span></span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt;&gt; dp;不用额外的数组，在grid原地修改即可，</span></span><br><span class="line">        <span class="comment">//因为grid本身的数组并不需要，后面的计算使用的是前面的累加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dp数组初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m;i++)<span class="comment">//累加第一行</span></span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i<span class="number">-1</span>];<span class="comment">//第一行右边的价值只能由左边累加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;n;i++)<span class="comment">//累加第一列</span></span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];<span class="comment">//第一列下边的价值只能由上边累加</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一定走到右下角，因为价值大于0</span></span><br><span class="line">        <span class="keyword">return</span> grid[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.90%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.7 MB, 在所有 C++ 提交中击败了94.41%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h1><h2 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h2><p>这种字符串的问题，可以考虑以第i位为结尾的后缀怎么怎么样。设dp[i]是以第i位结尾的字符串的最长不含重复字符的子字符串的长度，注意这里隐含地说明了第i位一定在这个字符串里，这给连续性带来了方便。</p>
<p>那么假如知道了dp[i-1]，那么dp[i]怎么得出呢？我们只需要知道s[i]上一次出现的位置即可（假设是j）。如果上一次出现的位置在dp[i-1]到i的范围内，那么这个子串需要缩小，dp[i]&#x3D;i-j，从j开始算。否则，i在dp[i-1]前面或者根本没出现，这两种情况都可以直接dp[i]&#x3D;d[i-1]+1，即s[i]和前面连接</p>
<p>如何记录上一次s[i]的位置呢？用一个哈希表存储，map[s[i]]表示和s[i]相同的字符上一次出现的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这种字符串的问题，可以考虑以第i位为结尾的后缀怎么怎么样</span></span><br><span class="line"><span class="comment">        设dp[i]是以第i位结尾的字符串的最长不含重复字符的子字符串的长度，</span></span><br><span class="line"><span class="comment">        注意这里隐含地说明了第i位一定在这个字符串里，这给连续性带来了方便</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        那么假如知道了dp[i-1]，那么dp[i]怎么得出呢？我们只需要知道s[i]上一次出现的位置即可（假设是j）。</span></span><br><span class="line"><span class="comment">        如果上一次出现的位置在dp[i-1]到i的范围内，那么这个子串需要缩小，dp[i]=i-j，从j开始算</span></span><br><span class="line"><span class="comment">        否则，i在dp[i-1]前面或者根本没出现，这两种情况都可以直接dp[i]=d[i-1]+1，即s[i]和前面连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        如何记录上一次s[i]的位置呢？用一个哈希表存储，map[s[i]]表示和s[i]相同的字符上一次出现的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;<span class="comment">//因为要创建dp和map，如果n是0就出问题。这里顺便把n=1的情况也一起干了</span></span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_v = <span class="number">1</span>;</span><br><span class="line">        map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//map.find()在找到元素时返回迭代器，否则返回map.end()。当还不确定找不到得到时，先判断一下</span></span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i]) == map.<span class="built_in">end</span>())<span class="comment">//没有这个元素，如果直接map[s[i]]就报错了，所以这里的顺序很重要</span></span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(map[s[i]]&lt;i-dp[i<span class="number">-1</span>])</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = i-map[s[i]];</span><br><span class="line"></span><br><span class="line">            map[s[i]] = i;<span class="comment">//更新</span></span><br><span class="line">            max_v = <span class="built_in">max</span>(dp[i],max_v);<span class="comment">//每次都要和dp[i]比较，这是这个解法的核心：每个不同位置结尾的子串都可能最长</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_v;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>简单的规律是一个丑数乘以2、3或5能得到更大的丑数，更进一步可以推导到：每个丑数都无非是前面的丑数乘2、3或5不断增加得来的。那么我们可以用动态规划，把前面得到的丑数不断乘以2、3、5就能得到更大的、后面的丑数</p>
<p>这里的问题是如果单单对一个数同时乘以2、3、5，那么会导致顺序不对，我们明确了要第n个丑数，因此这里有个排序的问题。除了排序的问题，还有重复的问题（如2*5和5*2是同一个丑数）</p>
<p>因此好的解法是，当要求下一个丑数时，一定是某些数（不一定是同一个数）乘2、3或5，把最小的那个拿来，然后把对应的数移向下一个（这导致了数不同）并判断重复，如果重复了这个数也要后移。因为上一个丑数是更前面的某些数乘2、3或5得到的最小值，且考虑了重复问题，那么这个新的最小的丑数比上一个丑数要大，且会比下一个丑数要小，这就有顺序了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个丑数都无非是前面的丑数乘2、3或5不断增加得来的</span></span><br><span class="line">        <span class="comment">//那么我们可以用动态规划，把前面得到的数字不断乘以2、3、5就能得到更大的、后面的丑数</span></span><br><span class="line">        <span class="comment">//这里的问题是如果单单对一个数同时乘以2、3、5，那么会导致顺序不对，因此这里有个排序的问题。</span></span><br><span class="line">        <span class="comment">//除了排序的问题，还有重复的问题</span></span><br><span class="line">        <span class="comment">//因此好的解法是，当要求下一个丑数时，一定是某些数乘2、3或5，把最小的那个拿来</span></span><br><span class="line">        <span class="comment">//然后把对应的数移向下一个并判断重复，如果有重复其他也要后移</span></span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;<span class="comment">//分别指向下一次要乘2、3、5的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;<span class="comment">//记录第i个丑数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//重复n次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> numa = dp[a]*<span class="number">2</span>, numb = dp[b]*<span class="number">3</span>, numc = dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(numa,<span class="built_in">min</span>(numb,numc));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果dp[i]等于这些数的某个或某几个，说明是使用了或者有重复，要向下跳一个</span></span><br><span class="line">            <span class="keyword">if</span>(numa == dp[i])</span><br><span class="line">                a++;</span><br><span class="line">            <span class="keyword">if</span>(numb == dp[i])</span><br><span class="line">                b++;</span><br><span class="line">            <span class="keyword">if</span>(numc == dp[i])</span><br><span class="line">                c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];<span class="comment">//返回第n个丑数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.4 MB, 在所有 C++ 提交中击败了73.97%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h1><h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p>哈希表查看有没有重复，然后再遍历一次找到第一个没重复的即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">bool</span>&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历查看重复</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i])==map.<span class="built_in">end</span>())<span class="comment">//用find函数看是否已存在</span></span><br><span class="line">                map[s[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map[s[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历查询第一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(map[s[i]])<span class="comment">//按s[i]的顺序来遍历</span></span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：40 ms, 在所有 C++ 提交中击败了39.13%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.4 MB, 在所有 C++ 提交中击败了75.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p>算法课写过的一道题，可以使用归并排序，只需要添加一点细节就可以了。这个算法的核心是，在归并排序merge的过程中，我们有两个指针指向前一段和后一段，如果后一段的元素要放上去，说明这个元素比前面一段的剩余元素要小，这就产生了逆序对，数量是前面那一段剩余的元素。而当我们把递归的小的段排好后，把这一段产生的逆序对给上层累加，上层继续merge就又可以计算了。排序并不会影响逆序对的数量，因为前一段和后一段分别有序，也不影响前后之间的相对关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSortCount</span>(<span class="number">0</span>,n<span class="number">-1</span>,nums,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSortCount</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终结果是这一次归并加上左右递归归并产生的逆序对，因为递归时已经排序好了，那个过程中记录的逆序对数要返回上层</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSortCount</span>(left,middle,nums,tmp)+<span class="built_in">mergeSortCount</span>(middle+<span class="number">1</span>,right,nums,tmp);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//现在左右两段分别是有序的，要创建一个辅助空间，有三种方式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1.vector&lt;int&gt; tmp = nums;//辅助空间，如果这样写每次都要拷贝一个很大的nums，会超时</span></span><br><span class="line"><span class="comment">        * 2.</span></span><br><span class="line"><span class="comment">        * int tmp[right-left+1];</span></span><br><span class="line"><span class="comment">        * for(int k=0;k&lt;right-left+1;k++)</span></span><br><span class="line"><span class="comment">        *     tmp[k] = nums[left+k];//创建对应位置的tmp，不过后面使用tmp就要注意下标了</span></span><br><span class="line"><span class="comment">        * 3.像1一样创建一个大的全局tmp，这使得下标能和nums对应，同时使用2的做法，只</span></span><br><span class="line"><span class="comment">        * 在使用时拷贝对应的元素，这就使得全过程只进行了线性拷贝</span></span><br><span class="line"><span class="comment">        * 这个使用时是指在底层的两段排序好后，像2一样，不过既然是全局的，就要用引用传入参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//tmp拷贝元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=left;k&lt;=right;k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = left, j = middle+<span class="number">1</span>;<span class="comment">//双指针分别指向两段的开头</span></span><br><span class="line">        <span class="type">int</span> cur = left;<span class="comment">//指向nums数组</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle <span class="keyword">and</span> j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]&lt;=tmp[j])</span><br><span class="line">                nums[cur++] = tmp[i++];<span class="comment">//赋值同时指针移动</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//后面的小于前面的，只有这时要产生逆序对，所有i-middle的元素都可以和j构成逆序对</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[cur++] = tmp[j++];<span class="comment">//赋值同时指针移动</span></span><br><span class="line">                res += middle-i+<span class="number">1</span>;<span class="comment">//i-middle共有middle-i+1个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//收尾</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle) nums[cur++] = tmp[i++];<span class="comment">//前一段剩下的都大于后一段，不过对应的j要产生的逆序对在前面的while产生完了</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right) nums[cur++] = tmp[j++];<span class="comment">//后面的大于前面的</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：144 ms, 在所有 C++ 提交中击败了86.13%的用户</span></span><br><span class="line"><span class="comment">内存消耗：43.3 MB, 在所有 C++ 提交中击败了64.45%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day18"><a href="#day18" class="headerlink" title="day18"></a>day18</h1><h2 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h2><p>这个算法的核心是，A指针走完A就从B的头开始走，B指针走完B就从A的头开始走，那么它们就能在走过相同步长后在相交点相遇。</p>
<p>假如没有相交点，最终会同时到达nullptr（等长则第一轮抵达，不等长则第二轮抵达）这就使得我们可以和判断相交一样，采用判断A&#x3D;&#x3D;B的形式，此时退出循环刚好返回nullptr，这在注释里有更详细的解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入两个链表，找出它们的第一个公共节点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line"></span><br><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//有没有都不影响算法的正确性</span></span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断是否要跳转或是否往下走，而不是先往下走再判断或者先判断再往下走</span></span><br><span class="line"><span class="comment">        如果先往下再判断，那么while中A和B就不可能是nullptr</span></span><br><span class="line"><span class="comment">        如果先判断再往下走，那么跳到head之后总会next，而head可能是相交节点</span></span><br><span class="line"><span class="comment">        因此跳转和next是互斥的，不能同时做（要同时的话需要其他辅助手段）</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        当没有交点时，最终会同时到达nullptr（等长则第一轮抵达，不等长则第二轮抵达）</span></span><br><span class="line"><span class="comment">        采用判断的话，A和B可以在执行next后同时到达nullptr达成break条件</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        而有交点时，如果A和B等长，则在第一轮中间就结束返回</span></span><br><span class="line"><span class="comment">        如果不等长，则第一轮A和B不会同时为nullptr，是nullptr就跳，不是就往下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(A != B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A == <span class="literal">nullptr</span>) A = headB;<span class="comment">//跳转</span></span><br><span class="line">            <span class="keyword">else</span> A = A-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(B == <span class="literal">nullptr</span>) B = headA;</span><br><span class="line">            <span class="keyword">else</span> B = B-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：32 ms, 在所有 C++ 提交中击败了97.75%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.1 MB, 在所有 C++ 提交中击败了90.20%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找数字I"><a href="#在排序数组中查找数字I" class="headerlink" title="在排序数组中查找数字I"></a>在排序数组中查找数字I</h2><p>排序数组第一时间想二分法，同时根据二分法比较时有没有“&#x3D;”，即<code>nums[middle]&lt;target</code>和<code>nums[middle]&lt;=target</code>的不同，指针会停在不同的位置，我们设置两次二分，得到左边界和右边界就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//二分法，判断条件的“=”能使得算法指针停在不同的边界</span></span><br><span class="line">        <span class="comment">//分别得出target左边界和右边界即可知道有多少个</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=r)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> middle = i + (r-i)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;target)</span><br><span class="line">                i = middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = middle<span class="number">-1</span>;<span class="comment">//如果找到target，会缩小右边界，继续往前找</span></span><br><span class="line">            <span class="comment">//也就是说i是左边界，i是target第一次出现的位置（如果有）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=nums.<span class="built_in">size</span>() || nums[i]!=target) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//i越界或者i的位置不是target，说明找不到，提前返回</span></span><br><span class="line">                                    <span class="comment">//越界是因为可能所有元素都比target小</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j&lt;=r)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> middle = j + (r-j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&lt;=target)<span class="comment">//如果找到target，会缩小左边界，继续往后找</span></span><br><span class="line">                j = middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = middle<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//也就是说j是右边界，这个右边界是target之后的那个数，因为找到target会继续往后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了90.78%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.8 MB, 在所有 C++ 提交中击败了82.86%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day19"><a href="#day19" class="headerlink" title="day19"></a>day19</h1><h2 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a>0~n-1中缺失的数字</h2><p>排序数组用二分，这些题其实就二分的判断条件改改就完事了，然后注意边界怎么缩小的，要不要-1，while结束是i&lt;j还是i&lt;&#x3D;j。一般来讲，边界都是m+1和m-1，对应的结束条件就是i&lt;&#x3D;j。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。</span><br><span class="line">在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = i+(j-i)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//索引k处的值要么大于k要么等于k</span></span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==middle)</span><br><span class="line">                i = middle+<span class="number">1</span>;<span class="comment">//middle和middle前都是正确的，缩小左边界</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//大于</span></span><br><span class="line">                j = middle<span class="number">-1</span>;<span class="comment">//middle处已经大于了，要么是middle要么往前，缩小右边界</span></span><br><span class="line">                    <span class="comment">//那么middle为什么能-1呢？这样不会跳过正确答案吗？</span></span><br><span class="line">                    <span class="comment">//这是因为如果middle是正确答案且-1跳过了，那么会一直i=middle+1，最后回到正确答案且结束循环</span></span><br><span class="line">                    <span class="comment">//同时如果不减一则while循环无法结束，卡在i=j处（一直执行j=middle=i）</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了53.30%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.6 MB, 在所有 C++ 提交中击败了94.64%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h2><p>这个问题特殊之处在于，除了出现一次的数字，其他数字都出现了两次，这个两次很关键，它可以通过异或运算来加工——两个相同的数异或为0，0异或其他数字为其他数字。因此，把这些出现了两次的数字都异或了，结果就是0，接着去异或一个出现一次的数字，那么异或的结果就是这个数字了。</p>
<p>然而问题还没有这么简单，这个数组有两个出现一次的数字。我们的想法是，如果能把这两个数字分分组，就像奇偶一样分成两组就好了，因为每一组其他的数字都出现两次（相同的当然在一组啦），那么分别对这两组异或就能得到两个答案了。</p>
<p>但这两个目标数字不一定一个是奇数一个是偶数，我们可以肯定的是它们数值不一样。我们接着从异或出发，因为我们在异或整个数组前不知道两个数字是什么，那么我们在异或整个数组后能得到一个数z，z相当于这两个数字异或，肯定有一位是1，记这一位是m（全0说明这两数相同了）。就像奇数偶数一样，它们只是最后一位不同，那么我们也可以根据这一位m来分组，第m位为1的一组，第m位为0的一组，这样就分成两组了，分别异或就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">要求时间复杂度是O(n)，空间复杂度是O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先遍历异或找出z</span></span><br><span class="line">        <span class="type">int</span> z = <span class="number">0</span>;<span class="comment">//初始为0，因为0异或谁结果就是谁</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">            z ^= num;<span class="comment">//注意这里是^=，z=z异或num</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出z为1的第m位</span></span><br><span class="line">        <span class="type">int</span> m = <span class="number">1</span>;<span class="comment">//00000....00001</span></span><br><span class="line">        <span class="keyword">while</span>((z&amp;m) == <span class="number">0</span>)</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;<span class="comment">//如果与运算是0，说明还没到1的那位，m左移把1对过去，注意这里是&lt;&lt;=，m等于m左移一位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在知道m了，边分组边异或</span></span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>;<span class="comment">//初始化同z</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num&amp;m)</span><br><span class="line">                x ^= num;<span class="comment">//第m位为1的异或</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                y ^= num;<span class="comment">//第m位为0的异或</span></span><br><span class="line">            <span class="comment">//两个数字肯定不在一起异或，因为第m位不同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;x,y&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了89.84%的用户</span></span><br><span class="line"><span class="comment">内存消耗：15.6 MB, 在所有 C++ 提交中击败了85.82%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day20"><a href="#day20" class="headerlink" title="day20"></a>day20</h1><h2 id="数组中数字出现的次数II"><a href="#数组中数字出现的次数II" class="headerlink" title="数组中数字出现的次数II"></a>数组中数字出现的次数II</h2><p>上一个问题是出现两次的数字异或是0，现在呢，出现三次的数字加起来，再模三就是0。因此所有数字加起来模三就是那个只出现一次的数字模三，但这只能求得余数，不过这至少给我们一些启发。</p>
<p>这个余数是小于3的，如果要用加法和余数表示这个数字的话，那么这个数字原来的那位数就必须小于3。由此联想到二进制的一位数，我们把所有的数字都看成二进制的话，它们相加就是每一位相加。对于那些出现三次的数字，全部来看的话，二进制上每个位都正好被3整除，因为数字要么这一位是0，要么就有三个1。最后我们把目标数字的二进制添加上去，因为要么是0要么是1，没有超出余数的范围，这样的话模三就可以了。</p>
<p>注意这里的二进制“相加”并不是真的相加，而是统计每个二进制位到底有多少个1，然后模三，余数就是目标数字二进制的对应位置的值。</p>
<p>总结一下就是：考虑数字的二进制形式，对于出现三次的数字，各二进制位出现的次数都是 3 的倍数。因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int最多只有三十二位，所以只需要统计32位上每一位的1的个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">binary</span><span class="params">(<span class="number">32</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历统计每一个num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)</span><br><span class="line">            <span class="comment">//对于每一个数，统记二进制位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)<span class="comment">//0表示最低位，往高位走</span></span><br><span class="line">            &#123;</span><br><span class="line">                binary[i] += num&amp;<span class="number">1</span>;<span class="comment">//取最后一位，如果是1就+1，如果是0就+0，数值对应就不用if-else了，直接加法</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>;<span class="comment">//num右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//现在要模三，取每一位数</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从高位来，这样res不断左移就往高处推了</span></span><br><span class="line">            <span class="comment">//如果从低位开始，res不能左移不能右移，反而k每次要左移i次</span></span><br><span class="line">            <span class="comment">//虽然影响不大，总究浪费点效率 </span></span><br><span class="line">            <span class="type">int</span> k = binary[<span class="number">31</span>-i]%<span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//k要么是0要么是1，k总是在最低位，所以res要不断左移</span></span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;<span class="comment">//先左移再取位，顺序反了的话最低位总是会左移...</span></span><br><span class="line">            res |= k;<span class="comment">//res = res|k</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：32 ms, 在所有 C++ 提交中击败了66.58%的用户</span></span><br><span class="line"><span class="comment">内存消耗：15.6 MB, 在所有 C++ 提交中击败了89.42%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h2><p>前后双指针，老生常谈了。</p>
<p>优化的话，可把while里面if判等的条件放在while判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。</span><br><span class="line">如果有多对数字的和等于s，则输出任意一对即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[i]+nums[j]!=target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]&gt;target)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[j]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：140 ms, 在所有 C++ 提交中击败了96.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：98.1 MB, 在所有 C++ 提交中击败了67.91%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day21"><a href="#day21" class="headerlink" title="day21"></a>day21</h1><h2 id="和为s的连续正整数序列"><a href="#和为s的连续正整数序列" class="headerlink" title="和为s的连续正整数序列"></a>和为s的连续正整数序列</h2><p>双指针一直往前滑动，维护一个滑动窗口就好了。这种方式实际上是在不断否定前面的序列，因为如果大了，那么右边界移动就更不可能了，所以只能左边界移动；如果小了就只移动右边界扩大，因为左边界起始点不动是可能的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</span><br><span class="line"></span><br><span class="line">序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">2</span>;<span class="comment">//窗口的左边界和右边界，一直往前看就行</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)<span class="comment">//i不能=j</span></span><br><span class="line">        &#123;   </span><br><span class="line">            count = (i+j)*(j-i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(count==target)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                    tmp.<span class="built_in">push_back</span>(k);</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                i++;<span class="comment">//i往后一位</span></span><br><span class="line">                j++;<span class="comment">//i往后肯定更小，j一定要往后</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count&lt;target)</span><br><span class="line">                j++;<span class="comment">//小了就j++，扩大右边界</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;<span class="comment">//大了就i++，缩小左边界，减去小的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6.5 MB, 在所有 C++ 提交中击败了62.75%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><p>用个辅助栈咯，在遍历过程中用个string存单词字母，遇到空格说明单词存好了，放入栈里，同时这个string变成空。那么如果后面还是空格，string是空，就可以辨别出是不是连续的空格了，因为单词后的空格string不是空。</p>
<p>最后要拼接，再把多余的空格删除。string经常要删除最后一个字符，用pop_back()舒服点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。</span><br><span class="line">为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. &quot;，则输出&quot;student. a am I&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; help;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//这轮遍历只记单词，空格一律过滤掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> tmp==<span class="string">&quot;&quot;</span>)<span class="comment">//遇到连续的空格</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> tmp!=<span class="string">&quot;&quot;</span>)<span class="comment">//遇到第一个空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                help.<span class="built_in">push</span>(tmp);</span><br><span class="line">                tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//最后一个单词不一定有空格，所以还要if一下</span></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                tmp+=s[i];<span class="comment">//不是空格的话</span></span><br><span class="line">                <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="comment">//最后的了</span></span><br><span class="line">                    help.<span class="built_in">push</span>(tmp);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!help.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res += help.<span class="built_in">top</span>();</span><br><span class="line">            help.<span class="built_in">pop</span>();</span><br><span class="line">            res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后会多一个空格</span></span><br><span class="line">        <span class="comment">//可以用substr(0,len-1)左闭右开</span></span><br><span class="line">        <span class="comment">//可以用earse(len-1)</span></span><br><span class="line">        <span class="comment">//可以用pop_back()</span></span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了77.87%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.2 MB, 在所有 C++ 提交中击败了50.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day22"><a href="#day22" class="headerlink" title="day22"></a>day22</h1><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        string tmp = s.<span class="built_in">substr</span>(<span class="number">0</span>,n);<span class="comment">//把前面n个记录下来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-n;i++)</span><br><span class="line">            s[i] = s[i+n];<span class="comment">//往前挪</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size-n;i&lt;size;i++)</span><br><span class="line">            s[i] = tmp[i-size+n];<span class="comment">//把后面填上去</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.2 MB, 在所有 C++ 提交中击败了52.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day23"><a href="#day23" class="headerlink" title="day23"></a>day23</h1><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>记住：使用一个辅助的非严格递减的双端队列，先进先出，头部元素就是窗口的最大值。</p>
<p>这题正常想挺难想的，关键词是顺序遍历（滑动）、最值，实际上跟min栈很像，也是以一定顺序push和pop。min栈用的是辅助栈，滑动窗口是先进先出的，因此可以考虑用一个辅助的单调双端队列。</p>
<p>这个队列是维持窗口可能的最大值的，要怎么设计的呢？我们的窗口向后移动时，会移除最前面的元素，添加后面的元素。如果后的元素较大，那么更前的比它小的元素一定不可能再成为之后某个窗口的最大值，因为它们比后面的元素先出去，还比后面的元素小。</p>
<p>基于这样的思想，就可以在插入单调队列时把比这个元素小的都移除，这些被移除的元素在nums数组的位置肯定在插入的元素前。那么怎么移除呢，完全遍历的话就浪费时间，如果能维持单调递减，就可以从后往前比较大小和pop了，</p>
<p>在窗口移动的过程中，我们不仅增加了一个元素还减少了一个元素，如果这个元素在单调队列里面，我们需要把它删掉。如果它不是前一个窗口的最大值，那么它一定不在单调队列了，因为它是前一个窗口的第一个元素，没有后面元素大肯定不在；如果它是前一个窗口的最大值，那它在队列头部，pop掉就完事了。这能保持队列内的候选者都是当前窗口内的元素。</p>
<p>这样，单调队列的第一个元素，即最大的元素一定是这个滑动窗口的最大值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单调队列，非严格递减</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">        deq.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);<span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//没形成窗口前，先维护双端队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把比nums[i]小的都丢了，当然如果队列已经空了就不做了</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() <span class="keyword">and</span> nums[i]&gt;deq.<span class="built_in">back</span>())</span><br><span class="line">                deq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">//把nums[i]添加进去</span></span><br><span class="line">            deq.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(deq[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//现在已经有一个滑动窗口了</span></span><br><span class="line">        <span class="comment">//移向下一个滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=k;j&lt;nums.<span class="built_in">size</span>();i++,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//deq现在是上一个滑动窗口的单调队列</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]==deq[<span class="number">0</span>])</span><br><span class="line">                deq.<span class="built_in">pop_front</span>();<span class="comment">//如果移除的值是最大值，就把最大值移出单调队列 </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//把比nums[j]小的都丢了，当然如果队列已经空了就不做了</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() <span class="keyword">and</span> nums[j]&gt;deq.<span class="built_in">back</span>())</span><br><span class="line">                deq.<span class="built_in">pop_back</span>();<span class="comment">//在j之前的数还比j小的话，那么这些数不可能是最大值了，因为这些数走得早</span></span><br><span class="line">            <span class="comment">//把nums[j]添加进去</span></span><br><span class="line">            deq.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             前面的操作能保证i-j窗口以外的元素已经绝对不在deq里了</span></span><br><span class="line"><span class="comment">             因为j之后的还没添加，i之前的，如果i-1不是最大值，那么上一个窗口的最大值就在i-j-1之间</span></span><br><span class="line"><span class="comment">             根据单调队列的实现，i之前的元素都不会在，如果i-1是最大值，那么i-1之前的元素都不会在</span></span><br><span class="line"><span class="comment">             且i-1会被pop掉</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(deq[<span class="number">0</span>]);<span class="comment">//添加最大值</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：212 ms, 在所有 C++ 提交中击败了32.23%的用户</span></span><br><span class="line"><span class="comment">内存消耗：125 MB, 在所有 C++ 提交中击败了34.95%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day24"><a href="#day24" class="headerlink" title="day24"></a>day24</h1><h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h2><p>在现实中，我们计算概率的时候会从前n-1个骰子的结果推向第n个骰子的结果，因为第n个骰子无非是1-6，某个值s的概率就是前n-1个骰子产生s-i的概率除以6（i从1到6），然后这些s-i都可以到达s，因此把这些概率累加。这种递推的想法给我们动态规划的考虑。</p>
<p>动态规划f(n,x) &#x3D; f(n-1,x-i)&#x2F;6.0（i：1-6，累加）。</p>
<p>这是逆向的想法，我们想要得到一个f(n,x)，要逆向推f(n-1,x-i)。但如果逆向，即从骰子为n一直向前推，当x&lt;&#x3D;6时都要做特殊处理。</p>
<p>因此改成正向的动态规划，从骰子为1开始，由于新增骰子的点数只可能为 1 至 6 ，因此概率 f(n−1,x) 仅与 f(n,x+1) , f(n,x+2), … , f(n,x+6) 相关。正向的递推就是当我们得到一个f(n,x)，可以产生一部分f(n+1,x+i)的概率，对不同的x，累加这些x+i即可。</p>
<p>因而，遍历 f(n−1) 中各点数和的概率，并将其相加至 f(n) 中所有相关项，即可完成 f(n−1) 至 f(n) 的递推。</p>
<p>具体的：动态规划正向递推，从小到大遍历n个骰子，遍历每个骰子的每一个值，对每个值遍历下一个骰子的1-6的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br><span class="line">你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//动态规划f(n,x) = f(n-1,x-i)/6.0（i：1-6，累加）</span></span><br><span class="line"><span class="comment">//如果逆向，即从骰子为n一直向前推，当x&lt;=6时都要做特殊处理</span></span><br><span class="line"><span class="comment">//因此改成正向的动态规划，从骰子为1开始，由于新增骰子的点数只可能为 1 至 6 ，因此概率 f(n−1,x) 仅与 f(n,x+1) , f(n,x+2), ... , f(n,x+6) 相关。</span></span><br><span class="line"><span class="comment">//因而，遍历 f(n−1) 中各点数和的概率，并将其相加至 f(n) 中所有相关项，即可完成 f(n−1) 至 f(n) 的递推。</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点数范围是n-6n，个数是5n+1</span></span><br><span class="line">        <span class="comment">//真实的值s是下标+1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6.0</span>)</span></span>;<span class="comment">//初始化，骰子1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//遍历骰子数量</span></span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">5</span>*i+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//i个骰子时，有5i+1个值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dp.<span class="built_in">size</span>();j++)<span class="comment">//对上一个骰子的每一个值，能对下一个骰子产生的值起作用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;k++)<span class="comment">//下一个骰子的值是1-6，每个值概率是六分之一</span></span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span>;<span class="comment">//第j+k个值可以由dp[j]产生，概率是六分之一。注意是+=，累加的，比如2+3和3+2点数都是5</span></span><br><span class="line">            dp = tmp;<span class="comment">//如果还有循环，dp就代表上一个骰子的值的概率</span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了94.82%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day25"><a href="#day25" class="headerlink" title="day25"></a>day25</h1><h2 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h2><p>很自然地想到排序（顺子嘛），然后正常的想法是遍历0，然后知道0的数目（4个0直接true），再接下去遍历，如果后面遍历遇到重复就false，如果往后都是+1递增就继续，如果不是+1递增，就把当前值+1（同时把0的数目减少一个，相当于补充一个中间+1值），再看是不是+1，如果不是，再用一个0…这样下去，遍历完就true，0用完就false。</p>
<p>当有更直观的办法，如果知道0的数目，也判断了没有重复，那么这5张牌是顺子的充要条件是max-min&lt;5。max是最大值，min是除0外的最小值。只要差值比5小，由于没有重复，那么0就可以填充在序列的中间，或者序列的外部（如果原来就是顺子，就填充在外部）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。</span><br><span class="line">2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,<span class="number">4</span>);<span class="comment">//数组长度为5，就直接利用了</span></span><br><span class="line">    <span class="comment">//统计大小王与判断重复</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为什么只遍历前四个元素呢？</span></span><br><span class="line">    <span class="comment">//原因是比较前后两个元素对头尾的下标有要求，不能越界，这里少遍历一个元素</span></span><br><span class="line">    <span class="comment">//更重要的一点是，如果有四个大小王，那么无论如何也能形成顺子，最后一个元素不用看了</span></span><br><span class="line">    <span class="comment">//如果没有四个大小王，说明第四个不是0，最后一个无论如何也不是0，没必要看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果重复就false，注意要elseif，因为0是可以重复的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//四个王就结束了</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里很关键，如果没有重复，那么除去0后剩下的元素要形成顺子，它们的梯度小于5即可</span></span><br><span class="line">    <span class="keyword">return</span> (nums[<span class="number">4</span>]-nums[count]&lt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=nums[l]) i++;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[l]);<span class="comment">//最后i停在比nums[l]小的元素，交换它们，把基准值放中间</span></span><br><span class="line">        <span class="built_in">quickSort</span>(nums,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：9.7 MB, 在所有 C++ 提交中击败了92.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day26"><a href="#day26" class="headerlink" title="day26"></a>day26</h1><h2 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h2><p>约瑟夫环问题，用链表模拟会超时。约瑟夫环有数学上的递推公式，因此有动态规划的解法。</p>
<p>输入 n, m，记此约瑟夫环问题为 「n, m 问题」 ，设解（即最后留下的数字）为 f(n) ，则有：</p>
<p>「n, m 问题」：数字环为 0, 1, 2, …, n - 1，解为 f(n) ；<br>「n-1, m 问题」：数字环为 0, 1, 2, …, n - 2，解为 f(n-1)；</p>
<p>对于「n, m 问题」，首轮删除环中第 m 个数字后，得到一个长度为 n - 1 的数字环。由于有可能 m &gt; n ，因此删除的数字为 (m−1)%n ，删除后的数字环从下个数字（即 m%n ）开始，设 t&#x3D;m%n ，可得数字环：</p>
<p><em>t</em>,<em>t</em>+1,<em>t</em>+2,…,0,1,…,<em>t</em>−3,<em>t</em>−2</p>
<p>删除一轮后的数字环也变为一个「n-1, m 问题」，观察以下数字编号对应关系：</p>
<table>
<thead>
<tr>
<th>「n−1,m问题」</th>
<th>→</th>
<th>「n,m问题」删除后</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>→</td>
<td>t+0</td>
</tr>
<tr>
<td>1</td>
<td>→</td>
<td>t+1</td>
</tr>
<tr>
<td>…</td>
<td>→</td>
<td>…</td>
</tr>
<tr>
<td>n-2</td>
<td>→</td>
<td>t-2</td>
</tr>
</tbody></table>
<p>  设「n-1, m 问题」某数字为 x ，则可得递推关系：<em>x</em>→(<em>x</em>+<em>t</em>)%n。</p>
<p>换而言之，若已知「n-1, m 问题」的解 f(n - 1) ，则可通过以上公式计算得到「n, m 问题」的解 f(n)，即：</p>
<p><em>f</em>(<em>n</em>)&#x3D;(<em>f</em>(<em>n</em>−1)+<em>t</em>)%<em>n</em>&#x3D;(<em>f</em>(<em>n</em>−1)+<em>m</em>%<em>n</em>)%<em>n</em>&#x3D;**(<em>f</em>(<em>n</em>−1)+<em>m</em>)%<em>n</em>**</p>
<hr>
<p>这个怎么理解呢？从正向递推去看，如果知道n-1问题的解，那么能对应到n问题的解。因为n问题首先要删除一个数变成n-1问题，而<strong>n问题的解和n-1问题的解从元素角度看必然是同一个</strong>（因为本来就是同一个问题的不同过程），只是它们在不同的序列，拥有<strong>不同的值</strong>而已。那么我们只需要把值做一次映射，就能从n-1问题的解的值映射到n问题的解的值。从n问题到n-1问题，删除了(m-1)%n，新序列每个值都减了或加了(m-1)%n+1，反过来只要加回去就可以了（加什么值最好用一个例子推）。从n&#x3D;1时开始往后推，不断映射到下一个规模的解返回即可（因为最终返回的解的值是在n问题序列的解）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。</span><br><span class="line">求出这个圆圈里剩下的最后一个数字。</span><br><span class="line"></span><br><span class="line">例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，</span><br><span class="line">则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//n=1时的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//从n=1递推到n=2，一直递推到n</span></span><br><span class="line">            x = (x+m)%i;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了93.52%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了94.35%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day27"><a href="#day27" class="headerlink" title="day27"></a>day27</h1><h2 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h2><p>动态规划，不谈了，ez</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果今天的价格比存储的最小值小，则更改最小值</span></span><br><span class="line">            <span class="keyword">if</span>(num&lt;=min)</span><br><span class="line">                min = num;<span class="comment">//不可能在今天卖出，因为一定是亏的或者是0</span></span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果大的话可以卖一下，min存储了前几天的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                profit = <span class="built_in">max</span>(profit,num-min);<span class="comment">//更新利润</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了88.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.4 MB, 在所有 C++ 提交中击败了79.39%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day28"><a href="#day28" class="headerlink" title="day28"></a>day28</h1><h2 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h2><p>首先不能用while等循环，显然就用递归了。然后当n&gt;0才递归，因此要判断，但是不能用if那些，可以考虑用布尔逻辑的短路效应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNums</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n&gt;0时，n是真，根据与表达式，还要看后面的真假，所以会做 n+=sumNums(n-1);</span></span><br><span class="line">        <span class="comment">//n=0时，整个表达式已经是假了，不会做后面的运算了，递归终止。</span></span><br><span class="line">        <span class="comment">//整个表达式的布尔真假没有意义，并不需要，只需要用来根据n的值决定做不做递归即可，最后返回n</span></span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6.1 MB, 在所有 C++ 提交中击败了25.90%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day29"><a href="#day29" class="headerlink" title="day29"></a>day29</h1><h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h2><p>加法器原理，用位运算实现。a+b相当于无进位加法加上进位。假设无进位加法结果是n，进位是c，则a+b&#x3D;n+c。无进位加法n&#x3D;a^b，即两数异或，位全1或全0这一位的结果都是0。进位可以用与运算，c&#x3D;(a&amp;b)&lt;&lt;1，因为是进位所以要左移。</p>
<p>在位运算后，我们就变成了要计算n+c，这还是一个加法，因此又要一轮无进位加法和进位，像递归一样不断往复下去，直到没有进位就可以停止了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//分为无进位加法结果n和进位结果c，则a+b=n+c</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算，把a当结果，把b加到a上</span></span><br><span class="line">        <span class="type">int</span> c;<span class="comment">//存储进位，无进位加法结果直接存a上，相当于n=a^b，下一轮两个加数是n和c，则n=a，b=c；n可以用a替代</span></span><br><span class="line">        <span class="keyword">while</span>(b)<span class="comment">//b不为0时进行，b为0说明加完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//c++不支持负数左移，要转unsigned，因为整个过程只是bit串运算，不用管正负，不需要c++去解释正负</span></span><br><span class="line">            c = (<span class="type">unsigned</span> <span class="type">int</span>)(a&amp;b) &lt;&lt; <span class="number">1</span>;<span class="comment">//两数的每个bit的进位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//无进位加法，加完再和进位加就可以</span></span><br><span class="line">            a = a^b;<span class="comment">//对于加法，都是1就进位，结果是0，都是0那结果也是0。都是1时进位在c那</span></span><br><span class="line">            b=c;<span class="comment">//c已经左移过了，本身是要a+c，但也不能用加法，所以还是要异或，a+c就像a+b一样，一直循环直到没进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了69.28%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day30"><a href="#day30" class="headerlink" title="day30"></a>day30</h1><h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p>不能用除法，所以考虑乘法，再考虑性能的话就要考虑乘法的递推。累乘的中间是割裂的，但割裂的这个i是递增的，所以这里面也有些规律可循。</p>
<p>再来思考一下，从形式上看有递推的效果，可以考虑动态规划，但是递推总是割裂的，差一点，原因是还要找规律。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>B[0]&#x3D;</td>
<td><strong>1</strong></td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>B[1]&#x3D;</td>
<td>A[0]</td>
<td><strong>1</strong></td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>B[2]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>1</td>
<td>…</td>
<td>A[n-1]</td>
<td>A[n]</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>B[n-1]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td><strong>1</strong></td>
<td>A[n]</td>
</tr>
<tr>
<td>B[n]&#x3D;</td>
<td>A[0]</td>
<td>A[1]</td>
<td>A[2]</td>
<td>…</td>
<td>A[n-1]</td>
<td><strong>1</strong></td>
</tr>
</tbody></table>
<p> 整个累乘可以分成上三角矩阵和下三角矩阵，B[i]的计算可以分成两次计算。前面动态规划差一点的原因就是中间有断裂，那么可以分别从两个三角来。比如先计算下三角的部分，那么<code>B[0] = 1; B[i] = B[i-1]*A[i-1];</code>，这样子迭代就计算好了下三角，注意我们是迭代的递推的，因此要从小的开始慢慢乘起来，所以在回头计算上三角时，是从下往上的，从A[n]累乘到A[1]，从B[n-1]到B[0]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, </span><br><span class="line">即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArr</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下三角递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>]*a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;<span class="comment">//不能用B[i-1]来递推了，用个tmp保存递推的中间值</span></span><br><span class="line">        <span class="comment">//上三角递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp *= a[i+<span class="number">1</span>];</span><br><span class="line">            B[i] *= tmp;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了86.75%的用户</span></span><br><span class="line"><span class="comment">内存消耗：23.7 MB, 在所有 C++ 提交中击败了91.26%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day31"><a href="#day31" class="headerlink" title="day31"></a>day31</h1><p>今天忘记了，明天补一道&#x2F;(ㄒoㄒ)&#x2F;~~</p>
<h1 id="day32"><a href="#day32" class="headerlink" title="day32"></a>day32</h1><h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p>主要是越界的处理，要提前去判断。先说一下具体的操作：</p>
<ul>
<li>先把开头的空格遍历过去</li>
<li>获得第一个非空格字符，如果非数字和正负号，返回0</li>
<li>如果是负号，存储sign变量；正号同理</li>
<li>如果是数字，说明是正号，正号可以不显式出现，因此默认情况下sign是正号。</li>
<li>然后开始处理连续的数字，前面存储的是res，当前数字是num，num&#x3D;str[i]-‘0’，res &#x3D; res*10+num。在此过程中，要提前判断：<ul>
<li>如果遇到非数字字符就直接break，返回res和正负</li>
<li>如果是数字字符，要判断拼接后会不会溢出，一个是res是否大于max&#x2F;10，如果大于的话*10就溢出了。最恰好的情况是res&#x3D;&#x3D;max&#x2F;10，如果num&gt;7就溢出了，根据正负号返回max或min。因为8的时候是正的溢出，返回max；但8不是负的溢出，但是此时的值也是min，不用再额外判断了。这种判断方式对于判断溢出、返回max和min很有效。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</span><br><span class="line"></span><br><span class="line">首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</span><br><span class="line"></span><br><span class="line">当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；</span><br><span class="line">假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</span><br><span class="line"></span><br><span class="line">该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</span><br><span class="line"></span><br><span class="line">注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</span><br><span class="line"></span><br><span class="line">在任何情况下，若函数不能进行有效的转换时，请返回 0。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line">示例 5:</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> sign = <span class="literal">true</span>;   <span class="comment">//默认为正数</span></span><br><span class="line">        <span class="comment">//先舍弃开头可能存在的空格</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        <span class="comment">//接着判断首个字符是否为正负号</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = <span class="literal">false</span>;  <span class="comment">//该字符串片段为负数</span></span><br><span class="line">            i++;          <span class="comment">//移至下一个字符接着判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span>) i++;   <span class="comment">//如果首个字符为‘+’则sign已经默认为true而无须更改，直接移动到下一位即可</span></span><br><span class="line">        <span class="comment">//下面开始对非正负符号位进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//如果第一个正负号字符后的首个字符就不是数字字符(也可能第一个字符就不是正负号)，那么直接返回0</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;   <span class="comment">//这里res用的int型，需要更加仔细考虑边界情况，但如果用long的话可以省去一些麻烦</span></span><br><span class="line">        <span class="type">int</span> num;      <span class="comment">//用来单独存储单个字符转换而成的数字</span></span><br><span class="line">        <span class="type">int</span> border = INT_MAX / <span class="number">10</span>;  <span class="comment">//用来验证计算结果是否溢出int范围的数据</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">//遇到非数字字符则返回已经计算的res结果</span></span><br><span class="line">            <span class="keyword">if</span>(res &gt; border || res == border &amp;&amp; str[i] &gt; <span class="string">&#x27;7&#x27;</span>)  <span class="comment">//注意这句话要放在字符转换前，因为需要验证的位数比实际值的位数要少一位</span></span><br><span class="line"><span class="comment">//这里比较巧妙的地方在于 1. 用低于int型数据长度一位的数据border判断了超过int型数据长度的值 2. 将超过最大值和低于最小值的情况都包括了</span></span><br><span class="line">            <span class="keyword">return</span> sign == <span class="literal">true</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            <span class="comment">//开始对数字字符进行转换</span></span><br><span class="line">            num = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后结果根据符号添加正负号</span></span><br><span class="line">        <span class="keyword">return</span> sign == <span class="literal">true</span> ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了63.07%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了78.85%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制加法"><a href="#二进制加法" class="headerlink" title="二进制加法"></a>二进制加法</h2><p>手动模拟，逐位加。把顺序先倒过来会好一点。然后这里遍历的长度是较长的那个，同时判断，如果短的到边了那就是+0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。</span><br><span class="line"></span><br><span class="line">输入为 非空 字符串且只包含数字 1 和 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: a = &quot;11&quot;, b = &quot;10&quot;</span><br><span class="line">输出: &quot;101&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//carry即表示进位又表示结果</span></span><br><span class="line">        <span class="comment">//carry表示进位和a、b位相加，其实就是三者中有多少个1。模二就是结果，结果是二就继续进位</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;<span class="comment">//如果长度不够就是0，够的话用比较或者-&#x27;0&#x27;都行</span></span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b[i] == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);<span class="comment">//当前位相加的结果，转char</span></span><br><span class="line">            carry /= <span class="number">2</span>;<span class="comment">//下一位的进位，三者之和是2或3才有进位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;<span class="comment">//最后的处理</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了85.36%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day33"><a href="#day33" class="headerlink" title="day33"></a>day33</h1><h2 id="前n个数字二进制中1的个数"><a href="#前n个数字二进制中1的个数" class="headerlink" title="前n个数字二进制中1的个数"></a>前n个数字二进制中1的个数</h2><p>动态规划，二进制中1的个数要想到 n&amp;(n-1)能把n中最低的1变成0。这个变成0一方面让数字变小，一方面让1的个数少了1；也即：缩小了规模同时得到了数值关系。因此就有了递推式：bit[i] &#x3D; bit[ i&amp;(i-1) ] +1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: n = 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">解释: </span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: n = 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br><span class="line">解释:</span><br><span class="line">0 --&gt; 0</span><br><span class="line">1 --&gt; 1</span><br><span class="line">2 --&gt; 10</span><br><span class="line">3 --&gt; 11</span><br><span class="line">4 --&gt; 100</span><br><span class="line">5 --&gt; 101</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(n + <span class="number">1</span>)</span></span>;<span class="comment">//初始化，bits[0] = 0;起始条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            bits[i] = bits[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;<span class="comment">//递推，i缩小了规模，尽管缩小的程序不知道，但因为i是递增的，所以&lt;i的都解决了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.6 MB, 在所有 C++ 提交中击败了72.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day34"><a href="#day34" class="headerlink" title="day34"></a>day34</h1><h2 id="单词长度的最大乘积"><a href="#单词长度的最大乘积" class="headerlink" title="单词长度的最大乘积"></a>单词长度的最大乘积</h2><p>传统的暴力解法：遍历每个字符串对，然后再看两个字符串有没有相同字母。</p>
<p>先思考下一定要遍历字符串对吗，有没有递推的方式？答案是没有，因为这里不同的字符串对前后文没有关系，没有什么能够保存的状态，无法递推或分治，每对字符串都是新状态，所以一定要遍历所有字符串。同时要判断重复，就又得遍历两个字符串的字母，时间复杂度是大于n方的。</p>
<p>采取空间换取时间的方式，利用一个额外空间把字符串是否重复的信息存取。注意不能遍历字符串对去获取信息，这样就没有差别了。因此，要对每个字符串自身获取信息，同时利用这个信息在O(1)的复杂度判断有无重复。</p>
<p>O(1)的复杂度值得我们去考虑数学运算或位运算，尤其是判断重复会想到哈希表，也就想到映射。因此可以把字符串的字母映射到26位长的比特串上，如果有对应字母，对应的位置就是1。由于最多26位，所以可以用单个int来保存这个信息，也就是掩码。在判重时，两个掩码进行与运算，如果结果为0说明没有相同字母。</p>
<p>核心是：利用位掩码判断两个字符串是否有相同字符（进行与运算)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。</span><br><span class="line">假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">masks</span><span class="params">(length)</span></span>;<span class="comment">//掩码，初始化为0。一个掩码由一位int表示</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) <span class="comment">//遍历所有字符串，words[i]对应masks[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            string word = words[i];</span><br><span class="line">            <span class="type">int</span> wordLength = word.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordLength; j++)<span class="comment">//遍历某个字符串，每个掩码假想有26位对应26个字母</span></span><br><span class="line">            &#123;</span><br><span class="line">                masks[i] |= <span class="number">1</span> &lt;&lt; (word[j] - <span class="string">&#x27;a&#x27;</span>);<span class="comment">//获取是哪个字母，然后把1左移到对应位置上或起来。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxProd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//遍历每个字符串对</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)<span class="comment">//j从i后面开始就可以了，降重</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((masks[i] &amp; masks[j]) == <span class="number">0</span>) <span class="comment">//没有相同字母也就是掩码对应的1位置不同，与的结果是0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    maxProd = <span class="built_in">max</span>(maxProd, <span class="built_in">int</span>(words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：40 ms, 在所有 C++ 提交中击败了76.83%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.1 MB, 在所有 C++ 提交中击败了47.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day35"><a href="#day35" class="headerlink" title="day35"></a>day35</h1><h2 id="数组中和为0的三个数"><a href="#数组中和为0的三个数" class="headerlink" title="数组中和为0的三个数"></a>数组中和为0的三个数</h2><p>固定元素+双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，</span><br><span class="line">同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</span><br><span class="line"></span><br><span class="line">你返回所有和为 0 且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//排序双指针</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i ++)<span class="comment">//固定第一个元素，0到倒数第三个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="comment">//如果跟前面一个一样，那么就算找到了也是和前面答案一样的，重复了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> c = - nums[i];<span class="comment">//c是剩下两个元素的和</span></span><br><span class="line">            <span class="comment">//头尾双指针</span></span><br><span class="line">            <span class="type">int</span> ll = i + <span class="number">1</span>, rr = n - <span class="number">1</span>;               <span class="comment">//j从i+1开始可以避免重复</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(ll &lt; rr)<span class="comment">//左右边界不重合，注意一定要遍历完，因为3+7和4+6都是答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[ll] + nums[rr];</span><br><span class="line">                <span class="comment">//移动头尾双指针找到第一个target</span></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; c)</span><br><span class="line">                    rr --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; c)</span><br><span class="line">                    ll ++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[i], nums[ll], nums[rr]&#125;);<span class="comment">//找到了就添加答案</span></span><br><span class="line">                    <span class="comment">//然后要把重复的都过滤掉，不然又是一组相同答案</span></span><br><span class="line">                    <span class="keyword">while</span>(ll &lt; rr &amp;&amp; nums[ll] == nums[++ ll]);      <span class="comment">//找到一个不重复的ll</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(ll &lt; rr &amp;&amp; nums[rr] == nums[-- rr]);</span><br><span class="line">                    <span class="comment">//过滤完后继续找下一个</span></span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：48 ms, 在所有 C++ 提交中击败了99.33%的用户</span></span><br><span class="line"><span class="comment">内存消耗：19.4 MB, 在所有 C++ 提交中击败了71.60%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day36"><a href="#day36" class="headerlink" title="day36"></a>day36</h1><h2 id="和大于等于target的最短子数组"><a href="#和大于等于target的最短子数组" class="headerlink" title="和大于等于target的最短子数组"></a>和大于等于target的最短子数组</h2><p>这种连续子数组，尤其时牵扯到子数组的长度、连续和等等，可以用滑动窗口，更新边界即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正整数的数组和一个正整数 target 。</span><br><span class="line"></span><br><span class="line">找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。</span><br><span class="line">如果不存在符合条件的子数组，返回 0 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span> ,j=<span class="number">0</span>;<span class="comment">//相等是因为可以只有1个元素满足</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//j不能改成&lt;n-1，因为j=n-1时虽然到最后了，不能退出，还要再判断更新一次minlen</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j <span class="keyword">and</span> j&lt;n)<span class="comment">//i&gt;j时返回，说明有len=1的满足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &lt;= count)<span class="comment">//当前窗口符合，缩小左边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen,j-i+<span class="number">1</span>);<span class="comment">//更新，窗口是i-j，大小是j-i+1</span></span><br><span class="line">                count -= nums[i];<span class="comment">//左边界移动更新count</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j++;<span class="comment">//右边界移动，注意j++和i++顺序不同，因为一个是加新的，一个是减旧的</span></span><br><span class="line">                <span class="keyword">if</span>(j==n) </span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//提前返回，当到最后（即使前面有符合的）不存在符合的子数组会越界</span></span><br><span class="line">                            <span class="comment">//因为当j到n-1时，在符合的窗口i++后可能不符合，j会尝试++，nums会越界</span></span><br><span class="line">                            <span class="comment">//一直不符合就更简单了，j一直++，但是又不能在while里改条件</span></span><br><span class="line">                count += nums[j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (minlen==INT_MAX)?<span class="number">0</span>:minlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.59%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.2 MB, 在所有 C++ 提交中击败了79.18%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day37"><a href="#day37" class="headerlink" title="day37"></a>day37</h1><h2 id="乘积小于K的子数组"><a href="#乘积小于K的子数组" class="headerlink" title="乘积小于K的子数组"></a>乘积小于K的子数组</h2><p>滑动窗口，控制边界。这里的重点是对子数组个数的计数，如何不重复又如何不遗漏。这里子数组的连续性给了比较好的性质。当我们的窗口乘积比较大的时候，要缩小左边界，用乘积除以左边界的值更新乘积；而当乘积小于K的时候，这时就产生了子数组，且移动右边界。</p>
<p>我们从移动右边界的情形来看计数，当我们要更新计数时，上一个右边界（右边界-1）已经计数好了，那么当前的这个窗口只需要更新那些新产生的子数组的个数。这些新产生的子数组必然包含了右边界的元素（因为没包含右边界元素的子数组在上一次计数就算进去了）且包含了右边界的元素一定是新产生的子数组，那么我们从右边界往左边界数子数组的个数，子数组大小从1开始（根据子数组的连续性）：[nums[j]]，[nums[j],num[j-1]],…,[nums[j],…,nums[i]]，个数就是窗口的大小j-i+1。这本质上是由于递推，上一次的子数组已经计算进去了。</p>
<p>因此，当乘积大时，更新左边界；当乘积符合时，更新计数，然后更新右边界。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: nums = [10,5,2,6], k = 100</span><br><span class="line">输出: 8</span><br><span class="line">解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br><span class="line">需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: nums = [1,2,3], k = 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pro = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据右边界来计数，每移动一次j都要更新值，所以用for的形式移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            pro *= nums[j];</span><br><span class="line">            <span class="comment">//i能等于j是为了能跳过某个本身就大于k的数，此时i=j+1，更新计数j-i+1也是0，然后就从下一个数开始</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;=j &amp;&amp; pro &gt;= k)<span class="comment">//如果pro较大，移动左边界直到窗口符合条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                pro /= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有符合的窗口</span></span><br><span class="line">            res += j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：64 ms, 在所有 C++ 提交中击败了71.68%的用户</span></span><br><span class="line"><span class="comment">内存消耗：59.7 MB, 在所有 C++ 提交中击败了65.21%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day38"><a href="#day38" class="headerlink" title="day38"></a>day38</h1><h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><p>本以为这题和上一题差不多，但还是不一样，因为数组中的数字可以是负的，这把思路都改变了。前面小于的话，当找到合适的窗口，里面的更小的子数组都可以算进去，这样每次滑动窗口就可以了。但是由于这里数字是负的，并不知道该移动哪个边界，移动左边界窗口和既有可能增大也有可能减小。</p>
<p>如果没有负数，测试了几个例子，理论上滑动窗口也是可以解决的。而当前这种情况，就要用到一种更为通用的方式：前缀和（对应前一题为前缀积）。</p>
<p>这里使用额外的空间，保存一些前缀和pre[i]，其中pre[i]表示从0-i所有元素的和。那么当我们每次遍历i时，能够通过之前的线性迭代很快获得当前的前缀和，这时要向前看x步找寻有没有和为k的一个子数组序列，本质上就是截出一段来，那么假设pre[i] - pre[j] &#x3D;k，我们就截到了j-i这一段，注意由于我们是遍历过来的，所以j会比i小（这里的本质是，发现所有符合条件的以nums[i]结尾的子数组，既然是nums[i]结尾，那么其余元素一定是向前的）。</p>
<p>如果找到了这么一个pre[j] &#x3D; pre[i] - k，就可以计数了。注意这样的pre[j]也许不只有一个，那么就可以用哈希表映射到次数，每次遍历完更新一下哈希表就好了。</p>
<p>注意前缀和是0的情况，因为为0时，也许有前缀和为0，也可以就是pre[i]而不减去其他前缀和，因此hash[0]本身应该多1，即初始化为1，其他为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入:nums = [1,2,3], k = 3</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//key为前缀和，value为次数</span></span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x:nums) &#123;</span><br><span class="line">            pre += x;<span class="comment">//前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;<span class="comment">//如果找得到pre-k的前缀和，则找到一组子数组</span></span><br><span class="line">                count += mp[pre - k];<span class="comment">//mp的值是pre-k的前缀和出现的次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;<span class="comment">//pre这个对应的前缀和+1，初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：48 ms, 在所有 C++ 提交中击败了99.09%的用户</span></span><br><span class="line"><span class="comment">内存消耗：35.1 MB, 在所有 C++ 提交中击败了72.84%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day39"><a href="#day39" class="headerlink" title="day39"></a>day39</h1><h2 id="0-和-1-个数相同的子数组"><a href="#0-和-1-个数相同的子数组" class="headerlink" title="0 和 1 个数相同的子数组"></a>0 和 1 个数相同的子数组</h2><p>核心思想就是把0看成-1，这样个数相同的子数组的和就是0，这样问题归约为：最长和为0的连续子数组。这与上一题相似，只不过上一题是个数，这一题是最长长度。假设有前缀和count，位置为i，那么上一次出现的count处，位置为j，j+1——i这一段子数组就符合要求。因此使用一个哈希表，把前缀和映射到count出现的第一个位置（这样能使子数组最长）。具体的，这个第一个位置，只要我们在找到count时不更新即可，如果找不到count就更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;<span class="comment">//长度就映射到位置，个数就映射到个数</span></span><br><span class="line">        <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        mp[counter] = <span class="number">-1</span>;<span class="comment">//如果此时前缀和为0的话，就是从头开始，这个要手动初始化</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;<span class="comment">//为1就累加前缀和</span></span><br><span class="line">                counter++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//为0就前缀和减一</span></span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">count</span>(counter)) &#123;<span class="comment">//从下标prevIndex+1 到下标 i 的子数组中有相同数量的 0 和 1，该子数组的长度为i−prevIndex</span></span><br><span class="line">                <span class="type">int</span> prevIndex = mp[counter];</span><br><span class="line">                maxLength = <span class="built_in">max</span>(maxLength, i - prevIndex);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果counter 的值在哈希表中不存在，则将当前余数和当前下标 i 的键值对存入哈希表中。</span></span><br><span class="line">                mp[counter] = i;<span class="comment">//第一次出现count的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：100 ms, 在所有 C++ 提交中击败了78.11%的用户</span></span><br><span class="line"><span class="comment">内存消耗：81.7 MB, 在所有 C++ 提交中击败了74.39%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/10/effectiveC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/10/effectiveC++/" class="post-title-link" itemprop="url">effective c++ 记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-10 09:41:01" itemprop="dateCreated datePublished" datetime="2022-08-10T09:41:01+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 21:48:57" itemprop="dateModified" datetime="2022-08-18T21:48:57+08:00">2022-08-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>108k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:38</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="目录-amp-索引"><a href="#目录-amp-索引" class="headerlink" title="目录&amp;索引"></a>目录&amp;索引</h1><ul>
<li>条款01：<strong>视 c++ 为一个语言联邦。</strong><ul>
<li>c++高效编程守则视状况而变化，取决于你使用c++的哪个部分。</li>
</ul>
</li>
<li>条款02：<strong>尽量以const，enum，inline 替换 #define。</strong><ul>
<li>对于单纯常量，最好以cosnt对象或enum替换#defines；</li>
<li>对于形似函数的宏（macros），最好改用inline函数替换#define。</li>
</ul>
</li>
<li>条款03：<strong>尽可能使用const。</strong><ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>
</li>
<li>条款04：<strong>确定对象被使用前已先被初始化。</strong><ul>
<li>为内置型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列（初始化列表），而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</li>
</ul>
</li>
<li>条款05：<strong>了解c++默默编写并调用哪些函数。</strong><ul>
<li>编译器可以暗自为class创建默认构造函数、拷贝构造函数、赋值操作符以及析构函数。</li>
</ul>
</li>
<li>条款06：<strong>若不想使用编译器自动生成的函数，就该明确拒绝。</strong><ul>
<li>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</li>
<li>附：在c++11以后，可以用delete修饰函数，这是一种更好的方法。</li>
</ul>
</li>
<li>条款07：<strong>为多态基类声明virtual析构函数。</strong><ul>
<li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li>classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不应该声明virtual析构函数。</li>
<li>纯虚的析构函数必须给出定义。</li>
</ul>
</li>
<li>条款08：<strong>别让异常逃离析构函数。</strong><ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
</li>
<li>条款09：<strong>绝不在构造和析构过程中调用virtual函数。</strong><ul>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</li>
</ul>
</li>
<li>条款10：*<em>令 operator&#x3D; 返回一个reference to <em>this。</em></em><ul>
<li>令 operator&#x3D; 返回一个reference to *this。</li>
</ul>
</li>
<li>条款11：<strong>在 operator&#x3D; 中处理“自我赋值”。</strong><ul>
<li>确保当对象自我赋值时 operator&#x3D; 有良好行为。其中技术包括比较“来源对象”和“”目标对象“的地址、精心周到的语句顺序、以及copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
</li>
<li>条款12：<strong>复制对象时勿忘其每一个部分。</strong><ul>
<li>copying函数应确保复制”对象内的所有成员变量“及”所有base class 成分“；</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应将共同技能放进第三个函数中，并由两个copying函数共同调用。</li>
</ul>
</li>
<li>条款13：<strong>以对象管理资源。</strong><ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII classes 分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择 ，因为其copy行为比较直观。若选择auto_ptr，复制动作会使被复制物指向null。</li>
</ul>
</li>
<li>条款14：<strong>在资源管理类中小心copying行为。</strong><ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying 行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。</li>
</ul>
</li>
<li>条款15：<strong>在资源管理类中提供对原始资源的访问。</strong><ul>
<li>APIs往往要求访问原始资源，所以每一个RAII class 应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换（比如一个get成员函数）或隐式转换（重载operator A()）。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
</li>
<li>条款16：<strong>成对使用new和delete时要采取相同形式。</strong><ul>
<li>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</li>
</ul>
</li>
<li>条款17：<strong>以独立语句将newed对象置入智能指针。</strong><ul>
<li>以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出（在资源对象产生到置入资源管理对象之间，产生异常的话），有可能导致难以察觉的资源泄漏。</li>
</ul>
</li>
<li>条款18：<strong>让接口容易被正确使用，不易被误用。</strong><ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促使正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>tr1::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁（见条款14）等等。</li>
</ul>
</li>
<li>条款19：<strong>设计class犹如设计type。</strong><ul>
<li>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。</li>
</ul>
</li>
<li>条款20：<strong>宁以pass-by-reference-to-const替换pass-by-value。</strong><ul>
<li>尽量以 pass-by-reference-to-const 替换pass-by-value。前者通常比较高效，并可避免切割问题。</li>
<li>以上规则并不适用于内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。</li>
</ul>
</li>
<li>条款21：<strong>必须返回对象时，别妄想返回其reference。</strong><ul>
<li>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference 指向一个local static对象”提供了一份设计实例。</li>
</ul>
</li>
<li>条款22：<strong>将成员变量声明为private。</strong><ul>
<li>切记将成员变量声明为private。这可赋予用户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。</li>
</ul>
</li>
<li>条款23：<strong>宁以non-member&amp;non-friend替换member函数。</strong><ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li>
<li>附：大量的便利函数可以使用相同的命名空间而放在不同的头文件里，这样用户可以根据自己对功能的需求使用头文件，减少编译相依性。其中该有个核心的头文件，提供核心便利函数以及类的实现。</li>
</ul>
</li>
<li>条款24：<strong>若所有参数皆需类型转换，请为此采用non-member函数。</strong><ul>
<li>如果你需要为某个函数的所有参数（包括this指针所指的哪个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</li>
<li>附：因为隐式转换需要匹配参数列，对于成员函数，第一个参数是*this，使得可能不能匹配转换。</li>
</ul>
</li>
<li>条款25：<strong>考虑写出一个不抛异常的swap函数。</strong><ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请全特化std::swap。</li>
<li>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</li>
<li>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
</li>
<li>条款26：<strong>尽可能延后变量定义式的出现时间。</strong><ul>
<li>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</li>
</ul>
</li>
<li>条款27：<strong>尽量少做转型动作。</strong><ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。</li>
<li>宁可使用c++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>
</li>
<li>条款28：<strong>避免返回handles指向对象内部成分。</strong><ul>
<li>避免返回handles（包括reference、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。</li>
</ul>
</li>
<li>条款29：<strong>为“异常安全”而努力是值得的。</strong><ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备实现意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</li>
<li>条款30：<strong>透彻了解inlining的里里外外。</strong><ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为function templates出现在头文件，就将它们声明为inline。</li>
</ul>
</li>
<li>条款31：<strong>将文件间的编译依存关系降至最低。</strong><ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，而不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。</li>
</ul>
</li>
<li>条款32：<strong>确定你的public继承塑膜出is-a关系。</strong><ul>
<li>“public 继承”意味着 is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</li>
</ul>
</li>
<li>条款33：<strong>避免遮掩继承而来的名称。</strong><ul>
<li>derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</li>
<li>条款34：<strong>区分接口继承和实现继承。</strong><ul>
<li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。（附：有强烈的特异性，必须重新实现。并且纯虚函数的定义实现可以用来充当缺省版本）</li>
<li>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。（附：根据自己的特殊情况看需不需要覆写，如果没必要可以用基类的版本，但这个缺省的功能可能会产生一些危险。）</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。（附：强烈的共性，派生类只管继承不覆写）</li>
</ul>
</li>
<li>条款35：<strong>考虑virtual函数以外的其他选择。</strong><ul>
<li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li>
<li>tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li>
</ul>
</li>
<li>条款36：<strong>绝不重新定义继承而来的non-virtual函数。</strong><ul>
<li>绝不重新定义继承而来的non-virtual函数。</li>
</ul>
</li>
<li>条款37：<strong>绝不重新定义继承而来的缺省参数值。</strong><ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。</li>
<li>附：注意仅仅是参数值，而非整个函数。函数是可以重新定义的，并且当使用了一个基类指针时，可以视为带了默认参数。</li>
</ul>
</li>
<li>条款38：<strong>通过复合塑模出has-a或“根据某物实现出”。</strong><ul>
<li>复合（composition）的意义和public继承完全不同。</li>
<li>在应用域（application domain），复合意味has-a；在实现域（implementation domain），复合意味is-implemented-in-terms-of（根据某物实现出）。</li>
</ul>
</li>
<li>条款39：<strong>明智而审慎地使用private继承。</strong><ul>
<li>private继承意味着is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，使用private是合理的。</li>
<li>和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象占用空间最小化”的程序库开发者而言，可能很重要。</li>
</ul>
</li>
<li>条款40：<strong>明智而审慎地使用多继承。</strong><ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性、以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相组合。</li>
</ul>
</li>
<li>条款41：<strong>了解隐式接口和编译期多态。</strong><ul>
<li>classes和templates都支持接口和多态。</li>
<li>对classes而言接口是显式的，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li>
</ul>
</li>
<li>条款42：<strong>了解typename的双重意义。</strong><ul>
<li>声明template参数时，前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。</li>
</ul>
</li>
<li>条款43：<strong>学习处理模板化基类内的名称。</strong><ul>
<li>可在 derived class template 内通过 “this-&gt;” 指涉 base class template 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成。</li>
<li>附：以及using声明</li>
</ul>
</li>
<li>条款44：<strong>将与参数无关的代码抽离templates。</strong><ul>
<li>Templates 生成多个 classes 和多个 functions，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li>
</ul>
</li>
<li>条款45：<strong>运用成员函数模板接受所有兼容类型。</strong><ul>
<li>请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
</li>
<li>条款46：<strong>需要类型转换时请为模板定义非成员函数。</strong><ul>
<li>当我们编写一个 class template，而它所提供之“与此 template 相关的”函数支持“所有参数隐式类型转换”时，请将那些函数定义为 “class template 内部的 friend 函数”。</li>
</ul>
</li>
<li>条款47：<strong>请使用traits classes 表现类型信息。</strong><ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。</li>
<li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试。</li>
</ul>
</li>
<li>条款48：<strong>认识template元编程。</strong><ul>
<li>Template metaprogramming（TMP，模板元编程）可将工作由运行期移到编译期，因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP可被用来生成“基于政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</li>
<li>条款49：<strong>了解new-handler的行为。</strong><ul>
<li>set_new_handle 允许用户指定一个函数，在内存分配无法获得满足时被调用</li>
<li>nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是有可能抛出异常</li>
</ul>
</li>
<li>条款50：<strong>了解new和delete的合理替换时机。</strong><ul>
<li>有许多理由需要写个自定义的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。</li>
</ul>
</li>
<li>条款51：<strong>编写new和delete时需固守常规。</strong><ul>
<li>operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。class 专属版本的还应该处理“比正确大小更大的（错误）申请”</li>
<li>operator delete 应该在收到 null 指针时不做任何事。class专属版本则还应该处理“比正确大小更大的（错误）申请”</li>
</ul>
</li>
<li>条款52：<strong>写了placement new也要写placement delete。</strong><ul>
<li>当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，就可能造成隐蔽的内存泄漏。</li>
<li>当你声明 placement new 和 placement delete ，请确定不要无意识（非故意）地遮掩了它们的正常版本。</li>
</ul>
</li>
<li>条款53：<strong>不要轻忽编译器的警告。</strong><ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器最高警告级别下争取”无任何警告“。</li>
<li>不要过度依赖编译器的报警能力，因为不同编译器对待事情的态度并不相同。一段有警告的代码，移植到另一个编译器上，可能没有任何警告。</li>
</ul>
</li>
<li>条款54：<strong>让自己熟悉包括TR1在内的标准程序库。</strong><ul>
<li>C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范，为获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost。</li>
</ul>
</li>
<li>条款55：<strong>让自己熟悉Boost。</strong><ul>
<li>Boost 是一个社群，也是一个网站。致力于免费，源码开放，同僚复审的 C++ 程序库开发。 Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li>
<li>Boost 提供许多 TR1 组件实现品，以及其他许多程序库。</li>
</ul>
</li>
</ul>
<h1 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h1><blockquote>
<p>视 c++ 为一个语言联邦。</p>
</blockquote>
<p>c++ 已经是个多重范型编程语言，是个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。要如何理解这样一个语言呢？</p>
<p>最简单的方法是将c++视为一个由相关语言组成的联邦而非单一语言。在其某个次语言种，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。为了理解c++，你必须认识其主要的次语言，总共只有四个：</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<p>比如，</p>
<ul>
<li>对于内置类型（C-like）而言，pass-by-value通常比pass-by-reference更高效。</li>
<li>在Object-Oriented C++，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，Template C++也是如此。</li>
<li>然而一旦跨入STL，迭代器和函数对象都是在C指针之上塑造出来的，pass-by-value守则再次适用。</li>
</ul>
<hr>
<p>记住：</p>
<blockquote>
<p>c++高效编程守则视状况而变化，取决于你使用c++的哪个部分。</p>
</blockquote>
<h1 id="条款02"><a href="#条款02" class="headerlink" title="条款02"></a>条款02</h1><blockquote>
<p>尽量以const，enum，inline 替换 #define。</p>
</blockquote>
<p>这个条款事实上为“宁可以编译器替换预处理器”，因为或许 #define 不被视为语言的一部分。</p>
<p>当你作出：<code>#define myconst 1.6</code>时，记号名称myconst也许从未被编译器看见，也许在编译器开始处理源码之前它就被处理器移走了。于是记号名称myconst有可能没进入记号表内。于是当你运用此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到1.6而非myconst（在程序里使用myconst，报错为1.6，因为预处理器会将myconst替换为1.6）。如果mycosnt被定义在一个非你所写的头文件内，你肯定对1.6以及它来自于何处毫无概念，于是你将因为追踪它而浪费时间。这个问题也可能出现在记号式调试器，原因仍是：你所使用的名称可能并未进入记号表。</p>
<p>解决之道是使用const：<code>const double myconst = 1.6;</code>作为一个语言常量，myconst肯定会被编译器看到，当然就会进入记号表内。</p>
<p>以常量替换#define时，有两种特殊情况：</p>
<ul>
<li><p>定义常量指针：由于常量定义式通常放在头文件内，因此有必要将指针（而不只是指针所指之物）声明为const。例如若要在头文件内定义一个常量的char*-base字符串，必须写const两次：</p>
<ul>
<li><code>const char* const authorName = &quot;Scott Meyers&quot;;</code></li>
<li>第一个const说明指向常量字符串，第二个const说明指针本身也是常量（不可改）</li>
<li>string对象通常更合宜，定义成这样往往更好：<code>const std::string authorName(&quot;Scott Meyers&quot;);</code></li>
</ul>
</li>
<li><p>class专属常量：#define 并不重视作用域，不能提供任何封装性。为了将常量的作用域限制于class内，必须让它称为class的一个成员。而为确保此常量至多只有一份实体（不允许不同实例使用不同的值初始化该const变量），必须让它称为一个static成员：</p>
<ul>
<li><code>class GP&#123;private: static const int num = 5;&#125;;</code>然而这是num的声明式而非定义式。通常c++要求对使用的任何东西提供一个定义式，但如果它是个class专属常量又是static且为整数类型，则需特殊处理。只要不取它们的地址，可以声明并使用而无须提供定义式。但如果取某个class的专属常量的地址，或编译器坚持要看到定义式，则必须提供定义：</li>
<li><code>const int GP::num; </code>不必提供数值，因为声明式已经提供初值。</li>
<li>因此<strong>个人感觉</strong>更建议的方式是，在类中声明（在头文件中）但不给予初值，在类外定义时（在实现文件种）再给予初值（这样不会忘记定义式），就不会出错。实际上，旧式编译器不支持在声明时给static成员赋初值。</li>
</ul>
</li>
<li><p>针对第二点，如果在class编译期间需要一个class常量值，比如类中还定义了一个数组<code>int scores[num];</code>，这时如果不允许num在声明时赋值，就可以采用”the enum hack”补偿做法，理论基础是：一个属于枚举类型的数值可权充int被使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span>&#123;num = <span class="number">5</span>&#125;;<span class="comment">//令num成为5的一个记号名称</span></span><br><span class="line">    <span class="type">int</span> scores[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>enum hack的行为某方面说比较像#define 而不像const，有时候这正是想要的。例如取const的地址是合法的，而取enum的地址和#define的地址是不合法的。如果不想让别人获得一个指针或引用指向你的某个整数常量，enum可以帮助你实现这个约束。</li>
<li>此外优秀的编译器不会为”整数型const对象“设定另外的存储空间（除非创建指针或引用指向该对象），但不够优秀的编译器可能会创建对象。enum和#define就绝不会导致非必要的内存分配。</li>
</ul>
</li>
</ul>
<p>另一个常见的#define误用情况是以它实现宏（macros）。宏看起来像函数，但不会招致函数调用带来的额外开销，下面这个宏夹带着宏实参，调用函数f：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))<span class="comment">//宏名没有类型，也没有参数类型。</span></span></span><br></pre></td></tr></table></figure>

<p>无论何时当你写出这种宏，必须记住为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加括号是为了处理表达式参数（即宏的参数可能是个算法表达式）时不出错，因为宏替换就是文本替换，所以如果有以下情况：</span><br><span class="line">	#define COM(A,B) (A)*(B)</span><br><span class="line">那么COM(6+5,3)这个调用会怎么替换呢？它会换成这样:</span><br><span class="line">	(6+5)*(3)</span><br><span class="line">显然这是和COM宏的意图一致的，但是如是去掉了定义中括号，即写成这样：</span><br><span class="line">	#define COM(A,B) A*B</span><br><span class="line">那么COM(6+5,3)这个调用会怎么替换呢？它就会换成这样:</span><br><span class="line">	6+5*3</span><br><span class="line">这样显然就和宏的意图不符合了。</span><br></pre></td></tr></table></figure>

<p>纵使加上小括号，也会出现不可思议的事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b);<span class="comment">//a被累加两次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b+<span class="number">10</span>);<span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>在这里，调用f之前，a的递增次数竟然取决于它和谁比较。因为宏本质是替换，++a把(a)替换了，就导致比较时累加一次，如果++a更大，则传入f的参数是++a，又累加一次。</p>
<p>幸运的是，只要写出template inline函数，就可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了const、enum、inline，我们对预处理器（特别是#define）的需求降低了，但并非完全消除。#include仍然是必需品，而#ifdef&#x2F;#ifndef也继续扮演控制编译的重要角色。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>对于单纯常量，最好以cosnt对象或enum替换#defines；</li>
<li>对于形似函数的宏（macros），最好改用inline函数替换#define。</li>
</ul>
</blockquote>
<h1 id="条款03"><a href="#条款03" class="headerlink" title="条款03"></a>条款03</h1><blockquote>
<p>尽可能使用const。</p>
</blockquote>
<p>const允许你指定一个语义约束，而编译器会强制实施这项约束。它允许你高速编译器和其他程序员某值应该保持不变。只要某值保持不变是事实，你就该说出来，因为这可以获得编译器的帮助。</p>
<p>如果const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在两边，表示二者都是常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = greeting;<span class="comment">//不是常量指针、不指向常量数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting;<span class="comment">//不是常量指针，指向常量数据</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//常量指针，不指向常量数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//常量指针、指向常量数据</span></span><br></pre></td></tr></table></figure>

<p>如果被指物（数据）是常量，const可以在类型之前也可以在类型之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;<span class="comment">//两种写法都一样</span></span><br></pre></td></tr></table></figure>

<p>在STL内，有const_iterator和iterator两种迭代器：</p>
<ul>
<li>const iterator iter;则iter作用像一个T* const，表示iter本身不可改，所指之物可改</li>
<li>const_iterator citer;则citer作用像一个const T*，表示所指之物不可改，本身可改</li>
</ul>
<p>const最具威力的用法是面对函数声明时的应用，可以和函数返回值、参数、函数自身（作为成员函数）产生关联。</p>
<ul>
<li><p>返回值：如const int f1，使得函数返回后的对象为右值，不可赋值，避免拿返回值再做赋值（f1() &#x3D; 5这样的事情）。const可以预防这些没有意义的赋值动作。</p>
</li>
<li><p>参数：即表示传入参数不可改动，除非有需要改动，否则将它们声明为const。这样可以避免“想要输入‘&#x3D;&#x3D;’却输入成‘&#x3D;’”的错误。</p>
</li>
<li><p>自身（const成员函数）：是为了确认该成员函数可以作用于const对象身上。</p>
<ul>
<li>1.它们使得class接口比较容易理解，能够得知哪个函数可以改动对象内容而哪个不行。</li>
<li>2.它们使“操作const对象（常对象）”成为可能，常对象只能调用const成员。</li>
<li>3.两个成员函数如果只是常量性不同（函数后有无const），也可以被重载。常对象调用const成员函数，而非常对象调用non-const成员函数。</li>
<li>附：真实程序中常对象大多用于以passed by pointer-to-const或passed by reference-to-const形式函数传参，如<code>void print(const A&amp; x);</code>一般都用于读取值。</li>
</ul>
<hr>
</li>
</ul>
<p>对于const成员函数，有两个流行的概念：bitwise constness（又称physical constness）和logcial constness。</p>
<ul>
<li>bitwise constness认为成员函数不更改对象内的任何一个bit，它正是c++对常量性的定义，因此const成员函数不可以改变对象内任何non-static成员变量。<ul>
<li>然而，如果一个类成员为non-const的指针（而非其所指之物），那么一个const成员函数可以仅仅返回该指针而不作任何改变（使得编译器通过）。这也就是说，可以通过常对象调用该const成员函数（返回non-const成员），然后在外部获取这个指针，再修改指针所指之物是合法的。</li>
<li>这其中没有任何错误：创建一个常对象并设某值，而且只对它调用const成员函数。但终究改变了它的值。</li>
</ul>
</li>
<li>这种情况导出logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。</li>
</ul>
<p>可以用mutable关键字释放掉non-static成员变量的bitwise constness约束。</p>
<hr>
<p>当const成员函数和non-const成员函数有实质等价的实现时，都去实现这两个函数就会使得代码重复、膨胀、编译时间、维护等问题。此时真正应该作的是实现const成员函数并让non-const成员函数调用它。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">text</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>&amp; <span class="title">func</span><span class="params">(...)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>&amp; <span class="title">func</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> text&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">func</span>(...));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码有两个转型动作：</p>
<ul>
<li>要让func调用func const，而不是调用自己（会造成无穷尽的递归）。因此必须明确指出是func const，所以这里将*this从原始类型text&amp;转型为const text&amp;，再调用func函数，则此时（是常对象）调用的是func const。<ul>
<li>将non-const对象转为const对象强迫进行了一次安全转型（是安全的），所以需要使用static_cast。</li>
</ul>
</li>
<li>使用const_cast将const func从返回值移除const。</li>
</ul>
<hr>
<p>const版本调用non-const版本并不是该作的事，因为const成员函数承诺绝不改变对象的逻辑状态，而non-const成员函数却没有这般承诺。这就是为什么这里能用static_cast作用于*this：这里并不存在const相关危险。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>
</blockquote>
<h1 id="条款04"><a href="#条款04" class="headerlink" title="条款04"></a>条款04</h1><blockquote>
<p>确定对象被使用前已先被初始化。</p>
</blockquote>
<p>读取未初始化我值，有时可能让程序终止运行，更可能的情况是读入一些“半随机”bits。最佳的处理办法就是：永远在使用对象之前先将它初始化。对于无任何成员的内置类型，必须手工完成。而内置类型以外的任何其他东西，都交给构造函数来初始化，其规则是：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>这个规则很简单，但重要的是别混淆了赋值和初始化。如果在类中先声明了成员，然后在构造函数的函数体赋值，则本质上这些成员变量执行的是声明-赋值，先调用默认的构造函数，然后执行赋值构造函数（两步，效率低）。更好的写法是用初始化列表替换赋值动作，对大多数类型而言，这样效率更高（一步，直接调用构造函数），有时甚至高效得多。对于内置类型对象，初始化和赋值成本相同，但为了一致性最好也通过初始化列表来初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>(name):<span class="built_in">Name</span>(name),<span class="built_in">Addr</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//初始化列表：Name调用带参构造函数，Addr调用默认构造函数</span></span><br></pre></td></tr></table></figure>

<p>规定总是在初始化列表中列出所有成员变量。那些无需初值的变量使用一个()即可，以免还得记住哪些成员变量不需要初值。</p>
<p>另外，如果成员变量是const或reference的，它们就必须使用初始化列表。因而很多时候最简单的做法就是总使用初始化列表。</p>
<p>在初始化列表中，成员的初始化次序与初始化列表中的次序无关，真的的次序是成员变量在类中被声明的次序。这导致后声明的变量可以使用先声明的变量来初始化，反之不行。因此，也最好按声明的次序在初始化列表里初始化。</p>
<p>初始化列表除了初始化成员变量，还初始化继承的基类，一般基类总是在最前面。现在，还剩下non-local static对象需要讨论。</p>
<hr>
<p>所谓static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-base对象都被排除。这种对象包括global对象、定义于namespace作用域内的对象、在class内、在函数内、以及在file作用域内被声明为static的对象。函数内的static对象称为local static对象（因为它们对函数而言是local的），其他对象称为non-local static对象。程序结束时static对象自动销毁，也即它们的析构函数会在main()结束时被自动调用。</p>
<p>所谓编译单元，是指产出单一目标文件的那些源码，基本上它是单一源码文件加上其所含入的头文件。</p>
<p>我们关心的问题涉及至少两个源码文件。如果某编译单元内的某个non-local static对象的初始化动作使用了另一个编译单元内的某个non-local static对象，它所用到的这个对象可能尚未被初始化。</p>
<p>下面是一个实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件系统，应是全局的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span><span class="comment">//来自你的程序库</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户的处理class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span><span class="comment">//来自程序库客户建立</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>(params);</span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disk = tfs.<span class="built_in">numDisks</span>();<span class="comment">//使用tfs对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;<span class="comment">//创建一个对象</span></span><br></pre></td></tr></table></figure>

<p>现在，除非tfs在tempDir之前被初始化，否则tempDir的构造函数会用到尚未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的non-local static对象，如何能确定tfs先初始化呢？</p>
<p>c++对此是非常困难，根本无解的。</p>
<p>一个小小的设计便可以完全消除这个问题，唯一需要做的是将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所包含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static对象被local static对象替换了。这便是Singleton模式的一个常见实现手法（《Design Patterns》）</p>
<p>这个手法的基础在于：c++保证函数内的local static会在“该函数被调用期间”以及“首次遇上该对象定义式”时被初始化。所以如果你以“函数调用”（返回reference指向local static对象）替换“直接访问non-local static对象”，就获得了保证：保证你所获得的哪个reference将指向一个历经初始化的对象。更棒的是，如果你从未调用non-local static对象的仿真函数，就不会引发构造和析构成本（直接访问需要先创建对象而不管之后会不会用到，这是有成本的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span>&#123;&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">//定义并初始化一个local static对象，并返回引用</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span>&#123;&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disk = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();<span class="comment">//改为tfs()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory tempD;</span><br><span class="line">    <span class="keyword">return</span> tempD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们使用函数返回的“指向static对象”的引用，而不再使用static对象自身。</p>
<p>这种结构下的reference-returning函数往往十分单纯：第一行定义并初始化一个local static对象，第二行返回它。</p>
<p>在多线程系统中仍带有不确定性（不论是local或者non-local）。处理的做法是：在程序的单线程启动阶段手工调用所有reference-returning函数，这可消除与初始化有关的race conditions。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>为内置型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列（初始化列表），而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</li>
</ul>
</blockquote>
<h1 id="条款05"><a href="#条款05" class="headerlink" title="条款05"></a>条款05</h1><blockquote>
<p>了解c++默默编写并调用哪些函数。</p>
</blockquote>
<p>如果没有声明拷贝构造、赋值构造、析构函数，编译器就会为它自动声明编译器版本的函数。此外如果没有声明任何构造函数，编译器也会自动声明一个默认构造函数。这些函数都是public且inline的。唯有当这些函数被需要（调用），它们才会被编译器创建出来。</p>
<p>「具体参考语法记录博客」</p>
<p>记住：</p>
<blockquote>
<p>编译器可以暗自为class创建默认构造函数、拷贝构造函数、赋值操作符以及析构函数。</p>
</blockquote>
<h1 id="条款06"><a href="#条款06" class="headerlink" title="条款06"></a>条款06</h1><blockquote>
<p>若不想使用编译器自动生成的函数，就该明确拒绝。</p>
</blockquote>
<p>所有编译器产出的函数都是public。为阻止这些函数被创建出来，你得自行声明它们，但这里并没有什么需求使你必须将它们声明为public。因此你可以将构造函数、析构函数声明为private。藉由明确声明一个成员函数，你阻止了编译器暗自创建其专属版本；而令这些函数为private，使得你成功阻止人们调用它。</p>
<p>而成员函数和friend函数还是可以调用private函数，因此更进一步的做法是，在private声明而不去定义，这样即使调用，也会得到错误。</p>
<p>一般的做法是，将阻止构造的动作设计在基类，然后继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);<span class="comment">//声明，没有函数体，且无参数名称（无意义）</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">anyclass</span>:<span class="keyword">private</span> Uncopyable<span class="comment">//不一定要public继承，个人理解为都可以，因为没有其他数据</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，anyclass的拷贝构造和赋值构造都不会自动生成，因为基类已经声明了。</p>
<p>记住：</p>
<blockquote>
<p>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</p>
<p>附：在c++11以后，可以用delete修饰函数，这是一种更好的方法。</p>
</blockquote>
<h1 id="条款07"><a href="#条款07" class="headerlink" title="条款07"></a>条款07</h1><blockquote>
<p>为多态基类声明virtual析构函数。</p>
</blockquote>
<p>当一个基类指针指向一个派生类对象，而基类实现中析构函数是non-virtual的，则此时若进行销毁（delete），实际上只会调用基类的析构函数而不会调用派生类的析构函数（因为编译器发现这是基类指针），导致内存释放不完全，因为派生类对象的成员仍然存活，只有基类成员被消除。</p>
<p>消除这个问题的做法是：给基类一个virtual析构函数。这明确告诉编译器这个类是多态的，要销毁对象时要在运行期根据所指对象来调用析构函数（通过虚表）。</p>
<ul>
<li>任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数；</li>
<li>如果class不含virtual函数，通常表明它并不意图被用作一个基类。</li>
<li>当class不企图被当作基类时，往往没有virtual函数，因为一旦有virtual函数，就需要一个虚函数指针指向虚表，这是额外的开销。</li>
<li>抽象类总是希望当作基类，因此往往析构函数写为（纯虚函数）：<code>virtual ~A() = 0;</code>除此之外，必须为纯虚的析构函数提供一份定义：<code>A::A()&#123;&#125;</code>。因为在析构时，编译器往往从最深层的析构函数开始调用，逐步调用每一个基类的析构函数，如果该析构函数没有定义，就会出错。</li>
</ul>
<p>不是所有的基类都是为了多态用途。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li>classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不应该声明virtual析构函数。</li>
<li>纯虚的析构函数必须给出定义。</li>
</ul>
</blockquote>
<h1 id="条款08"><a href="#条款08" class="headerlink" title="条款08"></a>条款08</h1><blockquote>
<p>别让异常逃离析构函数。</p>
</blockquote>
<p>不要在析构函数中抛出异常，原因是C++异常机制不能同时处理两个或两个以上的异常。多个异常同时存在的情况下，程序若不结束，会导致不明确行为。如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Widget</span>()&#123;...&#125;    <span class="comment">//假设这个可能吐出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Widget&gt; v;</span><br><span class="line">&#125;                    <span class="comment">//v在这里被自动销毁</span></span><br></pre></td></tr></table></figure>

<p>函数dosomething运行结束后，最为栈对象的vector v将被销毁，它同时也有责任销毁其内含的所有Widgets。假设v内含十个Widgets，而在析构第一个元素期间，有个异常被抛出。其他九个widgets还是应该被销毁（否则他们保存的任何资源都会发生泄漏），因此v应该调用它们各个析构函数。但假设在那些调用期间，第二个widget析构函数又抛出异常，C++无法同时处理两个或多个异常，多个异常同时存在的情况下，程序若不结束，会导致不明确行为。</p>
<p>如果析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？举个例子，假设你使用一个class负责数据库连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　 ...</span><br><span class="line">　　 <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>; <span class="comment">//返回DBConnection对象；为求简化暂略参数</span></span><br><span class="line">　　 <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">//关闭联机；失败则抛出异常。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为确保客户不忘记在DBConnection对象身上调用close()，一个合理的想法是创建一个用来管理DBConection资源的class，并在其析构函数中调用close。这就是著名的以对象管理资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123; <span class="comment">//这个class用来管理DBConnection对象 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　 ...</span><br><span class="line">　　<span class="built_in">DBConn</span>(<span class="type">const</span> DBConnection&amp; db)&#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;db=db;</span><br><span class="line">   &#125;</span><br><span class="line">　 ~<span class="built_in">DBConn</span>() <span class="comment">//确保数据库连接总是会被关闭</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　    db.<span class="built_in">close</span>();</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">　　 DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用close成功，一切都美好。但如果该调用导致异常，DBConn析构函数会传播该异常，也就是允许它离开这个析构函数。那会造成问题，解决办法如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：结束程序</span></span><br><span class="line">DBConn::~<span class="built_in">DBconn</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强制结束程序”是个合理选项，毕竟它可以阻止异常从析构函数传播出去（那会导致不明确的行为）。也就是说调用abort可以抢先制“不明确行为”于死地。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：吞下异常</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息。然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。为了让这成为一个可行方案，程序必须能够继续可靠的执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三：重新设计DBConn接口，使其客户有机会对可能出现的异常作出反应 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">//供客户使用的新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;       <span class="comment">//关闭连接(如果客户不调用DBConn::close)</span></span><br><span class="line">                  db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...) &#123; <span class="comment">//如果关闭动作失败，记录下来并结束程序或吞下异常。</span></span><br><span class="line">                制作运转记录，记下对close的调用失败；<span class="comment">//然后吞下异常或结束程序</span></span><br><span class="line">                ...</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 我们可以给DBConn添加一个close函数，赋予客户一个机会可以处理“因该操作而发生的异常”。把调用close的责任从DBConn析构函数手上移到DBConn客户手中，你也许会认为它违反了“让接口容易被正确使用”的忠告。</p>
<p>实际上这污名并不成立。如果某个操作可能在失败的时候抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。</p>
<p>由客户自己调用close并不会对他们带来负担，而是给他们一个处理错误的机会。如果他们不认为这个机会有用（或许他们坚信不会有错误发生），可能忽略它，依赖DBConn析构函数去调用close。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
</blockquote>
<h1 id="条款09"><a href="#条款09" class="headerlink" title="条款09"></a>条款09</h1><blockquote>
<p>绝不在构造和析构过程中调用virtual函数</p>
</blockquote>
<p>之所以不要在构造函数和析构函数起点调用virtual函数，是因为这种调用并不会带来预期的结果。</p>
<p>举个例子，假设有这样一个class继承体系，用来模拟股市的买进、卖出的订单等。在这样的过程中，一定要经过审计，因此每当创建一个交易对象时，在审计日志（audit log）中也需要创建一笔适当的记录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;         <span class="comment">//所有交易的base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">//做出一份因为类型不同而不同的日志记录，目前是一个纯虚函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()  <span class="comment">//base class的构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>();    <span class="comment">//最后的动作是对这笔交易进行记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;    <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//对这种类型的交易进行记录（log）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>: <span class="keyword">public</span> Transaction &#123;   <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//对这种类型的交易进行记录（log）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们执行如下语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p>无疑会有一个BuyTransaction构造函数被调用，但是，首先Transaction构造函数一定会更早的被调用。因为derived class对象内的base class成分会在derived class自身成分被构造之前先完成构造。</p>
<p>然而，Transaction构造函数中的virtual函数logTransaction却会引发问题。因为此时所调用的logTransaction是Transaction内的版本，而不是BuyTransaction内的版本——即使目前即将创建的对象是BuyTransaction。也就是说：base class构造期间，virtual函数绝不会下降到derived classes阶层。换种非正式的说法：在base class构造期间，virtual函数不是virtual函数。</p>
<ul>
<li>这是因为在base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived class阶层，要知道derived class的函数几乎必然取用local成员变量，而那些成员变量尚未初始化</li>
<li>更根本的原因在于：在derived class对象的base class构造期间，对象的类型是base class而不是derived class。不止virtual函数会被编译器解析至（resolve to）base class，若使用运行期间类型信息，也会把对象视为base class。</li>
</ul>
<p>在上面的例子中，当Transaction构造函数正在执行起来，打算初始化“BuyTransaction对象内的base class成分”时，该对象的类型是Transaction。而这个对象内的“BuyTransaction专属成分”尚未被初始化。因此在面对它们时，最安全的做法就是视它们不存在。对象在derived class构造函数开始执行之前不会成为一个derived class对象。</p>
<p>相同的道理同样适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现出未定义值。因此，C++将其视为仿佛不存在。进入base class析构函数后对象就变成了一个base class对象。</p>
<hr>
<p>因此，在上面的例子中，Transaction构造函数直接调用一个virtual函数，这很明显就违反了该条款的内容。这就导致了一个问题：因为logTransaction函数在Transaction内是一个pure virtual（纯虚函数）。除非它被定义了，否则程序无法连接，因为连接器找不到必要的Transaction::logTransaction实现代码。</p>
<p>但是，侦测“构造函数或析构函数运行期间是否调用virtual函数”并不简单。一般来说，如果Transaction有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复的一个优秀做法就是将共同的初始化代码（包括对logTransaction的调用）都放到一个初始化函数如init内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()    <span class="comment">//调用non-virtual（init()是non-virtual）</span></span><br><span class="line">    &#123;  <span class="built_in">init</span>();  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">logTransaction</span>();    <span class="comment">//调用了virtual！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码，和早期的版本是一样的，但是却有更深层次的危害，因为这样并不会引起编译器和连接器的报错。此时，由于logTransaction是Transaction的一个pure virtual函数，当pure virtual函数被调用是，大多执行系统会终止程序。然而，如果logTransaction是个正常的virtual（即impure）函数，并在Transaction内带有一份代码，该版本就会被调用，程序也会继续往下进行，只会造成创建一个derived class对象时会调用错误版本的logTransaction（而不报任何信息）。</p>
<p>唯一能避免这一问题的解决办法为：保证构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数，而他们调用的所有函数也都服从同一约束。</p>
<p>但是，又如何确保每一次都有Transaction继承体系上的对象被创建，就会有适当版本的logTransaction被调用？一种办法是在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要的信息给Transaction构造函数，而后那个构造函数边可以安全的调用non-virtual logTransaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std:;string&amp; logInfo)</span> <span class="type">const</span></span>;<span class="comment">//此时，是一个non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);    <span class="comment">//此时，是一个non-virtual调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">BuyTransaction</span>( parameters )</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>( parameters )) <span class="comment">//将log信息传递给base class构造函数</span></span><br><span class="line">        &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">( parameters )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换句话说，由于无法使用virtual函数从base class向下调用，在构造期间，可以由“令derived classes将必要的构造信息向上传递至base class构造函数”替换并加以弥补。</p>
<p>记住：</p>
<blockquote>
<p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</p>
</blockquote>
<h1 id="条款10"><a href="#条款10" class="headerlink" title="条款10"></a>条款10</h1><blockquote>
<p>令 operator&#x3D; 返回一个reference to *this。</p>
</blockquote>
<ul>
<li>赋值采用<code>右结合律</code>。</li>
<li>趣的一点，是你可以把它写出<code>连锁赋值</code>的形式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br><span class="line"><span class="comment">//它相当于x=（y=（z=15））；</span></span><br></pre></td></tr></table></figure>

<p>为了实现这种连锁赋值，赋值操作符<code>必须返回一个reference指向操作符的左侧实参</code>。这也是实现class重载赋值操作符应该遵循的协议。这种协议不仅适用于标准赋值，也<code>适用于所有赋值相关的运算</code>（+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，&lt;&lt;&#x3D;,…）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这只是协议，并无强制性，不遵循，代码一样可以通过编译。然而这份协议被所有内置类型和标准库提供的类型，如string，vector，complex，trl1::shared_ptr或即将提供的类型<code>共同遵守</code>，除非你有一个标新立异的好理由，不然还是遵守吧。</p>
<p>记住：</p>
<blockquote>
<p>令赋值操作符返回一个reference to *this。</p>
</blockquote>
<h1 id="条款11"><a href="#条款11" class="headerlink" title="条款11"></a>条款11</h1><blockquote>
<p>在 operator&#x3D; 中处理“自我赋值”。</p>
</blockquote>
<p>“自我赋值”发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;          <span class="comment">//赋值给自己</span></span><br></pre></td></tr></table></figure>

<p>虽然这种做法看起来比较傻，但是这种操作却是合法的，所以绝不要认定客户不会这么做。</p>
<p>此外，自我赋值并不是总是可以一眼分辨出来，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];        <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>如果i和j具有相同的值时，这就是一个自我赋值。再比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*px = *py;          <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>如果指针px和py恰巧指向同一个东西，这也是一个自我赋值。</p>
<p>这些并不明显的复制行为，是“别名（aliasing）”所带来的结果。所谓“别名”：就是有一个以上的方法指称（指涉）某对象。</p>
<p>一般而言，如果某段代码操作pointers或references，而它们被从来“指向多个相同类型的对象”，就需要去考虑这些对象是否为同一个对象。实际上，两个对象只要来自同一个继承体系，它们甚至不需要声明为相同类型就可能会造成“别名”，因为一个base class的reference或者pointer可以指向一个derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomethings</span><span class="params">(<span class="type">const</span> Base&amp; rb, Derived* pd)</span></span>;   <span class="comment">//rd和*pd有可能其实是同一个对象</span></span><br></pre></td></tr></table></figure>

<p>在这里，假如说我们尝试自行管理资源（即打算写一个用于资源管理的class，就需要这样做），就可能会掉进“在停止使用资源之前意外释放了它”的陷阱。举个例子，假如建立一个class用来保存一个指针指向一块动态分配的位图（bitmap）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;     <span class="comment">//指针，指向一个从heap分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是operator&#x3D; 的实现代码，看起来虽然合理，但是在进行自我赋值时并不安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)    <span class="comment">//不安全的operator= 的实现版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;     <span class="comment">//停止使用当前的bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);       <span class="comment">//使用rhs&#x27;s bitmap的副本（复件）</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以会出现自我赋值的问题，是因为operator&#x3D; 函数内的*this（赋值的目的端）和rhs有可能是同一个对象。如果它们是同一个对象，那么delete对象就不只是销毁当前对象的bitmap，它也同时销毁了rhs的bitmap。在函数末尾，Widget发现自己持有一个指针指向一个已被删除的对象。</p>
<p>想要阻止这样的错误，传统的做法是在operator&#x3D; 最前面进行一个“证同测试（identity test）”，以此达到自我赋值的检验目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)        <span class="comment">//证同测试（identity test）</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//如果是自我赋值，就不做任何事情</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解决办法是行得通的。在第一个版本的operator&#x3D; 中，不仅不具备“自我赋值安全性”，也不具备“异常安全性”，然而，这个新版本的operator&#x3D;，仍然存在异常方面的问题：如果“new BItmap”导致了异常（比如因为分配时内存不足或者因为Bitmap的copy构造函数抛出异常），Widget最终会持有一个指针指向一个被删除的Bitmap。(如果具备异常安全，在new发生之前不delete原来的对象，以防new异常后不能恢复。)</p>
<p>这样的指针是有害的：既不能安全的删除它，也不能安全的读取它。唯一能对它们做的安全的事情就是付出很多调试的功夫，去找到错误的起源。</p>
<hr>
<p>当我们让operator&#x3D; 具备“异常安全性”时，往往会自动获得“自我赋值安全性”的特性。因此，很多时候，并不专门去解决“自我赋值”的问题，而是将注意力放在“异常安全性（exception safety）”之上。例如对于下面，只需要注意在赋值pb所指的东西之前不要删除pb即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;     <span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">//令pb指向*pb的一个副本（复件）</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;     <span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，如果“new Bitmap”抛出异常，pb（及其栖身的那个Widget）也会保持原状。即使没有证同测试，这段代码也是能够处理自我赋值问题，因为我们对原bitmap做了一份复件、删除原bitmap、然后指向新制造的那个复件。</p>
<p>当然，如果我们想要提高效率，也可以将证同测试重新放到函数的起始处。然而这样做之前先问问自己，你估计“自我赋值”的发生频率有多高？因为这项测试也需要成本。它会使代码变大一些（包括原始码和目标码）并导入一个新的控制流分支，而两者都会降低执行速度。</p>
<hr>
<p>一个替代方案是，使用copy and swap技术。我在惯用法中更详细地说明了这项技术，事实上，内容基本包含了这一章节的内容。下面是简单的介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swqp</span><span class="params">(Widget&amp; rhs)</span></span>;   <span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);      <span class="comment">//为rhs数据制作一份复件</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this数据和上述的复件进行数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更为高效简洁的写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个写法更快的原因是参数通过值传递，抵消了创建temp的过程。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)   <span class="comment">//rhs直接就是被传对象的一份复件，此时是pass by value</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);           <span class="comment">//将*this数据和上述的复件进行数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法之所以可以，是因为：</p>
<ul>
<li>某class的copy assignment操作符可能被声明为“以by value方法接受实参”</li>
<li>以by value方法传递东西会形成一份复件。</li>
</ul>
<p>这种方法牺牲了代码的清晰性，但是却将“copy动作”从函数本体内移至“函数参数构造阶段”，使得编译器生成了更有效的代码。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>确保当对象自我赋值时 operator&#x3D; 有良好行为。其中技术包括比较“来源对象”和“”目标对象“的地址、精心周到的语句顺序、以及copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
</blockquote>
<h1 id="条款12"><a href="#条款12" class="headerlink" title="条款12"></a>条款12</h1><blockquote>
<p>复制对象时勿忘其每一个部分。</p>
</blockquote>
<p>设计良好的面向对象的系统，会将对象的内部封装起来，只留下两个函数来负责对象的拷贝（复制）：</p>
<ul>
<li>copy构造函数</li>
<li>copy assignment操作符</li>
</ul>
<p>我们将它们一起成为copying函数。</p>
<p>假如我们要声明自己的copying函数，即告诉编译器自己不会去使用缺省实现的某些行为，那么此时编译器会在代码几乎必然出错的情况下，却不去告诉你。</p>
<p>举个例子，考虑一个class，用来表示顾客，其中人为地书写copying函数（而非由编译器去创建），使得外界对它们的调用都会记录下来（logged）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logCall</span><span class="params">(<span class="type">const</span> std::string&amp; funcName)</span></span>;  <span class="comment">//制作一个log entry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs);     <span class="comment">//copy构造函数</span></span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs);    <span class="comment">//copy assignment操作符</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs) : <span class="built_in">name</span>(rhs.name)  <span class="comment">//复制rhs的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy assignment operator);</span></span><br><span class="line"><span class="string">    name = rhs.name;     //复制rhs的数据</span></span><br><span class="line"><span class="string">    return *this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然上面的代码看起来并没有什么问题，但是当另一个变量加入到其中时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123; ... &#125;;     <span class="comment">//日期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//定义与前面相同</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，既有的copying函数执行的是局部拷贝（partial copy）：它们只复制了顾客的name，而没有复制新添加的lastTransaction。</p>
<p>这明显是个错误，但是编译器却并不会报错（即使在最高级别的警告中）。因此，如果我们为class添加一个新的成员变量时，就必须同时修改copying函数。（同时也需要修改class的所有构造函数以及任何非标准形式的operator&#x3D;）。</p>
<hr>
<p>另外，一旦发生继承，则会造成一个更严重的危机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;   <span class="comment">//定义Derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);    <span class="comment">//</span></span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">priority</span>(rhs.priority)     <span class="comment">//复制rhs的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，PriorityCustomer的copying函数看起来好像是复制了PriorityCustomer内的每一样东西，但是实际上，它们只是复制了PriorityCustomer声明的成员变量，但是每个PriorityCustomer还内含了它所继承的Customer成员变量复件，而那些成员变量并没有被复制。即：Derived class没有连同base class中的字段一起复制。</p>
<p>PriorityCustomer的copy构造函数并没有指定实参传给其base class构造函数。（也即说它在它的成员初值列（member initialization list）中没有提到Customer）。</p>
<p>因此，PriorityCustomer对象的Customer成分会被不带有Customer构造函数（即default构造函数）初始化。default构造函数将会针对name和lastTransaction执行缺省的初始化动作。对于PriorityCustomer，它不曾企图修改其base class的成员变量，因此那些成员变量保持不变。</p>
<hr>
<p>任何时候只要你为派生类实现copying函数，必须很小心地也复制基类成分，那些成分往往是private，所以无法直接访问，应该让派生类的copying函数调用相应的基类函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);<span class="comment">//对base class成分进行赋值动作</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你编写一个copying函数时，请确保：</p>
<ul>
<li>复制所有local成员变量；</li>
<li>调用所有基类内的适当的copying函数。</li>
</ul>
<hr>
<p>copying函数往往有近似相同的实现，但需要记住的是：令某个copying函数调用另一个copying函数无法达到目标，应把相同的实现放入第三个函数中由两个copying函数调用（通常命名为init，且为private）。</p>
<p>原因是，拷贝构造函数是针对未初始化的对象的操作，而赋值操作符只能施行于已初始化对象身上。当对象已初始化时，使用赋值操作符调用”只能作用于未初始化对象“的拷贝构造函数是没有意义的；同样，对象未初始化时，使用拷贝构造函数调用”只能施行于已初始化对象“的赋值操作符也是没有意义的；乃至于根本没有相关语法。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>copying函数应确保复制”对象内的所有成员变量“及”所有base class 成分“；</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应将共同技能放进第三个函数中，并由两个copying函数共同调用。</li>
</ul>
</blockquote>
<h1 id="条款13"><a href="#条款13" class="headerlink" title="条款13"></a>条款13</h1><blockquote>
<p>以对象管理资源</p>
</blockquote>
<p>假设我们使用一个用来塑模投资行为（例如股票、债券等）的程序库，各种各样的投资类型继承自root class Investment。进一步假设这个库使用了通过一个 factory 函数为我们提供特定 Investment 对象的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; ... &#125;; <span class="comment">// “投资类型”继承体系中的root class</span></span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">/*返回指向Investment继承体系内的动态分配对象的指针。调用者有责任删除它。这里为了简化，刻意不写参数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当 createInvestment 函数返回的对象不再使用时，由调用者负责删除它。下面的函数 f 来履行以下职责：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Investment *pInv = <span class="built_in">createInvestment</span>(); <span class="comment">// 调用factory对象</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">delete</span> pInv; <span class="comment">// 释放pInv所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下几种情形会造成 f 可能无法删除它得自 createInvestment 的投资对象：</p>
<ul>
<li>“…” 部分的某处有一个提前出现的 return 语句，控制流就无法到达 delete 语句；</li>
<li>对 createInvestment 的使用和删除在一个循环里，而这个循环以一个 continue 或 goto 语句提前退出；</li>
<li>“…” 中的一些语句可能抛出一个异常，控制流不会再到达那个 delete。</li>
</ul>
<p>单纯依赖“f总是会执行其delete语句”是行不通的，因为代码可能会在时间渐渐过去后被其他人修改、维护。</p>
<p>为了确保 createInvestment 返回的资源总能被释放，我们需要将资源放入对象中，当控制流离开f，这个对象的析构函数会自动释放那些资源。将资源放到对象内部，我们可以依赖 C++ 的“析构函数自动调用机制”确保资源被释放。</p>
<p>许多资源都是动态分配到堆上的，并在单一区块或函数内使用，且应该在控制流离开那个块或函数的时候释放。标准库的 auto_ptr 正是为这种情形而设计的。auto_ptr 是一个类似指针的对象（智能指针），它的析构函数自动对其所指对象调用 delete。下面就是如何使用 auto_ptr 来预防 f 的潜在的资源泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// 调用工厂函数</span></span><br><span class="line">... <span class="comment">// 一如以往地使用pInv</span></span><br><span class="line">&#125; <span class="comment">// 经由auto_ptr的析构函数自动删除pInv</span></span><br></pre></td></tr></table></figure>

<p>这个简单的例子示范了“以对象管理资源”的两个关键想法：</p>
<ul>
<li>获得资源后应该立即放进管理对象内。</li>
<li>管理对象使用它们的析构函数确保资源被释放。</li>
</ul>
<p>auto_ptr 和 tr1::shared_ptr 都在它们的析构函数中使用 delete，而不是 delete []。这就意味着将 auto_ptr 或 tr1::shared_ptr 用于动态分配的数组是个馊主意。C++ 中没有可用于动态分配数组的类似 auto_ptr 或 tr1::shared_ptr 这样的东西，甚至在 TR1 中也没有。那是因为 vector 和 string 几乎总是能代替动态分配数组。</p>
<p>如果你手动释放资源（例如，使用 delete，而不使用资源管理类），你就是在自找麻烦。像 auto_ptr 和 tr1::shared_ptr 这样的预制的资源管理类通常会使本条款的建议变得容易，但有时你所使用的资源是目前这些预制的类无法妥善管理的，你就需要精心打造自己的资源管理类。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII classes 分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择 ，因为其copy行为比较直观。若选择auto_ptr，复制动作会使被复制物指向null。</li>
</ul>
</blockquote>
<h1 id="条款14"><a href="#条款14" class="headerlink" title="条款14"></a>条款14</h1><blockquote>
<p>在资源管理类中小心copying行为。</p>
</blockquote>
<p>如果一个RAII对象被复制，会发生什么？</p>
<p>在上一个条款之中，提到了“资源获得的时机就是初始化时机”（Resource Acquisition Is Initialization（RAII）），并且说明了auto_ptr和tr1::shared_ptr如何在heap-based的资源上作用的。但是，并不是所有的资源都是“heap-based”的，对于这种资源，上述的这两种指类指针对象就不再适合作为资源管理者了。于是，我们需要建立自己的资源管理类，</p>
<p>举个例子，加入使用C API函数处理类型为Mutex的互斥器对象（mutex objects），共有lock和unlock两个函数可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm)</span></span><br><span class="line"><span class="function">    &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;   <span class="comment">//获得资源</span></span><br><span class="line">    ~<span class="built_in">Lock</span>() ( <span class="built_in">unlock</span>(mutexPtr); )   <span class="comment">//释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用Lock时，符合RAII的标准：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;        <span class="comment">//定义所需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;               <span class="comment">//建立一个区块用来定义critical section</span></span><br><span class="line"><span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    <span class="comment">//锁定互斥器</span></span><br><span class="line">    ...         <span class="comment">//执行critical section内的操作</span></span><br><span class="line">&#125;               <span class="comment">//在区块结尾处，会自动解除互斥器的锁定</span></span><br></pre></td></tr></table></figure>

<p>这样的操作的是没有问题，但是如果此时Lock对象被复制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;       <span class="comment">//锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(m1l)</span></span>;      <span class="comment">//将ml1复制到ml2之上</span></span><br></pre></td></tr></table></figure>

<p>这个时候，对于这种情况，一般有两种选择：</p>
<ul>
<li>禁止复制。因为许多时候，允许RAII被复制并不合理。如果复制动作对于RAII对象不够合理，就应该禁止。实现这种禁止，即用到了条款6中所说的办法：将copying操作声明为private。</li>
<li>对底层资源使用“引用计数法”。有的时候，我们希望保持着资源，直到它的最后一个使用者（某个对象）被销毁。在这种情况下，复制RAII对象时，应该将资源的“被引用数”进行递增。tr1::shared_ptr就是如此。</li>
</ul>
<hr>
<p>通常只要内含一个tr1::shared_ptr成员变量，RAII classes就可以实现reference-counting copying行为（使用默认的拷贝构造函数即可，因为这时会对成员变量调用其拷贝构造）。假如前面的Lock想要使用reference counting，它可以直接去改变mutexPtr的类型即可：将其从Mutex*改为tr1::shared_ptr&lt; Mutex &gt;。</p>
<p>但是，需要注意的是，tr1::shared_ptr的默认行为为：当引用次数为0时，删除其所指物。删除操作并不是我们想要的，当我们使用一个Mutex，我们要做的释放动作是解除锁定而并非删除。</p>
<p>因此，tr1::shared_ptr是允许定义所谓的“删除器（deleter）”的，这是一个函数或者函数对象（function object），当引用的次数为0时被调用（这个功能并不存在与auto_ptr中，它总是将其指针删除）。这个删除器对于tr1::shared_ptr是第二个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span>   <span class="comment">//以某个Mutex初始化shared_ptr</span></span></span><br><span class="line"><span class="function">      : mutexPtr(pm, unlock)  //并且unlock函数作为删除器</span></span><br><span class="line"><span class="function">      &#123;</span></span><br><span class="line">          <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//注意！没有析构函数！</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;   <span class="comment">//使用shared_ptr代替raw pointer   </span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在条款5中说过，无论是编译器自动生成的、还是用户自定义的，class 析构函数都会自动调用其non-static成员变量（在这里是mutexPtr）的析构函数，使计数器减1。而mutexPtr的析构函数会在互斥器的引用计数为0时自动调用tr1::shared_ptr的删除器（在这里是unlock）。也就是说，之所以没有声明析构函数，完全只是依赖了编译器生成的缺省行为。</p>
<p>总之，对RAII对象的复制基本就两种情况：</p>
<ul>
<li>复制底部资源。可以是多个对象指向一份资源（引用计数）；也可以深度拷贝，对这个资源多生成一份副本（从内存来看是不同的）。</li>
<li>转移底部资源的拥有权。确保永远只有一个RAII对象指向一个原始资源。</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying 行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。</li>
</ul>
</blockquote>
<h1 id="条款15"><a href="#条款15" class="headerlink" title="条款15"></a>条款15</h1><blockquote>
<p>在资源管理类中提供对原始资源的访问。</p>
</blockquote>
<p>所谓资源管理类（resource-managing classes），可以有效的帮助我们去预防资源泄漏。但是，虽然在理想的情况下，我们希望所有的资源与对象之间的互动都依赖于这样的资源管理类，仍有许多的API会直接去涉及原始资源（raw resource）。</p>
<p>举个例子，在前面的条款13中，我们可以得知：使用智能指针auto_ptr或者tr1::shared_ptr来保存factory函数例如createInvestment的调用结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;<span class="comment">//pInv本身是shared_ptr，内部的成员指针才是Investment的</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望用某个函数来处理Investment对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dayHeld</span><span class="params">(<span class="type">const</span> Investment* pi)</span></span>;      <span class="comment">//返回投资的天数</span></span><br></pre></td></tr></table></figure>

<p>此时，如果我们想要这样去调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);      <span class="comment">//错误！！</span></span><br></pre></td></tr></table></figure>

<p>这样做是错误的，因为daysHeld需要的是Investment的指针，而并非此时传递给它的类型为tr1::shared_ptr的对象。</p>
<p>因此，此时需要一个函数，可以将RAII class对象转换为其所内含的原始资源（即tr1::shared_ptr -&gt; Investment*）<br>有两种方法可以实现这样的功能：</p>
<ul>
<li><p>显式转换：tr1::shared_ptr和auto_ptr都提供了一个get成员函数，用来执行显式转换。也就是说，可以返回智能指针内部的原始资源（的复件）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>());    <span class="comment">//成功的将pInv内的原始指针传给了daysHeld</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式转换：就像几乎所有的智能指针一样，这些对类指针对象都重载了指针取值（pointer dereferencing）操作符（operator -&gt;和operator *），它们允许隐式转换至底部的原始指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123;    <span class="comment">//investment继承体系的根类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span> <span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;     <span class="comment">//factory函数</span></span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>; <span class="comment">//令tr1::shared_ptr管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());  <span class="comment">//经由operator-&gt;访问资源</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//令auto_ptr管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable2 = !((*pi2).<span class="built_in">isTaxFree</span>());   <span class="comment">//经由operator*访问资源</span></span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<p>因为有时需要必须取得RAII内部的原始资源，一般的做法是提供一个隐式转换函数（operator A()，A的目标类型）。举个例子，对于用于字体的RAII class（对于C API而言，字体是一种原始数据结构、即原始资源）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;       <span class="comment">//这是一个C API</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;    <span class="comment">//来自同一组的C API</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;    <span class="comment">//RAII class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span> : f(fh)   //获得资源，采用pass-by-value的方法</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line">    ~<span class="built_in">Font</span>() &#123; <span class="built_in">releaseFont</span>(f); &#125;    <span class="comment">//释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;     <span class="comment">//原始（raw）字体资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有大量与字体相关的C API，它们处理的都是FontHandle，那么“将Font对象转换为FontHandle”将会是一件非常繁琐的事情。因此，Font class可以提供一个显式的转换函数，就像上面的get一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;    <span class="comment">//显式转换函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//然而，每次用户想要使用API时，都必须要调用get：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="type">int</span> newFontSize)</span></span>; <span class="comment">//C API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize);   <span class="comment">//明确地将Font转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>另外一种办法则是令Font提供隐式转换函数，转换的类型FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//隐式转换函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样，在调用C API时，就非常的方便了：</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);   <span class="comment">//将Font隐式地转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>但是，这种隐式转换却会增加错误的发生机会。例如，当我们需要使用Font时，却会意外的创建一个FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1; <span class="comment">//注意！这里的本意是拷贝一个Font对象，但是因为隐式转换的原因（f2前面的FontHandle），将f1给隐式转换为了FontHandle，然后才执行了复制操作</span></span><br></pre></td></tr></table></figure>

<p>在上面的程序中，FontHandle由Font对象f1进行管理，但是这个FontHandle也可以直接通过f2进行取得。这样就会引发问题，例如当f1被销毁时，字体会被释放，而f2因此会成为“虚吊的”（dangle）。</p>
</li>
</ul>
<hr>
<p>综上所说，是否应该提供一个显式转换函数（例如get成员函数）将RAII class转换为其底部资源，还是提供隐式转换，取决于其执行的具体功能，具体说来：</p>
<ul>
<li>让接口容易被正确使用，不易被误用。因此，通常显式转换函数如get就是比较好的方法，因为显式转换将非故意的类型转换的发生的可能性最小化了。</li>
<li>然而有时候隐式类型转换所带来的自然用法也能取得方便。</li>
</ul>
<p>最后，值得说明的是，从RAII class 获取原始资源并没有什么矛盾（你可能认为这样的类封装是失败的）。关于RAII class，它们并不是为了封装，而是为了确保：资源释放，这一行为，一定会发生。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>APIs往往要求访问原始资源，所以每一个RAII class 应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换（比如一个get成员函数）或隐式转换（重载operator A()）。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h1 id="条款16"><a href="#条款16" class="headerlink" title="条款16"></a>条款16</h1><blockquote>
<p>成对使用new和delete时要采取相同形式。</p>
</blockquote>
<p>这章内容比较简单，就是“单一对象”和“对象数组”的问题。</p>
<ul>
<li>当你使用delete[]时，实际上是告诉编译器我要delete的对象是一个数组，让它得知内存中存在一个“数组大小记录”，这样才能释放完全空间。</li>
<li>如果对象不是数组但依然用了delete[]，就会导致编译器在解释内存空间时误认为某一项是“数组大小”，然后错误地释放空间。</li>
<li>最后，不要对数组形式做typedef动作，因为这会导致你new时不容易发现到底有没有[]，从而导致delete出错。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p>
</blockquote>
<h1 id="条款17"><a href="#条款17" class="headerlink" title="条款17"></a>条款17</h1><blockquote>
<p>以独立语句将newed对象置入智能指针。</p>
</blockquote>
<p>首先，假设我们有个函数用来显示处理函数的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据“以对象管理资源”的条款，processWidget使用智能指针来对动态分配得到的Widget进行管理（即tr1::shared_ptr）</p>
<p>当我们试图调用processWidget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>());<span class="comment">//这种情况会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，此时是不能通过编译的。tr1::shared_ptr构造函数需要一个原始指针（raw pointer），但是这个构造函数是一个explicit构造函数，无法进行隐式转换。因此，需要将“newWidget”的原始指针转换为processWidget所需要的tr1::shared_ptr，因此需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; (<span class="keyword">new</span> Widget), <span class="built_in">priority</span> ());<span class="comment">//先使用构造函数，再拷贝构造</span></span><br></pre></td></tr></table></figure>

<p>但是，虽然此时我们使用了“对象管理式资源”，仍然会产生资源的泄漏！</p>
<p>在编译器产生一个processWidget调用代码之前，首先需要确定把即将被传递的各个实参是什么。在上面的代码中，第二个实参较为简单，只是一个对priority函数的调用；而第一个实参则较为复杂，对于这个实参std::tr1::shared_ptr&lt; Widget &gt; (new Widget)，它有两部分组成：</p>
<ul>
<li>执行“new Widget”表达式</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>因此，在调用processWidget之前，编译器需要创建代码，做以下三件事情：</p>
<ul>
<li>调用priority</li>
<li>执行“new Widget”</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>对于这三件事情，对于C++而言，“new Widget”的执行次序一定是在“tr1::shared_ptr构造函数被调用”之前，因为这个表达式的结果还需要被传递作为tr1::shared_ptr构造函数的一个实参。但是对于priority的调用而言，则是可以在第一、第二或者第三执行。假如选择在第二位执行，可以得到这样的执行序列：</p>
<ul>
<li>1.执行“new Widget”</li>
<li>2.调用priority</li>
<li>3.调用tr1::shared_ptr构造函数</li>
</ul>
<p>因此，对于上面这个执行次序，如果priority的调用产生异常，此时“new Widget”返回的指针将会遗失，因为它尚未被置入tr1::shared_ptr内，而这个智能指针的存在就是为了防止资源泄漏的。因此，在对processWidget的调用过程中是会引发资源泄漏，因为在“资源被创建（经由“new Widget”）”和“资源被替换为资源管理对象”这两个时间点之间可能会被发生干扰。</p>
<p>为了避免这样的问题，解决办法为分离语句。即分别写出：</p>
<ul>
<li><p>1.创建WIdget</p>
</li>
<li><p>2.将它置入一个智能指针之中，然后再将这个智能指针传给processWidget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;    <span class="comment">//在单独的语句内以智能指针存储newed所得对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">process</span>(pw <span class="built_in">priority</span>());     <span class="comment">//这个调用动作就不会造成泄漏</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>之所以可以解决这个问题，是因为编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有这个自由）。在上述修改后的代码中，“new Widget”表达式以及“对tr1::shared_ptr构造函数的调用”这两个动作，与“对priority的调用”是分隔开的，在不同的语句之中，因此编译器就不能再它们之间任意选择执行次序。</p>
<p>记住：</p>
<blockquote>
<p>以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出（在资源对象产生到置入资源管理对象之间，产生异常的话），有可能导致难以察觉的资源泄漏。</p>
</blockquote>
<h1 id="条款18"><a href="#条款18" class="headerlink" title="条款18"></a>条款18</h1><blockquote>
<p>让接口容易被正确使用，不易被误用。</p>
</blockquote>
<p>想要开发出一个“容易被正确使用，不易被误用”的接口，首先就需要明白使用这样的接口可能会产生怎样的错误？举个例子，假设我们为一个用来表示日期的class设计构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然这样定义的构造函数乍一看没什么问题，但其实在调用时，却可能会产生以下两个错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的传递参数次序：</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;    <span class="comment">//把月和日传递反了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递一个无效的月份或天数：</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">1995</span>)</span></span>;    <span class="comment">//二月有30号？？</span></span><br></pre></td></tr></table></figure>

<p>想要解决这样的问题，类型系统（type system）是一个关键办法。我们使用外覆类型（wrapper type）来区别这样的天数、月份和年份，然后在Date构造函数中使用这些类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> : val(d) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> : val(m) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span> : val(y) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;        <span class="comment">//错误的类型！</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">3</span>), Year(<span class="number">1995</span>))</span></span>;  <span class="comment">//错误的类型！</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;  <span class="comment">//正确了！</span></span><br></pre></td></tr></table></figure>

<p>当我们确定好类型的定义，限制它们的取值也是非常重要。比如，月份的取值只能是1-12。方法之一，就是利用enum表现月份。不过enum并不具备类型安全性。因此，比较安全的解法是预先定义所有有效的Months：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>): &#125;  <span class="comment">//函数，返回有效的月份（本质是构造函数）</span></span><br><span class="line">    <span class="type">static</span> Month <span class="built_in">Feb</span>() &#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125; <span class="comment">//“以函数替换对象”，请回忆条款4中non-local static对象问题</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>);&#125;</span><br><span class="line">    ...    <span class="comment">//其他的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span>   <span class="comment">//阻止生成新的月份</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>预防错误的另一种方法，限制类型内什么事情可以做，什么不可以做。常见的限制是加上const。在前面的条款3中，就对const的作用进行了说明。</li>
<li>“让types容易被正确使用，不容易被误用”，进一步表现为：除非有更好的理由，否则应该尽量让我们定义的types的行为与内置的types一致。一旦有怀疑，就拿int类型当范本。比如a*b这个表达式不允许赋值。</li>
<li>避免无端的与内置类型不兼容，真正的理由是为了提供行为一致的接口。STL容器的接口就比较一致，这就使得它们非常容易被使用。例如，每个STL容器都有size函的成员函数，它会告诉调用者目前容器内的对象的个数。</li>
</ul>
<hr>
<p>如果一个接口要求使用者必须记住某些事情，就会有着“不正确使用”的倾向，因为使用者很有可能忘记做这件事。举个例子，在条款13中所说的factory函数，它会返回一个指针指向Investment继承体系内的一个动态分配的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了避免资源的泄漏，createInvestment返回的指针最终必须被删除，但是在这个过程中，至少可能会出现两个错误机会：（1）没有删除指针。（2）删除同一个指针超过一次。</p>
<p>在条款13中提供的解决办法是将createInvestment的返回值存储在一个智能指针内，于是delete的责任就赋予了智能指针。不过，使用者如果忘记使用智能指针，则会出现问题。因此，较为理想的接口就是令factory函数返回一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这实际上就是强迫使用者将返回值存储在一个tr1::shared_ptr内，</span></span><br><span class="line"><span class="comment">//因此几乎就消除了忘记删除底部Investment对象的可能性。</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>假设class的设计，希望“从createInvestment取得Investment*指针”，将该指针传递给一个名为getRidOfInvestment的函数，而不是直接delete。那么这样设计的一个接口（上面那个）却会产生新的错误：企图使用错误的资源析构机制——即使用delete替换getRidOfInvestment。</p>
<p>对于这个问题，一个解决办法则是：返回一个“将getRidOfInvestment绑定为删除器（deleter）”的tr1::shared_ptr。</p>
<p>在前面的条款中有讲到过，tr1::shared_ptr提供的构造函数有两个实参：</p>
<ul>
<li>（1）被管理的指针</li>
<li>（2）引用次数变成0时被调用的“删除器”</li>
</ul>
<p>由此可得，我们可以创建一个null tr1::shared_ptr并以getRidOfInvestment作为其删除器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试图创建一个null shared_ptr并携带一个自定的编译器</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="number">0</span>, getRidOfInvestment)</span></span>;</span><br><span class="line"><span class="comment">//错误的形式！无法通过编译！！</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是不能通过编译的，因为tr1::shared_ptr构造函数的第一个参数必须是个指针，而0不是指针。因此，转型（cast）可以解决这样的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确地创建一个null shared_ptr并携带一个自定的编译器</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), getRidOfInvestment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们想要实现createInvestment使它返回一个tr1::shared_ptr并夹带getRidOfInvestment函数作为删除器，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), getRidOfInvestment)</span></span>;</span><br><span class="line">    retVal = ...;    <span class="comment">//令retVal指向正确的对象</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果被管理的原始指针可以在建立智能指针之前先确定下来，那么将原始指针传给构造函数会比先初始化为null再赋值更好。</p>
<hr>
<p>tr1::shared_ptr的一个优秀的性质是：它会自动的使用它的“每个指针专属的删除器”这样的性质消除了一个潜在的可能错误：“cross-DLL problem”。</p>
<p>这个问题发生于“对象在动态链接库（DLL）中被创建，但却在另一个DLL内被delete销毁”。在一些平台上，这一类“跨DLL的new&#x2F;delete成对运用”会导致运行期间错误。</p>
<p>然而tr1::shared_ptr就没有这个问题，因为它默认的删除器是来自“tr1::shared_ptr诞生所在的那个那个DLL”的delete。举个例子来说，如果Stock派生自Investment，而createInvestment的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt;(<span class="keyword">new</span> Stock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的那个tr1::shared_ptr可被传递给任何其他的DLLs，无需在意“cross-DLL problem”。这个指向Stock的tr1::shared_ptr会追踪记录“当Stock的引用次数变成0时该调用的那个DLL’s delete”。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促使正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>tr1::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁（见条款14）等等。</li>
</ul>
</blockquote>
<h1 id="条款19"><a href="#条款19" class="headerlink" title="条款19"></a>条款19</h1><blockquote>
<p>设计class犹如设计type。</p>
</blockquote>
<p>当我们定义一个新的class时，就相当于定义了一个新的type。</p>
<p>如何设计一个高效的classes？主要面对以下的问题：</p>
<ul>
<li><strong>新type的对象应该如何被创建和销毁？</strong>这会影响到class的构造函数和构造函数以及内存分配函数和释放函数（operator new, operator new[], operator deleter和operator deleter[]）。</li>
<li><strong>对象的初始化和对象的赋值应该有什么差别？</strong>这个问题的答案，决定了构造函数和赋值（assignment）操作符的行为，以及它们之间的差异。需要注意的是，“初始化”和“赋值”是不同的，因为他们应用于不同的函数调用。（详见条款4）</li>
<li><strong>新type的对象如果被passed by value（以值传递），会怎样？</strong>需要记住的是，copy构造函数用来定义一个type的pass-by-value应该如何去实现。</li>
<li><strong>什么是type的“合法值”？</strong>对class的成员变量来说，通常某些只有数值集是有效的。那些数值集决定了class需要维护的约束条件（invariants），因此，也就决定了成员函数（特别是构造函数、赋值操作符以及所谓的“setter”函数）必须要进行错误检查工作。</li>
<li><strong>创建的新type需要配合某一个继承图系（inheritance graph）么？</strong>如果继承来自某些既有的classes，那么设计的新classes就受到了束缚，特别是受到“它们的函数是virtual或者non-virtual”的影响。如果我们定义的class允许其他class去继承，这样会影响我们所声明的函数——尤其是析构函数——是否为virtual（详见条款7）。</li>
<li><strong>创建的新type需要怎样的转换？</strong>如果我们希望允许类型T1可以被隐式地转换为类型T2，就必须在class T1中写一个类型转换函数（operator T2）或者在class T2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数。如果我们只允许explicit构造函数存在，就必须写出专门负责执行转换操作的函数。</li>
<li><strong>什么样的操作符和函数对新创建的type而言是合理的？</strong>针对这个问题，需要决定class声明哪些函数，在这些函数中，哪些应该是member 函数，哪些则不是。</li>
<li><strong>什么样的标准函数应该被驳回？</strong>这些函数是必须声明为private的函数（详见条款7）。</li>
<li><strong>谁来取用新的type成员？</strong>这个问题可以帮助我们决定哪些成员应该是public、protected和private；同时也可以帮我们决定哪一个class&#x2F;function应该是friends，以及将它们嵌套到另一个之内是否合理。</li>
<li><strong>什么是新type的“未声明接口”（undeclared interface）？</strong>它会对效率、异常安全性以及资源运用（例如多任务锁定和动态内存）提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</li>
<li><strong>创建的新的type有多么一般化？</strong>如果说我们所需要的不是一个type，而是需要一整个types家族，那么我们就需要定义一个新的class template。</li>
<li><strong>真的需要定义一个新的type吗？</strong>如果只是定义新的derived class以便既有的class添加功能，那么单纯的定义一个或多个non-member函数或者template，或许更能达到目标。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。</p>
</blockquote>
<h1 id="条款20"><a href="#条款20" class="headerlink" title="条款20"></a>条款20</h1><blockquote>
<p>宁以pass-by-reference-to-const替换pass-by-value。</p>
</blockquote>
<p>在一般的情况下，默认情况中C++会以by value的方式传递对象自（或来自）函数。除非我们去特别指定，否则函数参数都是以实际实参的复件为初值，而调用端获得的也是函数返回值的一个复件。这些复件是由对象的copy构造函数生成的，这可能会造成pass-by-value称为较为费事儿的操作。</p>
<p>对于下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    !<span class="built_in">Student</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">    std::string schoolAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，我们调用函数validateStudent，该函数需要一个Student实参（by value）并返回它是否是有效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;   <span class="comment">//函数以by value的形式接受学生</span></span><br><span class="line">Student white;    <span class="comment">//定义一个学生white</span></span><br><span class="line"><span class="type">bool</span> whiteIsOk = <span class="built_in">validateStudent</span>(white);   <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p>当我们执行上面的代码时：首先，Student的copy构造函数会被调用，以white为蓝本将s进行初始化。同时，当validateStudent返回s时会被销毁。因此，对于此函数而言，参数的传递成本是：</p>
<ul>
<li>一次Student copy构造函数调用</li>
<li>一次Student析构函数调用</li>
</ul>
<p>但是！这还不算完！Student对象内有两个string对象，因此每次构造一个Student对象也就构造了两个string对象。此外，Student对象继承自Person对象，因此，每次每次构造Student对象是也必须构造一个Person对象。一个Person对象又有两个string对象，因此，每一次Person的构造动作也要承担两个string对构造动作。</p>
<p>于是，最终结果是：以by value的形式传递一个Student对象会调用一次Student对象会导致调用一次Student copy构造函数、一次Person copy构造函数、四次string copy构造函数。因此，当函数内的Student复件被销毁时，每一个构造函数调用动作都会对应一个析构函数调用动作。以by-value方式传递一个Student对象，</p>
<p>总体成本是：六次构造函数 和 六次析构函数。</p>
<hr>
<p>这是一个非常大的代价了。想要回避这样的大代价的一个办法就是pass by reference-to-const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样的传递方法，效率要高的多：没有构造函数或者析构函数被调用，因为没有任何新对象被创建。</p>
<p>在上面修改后的代码，参数const是非常重要的。因为在原先的validateStudent中参数是以by-value的形式进行传递的，因此变相的就告诉我们这个传递的参数是收到保护的，函数内绝不会对传入的Student进行任何的更改，能更改也只是对Student的复件进行修改。</p>
<p>于是，Student以by reference方式的传递，将它声明为const是必要的，使得确保传递的Student不至于被修改。</p>
<hr>
<p>以by reference方式传递参数，也可以避免slicing（对象切割）问题。</p>
<p>当一个derived class对象以by value方式进行传递，并被视为一个base class对象，base class的copy构造函数会被调用，然而：“造成此对象的行为像一个derived class对象”的那些特质化的特征全部被切割掉了，仅仅留下了一个base class对象。造成这种情况的原因是，这个对象正是base class构造函数进行建立的，然而这种现象是我们一定不希望看到的。</p>
<p>举个例子，假设我们定义一组class，用来实现一个图形窗口系统：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">//返回窗口的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//显示窗口和其中的内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于所有的Window对象，都有一个名称，我们可以通过name函数获取。所有的窗口显示，我们也可以通过display函数来进行实现。<br>其中，display函数是一个virtual函数，这就意味着base class Window对象的显示方式和WindowWithScrollBars对象的显示方式是不同的。</p>
<p>而当我们希望写一个函数去打印窗口的名称，然后显示该窗口，下面的写法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisply</span><span class="params">(Window w)</span>   <span class="comment">//不正确，参数可能会被切割</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用上述的参数并向其传递一个WindowWithScrollBars对象时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br></pre></td></tr></table></figure>

<p>此时，参数w会被构造称为一个Window对象，因为它是pass by value的。于是，使得wwsb“之所以是一个WindowWithScrollBars对象”的所有特征都会被切割掉，简而言之：在printNameAndDisplay函数内不管是传递过来的对象时什么类型，参数w就像是一个Window对象。<br>因此，在printNameAndDisplay函数内调用display调用的总是Window::display，而绝不会是WindowWithScrollBars::display。</p>
<p>解决切割（slicing）问题的办法，就是以by reference-to-const方式传递w：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> printNameAndDisplay（<span class="type">const</span> Window&amp; w）</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，传进来的窗口的是什么类型，w就表现出那种类型。</p>
<hr>
<p>当我们观察C++编译器底层时，可以看到reference往往是以指针来实现的，因此：pass by reference通常意味传递的是指针。</p>
<ul>
<li>根据这点，如果我们需要传递的对象属于内置类型（例如int），pass by value往往比pass by reference的效率更高。对于这一点，也同样适用于STL的迭代器和函数对象，因为习惯上，它们都被设计为passed by value。</li>
<li>因为内置类型都相当的小，所以可能有人就会认为，所有小型types都可以使用pass-by-value，甚至当它们是用户自定义的class也一样，这个结论是错误的！因为对象小不代表copy构造函数的代价就不高。有许多对象——包括大多数STL容器——内含的东西只比一个指针多一些而已，但是复制这种对象却需要承担“赋值这些指针所指的每一样东西”。因此，代价也是非常昂贵的。</li>
<li>即使小型对象拥有并不昂贵的copy构造函数，在效率上也可能有差距。某些编译器在对待“内置类型”和“用户自定义类型”的态度上截然不同，即使两者拥有相同的底层表述（underlying representation）。</li>
<li>“小型的用户自定义类型不一定通过pass-by-value”的另一个理由是：作为一个用户自定义类型，其大小容易变化。一个type目前虽然比较小，将来却可能会变得比较大，因为其内部实现可能会变化。</li>
</ul>
<p>总而言之，其他小型的type包括自定义的class，对象本身小不代表copy代价不高；就算代价不高，编译器的不同对待也会导致效率也比较低；并且这些自定义类型大小是容易变化的。</p>
<p>一般而言，我们可以认为：</p>
<ul>
<li>pass-by-value代价不高的唯一对象就是内置类型和STL的迭代器和函数对象。</li>
</ul>
<p>以至于所其他其他的任何东西，都应当尽量以pass-by-reference-to-const替换pass-by-value。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>尽量以 pass-by-reference-to-const 替换pass-by-value。前者通常比较高效，并可避免切割问题。</li>
<li>以上规则并不适用于内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。</li>
</ul>
</blockquote>
<h1 id="条款21"><a href="#条款21" class="headerlink" title="条款21"></a>条款21</h1><blockquote>
<p>必须返回对象时，别妄想返回其reference。</p>
</blockquote>
<p>在上一章中我们了解到，pass-by-value有很多效率方面的问题，因此pass-by-reference可能是一种比较好的方法。<br>但是！盲目的用reference可能会造成这样的错误：开始传递一些references指向其实并不存在的对象！</p>
<p>举个例子，对于一个用以表现有理数（rational number）的class，内含一个函数用来计算一个有理数的乘积：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//分子numerator和分母denominator</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">      <span class="type">const</span> Rational</span><br><span class="line">        <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line">                   <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，这个版本的operator 是以by value的方法返回其计算结果——一个rational对象。对于这样的返回方法，代价如何？<br>假如说我们进行修改，使用reference进行传递，就不需要付出代价了。</p>
<p>但是：所谓的reference，只是一个名称，代表着某个既有对象。即，它一定是某物的另一个名称。</p>
<p>就像上面的operator* ，如果他返回一个reference，那么后者一定指向某个既有的Rational对象，内含两个Rational对象的乘积。因此，我们不能期望这样一个内含乘积的Rational对象在调用operator* 之前就存在。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;       <span class="comment">//a = 1/2</span></span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;       <span class="comment">//b = 3/5</span></span><br><span class="line">Rational c = a * b;     <span class="comment">//c应该是3/10</span></span><br></pre></td></tr></table></figure>

<p>期望“原本就存在一个值为3&#x2F;10的Rational对象”并不合理。如果operator* 要返回一个reference指向这个数值，它就必须自己创建这个Rational对象！</p>
<hr>
<p>一般来说，函数创建新对象有两种方法：</p>
<ul>
<li>在stack空间创建</li>
<li>在heap空间创建</li>
</ul>
<p>如果我们定义一个local变量，就是在stack空间创建对象。根据这个策略，尝试写一下operator*：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;  <span class="comment">//使用了构造函数实现，但是非常糟糕！</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure>

<p>对于上面这个方法，是一个比较糟糕的办法！因为我们的目标是避免使用构造函数，而result却必须用构造函数的方法来进行构造。更严重的是，这个函数返回一个reference指向result，但是result是一个local对象，而local对象在函数退出之前就被销毁了。因此，此时operator* 所指向的Rational，是一个已经被销毁的Rational！于是，此时将会陷入“无定义行为”的困境。</p>
<p>简单总结一句话：任何函数如果返回一个reference指向某个local对象，都会产生必然的错误！</p>
<hr>
<p>因此，我们考虑在heap内构造一个对象，并返回reference指向它。<br>Heap-based对象是由new创建的，因此我们需要写一个heap-based operator*，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.n * rhs.d);    <span class="comment">//更为！糟糕的写法！</span></span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们依然需要付出一个“构造函数调用”的代价，因为分配获得的内存将以一个适当的构造函数完成初始化动作。<br>然而，此时还有一个更为严重问题：谁应该为被new出来的对象实施delete？</p>
<p>即使我们十分谨慎，还是会在合情合理的使用下，造成内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational w, x,y,z;</span><br><span class="line">w = x * y * z;          <span class="comment">//与operator*(operator*(x, y), z)相同</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，同一个语句调用了两次operator*，因此使用了两次new，因此也就需要两次delete。但是，并没有合理的办法让operator*的使用者进行哪些delete调用，因为没有合理的办法让他们取得operator* 返回的references背后隐藏的那个指针。</p>
<p>这势必会造成内存泄漏！</p>
<hr>
<p>无论是on-the-stack，还是on-the-heap的做法，都因为对operator* 返回的结果调用构造函数而产生了问题，而最开始的目标就是避免如此的构造函调用动作！于是，另一个想法则是基于：</p>
<ul>
<li>让operator* 返回的reference指向一个被定义于函数内部的static Rational对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result;    <span class="comment">//还是很糟糕！定义static对象，该函数将返回它的reference</span></span><br><span class="line">    result = ... ;             <span class="comment">//将lhs乘以rhs，并将结果置于result之内</span></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>上面的代码之所以糟糕，是因为如果对于以下的使用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                <span class="type">const</span> Rational&amp; rhs);   <span class="comment">//一个针对Rational而写的operator==</span></span><br><span class="line">Rational a, b, c, d;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c * d))</span><br><span class="line">&#123;</span><br><span class="line">    乘积相等所执行的动作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    乘积不等所执行的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现的问题是：无论a, b, c, d的值是多少，表达式((a * b) &#x3D;&#x3D; (c * d))总是被判定为True！</p>
<p>让我们将上述的if判断语句写成等价的函数形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d))</span><br></pre></td></tr></table></figure>

<p>上面这句代码，可以看到在operator==被调用之前，已经有两个operator* 被调用了，并且每一个都返回reference指向operator* 内部定义的static Rational对象。因此，operator==被要求将“operator* 内的static Rational对象值” 拿来和“operator* 内的static Rational对象值” 进行比较，这自然就是相等了。</p>
<p>值得注意的是，两次的operator*的调用确实是改变了static Rational对象值，但是由于他们都是返回reference，因此调用段看到的永远是static Rational对象的“现值”。</p>
<p>另外，如果创建一个static array保存这些static对象呢？一方面这个数组的大小很难选择（太小不够用，太大降低效率），一方面每个对象都会在函数第一次调用时构造完成，调用n个构造函数和最后有n个析构函数。接着，为了把结果值写入array，又要调用赋值操作，很多时候赋值操作相当于一个拷贝构造和一个析构函数，情况就更恶劣了。</p>
<hr>
<p>于是，一个“必须返回新对象”的函数的正确写法是：直接让这个函数返回一个新对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incline <span class="type">const</span> Rational <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Raitonal&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，operator*返回值的构造成本和析构成本是必须支出的，但是这只是获得正确行为的小小代价。</p>
<p>总之：</p>
<ul>
<li>当我们必须在“返回一个reference和返回一个object”之间进行选择时，选择行为正确的那一个。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference 指向一个local static对象”提供了一份设计实例。</p>
</blockquote>
<h1 id="条款22"><a href="#条款22" class="headerlink" title="条款22"></a>条款22</h1><blockquote>
<p>将成员变量声明为private。</p>
</blockquote>
<p>总结下来主要有三点理由：</p>
<ul>
<li>语法一致性：如果public的都是函数，用户在调用成员时都加上小括号就行了，不必再考虑这是变量还是函数（要不要加括号）；</li>
<li>精确控制：将变量放private，可以继而通过函数实现精准地控制，如这些变量读写访问权限；</li>
<li>封装：public意味着不封装，不封装意味着不可改变。如果将成员变量隐藏，那么暴露出来的函数即使内部实现改变（适应不同情况，可能用不同成员变量）也不会对客户造成多大的困扰，最多只需要重新编译。这样的封装，使得class的约束条件容易得到维护，保留了日后变更实现的权力。<ul>
<li>改变public事物总是收到束缚的，因为会破坏许多客户码（它们用暴露出来的成员实现其他功能等等）。</li>
<li>protected虽然不能被外部对象访问，但可以被派生类本身访问，因此也是不封装的，改变它会使得派生类代码被破坏。</li>
<li>也就是说：private提供封装，其他不提供封装。</li>
</ul>
</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>切记将成员变量声明为private。这可赋予用户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。</li>
</ul>
</blockquote>
<h1 id="条款23"><a href="#条款23" class="headerlink" title="条款23"></a>条款23</h1><blockquote>
<p>宁以non-member&amp;non-friend替换member函数。</p>
</blockquote>
<p>假设有一个class用来表示网页浏览器。这样的class可能提供的众多函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;<span class="comment">//清除下载元素高速缓存区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;<span class="comment">//清除访问过的URLs的历史记录</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;<span class="comment">//清除系统中的所有cookies</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此，用户可能会觉得使用一个操作来执行这些任务，因此WebBrowser也提供这样一个member函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;  <span class="comment">//调用上述的三个函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时，这个机能也可以通过一个non-memebr函数调用适当的member函数而提供：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearBrowser</span> <span class="params">(WebBrowser&amp; wb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wb.<span class="built_in">clearCache</span>();</span><br><span class="line">    wb.<span class="built_in">clearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">removeCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，对于上面两个办法，哪一种较好呢？</p>
<p>首先，对于面向对象守则的要求，数据及操作数据的那些函数应该被捆绑在一起。这就意味着使用member函数可能是一个比较好的选择。然而事实上并非如此。</p>
<ul>
<li>面向对象守则要求数据应该尽可能地被封装，而与直观相反的是，member函数clearEverything所带来的封装性比non-member函数clearBrowser要低。</li>
<li>提供non-member函数可允许对WebBrowser相关机能有较大的包裹弹性（packaging flexibility），而那最终导致较低的编译相依度，增加WebBrowser的可延伸性。</li>
<li>因此，许多方面non-member做法比member做法好。</li>
</ul>
<hr>
<p>从封装开始讨论。</p>
<p>如果某些东西被封装，它就不再可见。越多的东西被封装，就越少的人可以看见。而越少的人可以看到它，我们就有越大的弹性去改变它，因为我们的改变仅仅直接影响看到改变的那些人事物。</p>
<ul>
<li>因此，越多的东西被封装，我们改变这些东西的能力就越大。简而言之，封装使得我们能够改变事物而只影响有限的用户。</li>
</ul>
<p>越少的代码可以看到数据（即访问到它），越多的数据就可以封装，而我们就越能自由地改变对象数据，例如改变成员变量的数量、类型等。</p>
<ul>
<li>简而言之，越多的函数可以访问这个数据，它的封装性就越低。</li>
</ul>
<p>在上一个条款22中可以得知，成员变量应该是private，因为如果它们不是private，就会有无限量的函数可以访问到它们，它们也就毫无封装性。</p>
<ul>
<li>能够访问private成员变量的函数只有class的member函数加上friend函数。</li>
</ul>
<p>对于member函数，它可以访问class内的：private数据、private函数、enums、typedefs等等。而对于non-member函数，它无法访问上述的任何一个。如果我们需要在member函数和non-member函数中选择，而且两者提供相同的机能，则：</p>
<ul>
<li>导致较大封装性的是non-member non-friend函数，因为它并不会增加“能够访问class内的private”的函数数量。</li>
</ul>
<p>因此，这也就解释了为什么clearBrowser（non-member non-friend函数）比clearEverything（member函数）更受欢迎：它导致WebBrowser class有有较大的封装性。</p>
<ul>
<li>这个论述仅适用于non-member non-friend函数。friends函数对class private成员的访问权利和member函数相同。因此，从封装的角度来看，这里的选择关键并不在于member和non-member函数之间，而在于member和non-member&amp;non-friend函数之间。当然，封装并非我们的唯一考量。当我们考虑隐式类型转换时（条款24），就应该在member和non-member函数间进行选择了。</li>
<li>只因为在意封装性而让函数“变成class的non-member”，并不意味着它“不可以是另一个class的member。”例如，我们可以令clearBrowser称为某个工具类（utility class）的一个static member函数，只要它不是WebBrowser的一部分（或者称为其friend），就不会影响WebBrowser的private成员封装性。</li>
</ul>
<hr>
<p>在C++中，比较自然地做法是：让clearBrowser成为一个non-member函数，并且位于WebBrowser所在的同一个namespace（命名空间）中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不仅仅是看起来自然而已，namespace和class不同，前者可以跨越多个源码文件而后者不可以（namespace提供功能上的切割）。这一点很重要，因为clearBrowser这个函数是个“提供便利的函数”，如果它既不是member或friend。它就没有对WebBrowser的特殊访问权利，也就不能提供其他机能。没有这个函数，用户可以通过自行调用三个函数来清除网页。</p>
<p>这样，一个像WebBrowser这样的class可能会拥有大量的便利函数，某些与书签有关，某些与打印有关，某些则与cookie管理有关。而大多数情况下用户只对其中某一个或某几个感兴趣。</p>
<p>因此，分离它们的最直接的办法就是讲某一个相关函数声明在一个头文件内，将另一个相关函数声明在另一个头文件中且使用相同的命名空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowser.h，这个头文件针对class WebBrowser自身以及WebBrowser核心机能</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebBrowser</span> &#123; ... &#125;;<span class="comment">//类的实现在这里，类不允许跨文件（切割）</span></span><br><span class="line">    ...      <span class="comment">//核心机能，例如几乎所用用户都会用到的non-member函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件webbrowserbookmarks.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ...      <span class="comment">//与书签相关的便利函数，注意只是这些便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    ...      <span class="comment">//与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这正是C++标准程序库的组织方式。标准程序库并不是拥有单一、整体、庞大的&lt; C++StandardLibrary &gt;头文件并在其中内含std命名空间内的每一样东西，而是有数十个头文件（&lt; vector &gt;, &lt; algorithm &gt;, &lt; memory&gt; 等等），每个头文件声明std的某些机能。如果一个用户只想使用vector的相关机能，他并不需要去<code>#include &lt;memory&gt;</code>于是，这就允许用户只对他们所用的那一小部分系统形成编译相依。</p>
<p>然而：这种切割并不使用于class成员函数，因为一个class必须整体定义，不能被分割为片段，因此这种时候该使用namespace。</p>
<p>简而言之，将所有便利函数放在多个头文件内但是隶属于同一个命名空间，意味用户可以轻松扩展这一组便利函数。他们需要做的仅仅是添加更多non-member non-friend函数到这个命名空间中。</p>
<ul>
<li>这一点是class无法提供的另一个性质，因为class定义式对于用户而言是不可扩展的。尽管用户可以派生出新的classes，但是derived classes无法访问base class中被封装（即private）成员，于是此时的“扩展机能”拥有的只是次级身份。</li>
<li>此外，并非所有的class都被设计作为base classes。</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。</li>
<li>附：大量的便利函数可以使用相同的命名空间而放在不同的头文件里，这样用户可以根据自己对功能的需求使用头文件，减少编译相依性。其中该有个核心的头文件，提供核心便利函数以及类的实现。</li>
</ul>
</blockquote>
<h1 id="条款24"><a href="#条款24" class="headerlink" title="条款24"></a>条款24</h1><blockquote>
<p>若所有参数皆需类型转换，请为此采用non-member函数。</p>
</blockquote>
<p>令class支持隐式类型转换通常是一个糟糕的选择。但是，这条规则也有例外，最常见的就是建立数值类型时。假设对于一个class用来表示有理数，因此允许整数“隐式转换”为有理数看起来其实是挺合理的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>,     <span class="comment">//构造函数刻意不是explicit</span></span><br><span class="line">             <span class="type">int</span> denominator = <span class="number">1</span>);  <span class="comment">//允许int-to-rational进行隐式转换，前提是构造函数有默认参数</span></span><br><span class="line">    							 <span class="comment">//这样就可以把int解释成分子的参数，而分母使用默认值1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;          <span class="comment">//分子的访问函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">//分母的访问函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接着，对于算数运算的实现，到底应该使用member函数、non-member函数，还是non-member friend函数来实现？首先，对于operator* 的实现，虽然在条款23中指出，将函数放进相关class内又是会与面向对象守则发生矛盾，但先暂时不考虑，先看一下将operator* 写成Rational 成员函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">const</span> Rational <span class="keyword">operator</span>* （<span class="type">const</span> Rational&amp; rhs） <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种设计，可以以很方便的方式实现相乘：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEight;   <span class="comment">//成功！</span></span><br><span class="line">result = result * oneEight;             <span class="comment">//成功！</span></span><br></pre></td></tr></table></figure>

<p>暂时看上去，是可行的。但是如果我们此时用两个不同类型的数据进行相乘——比如，一个Rational和int相乘，就可能会出现问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">//成功！</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;   <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这样的错误？？当我们以对应的函数形式重写上述两行代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);  <span class="comment">//成功！</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>因此，错误就显而易见了：</p>
<ul>
<li>oneHalf是一个内含operator* 函数的class的对象，因此没有问题。</li>
<li>整数2并没有对应的class，也就没有operator* 成员函数。</li>
</ul>
<p>此时，编译器也会尝试在命名空间内或在global作用域内调用以下形式的non-member operator*：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">operator</span>*(<span class="number">2</span>, oneHalf);     <span class="comment">//错误！</span></span><br><span class="line"><span class="comment">//在此例中，并不存在这样一个接受int和Rational作为参数的non-member operator*， 因此会查找失败。</span></span><br></pre></td></tr></table></figure>

<p>在这里，上面第一次有参数2，之所以成功，是因为这里发生了所谓的隐式类型转化（implicit type conversion）。</p>
<p>编译器知道此时确实是传递了一个int，而函数需要的却是Rational；但编译器同时也知道，只要它调用Rational构造函数并赋予传递来的int，就可以构造出适当的Rational出来。换句话说，此时的调用动作在有点像以下的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;     <span class="comment">//根据2建立一个暂时性的Rational对象，2作为分子的参数，分母使用默认值</span></span><br><span class="line">result = oneHalf * temp;    <span class="comment">//等同于oneHalf.operator*(temp)</span></span><br></pre></td></tr></table></figure>

<p>这也只是因为涉及到了non-explicit构造函数，编译器才会这样去实现。如果 Rational的构造函数是explicit，下面两条语句都是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;   <span class="comment">//错误！无法将2转换位Rational</span></span><br><span class="line">result = <span class="number">2</span> * result;    <span class="comment">//一样的错误！</span></span><br></pre></td></tr></table></figure>

<p>此时我们可以看到，这就很难让Rational class支持混合式算数运算了。</p>
<hr>
<ul>
<li><p>只有当参数被列于参数列（parameter list）内，这个参数才是隐式类型转换的合格参与者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C++的参数列表有函数的参数列表、宏定义的参数列表、模板的类型参数列表等。</span><br><span class="line">参数列表又可以分为形式参数列表和实际参数列表。</span><br><span class="line">例如: 在定义函数时函数头部所列的就是形式参数列表，在调用函数时所列的就是实际参数列表。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这也就解释了为何第一次可以通过编译，而第二次不可以：因为第一次的调用伴随着一个放在参数列内的参数，第二次则没有（operator*函数没有两个放在参数列参数的版本）。实际上，是由于member函数自动使用*this占用第一个参数。</p>
<p>因此，最终的解决方案就出现了：</p>
<ul>
<li>让operator* 成为一个non-member函数，并允许编译器在每一个实参身上执行隐式类型转换：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;            <span class="comment">//并不包含operator*的定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs,   <span class="comment">//构成了一个non-member函数</span></span><br><span class="line">                         <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(),</span><br><span class="line">                    lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Rational <span class="title">oneForth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneForth * <span class="number">2</span>;      <span class="comment">//成功了！</span></span><br><span class="line">result = <span class="number">2</span> * oneForth;      <span class="comment">//成功了！！</span></span><br></pre></td></tr></table></figure>

<p>此时，问题得到了顺利的解决，不过仍然有一点需要考虑：</p>
<ul>
<li>operator* 是否应该是Rational class的一个friend函数呢？</li>
</ul>
<p>就这个例子而言，答案是否定的！因为operator* 完全可以由Rational的public接口完成任务，上面的代码也是这样去实现的。（public的构造函数和分子分母的访问函数）于是，这也又引发了一个重要的结论：</p>
<ul>
<li>member函数的反面是non-member函数，而不是friend函数。</li>
</ul>
<p>有很多程序员会有这样的误解，如果一个“与某class相关”的函数不应该成一个member，那么它就一定要称为friend，这是一个错误的理解。无论何时如果可以避免使用friend函数，就应该去避免。虽然friend有其正当性，但下面的结论依然成立：</p>
<ul>
<li>不能只因为函数不该成为member，就自动让它成为friend。可以用class中public的成员函数作为接口，供non-member函数访问class相关的内容。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>如果你需要为某个函数的所有参数（包括this指针所指的哪个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</p>
<p>附：因为隐式转换需要匹配参数列，对于成员函数，第一个参数是*this，使得可能不能匹配转换。</p>
</blockquote>
<h1 id="条款25"><a href="#条款25" class="headerlink" title="条款25"></a>条款25</h1><blockquote>
<p>考虑写出一个不抛异常的swap函数。</p>
</blockquote>
<p>swap是一个有趣的函数。</p>
<p>原本它只是STL的一部分，而后则成为异常安全性编程（exception-safe programming）的主体，以及后来用于处理自我赋值可能性（条款11）的一个常见机制。因此，swap的实现是非常重要的。</p>
<p>所谓的swap（置换）两对象的值，指的就是将两对象的值彼此赋予对方。在默认的情况之下，swap动作可以由STL提供的swap算法来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namsespace std &#123;</span><br><span class="line">    <span class="function">tempate&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要类型T支持copying（通过copy构造函数和copy assignment操作符来完成），缺省的swap实现代码就会自动置换类型为T的对象，我们并不需要额外的工作。这种缺省的实现比较简单，涉及到了三个对象的复制：</p>
<ul>
<li>a复制到temp</li>
<li>b复制到a</li>
<li>temp复制到b</li>
</ul>
<p>但是对于某些类型而言，这些复制动作并没有必要！</p>
<p>其中最主要的即“以指针指向一个对象，内含真正数据”的类型。这种类型最常见的表现形式就是“pimpl手法”（pointer to implementation）如果以这种手法设计Widget class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b, c;      <span class="comment">//可能有许多数据，意味着复制时间很长</span></span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;          <span class="comment">//该class使用pimpl手法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; rhs);     <span class="comment">//复制Widget时，令它复制其WidgetImpl对象</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)   <span class="comment">//operator=的实现见条款10~12</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;    <span class="comment">//指针，所指的对象就是内含Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一旦我们需要置换两个Widget对象的值，我们唯一需要做的就是置换其pImpl指针而已。<br>但是，缺省的swap并不知道这一点！它不仅会复制三个Widgets，还会复制三个WidgetImpl对象！效率一下子就变得很低了。</p>
<hr>
<p>我们希望告诉std::swap，当Widgets被置换时，真正应该做的就是置换内部的pImpl指针。而实现这一想法的做法是</p>
<ul>
<li>将std::swap针对Widget特化。</li>
</ul>
<p>下面的代码是思路的实现，但是无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namsespace std &#123;        <span class="comment">//这是std::swap针对“T是Widget”的特化版本，并不能通过编译</span></span><br><span class="line">    tempate&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);    <span class="comment">//置换Widget时，只需要置换它们的pImpl指针即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tempate&lt;&gt;：表示它是std::swap的一个全特化（total template specialization）版本；函数名之后的：表示这一特化版本会针对“T是Widget”而设计的；换句话说，一般性的swap template施加于Widget身上便会启用这个版本。</p>
<p>通常而言，我们不能改变std命名空间内的任何东西，但是可以为标准templates（如swap）制造（全）特化版本，使得它专属于我们自己定义的class（例如Widget）。上面的代码也正是这样去实现的。</p>
<p>而之所以上面的代码无法通过编译，是因为：</p>
<ul>
<li>它企图访问a和b内的pImpl指针，但这个指针是private。</li>
</ul>
<p>因此，一个解决办法则是：</p>
<ul>
<li>令Widget声明一个名为swap的public成员函数，来去做真正的置换工作，然后将std::swap特化，令它调用该成员函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;          <span class="comment">//与前面相同，唯一的差别就是增加swap函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;   <span class="comment">//这个声明是非常必要的</span></span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);   <span class="comment">//若要置换Widget，就置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;     <span class="comment">//修订后的std::swap特化版本</span></span><br><span class="line">    tempate&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);    <span class="comment">//如果要置换Widgets，调用其swap成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，不仅能够通过编译，而且还与STL容器有一致性：</p>
<ul>
<li>所有STL容器也都提供有public swap成员函数和std::swap特化版本（用以调用前者）</li>
</ul>
<p>然而，假设Widget和WidgetImpl都是class template而并非class，也许可以尝试将WidgetImpl内的数据类型加以参数化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WidgetImpl</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">temolate&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>在Widget内放一个swap成员函数就像前面一样简单，但是在特化std::swap时却会遇到问题！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">void</span> swap&lt; Widget&lt;T&gt; &gt; ( Widget&lt;T&gt;&amp; a,    <span class="comment">//错误！</span></span><br><span class="line">                             Widget&lt;T&gt;&amp; b)</span><br><span class="line">    &#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这样看起来是合理的，然而却并不合法。<br>当我们企图偏特化（partially specialize）一个function template（std::swap），而C++只允许对class template偏特化，在function template身上偏特化是不可以的，只能全特化。</p>
<p>当我们打算偏特化一个function template时，一般的做法是简单地为它添加一个重载模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//std::swap的一个重载版本</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, <span class="comment">//需要注意的是，swap后面没有&quot; &lt;...&gt; &quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">              Widget&lt;T&gt;&amp; b)</span> <span class="comment">//但是这样也是不合法的！</span></span></span><br><span class="line"><span class="function">    </span>&#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>般而言，我们是可以重载function template的，但是std是一个特殊的命名空间，因此管理规则也比较特殊：</p>
<ul>
<li>使用者可以全特化std内的template，但是不可以添加新的template（或者class、function以及其他东西）</li>
</ul>
<p>因此，所谓的“禁止”，其实添加新东西到std里是可以编译的，但是这样的行为是没有明确定义的。如果我们希望程序有可预期的行为，就不要添加任何新东西到std之中。</p>
<hr>
<p>我们不要添加任何新东西到std内。但我们还是需要一个办法，以提供高效的template特定版本的swap。解决办法是：</p>
<ul>
<li>依然是声明一个non-member swap，让它调用member swap，但不再将那个non-member swap声明为std::swap的特别版本或重载版本。（不需要为std的swap来全特化了，只做一个非成员函数的swap来调用）</li>
</ul>
<p>因此，为了简化起见，假设Widget的所有相关机能被置于命名空间WidgetStuff，于是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...                         <span class="comment">//模板化的WidgetImpl等等</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//和前面一样，内含swap成员函数</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;        <span class="comment">//non-member swap函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a,     <span class="comment">//这里并不属于std命名空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">              Widget&lt;T&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>于是，当我们置换两个Widget对象，因而调用swap，C++的名称查找法则（name lookup rules；更具体的说是所谓argument-dependent lookup或Kobeig lookup法则）将会找到WidgetStuff内的Widget专属版本。</p>
<p>也可以不使用额外的命名空间，但何必在gloabal命名空间内塞满各式各样的class、template、function等等呢？</p>
<hr>
<p>然而，虽然上面的做法对于class和class template都行得通，但我们还是应该为class（非template的）特化std::swap。</p>
<p>所以，如果我们想让“class 专属版”的swap在尽可能多的语境下被调用，我们就应该同时在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。也即为class写三个swap：成员函数版，非成员函数版和std全特化版本。后两个版本调用第一个版本。</p>
<hr>
<p>上面所说的swap，一直是从我们自身角度去考虑。如果我们从用户的角度来看，对swap进行定义也非常有必要。假设正在写一个function template，其内需要置换两个对象值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，调用了swap，但是调用的是哪一个一般化版本？</p>
<ul>
<li>std既有的一般化版本？</li>
<li>某个可能存在的特化版本？</li>
<li>存在的T专属版本而且可能存在与某个命名空间内（非std内）</li>
</ul>
<p>我们希望的是调用T专属版本，并在该版本不存在的情况下，再去调用std内的一般化版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usint std::swap;    <span class="comment">//令std::swap在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);   <span class="comment">//为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦编译器看到了对swap的调用，它们便查找适当的swap并加以调用。C++的名称查找发着会确保将找到global作用域或者T所在的命名空间内的任何T专属的swap。</p>
<ul>
<li>如果T是Widget并位于命名空间WidgetStuff内（或者在global空间，如果你是在那实现的话），编译器就会使用“实参取决的查找规则”（argument-dependent lookup）找出WidgetStuff内的swap。</li>
<li>如果没有T专属的swap存在，编译器就会使用std内的swap——由using std::swap这条语句，使得这个选择被展现。<ul>
<li>当然，如果已经针对T将std::swap进行了全特化，这个全特化版本也直接会被优先使用（优先于泛型版本的std::swap）。</li>
</ul>
</li>
</ul>
<p>因此，令适当的swap被调用是比较容易的。但需要小心的是：不要添加额外的修饰符，这样会影响C++挑选适当的函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(obj1, obj2);      <span class="comment">//错误的swap调用方式</span></span><br></pre></td></tr></table></figure>

<p>上面这个举动，会迫使编译器只认std内的swap，因而不再可能调用一个定义于其他地方的适当T专属版本。</p>
<hr>
<p>到目前为止，这三部分已经讨论了：</p>
<ul>
<li>default swap</li>
<li>member swap</li>
<li>non-member swap</li>
<li>std::swap 特化版本</li>
<li>swap的调用</li>
</ul>
<p>因此，做一个总结：</p>
<ul>
<li>首先：如果swap的缺省实现（std版本）对我们的class或class template提供可接受的效率，那么我们并不需要做其他的事情。</li>
<li>其次：如果swap的缺省版本效率不足（基本上就是因为class或者class template使用了某种pimpl手法），则三部曲：<ul>
<li>1.提供一个public swap成员函数，让它高效地置换对应类型的两个对象值。这个函数绝不能抛出异常（其他函数是调用它）。</li>
<li>2.在我们的class或template所在的命名空间内（最好是用特殊空间，但在global空间也不会编译错误）提供一个non-member swap，并令它调用上述swap成员函数。</li>
<li>3.如果我们正在编写一个class（而非class template），就需要为我们的class特化std::swap，并令它调用我们的swap成员函数。否则不需要这一步。</li>
</ul>
</li>
<li>最后，如果我们调用swap（在最高的层次调用），请确定包含一个using声明式，以便让std::swap在我们的函数内部可以曝光可见，然后不加任何namespace修饰符，直接去调用swap。</li>
</ul>
<hr>
<p>还有一点：</p>
<ul>
<li>成员版本的swap绝对不可以抛出异常！</li>
</ul>
<p>原因在于，swap的一个最好的应用就是为了帮助class（和class template）提供强烈的异常安全性（exception-safety）保障。当然，这一约束只施行于成员版！不可实施于非成员版（也不必，因为非成员版就是调用成员版），因为swap缺省版本是以copy构造函数和copy assignment操作符为基础的，在一般情况下是允许抛出异常的。</p>
<p>因此，当我们写一个自定义版本的swap时，往往需要提供以下两点：</p>
<ul>
<li>高效置换对象值的办法</li>
<li>不抛出异常</li>
</ul>
<p>一般而言，上面这两个特性是连在一起的，因为高效率的swap几乎总是基于对内置类型的操作（例如pimpl首发的底层指针），而内置类型上的操作绝不会抛出异常。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请全特化std::swap。</li>
<li>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</li>
<li>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
</blockquote>
<h1 id="条款26"><a href="#条款26" class="headerlink" title="条款26"></a>条款26</h1><blockquote>
<p>尽可能延后变量定义式的出现时间。</p>
</blockquote>
<p>两个理由：</p>
<ul>
<li>定义好的变量可能没有使用，这样就多了一次构造和析构。这个没有使用可能是由于提前返回、抛出异常造成的。所以，尽可能延后变量的定义直到要使用为止；</li>
<li>有时变量先定义了但还不知道初值，而是等后面再赋值。这对于大多数类（可以说除了内置类型以外的其他类）来说是低效的，因为定义再赋值使用一次（默认）构造和一次赋值，效率往往比一次（带参）构造（直接在构造时指定初值）来得差。所以，尽可能延后变量定义直到确定初值为止。</li>
</ul>
<p>关于第二点，假如在一个循环中使用一个变量，到底应不应该在循环体中定义呢？</p>
<ul>
<li>在循环体外定义：1个构造函数+1个析构函数+n个赋值</li>
<li>在循环体内定义：n个构造+n个析构</li>
</ul>
<p>如果一个赋值的成本低于一个构造+一个析构，那么往往选择第一种做法，尤其当n很大的时候。否则第二种做法好。此外做法1造成变量的作用域比做法2要大，有时对程序的可理解性和易维护性造成冲突。因此除非：</p>
<ul>
<li>赋值比构造+析构成本低；</li>
<li>正在处理代码中效率高度敏感的部分。</li>
</ul>
<p>否则应该使用做法2。</p>
<p>记住：</p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
<h1 id="条款27"><a href="#条款27" class="headerlink" title="条款27"></a>条款27</h1><blockquote>
<p>尽量少做转型动作。</p>
</blockquote>
<p>C++的设计目标之一是，保证“类型错误”绝对不可能发生。理论上如果你的程序很“干净地”通过编译，就表示它并不企图在任何对象身上执行任何不安全、无意义、愚蠢荒谬的操作。这是一个极具价值的保证，可别草率的放弃它。</p>
<p>不幸的是，转型破坏了类型系统。那可能导致任何种类的麻烦，有的容易辨识，有些非常隐晦。C、java、c#语言中可能转型是必要的、无法避免的，相比于C++也比较不那么危险。但是C++中，应该尽量少的做转型，C++中使用转型比较危险，应该尽量将转型动作使用不转型的手法给化解掉。</p>
<p>有三种转型的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：C语言风格的转型语法：</span></span><br><span class="line">(T)expression     <span class="comment">//将expression转换为T类型</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">//形式二:函数风格的转型：</span></span><br><span class="line"><span class="built_in">T</span>(expression)     将expression转换为T类型</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式三：C++风格的转型语法</span></span><br><span class="line"><span class="built_in">const_cast</span>&lt;T&gt;(expression);<span class="comment">//const-&gt;non const</span></span><br><span class="line"><span class="comment">//const_cast 用来将对象的const属性去掉,功能单一,使用方便.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;T&gt;(expression);</span><br><span class="line"><span class="comment">//dynamic_cast 用于继承体系下的&quot;向下安全转换&quot;,通常用于将基类对象指针转换为其子类对象指针,</span></span><br><span class="line"><span class="comment">//它也是唯一一种无法用旧式转换进行替换的转型,也是唯一可能耗费重大运行成本的转型动作.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;T&gt;(expression);</span><br><span class="line"><span class="comment">//低级转型,结果依赖与编译器,这因为着它不可移植,我们平常很少遇到它,通常用于函数指针的转型操作.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T&gt;(expression);</span><br><span class="line"><span class="comment">//static_cast 用来进行强制隐式转换,我们平时遇到的大部分的转型功能都通过它来实现.</span></span><br><span class="line"><span class="comment">//例如将int转换为double,将void*转换为typed指针,将non-const对象转换为const对象,反之则只有const_cast能够完成.</span></span><br></pre></td></tr></table></figure>

<p>注意：形式一、二并无差别，统称旧式转型，形式三称为新式转型。</p>
<hr>
<p>新式转型的优点：</p>
<ul>
<li>在代码新式转型容易被识别出来(无论是人工识别还是使用工具如grep)，因而简化“找出类型系统在哪个点被破坏”的过程(简化找错的过程)。</li>
<li>各种转型动作的目标越窄化，编译器越能判断出出错的运用。例如：如果你打算将常量性去掉，除非使用新式转型的const_cast否则无法通过编译。</li>
</ul>
<p>旧式转型的唯一适用场景( 对于作者本人来说的唯一)：</p>
<p>唯一使用旧式转型的时机是，当调用一个explicit构造函数将一个对象传递给一个函数时。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="type">int</span> size)</span></span>;<span class="comment">//禁用隐式转换，下面就不可以只传15这个参数，需要显式转换。</span></span><br><span class="line">    							<span class="comment">//如果没有explicit，是可以只传15的，会自动执行隐式转换，把15放入构造函数里去构造。</span></span><br><span class="line">      ...</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(Widget&amp; w)</span></span>;</span><br><span class="line">  <span class="built_in">doSomething</span>(<span class="built_in">Widget</span>(<span class="number">15</span>)); <span class="comment">//&quot;旧式转型&quot;中的函数转型</span></span><br><span class="line">  <span class="built_in">doSomething</span>(<span class="built_in">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));<span class="comment">//&quot;新式转型&quot;</span></span><br></pre></td></tr></table></figure>

<p>从某个角度来说，蓄意的“对象生成”动作不怎么像“转型”，因此没使用新式转型。但是，其他情况下（或者所有情况下），即使觉得旧式转型合理，也最好使用新式转型。</p>
<hr>
<ul>
<li><p>容易产生的误解：请不要认为转型什么都没做，其实就是告诉编译器把某种类型视为另一种类型。实际上，任何一种转型动作往往真的令编译器额外地编译出运行期间执行的代码。例如将int转型为double就会发生这种情况，因为在大部分的计算器体系结构中，int的底层表述不同于double的底层表述。</p>
</li>
<li><p>转型动作导致编译器在执行期间编译出不同的码的另外一个例子：单一的对象可能拥有一个以上的地址(例如:”以base*指向它”时的地址和”以Derived*指向它”时的地址不同，因为这时会有一个偏移量在运行期间施加在Derived*身上，用以取得正确的base*的指针值。偏移量是因为：类成员本身的位置是确定的，但是对于派生类、基类来说，指向的起始位置不一样）。实际上一旦使用多重继承,这事几乎一直发生。即使在单一继承中也可能发生。</p>
<ul>
<li>有了偏移量这个经验后，我们也不能做出“对象在C++中如何布局”的假设。因为对象的布局方式和它们的地址计算发式随着编译器的不同而不同，这就以为着写出”根据对象如何布局”而写出的转型代码在某一平台上行得通，在其它平台上则不一定。很多程序员历经千辛万苦才学到这堂课。</li>
</ul>
</li>
<li><p>转型动作容易写出似是而非的代码：很多框架都需要在派生类的virtual函数中第一个动作就调用基类的版本的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialWindow</span>:<span class="keyword">public</span> Window&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Window&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();<span class="comment">//调用基类的实现代码</span></span><br><span class="line">        ... <span class="comment">//这里进行SpecialWindow的专属行为.</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码看着似乎合情合理，但是实际却是错误的。错在转型语句。为什么错呢？</p>
<p>首先它确实执行了多态，调用的函数版本是正确的，但是由于做了转型，它并没有真正作用在派生类对象身上，而是作用在了派生类对象的基类部分的副本身上，改动的是由于转型产生的那份基类副本（因为先产生副本，然后调用副本的函数）。如果后面的代码是对派生类更改的话，导致的最终结果就是：当前对象的基类部分没有被改动，但是派生类部分却被真实地改动了。</p>
<p>解决的方法是拿掉转型，直接调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SpecialWindow::onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Window::<span class="built_in">onResize</span>(); <span class="comment">//此时才是真正的调用基类部分的onResize实现.</span></span><br><span class="line">    ...     <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
</ul>
<p>关于dynamic_cast，首先要有一个认识，就是dynamic_cast的实现版本执行速度相当的慢。尤其是在深度继承和多重继承中，速度更慢。</p>
<ul>
<li>何时需要dynamic_cast：通常当你想在一个你认定为derived class对象上执行derived class操作函数时，但是你的手上只有一个指向base 的指针或引用时，你会想到使用dynamic_cast进行转型</li>
</ul>
<p>有两个一般性做法可以避免使用dynamic_cast（并非总是可以，但许多情况下可行）：</p>
<ul>
<li>方法一：如果有多个对象，使用容器（如vector），并在其中存储直接指向derived class对象的指针(通常是智能指针)，这样就避免了上述需求。</li>
<li>方法二：在base class内提供virtual函数做你想对各个派生类想做的事情。这样可以使得你通过base class 接口处理“所有可能之各种派生类”。因为virtual函数使得编译器不识别指针类型来选择函数，而是看运行期实际的对象类型来选择函数。</li>
</ul>
<p>一连串dynamic_cast的代码又大又慢，而且基础不稳，因为每次继承体系一有改变，所有这种代码必须再次进行检查看看是否需要修改。例如假如新的派生类，就要加新的分支。这样的代码应该使用“基于virtual函数调用”的东西取而代之。</p>
<p>最后，完全不用转型是不切实际的。但是我们应该尽量避免转型。就像面对众多蹊跷可疑的构造函数一样，我们应该尽可能隔离转型动作，通常是把它隐藏在某个函数内，函数的接口会保护调用者不受函数内部任何肮脏龌龊的动作的影响。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内。</li>
<li>宁可使用c++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>
</blockquote>
<h1 id="条款28"><a href="#条款28" class="headerlink" title="条款28"></a>条款28</h1><blockquote>
<p>避免返回handles指向对象内部成分。</p>
</blockquote>
<p>reference、指针、迭代器系统都是所谓的handles(号码牌，用来获得某个对象)。函数返回一个handle而被用户得知，随之而来的便是“减低对象封装性”的风险。它也可能产生虽调用const成员函数却造成对象状态被更改的风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Point</span>(intx,inty);</span><br><span class="line">       <span class="built_in">voidsetX</span>(intnewVal);</span><br><span class="line">       <span class="built_in">voidsetY</span>(intnewVal);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RectData</span>&#123;</span><br><span class="line">       Pointulhc;</span><br><span class="line">       Pointlrhc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span><span class="type">const</span></span>&#123;returnpData-&gt;ulhc;&#125;</span><br><span class="line">       <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span><span class="type">const</span></span>&#123;returnpData-&gt;lrhc;&#125;</span><br><span class="line">       ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       std::tr1::shared_ptr&lt;RectData&gt;pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码便是自相矛盾的一个例子。point 类是一个代表点的类，RectData代表一个矩形的结构，Rectangle类则代表一个矩形，该类能够返回表示矩阵的左上和右下的两个点。</p>
<p>由于这两个函数为const的，因此所要表达的意思就是，返回矩阵的两个点，但是不能修改他们。但是又由于返回的是点的reference形式，因此通过reference，实际是可以改变返回的点的数据的（可以作为左值修改）。因此，造成了自相矛盾。问题的原因就是，函数返回了handle。</p>
<p>这进而说明：</p>
<ul>
<li>成员变量的封装性最多等于“返回其reference”的函数的访问级别。即使数据本身被声明为private的，但是如果返回他们的reference的函数是public的，那么数据的访问权限就编程public了。</li>
<li>如果const成员函数传出一个reference（返回外部对象的引用），后者所指数据又不在自身对象内，那么这个函数的调用者可以修改此数据。(这是 bitwise constness 带来的后果。)<ul>
<li>如果返回的是对象自身的数据，const的限制会强制使得数据成员类型为const（这样使得数据不能改变），这样就不能返回该数据的引用，因为类型不匹配了。</li>
</ul>
</li>
</ul>
<hr>
<p>上述代码的改进版本：在返回handles 的成员函数前加const。这便解决了自相矛盾问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="type">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span><span class="type">const</span></span>&#123;returnpData-&gt;ulhc;&#125;</span><br><span class="line">       <span class="function"><span class="type">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span><span class="type">const</span></span>&#123;returnpData-&gt;lrhc;&#125;</span><br><span class="line">       ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       std::tr1::shared_ptr&lt;RectData&gt;pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码在其他场景下可能存在的问题：虚吊问题。所谓虚吊问题，就是指针指向了一个不复存在的对象。最常见的问题来源就是函数返回值，例如，某个函数返回GUI对象的外框，是一个矩形形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GUIObject</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">const</span> Rectangle <span class="title">boundingBox</span><span class="params">(<span class="type">const</span> GUIObject &amp;obj)</span></span>;<span class="comment">//返回值为const，避免没有意义的右值赋值</span></span><br><span class="line"><span class="comment">//现在，客户可能这么使用。</span></span><br><span class="line">GUIObject *pgo;</span><br><span class="line"><span class="type">const</span> Point *pUpperLeft= &amp;(<span class="built_in">boundingBox</span>(*pgo).<span class="built_in">upperLeft</span>() );</span><br></pre></td></tr></table></figure>

<p>boundingBox 函数传入一个GUI对象，它返回一个GUI的外框，即是一个矩形，然后获取这个矩形的右下方的点，并使用一个指针指向它。而函数的返回值是一个临时的对象（by value），即这个矩形是一个临时的对象，当这个语句执行结束后，矩形对象被销毁，因此其内部的点也被销毁，而此时pUpperLeft指向了一个被销毁的点。就形成了所谓的虚吊。</p>
<p>这就是为什么函数如果返回一个handle代表对象内部成分总是危险的原因。不论这个handle是个指针或迭代器或引用，也不论这个handle是否为const（指返回值），也不论返回handle的成员函数是否为const。这里的唯一关键是，有个handle被传出去了，一旦如此你就是暴露在“handle比其所指对象更长寿”的风险下。</p>
<p>这并不意味着绝对不可以让成员函数返回handle，有时候必须返回handle，例如vectoer的operator[]，operator&#x3D;返回容器内部的数据，然而着只是少数的例外。一般来讲，返回整个对象的引用来提高效率（不破坏封装，且虚吊是容易控制的，你清除你的类什么时候销毁），而非对象内部成分的引用。</p>
<p>记住：</p>
<blockquote>
<p>避免返回handles（包括reference、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。</p>
</blockquote>
<h1 id="条款29"><a href="#条款29" class="headerlink" title="条款29"></a>条款29</h1><blockquote>
<p>为“异常安全”而努力是值得的。</p>
</blockquote>
<p>当异常被抛出时,”异常安全”函数有两个条件：</p>
<ul>
<li>不泄露任何资源：从堆中申请的资源应该确保被释放</li>
<li>不允许数据败坏：函数不能对数据修改到一半而抛出异常以致数据被破坏。</li>
</ul>
<p>解决”不泄露任何资源”很容易，只要使用资源管理类(如shared_ptr，见条款13）即可，”不允许数据败坏”(如delete掉数据，但程序异常没有在new回来，或是数据记录先修改了，但是由于异常，实际上并不需要修改）是主要考虑的问题。在解决问题前，需要知道三个层次的保证。</p>
<p>异常安全函数提供以下三种层次的保证:</p>
<ul>
<li>基本保证：如果异常被抛出，程序内任何事物仍然保持在有效状态下，没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态（例如所有class约束条件都继续得到满足）。然而程序的现实状态很难预料，可处于任何合法状态：客户必须确认对象的状态。</li>
<li>强烈保证：如果异常被抛出，程序状态不改变。”如果函数成功，就是完全成功；如果函数失败，程序会回复到’调用函数之前’的状态”。</li>
<li>不抛掷(nothrow)保证：程序绝不抛出异常且总是能够完成承诺的内容。</li>
</ul>
<p>以上三种层次的保证逐渐增强。</p>
<p>一般来说,实现不抛掷保证不太现实：</p>
<ul>
<li>如果程序要保证nothrow，那么就要保证它所调用的所有函数也nothrow；</li>
<li>任何使用动态内存的代码（如STL容器）都有可能抛出无法找到足够内存而产生的ban_alloc异常。因此，提供异常安全保证通常从基本保证和强烈保证中选择。</li>
</ul>
<p>要实现异常安全的两个条件,一般有以下策略：</p>
<ul>
<li>资源管理对象的使用以确保不泄露堆中资源；</li>
<li>对函数语句顺序的细致规划以阻止数据的败坏。一般来讲：不要为了表示某件事将要发生而改变对象状态，除非真的发生了（例如对计数累加在对象生成之后，而非生成之前）。</li>
<li>使用”copy and swap”策略：为打算修改的对象做出一份副本，然后在副本上进行修改，若函数抛出异常，只有副本的数据发生败坏；若修改成功执行，调用swap函数（保证不抛异常）进行置换。这是解决数据败坏的有效途径。</li>
</ul>
<p>copy-and-swap有以下限制：</p>
<ul>
<li>使用”copy and swap”策略构造临时对象，因此要付出额外的资源和效率负担。</li>
<li>要使用swap函数，必须保证swap函数不抛出任何异常(见条款25)。</li>
<li>使用”copy and swap”策略不保证整个函数有强烈的异常安全性，如果函数内调用其它函数，会产生”连带影响”。比如调用两个函数，都保证强烈的异常安全，第一个成功，第二个异常。整个函数还是由于第一个函数调用成功而改变了，虽然是异常安全的，但不是强烈的。</li>
</ul>
<p>异常安全符合短板原理：一个软件系统内只要有一个函数不符合异常安全性，整个软件系统就不具备异常安全性，没有所谓的局部安全性。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备实现意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</blockquote>
<h1 id="条款30"><a href="#条款30" class="headerlink" title="条款30"></a>条款30</h1><blockquote>
<p>透彻了解inlining的里里外外。</p>
</blockquote>
<p>inline函数是特殊的函数，它有宏的优点，却克服了宏的缺点（条款2）。inline函数可以免除函数调用所招致的额外开销，但你实际获得的好处可能比你想象的还多，编译器会对inline函数本体执行语境相关最优化。</p>
<p>inline 函数背后的机制是：将对此函数的每一个调用都用函数本体替换之。这样无疑会增加产出码的大小。在内存比较小的机器上，不宜过多使用inline函数。即使使用虚拟内存，也会导致额外的换页行为（paging），降低指令高速缓存装置的击中率（instruction cache hit rate），以及伴随而来的效率损失。如果inline函数本体很小，编译器对函数本体产出的码可能比函数调用所产出的码更小；如果这样，那么将函数inlining确实会减小目标码和提高高速指令高速缓存装置的击中率。</p>
<p>在函数前面加上inline关键字不是强制这个函数变为inline函数，这只是向编译器提一个申请。这个申请有时是隐喻的，例如将函数定义在class内。如果把friend函数定义在class内，那么它们也将隐喻声明为inline。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SetNumber，GetNumber 函数为隐式 inline，Try 函数为显式 inline。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inline</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inline</span>(<span class="type">int</span> mNumber): <span class="built_in">Number</span>(mNumber) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetNumber</span><span class="params">(<span class="type">int</span> mNumber)</span> </span>&#123;</span><br><span class="line">        Number = mNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNumber</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Try</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> Inline <span class="title">Inline</span><span class="params">(<span class="number">999</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; Inline.<span class="built_in">GetNumber</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>明确声明为inline函数的的做法是在其定义式前加上关键字inline。例如标准的max template（来自）是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> T&amp; <span class="title">std::max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>inline函数和templates通常都被定义于头文件。这不是巧合。</p>
<ul>
<li>inline函数通常一定被置于头文件内，大多数建置环境（build environment）在编译过程中进行inlining，将一个“函数调用”替换为“被调用函数的本体”，在替换时需要知道这个函数长什么样子（因此必须要提前定义，所以放头文件里）。有的环境可以在运行期间完成inlining，但一般是例外。Inlining在大多数C++中是编译期行为。</li>
<li>Templates通常也放置在头文件，因为它一旦被使用，编译器为了将它具体化，也需要知道它长什么样子（因此必须要提前定义，所以放头文件里）。有些编译环境可以在链接期间才执行template具体化，但是编译期间完成的更常见。</li>
</ul>
<p>实际上templates和inlining无关，对于template，如果inline则所有的template的具体实现的函数都会被inline。如果没有理由要求都inline，则应该避免将这个template inline，否则会招来代码膨胀的成本。</p>
<hr>
<p>大部分编译器拒绝太过复杂的inlining函数（例如有循环或递归）。virtual函数也不能是inline函数，因为virtual函数是直到运行时才确定调用哪个函数，而inline是执行前将调用动作替换为函数本体。</p>
<p>所以表面上是inline函数，实际上未必是，很大程度上取决于编译器。大多数编译器提供了一个诊断级别：如果无法将你要求的函数inline化，会给你一个警告信息。</p>
<hr>
<p>编译器将inline函数调用替换为inline函数本体的同时，还是可能会为该函数生成一个函数本体。如果程序要取某个inline函数的地址，编译器通常必须为此函数生成赢outlined函数本体。如果inline函数本体不存在，自然就不会有这个函数的地址。但是，通过函数指针调用inline函数，这时inline函数一般不会被inlined。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;……&#125;<span class="comment">//假设编译器会inline函数f</span></span><br><span class="line"><span class="built_in">void</span> ( *pf)()=f;<span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="built_in">f</span>();<span class="comment">//这个调用会被inlined，因为是正常调用</span></span><br><span class="line"><span class="built_in">pf</span>();<span class="comment">//这个调用可能不会被inlined，因为它是通过函数指针达成</span></span><br></pre></td></tr></table></figure>

<p>就算你未使用函数指针，程序有时也会使用。例如，编译器会生成构造函数和析构函数的outline副本，这样就可以获得这些函数的指针，在array内部元素的构造和析构过程中使用。</p>
<p>实际上，把构造函数和析构函数做为inline函数未必合适，表面上看并不可以看出原因。考虑下面Derived class构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bm1, bm2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;&#125;<span class="comment">//Derived构造函数</span></span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string dm1, dm2, dm3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>class Derived的构造函数不含任何代码，应该是inlining函数的绝佳候选。但实际上未必。C++对于“对象被创建和销毁时都发了什么事”做了各种保证。例如，当你创建一个对象，base class和derived class的每一个成员变量都会被自动构造；当你销毁一个对象，会有反向的析构过程。</p>
<p>这是正常运行时的情况，但是如果对象在构造期间有异常被抛出，那么该对象已经构造好的那一部分应该自动销毁。当然，这是编译器负责的事情，但是编译器是怎么实现的呢？那就是编译器在你的程序中插入了某些代码，通常就在构造函数和析构函数内。我们可以想象一下，那个空的构造函数到底应该是怎么样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译后实际上可能的（或大致上的）构造函数</span></span><br><span class="line">Derived::<span class="built_in">Derived</span>()<span class="comment">//概念实现</span></span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123; dm1.std::string::<span class="built_in">string</span>();&#125;<span class="comment">//构造dm1</span></span><br><span class="line">    <span class="built_in">catch</span>(……)&#123;</span><br><span class="line">        Base::~<span class="built_in">Base</span>();<span class="comment">//销毁base class部分</span></span><br><span class="line">        <span class="keyword">throw</span>;<span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123; dm2.std::string::<span class="built_in">string</span>(); &#125;<span class="comment">//构造dm2</span></span><br><span class="line">    <span class="built_in">catch</span>(……)&#123;</span><br><span class="line">        dm1.str::string::~<span class="built_in">string</span>();<span class="comment">//销毁dm1</span></span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123; dm3.std::string::<span class="built_in">string</span>();&#125;</span><br><span class="line">    <span class="built_in">catch</span>(……)&#123;</span><br><span class="line">        dm2.std::string::~<span class="built_in">string</span>();</span><br><span class="line">        dm1.std::string::~<span class="built_in">string</span>();</span><br><span class="line">        Base::~<span class="built_in">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码并不是编译器生成的，编译器生成的应该会更加精致复杂，处理异常也没这么简单。但这也足够反应空白的Derived构造函数提供的行为。不论编译器怎么优化，Derived构造函数都会调用base class的构造函数和其成员变量的构造函数，而那些调用（它们自身也可能被inlined）会影响编译器是否对此空白函数inlining。这个道理同样适用于Base构造函数，也同样适用于析构函数。</p>
<p>上面的原因叙述的是：也许一个空的构造函数、析构函数并不含什么代码、未做什么事情，但实际上编译后会有许多代码。然而还有另一个原因，如果其他函数经常调用这个类，那么那个函数每构建一个对象，就inline一份构造函数。例如：如果string构造函数恰巧被inlined了，那么Derived的构造函数也将获得五份“string构造函数代码”副本，这可能是巨大的代码膨胀。</p>
<p>因此，必须慎重考虑构造函数、析构函数是否该被inline。</p>
<hr>
<p>程序员还要考虑将函数声明为inline带了的其他影响：inline函数无法随着程序库的升级而升级。例如，fun是个inline函数，客户将fun编进其程序中，一旦程序库设计者升级程序库，所有用到函数fun的客户端程序多必须重新编译。但是如果fun是non-inline的，客户端只需重新连接即可；如果是动态链接库，客户端甚至感觉不到程序库升级。还有一个影响就是调试。大部分调试器无法调试inline函数，因为你不能再一个不存在的函数内设立断点。</p>
<p>这就使得我们在使用inline时更加慎重，一开始先不要将任何函数声明为inline，后面再手工优化代码。有一个80-20经验法则：平均而言，一个程序往往将80%的执行时间花费在20%的代码上。因此，作为一个开发者，你的目标是找出这可以有效增进程序整体效率的20%代码，用inline或其他方法将它瘦身。但除非选对目标，否则一切都是虚功。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为function templates出现在头文件，就将它们声明为inline。</li>
</ul>
</blockquote>
<h1 id="条款31"><a href="#条款31" class="headerlink" title="条款31"></a>条款31</h1><blockquote>
<p>将文件间的编译依存关系降至最低。</p>
</blockquote>
<p>假如你修改了C++ class实现文件，修改的仅仅是实现，而没有修改接口，而且只修改private部分。此时，重新构建这个程序时，会发现整个文件、以及用到该class 的文件都被会被重新编译和连接，这不是我们想要看到的。</p>
<p>问题出在C++没有把关于接口与实现相分离这件事做好。C++ 的class 的定义式中不仅定义了接口，还定义了实现细目(成员变量)。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr); </span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string theName;        <span class="comment">//实现细目 </span></span><br><span class="line">    Date theBirthDate;          <span class="comment">//实现细目 </span></span><br><span class="line">    Address theAddress;         <span class="comment">//实现细目 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当编译器没有取得实现代码所需要的class string，Date和Address的定义式时，它无法通过编译。</p>
<p>它所需要的这样的定义式往往由#include &lt;&gt;提供（里面有class string，Date和Address的实现代码）。例如本例中需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;date.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;address.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>如果这些头文件中(或头文件所依赖的头文件)的一个的实现被改变了，那么每一个含入或用到Person class的文件都得重新编译。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p>
<hr>
<p>C++ 为什么坚持将实现细目置于class定义式中而不如下述这样做，以实现接口与实现分离呢：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123; <span class="keyword">class</span> <span class="title class_">string</span>;&#125; <span class="comment">// 前置声明（不正确） </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;<span class="comment">// 前置声明 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>;<span class="comment">// 前置声明 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr); </span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述设想不成立，原因有两条：</p>
<ul>
<li><p>第一：string并不是一个class，他是一个typedef(定义为basic_string)。因此上述针对string做的声明并不正确；正确的声明比较复杂，因为涉及额外的template。退一步讲，你本来就不应该尝试手工声明标准库程序的一部分，你应该仅仅使用适当的#include完成目的。其实标准头文件这也不是编译的瓶颈，也有解决的方法。例如：你可以值改变你的接口设计，避免使用标准头文件的非法的#include。</p>
</li>
<li><p>第二：问题的关键是：编译器必须在编译期间知道对象的大小。例如：下述程序中，当编译器看到x时，由于知道它是int类型的，也就知道需要为它分配多大的空间。但是当编译器看到自定义的类Person对象p时，编译器必须看到Person的类定义才能知道为p对象分配多大的内存。如果class中没有实现细目，也就是连一个成员变量都没有，那么编译器就无法确定为其分配多大内存（接口即函数是不占内存的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(params)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>使用指针，可以解决这个问题，因为一个指针的大小是确定的，如果在Person类使用指针指向成员对象，内存就可以确定下来了。</p>
<p>方法一Handle classes：基本的思想就是：将对象的实现细目隐藏到一个指针(通常是一个智能指针)背后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">//为了使用string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonImpl</span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr); </span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span><span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span><span class="type">const</span></span>; </span><br><span class="line">    ... </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; <span class="comment">// 指向实现物的指针 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述程序中，将原本的Person 类写成两个部分，接口那部分是主要的部分，其中含了一个智能指针，指向实现细目。而实现细目另外定义了一个类：PersonImpl。这种设计手法被称为：pimpl idiom。</p>
<p>注意：pimpl 指的是 pointer to implementation。这种class内的指针往往被称为：pImpl指针。上述class的写法 往往被称为handle class。</p>
<p>这样做使得接口与实现分离。即：Person的客户与 [Date、Address、以及Person的实现细目]就分离了。这带来的好处是：</p>
<ul>
<li>这些class的修改，都不需要Person客户进行重新编译（它们不会导致Person改变，指针大小是确定的）。</li>
<li>而且由于客户无法看到实现细目，也就不能写出由这些实现细目所决定的代码。</li>
</ul>
<p>这个分离的关键在于以“声明的依存性”替换“定义的依存性”，这正是编译器依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依。</p>
<p>其他情况也来自于这个设计策略：</p>
<ul>
<li>如果用 object reference 或 object pointer 可以完成任务，就不要用 objects。可以只靠声明式定义出指向该类型的 pointer 和 reference；但如果定义某类型的 objects，就需要用到该类型的定义式（要分配内存）。</li>
<li>如果能够，尽量以 class 声明式替换 class 定义式。当你声明一个函数而它用到某个 class 时，你并不需要该 class 的定义式，纵使函数以 by value 方式传递该类型的参数（或返回值）亦然。<ul>
<li>真正的定义式在函数调用前曝光即可。因为用户不太可能会用到所有的函数，客户只需要引入需要的函数的class定义式的头文件即可。</li>
<li>此外这里没有谈到函数的定义，因为一般头文件进行函数的声明，而定义在cpp文件。声明是在编译时处理的而定义在链接时处理，这里讨论的问题不涉及链接。<ul>
<li>补充：正常情况下，应该是：函数声明在.h中，函数定义在.cpp中。 原因： （1）如果你对这个函数体进行了修改，那么只会重新编译相应的.cpp文件，在进行大工程编译时，会大大缩短编译时间。 （2）即便是对整个工程进行重新编译，在进行代码扩充阶段时，定义在.h中的情况，要比定义在.cpp的情况浪费更多的内存和编译时间。 2. 纯粹从理论角度来说，函数可以定义在.h中，但一定要加上#ifdef – #define – #endif对代码块进行包裹，避免出现重复定义的链接错误。</li>
</ul>
</li>
</ul>
</li>
<li>为声明式和定义式提供不同的头文件。两个头文件应该保持一致性，其中一个头文件发生改变，另一个就得也改变。一个内含了class 接口的定义，另一个仅仅内含声明。比如客户要使用Date，那么程序库作者应该提供声明的头文件和定义的头文件，客户引入声明的头文件来声明函数而不需要自己前置声明Date类。头文件名称如<code>&lt;datefwd.h&gt;</code>，这个命名方式取法C++标准程序库头文件。<ul>
<li>因而，这个条款也使用于template，因为template虽然一般定义式也写在头文件，但有的定义式也在非头文件内，这样就可以把只含声明式的头文件提供给template。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>方法二：Interface classes手法，基本思想是：令Person class 成为一种特殊的abstract base class (抽象基类)，称为interface class。</p>
<p>这样的类通常：没有成员变量，也没有构造函数，只有一个virtual 的析构函数以及一组pure virtual 用来描述接口。对于 Interface class 的客户，必须以接口的指针或者引用来编写应用程序。因为不可能针对内含 pure-virtual 的函数的 abstract class 具现出实例。就像 Handle class的客户那样，除非 Interface class 的接口被修改，否则客户不需要重新编译。</p>
<p>由于这样的类往往没有构造函数，因此通过工厂函数或者virtual构造函数创建，他们返回指针，指向动态分配对象所得的对象，这样的对象支持interface class的接口，这样的函数在interface class往往被声明为 static,例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ... </span><br><span class="line">    <span class="type">static</span> std::<span class="function">tr1::shared_ptr&lt;Person&gt; </span></span><br><span class="line"><span class="function">    <span class="title">create</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户使用他们像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::string name; </span><br><span class="line">Date dateBirth; </span><br><span class="line">Address address; </span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateBirth, address))</span></span>; </span><br><span class="line">... </span><br><span class="line">std::cout &lt;&lt; pp-&gt;<span class="built_in">name</span>() </span><br><span class="line">            &lt;&lt; <span class="string">&quot;was born on &quot;</span> </span><br><span class="line">            &lt;&lt; PP-&gt;<span class="built_in">birthDate</span>() </span><br><span class="line">            &lt;&lt; <span class="string">&quot; and now lives at &quot;</span> </span><br><span class="line">            &lt;&lt; pp-&gt;<span class="built_in">address</span>(); </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然支持 interface class 接口的那个具象类（concrete classes）必须被定义出来，而真正的构造函数必须被调用。假设有个 derived class RealPerson，提供继承而来的 virtual 函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealPerson</span> : <span class="keyword">public</span> Person&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">RealPerson</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr) </span><br><span class="line">    : <span class="built_in">theName</span>(name), <span class="built_in">theBirthDate</span>(birthday), <span class="built_in">theAddress</span>(addr) </span><br><span class="line">    &#123;&#125; </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealPerson</span>()&#123;&#125; </span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">birthDate</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function">std::string <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::string theName; </span><br><span class="line">    Date theBirthDate; </span><br><span class="line">    Address theAddress; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了 RealPerson 之后，写出 Person::create 就真的一点也不稀奇了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Date&amp; birthday, <span class="type">const</span> Address&amp; addr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> <span class="built_in">RealPerson</span>(name, birthday, addr)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更现实的 Person::create 实现代码会创建不同类型的 derived class 对象，取决于诸如额外参数值、独自文件或数据库的数据、环境变量等等。</p>
<p>RealPerson 示范实现了 Interface class 的两个最常见机制之一：从 interface class 继承接口规格，然后实现出接口所覆盖的函数。</p>
<hr>
<p>handle classes 和 interface classes 解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性。但也会带来开销：</p>
<ul>
<li><p>handle classe：</p>
<p>成员函数必须通过 implementation pointer 取得对象数据。那会为每一次访问增加一层间接性。每个对象消耗的内存必须增加一个 implementation pointer 的大小。 implementation pointer 必须初始化指向一个动态分配的 implementation object，所以还得蒙受因动态内存分配儿带来的额外开销。</p>
</li>
<li><p>Interface classe：</p>
<p>由于每个函数都是 virtual，必须为每次函数调用付出一个间接跳跃。此外 Interface class 派生的对象必须内含一个 vptr（virtual table pointer）。</p>
</li>
</ul>
<p>在程序开发过程中使用 handle class 和 interface class 以求实现码有所改变时对其客户带来最小冲击。</p>
<p>而当他们导致速度和&#x2F;或大小差异过于重大以至于 class 之间的耦合相形之下不成为关键时，就以具象类（concrete class）替换 handle class 和 interface class。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，而不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及templates都适用。</li>
</ul>
</blockquote>
<h1 id="条款32"><a href="#条款32" class="headerlink" title="条款32"></a>条款32</h1><blockquote>
<p>确定你的public继承塑膜出is-a关系。</p>
</blockquote>
<p>以C++进行面向对象编程，最重要的一个规则是：public inheritance意味着”is-a”的关系。</p>
<p>如果令 class D（”Derived”）以 public 形式继承 class B（”Base”），便是告诉C++编译器说，每一个类型为D的对象同时也是一个类型为B的对象。意思是B比D表现出更一般化的概念，而D比B表现出更特殊化的概念。</p>
<p>以一个具体例子来说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;……&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> Person &#123;……&#125;;</span><br></pre></td></tr></table></figure>

<p>由生活经验可以知道，每个学生都是人，但是并非每个人都是学生。这就是这个继承体系的主张。可以预期，对人成立的每件事，对学生也都成立。但是对学生成立的事对人未必成立。在C++中，任何函数如果期望接受类型为Person对象的实参（或pointer to person，或reference to person），也都可以接受一个类型为Student对象的实参（或pointer to student，或reference to student）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br><span class="line">   Person p;</span><br><span class="line">   Student s;</span><br><span class="line">   <span class="built_in">eat</span>(p);<span class="comment">//正确</span></span><br><span class="line">   <span class="built_in">eat</span>(s);<span class="comment">//正确，s是人</span></span><br><span class="line">   <span class="built_in">study</span>(s);<span class="comment">//正确</span></span><br><span class="line">   <span class="built_in">study</span>(p);<span class="comment">//错误 ，p不是学生</span></span><br></pre></td></tr></table></figure>

<p>当然，上面正确的前提是以public继承，如果以private继承，意义将完全不同（条款39），protected继承也是一样。</p>
<hr>
<p>有时public和is-a之间的关系会误导我们。例如，企鹅（penguin）是一种鸟，这是事实；鸟可以飞，这也是事实。如果以C++描述这层关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是我们知道，企鹅不会飞，这个是事实。这个问题的原因是语言（英语）不严谨。当我们说鸟会飞时，我们表达的意思是一般的鸟都会飞，并不是表达所有的鸟都会飞。我们还应该承认一个事实：有些鸟不会飞。这样可以塑造一下继承关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlyingBird</span>: <span class="keyword">public</span> Bird&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vitual <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird&#123;<span class="comment">//没有fly函数</span></span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样的设计能更好的反映我们真正要表达的意思。但是这时，我们仍未完全处理好这些鸟事。例如，如果你的系统不会区分鸟会不会飞，你关心的是鸟啄和鸟翅，这样的话，原先的“双class继承体系”更适合你的系统。并不存在完美设计，具体问题要具体讨论。</p>
<p>还有一个方法来处理“所有鸟都会飞，企鹅是鸟，但企鹅不会飞”这个问题，我们可以在企鹅类重新定义fly函数，让它在产生一个运行期错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;<span class="comment">//输出错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Penguin</span>: <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123; <span class="built_in">error</span>(<span class="string">&quot;Attemp to make a penguin fly&quot;</span>);&#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里前面的解决方法不同，这里不说企鹅不会飞，当你说企鹅会飞时，会告诉你这是一个错误。但是这种解决方法之间有什么差异？从错误被侦测出来的时间来看:</p>
<ul>
<li>第一种解决方法“企鹅不会飞”这个限制条件在编译期强加事实；</li>
<li>第二个解决方法，“企鹅会飞是错误”是在运行期检测出来的。</li>
<li>第一种解决方法更好，条款18说过，好的接口可以防止无效的代码通过编译，相比之下，我们应该选择在编译期来找出这个问题。</li>
</ul>
<hr>
<p>在考虑一个例子，基础几何我们都学过，那么正方形和矩形的关系有多么复杂呢？先看下面这个例子：class Square应该以public形式基础class Rectangle吗？我们都知道正方形是特殊的矩形，如果以public继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> newHeight)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> newWidth)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">height</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">width</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">makeBigger</span><span class="params">(Rectangle&amp; r)</span><span class="comment">//增加r的面积</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> oldHeight=r.height;</span><br><span class="line">       r.<span class="built_in">setWidth</span>(r.<span class="built_in">width</span>()+<span class="number">10</span>);<span class="comment">//r宽度增加</span></span><br><span class="line">       <span class="built_in">assert</span>(r.<span class="built_in">height</span>()==oldHeight);<span class="comment">//判断r的高度是否改变</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的assert结果肯定为真，因为makeBigger只是改变了r的宽度，高度并未改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>:<span class="keyword">public</span> Rectangle&#123;……&#125;;</span><br><span class="line">Square s;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">asseret</span>(s.<span class="built_in">width</span>()==s.<span class="built_in">height</span>());<span class="comment">//对所有正方形都为真</span></span><br><span class="line"><span class="built_in">makeBigger</span>(s);<span class="comment">//因为是public继承是is-a关系，所以可以使用这个函数</span></span><br><span class="line"><span class="built_in">asseret</span>(s.<span class="built_in">width</span>()==s.<span class="built_in">height</span>());<span class="comment">//对正方形也应该为真</span></span><br></pre></td></tr></table></figure>

<p>那么现在肯定是有问题了。因为第一个assert时，长和宽多相等；之后增加了宽度，长度不变；到了第二个assert时，长和宽还相等。</p>
<p>前面说过，以public继承，能够施行于base class对象身上的每件事，都可以施行于derived对象身上。在正方形和矩形的例子（还有一个类似的是条款38的sets和lists），这个结论行不通，所以——用public继承塑模它们之间的关系不正确。我们应该记住：代码通过编译不表示就可以正确运行。</p>
<p>is-a只是存在class继承关系中的一种，还有两个继承关系式has-a（有一个）和is-implemented-in-terms-of（根据某物实现出）。这些关系将在条款38和条款39讨论。在设计类时，应该了解这些classes之间的相互关系和相互差异，在去塑模类之间的关系。</p>
<p>记住：</p>
<blockquote>
<p>“public 继承”意味着 is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</p>
</blockquote>
<h1 id="条款33"><a href="#条款33" class="headerlink" title="条款33"></a>条款33</h1><blockquote>
<p>避免遮掩继承而来的名称。</p>
</blockquote>
<p>这里说的名称，是和继承以及作用域有关。先看一个和作用域有关的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//global</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunc</span><span class="params">()</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x;<span class="comment">//local</span></span><br><span class="line">    std::cin&gt;&gt;x;<span class="comment">//给local变量赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个cin是给local变量x赋值，而不是global变量x，因为内层作用域名称会遮掩外围作用域名称。当编译器在someFunc作用域内遇到名称x时，它在local作用域内查找是否有这个变量定义，如果找不到就再去找其他作用域。这个例子中的变量x类型不同，local的是double类型，而global的是int类型；但是这个并不要紧，C++的名称遮掩规则（name-hiding rules）所做的唯一事情就是：遮掩名称，至于类型并不重要。</p>
<hr>
<p>现在来看一下继承。当一个derived class成员函数内指涉（refer to） base class内的某物（成员函数、成员变量、typedef等）时，编译器可以找到所指涉的东西，因为derived class继承了声明在base class内的所有东西。derived class的作用域被嵌套在base class作用域内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;         </span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子中既有public，又有private。成员函数有pure virtual、impure virtual和non-virtual，这是为了强调我们讨论的是名称，和其他无关。这个例子是单一继承，了解单一继承很容易推断多重继承。假设在derived class的mf4内调用mf2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::mf4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mf2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器看到mf2时，要知道它指涉（refer to）什么东西。首先在local作用域内（即mf4覆盖的作用域）查找有没有名称为mf2的东西；如果找不到，再查找外围作用域（class Derived覆盖的作用域）；如果还没找到，再往外围找（base class覆盖作用域），在这里找到了。如果base内还是没找到，之后继续在base那个namespace作用域内找，最后往global作用域找。</p>
<p>下面把这个例子变得稍微复杂一点，重载mf1和mf3，且添加一个新版mf3到Derived中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>因为以作用域为基础的“名称遮掩规则”，base class内所有名称为mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf3都不再被Derived继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   d.<span class="built_in">mf1</span>();<span class="comment">//正确，调用Derived::mf1</span></span><br><span class="line">   d.<span class="built_in">mf1</span>(x);<span class="comment">//错误，因为Derived::mf1遮掩了Base::mf1</span></span><br><span class="line">   d.<span class="built_in">mf2</span>();<span class="comment">//正确，调用Base::mf2</span></span><br><span class="line">   d.<span class="built_in">mf3</span>();<span class="comment">//正确，调用Derived::mf3</span></span><br><span class="line">   d.<span class="built_in">mf3</span>(x);<span class="comment">//错误，因为Derived::mf3遮掩了Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>条款32中说过public继承是”is-a”关系，如果使用public继承而又不继承那些重载函数，就是违反了”is-a”关系。要想上面的函数调用都正确，可是使用using声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">        ……</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//让Base class内名为mf1和mf3的所有东西在Derived作用域内都可见，且为public</span></span><br><span class="line">        <span class="keyword">using</span> Base::mf1;</span><br><span class="line">        <span class="keyword">using</span> Base::mf3;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ……</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//这就相当于派生类里有许多重载版本的函数</span></span><br></pre></td></tr></table></figure>

<p>这样，下面的调用都不会出错了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   d.<span class="built_in">mf1</span>();<span class="comment">//正确，调用Derived::mf1</span></span><br><span class="line">   d.<span class="built_in">mf1</span>(x);<span class="comment">//调用Base::mf1</span></span><br><span class="line">   d.<span class="built_in">mf2</span>();<span class="comment">//正确，调用Base::mf2</span></span><br><span class="line">   d.<span class="built_in">mf3</span>();<span class="comment">//正确，调用Derived::mf3</span></span><br><span class="line">   d.<span class="built_in">mf3</span>(x);<span class="comment">//调用Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>如果你继承base class，且加上重载函数；你又希望重新定义或覆写其中一部分，那么要把被遮掩的每个名称引入一个using声明。</p>
<p>public继承暗示base和derived class之间是一种”is-a”关系，这也是上述using声明放在derived class的public作用域内的原因：base class内的public名称在publicly derived class内也应该是public。</p>
<p>如果想要private继承Base，而Derived唯一想继承的是时Base内mf1无参数的那个版本，using声明在这派不上用场，因为using声明会使继承而来的某个名称所有函数在derived class都可以见。这样的实现需要一个不同的技术，一个简单的转交函数（forwarding function）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">private</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">mf1</span><span class="params">()</span><span class="comment">//转交函数（forwarding function），只转交某个版本的mf1</span></span></span><br><span class="line"><span class="function">    </span>&#123;Base::<span class="built_in">mf1</span>();&#125;;<span class="comment">//隐式成为inline</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">d.<span class="built_in">mf1</span>();<span class="comment">//调用Derived::mf1</span></span><br><span class="line">d.<span class="built_in">mf1</span>(x);<span class="comment">//错误，Base::mf1被遮掩了</span></span><br></pre></td></tr></table></figure>

<p>上面所述都是不含templates。当继承结合templates时，又会面临“继承名称被遮掩”，关于以“角括号定界”的东西，在条款43讨论。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
<h1 id="条款34"><a href="#条款34" class="headerlink" title="条款34"></a>条款34</h1><blockquote>
<p>区分接口继承和实现继承。</p>
</blockquote>
<p>public继承的概念，由2部分构成：函数接口（function Interface）继承和函数实现（function implementation）继承。我们在设计class时：</p>
<ul>
<li>有时希望derived class只继承函数的接口（即函数声明）；</li>
<li>有时候希望derived class继承函数接口和实现，但又覆写它们所继承的实现；</li>
<li>又有时候希望derived class同时继承函数的接口和实现，但不覆写任何东西。</li>
</ul>
<p>为了更好理解上述差异，用一个绘图程序来说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;……&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ellipse</span>:<span class="keyword">public</span> Shape&#123;……&#125;;</span><br></pre></td></tr></table></figure>

<p>Shape中有pure virtual函数，所以它是个抽象类，不能创建Shape对象，但Shape强烈影响了所有以public继承它的derivedclass，因为成员函数的接口总会被继承。条款32所说，public继承意味着is-a。</p>
<p>Shape class有三个函数。<code>draw</code>是pure virtual函数；<code>error</code>是impure pure函数；<code>objectID</code>是non-virtual函数。</p>
<p>pure virtual函数有两个特点：它们必须被继承了它们的具体class重新声明，而且在抽象class中通常没有定义。这也就是说明：</p>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。</li>
</ul>
<p>但是我们可以为pure virtual函数提供定义，即为<code>Share::draw</code>提供一份实现，C++不会发出怨言，但是调用这个函数的唯一途径是调用时指明其class名称：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps=<span class="keyword">new</span> Shape;</span><br><span class="line">ps-&gt;<span class="built_in">draw</span>();</span><br><span class="line">ps-&gt;Share::<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure>

<hr>
<p>impure virtual函数和pure virtual函数有所不同，derived classes继承其函数接口，但impure virtual函数会提供一份实现代码，derived class可能覆写（override）它。</p>
<ul>
<li>声明简朴的（非纯）impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现。</li>
</ul>
<p>考虑Shape::error这个例子，error接口表示，每个class都必须支持一个遇上错误时可调用的函数，但每个class可以自由处理错误。如果某个class不想针对错误做出特殊行为，可以退回到Shape class提供的缺省错误处理行为。也就是说Shape::error的声明式告诉derived class设计者：你必须支持一个error函数，但如果你不想自己写，可以使用Shape class提供的缺省版本。</p>
<p>如果允许impure virtual函数同时指定函数声明和函数缺省行为，有可能造成危险。考虑一个具体例子，一个XYZ航空公司设计飞机继承体系，该公司有A型和B型两种飞机，都以相同方式飞行，可以考虑这样设计继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airport</span>&#123; ……&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span>;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将飞机飞到指定的destination</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane&#123;……&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane&#123;……&#125;;</span><br></pre></td></tr></table></figure>

<p>因为不同型飞机不需要不同的fly实现，Airplane::fly被声明为virtual；为了避免在ModelA和ModelB重新撰写相同代码，缺省的飞行行为有Airplane::fly提供。</p>
<p>上面这种设计方式是典型的面向对象设计。两个classes共享的性质放到base class中，然后被这两个class继承。这样可以突出共同性质，避免代码重复。</p>
<p>但是如果XYZ要购买一种新型飞机C，C和A、B飞行方式不同。XYZ公司程序员给C型飞机添加了一个class，但是没有重新定义fly函数，然后又写了如下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Airport <span class="title">PDX</span><span class="params">()</span>；<span class="comment">//某个机场</span></span></span><br><span class="line"><span class="function">Airplane* pa</span>=<span class="keyword">new</span> ModelC;</span><br><span class="line">……</span><br><span class="line">pa-&gt;<span class="built_in">fly</span>(PDX);<span class="comment">//调用了Airplane::fly</span></span><br></pre></td></tr></table></figure>

<p>这会造成大灾难，因为程序员试图以ModelA或ModelB的方式来飞ModelC。问题不在于Airplane::fly有缺省行为，在于ModelC在未搞清楚的情况下就使用了这个缺省行为。幸运的是可以做到：提供缺省实现给derived classes，除非derived classes真的要用。这个做法是切断virtual函数接口和其缺省实现之间的连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">defaultFly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Airplane::deFaultFly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将飞机飞到指定目的地</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将Airplane::fly改为pure virtual函数，只提供接口。但是缺省的行为在Airplane::defaultFly函数中出现。如果要使用其缺省行为，可以在fly函数调用defaultFly函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也就是告诉派生类必须实现fly，但你可以用我提供的默认飞行模式   </span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destation)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="built_in">defaultFly</span>(destation)&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ModelB</span>: <span class="keyword">public</span> Airplane</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ModelC</span>: <span class="keyword">public</span> Airplane&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">void</span> ModelC:<span class="built_in">fly</span>(<span class="type">const</span> Airport&amp; destination)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将C型飞机飞到指定目的地</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面设计中，Airplane::defaultFly是个non-virtual，derived classes不用重新定义（条款36）。如果Airplane::defaultFly是virtual函数，就会出现循环问题：万一derived classes忘记重新定义defaultFly函数会怎样？</p>
<p>有的人返回以不同的函数分别将提供接口和缺省实现，这样会因为过度雷同的函数名称引起class命名空间污染问题；但是他们同意接口和缺省实现应该分开。我们可以利用“pure virtual函数必须在derived classes中重新声明，但它们可以拥有自己的实现”这个特点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 依旧是转调用默认版本，不同的是，默认版本由纯虚函数的实现版本提供，这样不会显得命名空间臃肿</span></span><br><span class="line"><span class="comment">// 同时，纯虚函数也强制派生类根据自己实现一份版本</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Airplane</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>=<span class="number">0</span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span><span class="comment">//pure virtual函数实现</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">//缺省实现</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ModelA</span>: <span class="keyword">public</span> Airplane&#123;</span><br><span class="line">   <span class="keyword">public</span>: </span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">       </span>&#123;Airplane::<span class="built_in">fly</span>(destination);&#125;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ModelB</span>:<span class="keyword">public</span> Airplane</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ModelC</span>: <span class="keyword">public</span> Airplane</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="type">const</span> Airport&amp; destination)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">//ModelC的实现</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现和上一个不同之处在于，用pure virtual函数Airplane::fly替换了独立函数Airplane::defaultFly。现在的fly被分割为两个基本要素：其声明部分表现为接口（derived classes必须使用），定义部分表现为缺省行为（derived classes明确提出申请才可以用）。</p>
<hr>
<p>最后来看看Shape的non-virtual函数objectID；Shape::objectID是个non-virtual函数，这意味着它不打算在derived class中有不同行为。</p>
<ul>
<li>声明non-virtual函数的目的是为了令derived classes继承函数 的接口及一份强制性实现。</li>
</ul>
<p>可以把Shape::objectID看做“每个Shape对象都有一个用来产生识别码的函数，这个识别码采用相同计算方法。non-virtual函数代表的意义是不变性（invariant）凌驾特异性（specialization），所以不应该在derived classes中被重新定义。</p>
<hr>
<p>pure virtual函数对应只继承接口；simple（impure） virtual函数对应继承接口和一份缺省实现；non-virtual函数对应继承接口和一份强制实现。在设计classes时，要分清这些区别和联系，否则容易犯两个错误：</p>
<ul>
<li>第一个错误是将所有函数声明为non-virtual。这会使derived classes没有空间进行特化工作；non-virtual析构函数会有问题（条款7）。如果关心virtual函数的成本问题，可以参考条款30的80-20法则。典型的程序有80%时间在执行20%代码，函数中有80%的virtual函数不一定会给程序带了多大效率损失，将心力花在那些20%代码上才是关键。</li>
<li>第二个错误是将所有成员函数声明为virtual。有时候这样是正确的，例如条款31的Interface classes。但如果有些函数在derived classes中确实不应该被重新定义，那么就应该将这些函数声明为non-virtual。</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。（附：有强烈的特异性，必须重新实现。并且纯虚函数的定义实现可以用来充当缺省版本）</li>
<li>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。（附：根据自己的特殊情况看需不需要覆写，如果没必要可以用基类的版本，但这个缺省的功能可能会产生一些危险。）</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。（附：强烈的共性，派生类只管继承不覆写）</li>
</ul>
</blockquote>
<h1 id="条款35"><a href="#条款35" class="headerlink" title="条款35"></a>条款35</h1><blockquote>
<p>考虑virtual函数以外的其他选择。</p>
</blockquote>
<p>假设你在制作一款游戏，游戏内的人物都有自己的生命值，而不同的人物会有不同的方式来计算它们健康指数，所以，需要将成员函数<code>healthValue()</code> 声明为虚函数是非常正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>healthValue()</code> 并未被声明为纯虚函数，这表示有一个计算健康指数的默认算法。但是，这样做并不是最完美，它也有缺陷，有没有替代方式呢？</p>
<hr>
<p>方法1：藉由Non-Virtual Interface手法实现Template Method模式</p>
<p>此手法主张的做法：</p>
<ul>
<li>将healthValue()函数声明为public，并且改为non-virtual函数</li>
<li>再设计一个private virtual函数，将healthValue()原本的功能移至该函数中，然后在healthValue()函数中调用该函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//派生类不应该重新定义它</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...                         //事前工作</span></span><br><span class="line">        <span class="type">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        <span class="comment">//..                          //事后工作</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//返回人物的健康指数，派生类可以重新定义它</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span><span class="type">const</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>NVI手法特点:</p>
<ul>
<li>令客户通过public non-virtual成员函数间接调用private virtual函数，称为non-virtual interface（NVI）手法。它是所谓Template Method设计模式的一个独特表现形式。我们把这个non-virtual 函数称为virtual函数的外覆器</li>
<li>NVI手法的优点：我们可以在non-virtual函数中做一些其他事情。例如：<ul>
<li>事前工作：可以进行锁定互斥器、制造运转日志记录项、验证class约束条件、验证函数先决条件等等</li>
<li>事后工作：可以进行互斥器解锁、验证函数的事后条件、再次验证class约束条件等等</li>
</ul>
</li>
</ul>
<p>这些优点是在客户端直接调用virtual函数的情况中做不到的</p>
<p>private的虚函数并不会改变多态性，只是改变了访问权限而已。NVI手法可以在派生类中重新定义private virtual函数：</p>
<ul>
<li>重新定义virtual函数：表示某些事“如何”被完成</li>
<li>调用virtual函数：表示它何时被完成</li>
<li>这两件事情互不干扰。因此NVI手法允许在派生类中重新定义virtual函数，从而赋予它们“如何实现机能”的控制能力</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//返回值是为了代码编译通过，无特殊意义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span> :<span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//重写基类的doHealthValue()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">doHealthValue</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameCharacter *p = <span class="keyword">new</span> GameCharacter;</span><br><span class="line">    p-&gt;<span class="built_in">healthValue</span>();  <span class="comment">//打印：Base</span></span><br><span class="line"></span><br><span class="line">    GameCharacter *p2 = <span class="keyword">new</span> Hero;</span><br><span class="line">    p2-&gt;<span class="built_in">healthValue</span>(); <span class="comment">//打印：Derived</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于virtual函数的访问级别：</p>
<ul>
<li>在NVI手法下其实virtual函数不一定得是private的</li>
<li>在有些情况下，要求派生类在virtual函数中调用基类的virtual函数（参阅条款27），那么当virtual函数在基类中为private之后，派生类就不可以访问了。因此，在这种情况下，virtual函数可以设置为protected。有时甚至一定得是public。</li>
<li>在NVI手法下，virtual函数尽量不要设置为public，因为设置为public之后，就与NVI手法的初衷相反了，失去了封装性</li>
</ul>
<hr>
<p>方法2：藉由Function Pointers实现Strategy模式</p>
<p>上面介绍的NVI方法虽然可以避免客户端直接调用virtual函数，但是在non-virtual函数中还是调用了virtual函数，这种方法还是没有免去定义virtual函数的情况。现在我们进行另一种设计，要求每个人物的构造函数接受一个指针，指向一个健康计算函数，我们可以调用该函数进行实际计算。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的，计算健康指数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCala</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数指针别名</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalaFunc hcf = defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        :healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过函数指针调用函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HealthCalcFunc healthFunc; <span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样做的优点是：同一个人物类型的不同实例之间可以有不同的健康计算函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123; <span class="comment">//同上 &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span> :<span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalaFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        :GameCharacter(hcf) &#123;</span>&#125;</span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;</span><br><span class="line">    <span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthQuickly)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，已定义的对象，在运行期间可以更改健康指数计算函数。例如，可以在类中再添加一个成员函数，用来更改当前计算健康指数的函数指针。</p>
<p>这种方法的争议是：</p>
<ul>
<li>当全局函数可以根据class的public接口来取得信息并且加以计算，那么这种方法是没有问题的。但是如果计算需要访问到class的non-public信息，那么全局函数就不可以使用了。</li>
<li>解决上面的问题，唯一方法就是：弱化class的封装。例如将这个全局函数定义为class的friend，或者为其某一部分提供public访问函数</li>
<li>因此，这些争议对于“以函数指针替换virtual函数”其是否利大于弊？取决于你的是继续需求</li>
</ul>
<hr>
<p>方法3：藉由tr1::function完成Strategy模式</p>
<p>使用全局函数替换成员函数，这种成员函数太过死板，因为“健康指数计算”不必非得是个函数，还可以是其他类型的东西（例如函数模板、函数对象、成员函数、仿函数等），只要其能计算“健康指数”即可，我们可以使用C++标准库中的function模板来取代全局函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">defaultHealthCala</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//其余部分同上</span></span><br><span class="line">    <span class="comment">//只是将函数指针改为了function模板，其接受一个const GameCharacter&amp;参数，并返回int</span></span><br><span class="line">    <span class="keyword">typedef</span> std::tr1::function&lt;<span class="type">int</span>(<span class="type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> </span></span><br><span class="line"><span class="function">        :healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们可以不单单调用全局函数来计算“人物的健康指数”，还可以设计很多种方式来计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123; <span class="comment">//同上&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvilBadGuy</span> :<span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        :GameCharacter(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EyeCandyCharacter</span> :<span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="comment">//构造函数类似EvilBadGuy </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算健康指数函数</span></span><br><span class="line"><span class="function"><span class="type">short</span> <span class="title">calcHealth</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象，用来计算健康指数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HealthCalculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span><span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其提供一个成员函数，用以计算健康</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">health</span><span class="params">(<span class="type">const</span> GameCharacter&amp;)</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//人物1，其使用calcHealth()函数来计算健康指数</span></span><br><span class="line">    <span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//人物2，其使用HealthCalculator()函数对象来计算健康指数</span></span><br><span class="line">    <span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//人物2，其使用GameLevel类的health()成员函数来计算健康指数</span></span><br><span class="line">    GameLevel currentLevel;</span><br><span class="line">    <span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(std::tr1::bind(&amp;GameLevel::health, currentLevel, _1))</span></span>;<span class="comment">//传入成员函数的第一个参数*this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点是：</p>
<ul>
<li>支持隐式转换，参数可被隐式转换为const GameCharacter&amp;，返回类型可以被隐式转换为int；</li>
<li>支持了任何兼容的的可调用物（兼容就是指能隐式转换参数、返回值的）</li>
<li>能用tr1::bind进行参数扩展</li>
</ul>
<hr>
<p>方法4：古典的Strategy模式</p>
<p>在古典的Strategy设计模式中，会将用来计算健康的函数设计为一个继承体系，并且有virtual函数，这些函数用来计算健康</p>
<ul>
<li>GameCharacter是一个继承体系的根类，其派生类有EvilBadGuy、EyeCandyCharacter</li>
<li>HealthCalcFunc是一个继承体系的根类，其派生类有SlowHealthLoser、FastHealthLoser</li>
<li>每一个GameCharacter对象都内含一个指针，指向于一个来自HealthCalcFunc继承体系中的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCalcFunc</span> &#123; <span class="comment">//计算健康指数的类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> GameCharacter&amp; gc)</span><span class="type">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameCharacter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* hcf = &amp;defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        :pHealthCalc(hcf) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">healthValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHealthCalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个模式也具有弹性，例如为HealthCalcFunc类添加派生类，那么就可以纳入新的计算方法</p>
<hr>
<p>四种方法总结：</p>
<ul>
<li>使用non-virtual interface（NVI）手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性（private或protected）的virtual函数</li>
<li>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式</li>
<li>以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式</li>
<li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li>
<li>tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li>
</ul>
</blockquote>
<h1 id="条款36"><a href="#条款36" class="headerlink" title="条款36"></a>条款36</h1><blockquote>
<p>绝不重新定义继承而来的non-virtual函数。</p>
</blockquote>
<p> 假设 class D系由 class B以 public 形式派生出来，class B定义有一个 public 成员函数mf。由于mf的参数和返回值都不重要，所以假设两者皆为 void。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>虽然我们对于B、D和mf一无所知，但面对一个类型为D的对象 x：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D x;        <span class="comment">// x是一个类型为D的对象</span></span><br></pre></td></tr></table></figure>

<p>如果以下行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B *pB = &amp;x; <span class="comment">// 获得一个指针指向x</span></span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();   <span class="comment">// 经由该指针调用mf</span></span><br></pre></td></tr></table></figure>

<p>  异于以下行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D *pD = &amp;x;</span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();</span><br></pre></td></tr></table></figure>

<p>两者都通过对象 x 调用成员函数 mf，由于两者所调用的函数都相同，所以行为应该相同，是吗？是的，一般如此。</p>
<p>更明确地说，如果mf是个non-virtual 函数而D定义有自己的mf，那就不是如此：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mf</span><span class="params">()</span></span>;      <span class="comment">// 遮掩了B::mf</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">pB-&gt;<span class="built_in">mf</span>();           <span class="comment">// 调用B::mf</span></span><br><span class="line">pD-&gt;<span class="built_in">mf</span>();           <span class="comment">// 调用D::mf</span></span><br></pre></td></tr></table></figure>

<p> 造成此行为的原因是：non-virtual 函数如 B::mf 和 D::mf 都是静态绑定(staticlly bound,详见条款37)。这意思是说，由于pB被声明为一个pointer-to-B，通过pB调用的non-virtual 函数永远是B所定义的版本，即使pB指向一个类型为”D派生的class”的对象。</p>
<p>但另一方面，virtual 函数却是动态绑定(dynamically bound，详见条款37)，所以它们不受这个问题困扰。如果mf是个 virtual 函数，不论是通过pB或pD调用mf，都会导致调用D::mf，因为pB和pD真正指的都是一个类型为D的对象。</p>
<p>如果正在编写 class D并重新定义继承自 class B的non-virtual 函数mf，D对象很可能展现出不一致的行为。更明确地说,当mf被调用，任何一个D对象都可能展现出B或D的行为：决定因素不在对象自身，而在于”指向该对象的指针”当初的声明类型。</p>
<hr>
<p>但那只是实务面上的讨论，真正的理论层面的理由，接下来讨论：</p>
<p>条款32已经说过，所谓 public 继承意味is-a的关系。条款34则描述为什么在 class 内声明一个non-virtual 函数会为该 class 建立起一个不变性，凌驾其特异性。如果将这两个观点施行于两个 class B和D以及non-virtual 成员函数B::mf身上，那么：</p>
<ul>
<li>适用于B对象的每一件事，也适用于D对象，因为每个D对象都是一个B对象</li>
<li>B的derived class 一定会继承mf的接口和实现，因为mf是B的一个non-virtual函数</li>
</ul>
<p>现在，如果D重新定义mf，设计便出现矛盾。既然D以 public 形式继承B，并且mf是B的一个non-virtual 函数，那么D的mf行为和B的mf行为必须是一致的。但D又重新定义mf,这就发生了矛盾。</p>
<p>因此，任何情况下都不应该重新定义一个继承而来的non-virtual 函数。</p>
<p>同时这个条款也解释了为什么多态性base class 内的析构函数应该是 virtual。如果违反了这个准则，在base class 内声明一个non-virtual 析构函数，那么在derived class 就不能重新定义一个派生类的non-virtual 析构函数。但即使没有重新定义non-virtual 析构函数，编译器也会为derived class 定义一个默认的析构函数，仍然发生矛盾。</p>
<p>记住：</p>
<blockquote>
<p>绝不重新定义继承而来的non-virtual函数。</p>
</blockquote>
<h1 id="条款37"><a href="#条款37" class="headerlink" title="条款37"></a>条款37</h1><blockquote>
<p>绝不重新定义继承而来的缺省参数值。</p>
</blockquote>
<p>我们在条款36刚刚说过继承non-virtual函数是错误的。所以本条款更确切的说是：绝不重新定义继承而来的带有缺省参数值的virtual函数。理由很明确：virtual是动态绑定，而缺省参数是静态绑定。动态绑定又叫后期绑定，静态绑定又叫前期绑定。</p>
<p>先说一下静态类型和动态类型的概念：对象的所谓静态类型就是它在程序中被声明时所采用的类型 ，对象的动态类型指的是目前所指对象的类型，也就是说动态类型可以表现出一个对象将会有什么行为。</p>
<p>下面是一个继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> :<span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们定义下面的代码，它们都被声明为pinter-to-Shpae类型，因此它们不论它们指向什么，静态类型都是Shape*：</p>
<p>动态类型是指该该对象将会有什么行为。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps;                 <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;    <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle; <span class="comment">//静态类型为Shape*</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps;</span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;<span class="comment">//动态类型是Circle*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;<span class="comment">//动态类型是Rectangle*</span></span><br><span class="line"></span><br><span class="line">ps = pc; <span class="comment">//ps的动态类型如今是Circle*</span></span><br><span class="line">ps = pr; <span class="comment">//ps的动态类型如今是Rectangle*</span></span><br></pre></td></tr></table></figure>

<p>根据语法我们知道，对于virtual函数的调用，是根据其动态类型决定的。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps;                 </span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle; </span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line"></span><br><span class="line">pc-&gt;<span class="built_in">draw</span>(Shape::Red); <span class="comment">//调用Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(Shape::Red); <span class="comment">//调用Rectangle::draw(Shape::Red)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>虽然对于virtual函数的调用时动态绑定的，但是对于virtual函数的缺省参数值却是静态绑定的</p>
<p>见下面的代码：</p>
<ul>
<li>我们知道virtual函数是动态绑定的，pr的动态类型为Rectangle，所以调用的是Rectangle::draw()</li>
<li>但是virtual函数的缺省参数值是静态绑定的，在上面类的定义中Rectangle的draw()函数也有默认参数，但是由于pr指针的静态类型是Shape，因此pr的draw()函数的缺省参数值就是Shape::draw()函数中的参数值，为Shape::Red。</li>
<li>因此这个调用是派生类和基类各出一份力，基类提供默认参数，派生类提供动作。这个情况也适用于pc，注意Circle的实现并不是默认参数版本，但也因此可以认为有默认参数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(); <span class="comment">//调用的是Rectangle::draw(Shape::Red)，而不是Rectangle::draw(Shape::Green)</span></span><br></pre></td></tr></table></figure>

<p> 以上事实不只局限于“ps，pc和pr都是指针”的情况：即使把指针换成references问题仍然存在。重点在于draw是个virtual函数，而它有个缺省参数值在derived class中被重新定义了。</p>
<p>为什么要设计这种行为的原因在于运行效率。如果缺省参数值也是动态绑定，编译器就必须有某种办法在运行期为virtual函数决定适当的参数缺省值，这比目前实行的“在编译期决定”的机制更慢而且更复杂。</p>
<hr>
<p>这一切都很好，但如果你试着遵守这条规则，并且同时提供缺省参数值给base和derived classes的用户，又会发生什么事呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这导致了代码重复。更糟的是，代码重复又带着相依性（with dependencies）：如果Shape内的缺省参数值改变了，所有“重复给定缺省参数值”的那些derived classes也必须改变，否则它们最终会导致“重复定义一个继承而来的缺省参数值”。</p>
<hr>
<p> 当你想令virtual函数表现出你所想要的行为但却遭遇麻烦，聪明的做法是考虑替代设计。</p>
<p>条款35列了不是virtual函数的替代设计，其中之一是NVI（non-virtual interface）手法：令base class内的一个public non-virtual函数调用private virtual函数，后者可被derived classes重新定义。这里我们可以让non-virtual函数指定缺省参数，而private virtual函数负责真正的工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="type">const</span>      <span class="comment">// 如今它是non-virtual</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">doDraw</span>(color);                           <span class="comment">// 调用一个virtual</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 真正的工作在此处完成</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="type">const</span></span>;     <span class="comment">// 注意，不须指定缺省参数值</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  由于non-virtual函数应该绝对不被derived classes覆写（见条款36），这个设计很清楚地使得draw函数的color缺省参数值总为Red。</p>
<p>记住：</p>
<blockquote>
<p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。</p>
<p>附：注意仅仅是参数值，而非整个函数。函数是可以重新定义的，并且当使用了一个基类指针时，可以视为带了默认参数。</p>
</blockquote>
<h1 id="条款38"><a href="#条款38" class="headerlink" title="条款38"></a>条款38</h1><blockquote>
<p>通过复合塑模出has-a或“根据某物实现出”。</p>
</blockquote>
<p>复合（composition）是类型之间的一种关系，一个类型的对象包含其他类型对象便是这种关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span>&#123; …… &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span>&#123; …… &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ……</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Address address;</span><br><span class="line">    PhoneNumber mobilePhone;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Person对象中包含string，Address，PhoneNumber对象，这就是复合。还有几个同义词：layering（分层），containment（内含），aggregation（聚合），embedding（内嵌）。</p>
<p>条款 32中提到，public是is-a关系，复合是has-a（有一个）或is-implemented-in-terms-of（根据某物实现出）。在程序中，大概可以分为两个领域（domains）。程序中对象相当于你所塑造现实世界中某物，例如地址、电话号码，这样的对象属于应用域（application domain）。还有一些是实现细节上的人工复制品，例如缓冲区（buffers）、互斥器（mutexes）、查找树（search tree）等，这些是实现域（implementation domain）。</p>
<p>当复合发生在应用域对象之间时，表现出has-a关系；发生在实现域表现出is-implemented-in-terms-of关系。</p>
<hr>
<p>区分is-a和is-implemented-in-terms-of比较麻烦。通过一个例子来说明，假设你需要一个template，用来构造一组classes来表示不重复对象组成的sets。首先我们想到用标准程序库提供的set template。</p>
<p>标准程序库的set由平衡查找树（balance search tree）实现，每个元素使用了三个指针的额外开销。这样可以使查找、插入、移除等操作时间复杂度为O(logN)（对数时间，logarithmic-time）。如果速度比空间重要，这样做合理，但是如果空间比速度重要，那么标准库提供的set将不满足我们需求.</p>
<p>set实现方法很多，可以在底层使用linked lists来实现，标准库中有list template，于是我们复用它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>: <span class="keyword">public</span> std::list&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面看起来很美好，其实是错误的。条款 32曾说过，public继承是is-a关系，即set是一种list并不对。例如set不能包含重复元素，但是list可以。</p>
<p>因为这两个classes之间并非is-a关系，所以public继承并不适用。正确的做法是，set对象可以根据一个list对象来实现出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;calss T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">member</span><span class="params">(<span class="type">const</span> T&amp; item)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::list&lt;T&gt; rep;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只要熟悉list，便很快可以实现上面几个接口函数。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>复合（composition）的意义和public继承完全不同。</li>
<li>在应用域（application domain），复合意味has-a；在实现域（implementation domain），复合意味is-implemented-in-terms-of（根据某物实现出）。</li>
</ul>
</blockquote>
<h1 id="条款39"><a href="#条款39" class="headerlink" title="条款39"></a>条款39</h1><blockquote>
<p>明智而审慎地使用private继承。</p>
</blockquote>
<p>public继承是is-a关系，条款32曾讲过并给出例子，如果把那个例子用private继承会怎样？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;……&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">private</span> Person&#123;……&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eat</span>(p);</span><br><span class="line"><span class="built_in">eat</span>(s)</span><br></pre></td></tr></table></figure>

<p>上面的<code>eat(s)</code>会出错，因为private继承不是is-a关系。如果继承关系是private，那么编译器不会自动将一个derived class对象转换为base class对象；此外继承base的所有成员，在derived class中都是private。</p>
<p>private继承意味implemented-in-terms-of（根据某物实现出）。如果class D以private形式继承class B，我们的用意是采用class B内已经具备的某些特性。private继承纯粹只是一种实现技术（这也是为什么derived class中，base class成员都是private的：因为它们都只是实现枝节而已）。private继承意味只有实现部分被继承，接口部分应略去。D以private形式继承B，意思是D对象是根据B对象实现而得。</p>
<p>private继承意味is-implemented-terms-of（根据某物实现出），和条款38的复合意义相同。那么如何在两者之间取舍?答案是尽可能的复合，必要时才使用private继承。</p>
<hr>
<p>现在有个Widget class，我们想记录每个成员函数调用次数，在运行期间周期性审查这份信息。为了完成这项工作，需要用到定时器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="type">int</span> tickFrequency)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnTick</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//定时器滴答一次，此函数调用一次</span></span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每次滴答调用某个virtual函数，我们可以重新定义那个virtual函数，来取出Widget当时状态。为了重新定义Timer内的virtual函数，Widget必须继承Timer。因为Widget不是Timer，因此不适用public继承。还有一个观点支持不适用public，Widget对象调用onTick有点奇怪，会违反条款18：让接口容易被正确使用，不容易被误用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">private</span> Timer&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//查看Widget的数据等操作</span></span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设计也可以通过复合实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ……</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    ……</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>这个设计稍微复杂一点，涉及到了public继承和复合，以及导入一个新class。我们有理由来选择这个复合版本，而不是private继承版本。</p>
<ul>
<li>Widget可能会有派生类，但是我们可能会想阻止在派生类中重新定义onTick。如果是使用private继承，上面的想法就不能实现，因为derived classes可以重新定义virtual函数（条款35）。如果采用复用方案，Widget的derived classes将无法采用WidgetTimer（private的），自然也就无法继承或重新定义它的virtual函数了。</li>
<li>采用复合方案，还可以降低编译依存性。如果Widget继承Timer，当Widget编译时Timer的定义必须可见，所以Widget所在的定义文件必须包含Timer的定义文件。复合方案可以将WidgetTimer移出Widget所在的文件，而让Widge只含有一个指针即可并声明WidgetTimer即可。</li>
</ul>
<hr>
<p>那么何时选择private继承呢？</p>
<p>private继承主要用于“当一个意欲成为derived class者想访问一个意欲成为base class者的protected成分，或为了重新定义一个或多个virtual函数”。这时候，两个classes之间关系是is-implemented-in-terms-of，而不是is-a。有一种激进情况涉及空间最优化，会促使你选择private继承，而不是继承加复合。</p>
<p>这个情况只适用于你所处理的class不带任何数据。它不包含non-static变量、virtual函数，没有继承virtual base class。这样的empty classes对象没使用任何空间，因为它没有任何数据对象要存储。但是因为技术原因，C++对象都必须有非零大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;；</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sizeof(HoldsAnInt)&gt;sizeof(int)。大多数编译器中，sizeof(Empty)为1，通常C++官方勒令安插一个char到对象内，但class大小还有字节对其需求（比如对齐）。</p>
<p>“独立（非附属）”对象大小一定不为零，这个约束不适用于derived class对象内的base成分，因为它们不独立，如果继承Empty，而不是复合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HoldsAnInt</span>: <span class="keyword">private</span> Empty&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，几乎可以确定sizeof(HoldsAnInt)&#x3D;&#x3D;sizeof(int)。这是所谓的EBO（empty base optimization；空白基类最优化）。如果客户非常在意空间，那么使用EBO。EBO一般只在单一继承下才行，统治C++对象布局的那些规则通常表示EBO无法被施行余“拥有多个base”的derived classes身上。</p>
<p>那么这样的empty class有什么用呢？</p>
<ul>
<li>empty class并不是真的empty。它们内往往含有typedef、enum、static或弄-virtual函数。SLT有许多技术用途的empty classes，其中内含有的成员（通常是typedefs），包括base classes unary_function和binary_function，这些是“用户自定义之函数对象”，通常会继承的classes。</li>
</ul>
<p>前面提到，只要可以尽可能选择复合，但这也不是全部。当面对并不存在is-a关系的两个classes，其中一个需要访问另一个的protected成员，或需要重新定义其一个或多个virtual函数，private继承可能成为正统设计策略。在考虑了其他方案后，仍然认为private继承是“表现两个classes之间的关系”的最佳办法，那就使用它。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>private继承意味着is-implemented-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，使用private是合理的。</li>
<li>和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象占用空间最小化”的程序库开发者而言，可能很重要。</li>
</ul>
</blockquote>
<h1 id="条款40"><a href="#条款40" class="headerlink" title="条款40"></a>条款40</h1><blockquote>
<p>明智而审慎地使用多继承。</p>
</blockquote>
<p>多重继承的意思是继承一个以上的base classes，但这些base classes并不常在继承体系中又有更高级的base classes。多重继承并不是继承有多个层级的意思。</p>
<p>使用多重继承 ，程序有可能从一个以上的基类继承相同名称（如函数，typedef等），那会导致较多的歧义。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BorrowableItem</span> &#123;		<span class="comment">//图书馆允许你借某些东西</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;		<span class="comment">//离开时进行检查</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectronicGadget</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="type">const</span></span>;	<span class="comment">//执行自我检测，返回是否测试成功</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP3Player</span>: <span class="keyword">public</span> BorrowableItem, <span class="keyword">public</span> ElectronicGadget &#123;	<span class="comment">//多重继承</span></span><br><span class="line">    ...						<span class="comment">//类的定义不是我们关心的重点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.<span class="built_in">checkOut</span>(); 				<span class="comment">// 歧义，此处的 checkOut 是 BorrowableItem 类的还是 ElectronicGadget 类的呢？</span></span><br><span class="line">							<span class="comment">//即使两个函数中只有一个可访问,因为</span></span><br><span class="line">							<span class="comment">//BorrowableItem 的 checkOut 是 public，而 ElectronicGadget 内的却是 private</span></span><br></pre></td></tr></table></figure>

<p>C++解析重载函数调用的规则：在看到是否有函数可调用之前，C++首先确认这个函数对此调用是否是最佳匹配。找出最佳匹配才去检验可取用性。上述例子中的两个 checkOut 有相同的匹配程度（因此才造成歧义），没有所谓的最佳匹配。因此ElectronicGadget::checkOut 的可访问性也就从未被编译器审查。</p>
<p>为了解决歧义，必须指明你要调用哪一个 基类 内的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.BorrowableItem::<span class="built_in">checkOut</span>();		<span class="comment">//OK</span></span><br><span class="line">mp.ElectronicGadget::<span class="built_in">checkOut</span>();	<span class="comment">//报错，该类的 checkOut 是 private</span></span><br></pre></td></tr></table></figure>

<hr>
<p>如果继承一个以上的基类，且基类继承更高级的基类，就可以会导致菱形继承。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span>:<span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutFile</span>:<span class="keyword">public</span> File&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span>:<span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutFile&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上述继承体系中，File与IOFile之间有一条以上的相通路线。于是IOFile继承File成员时，需要面对的问题：是打算让base class内的成员变量经由每一条路径被复制（成员变量重复啦），还是说IOFile从InFile和OutFile继承的成员变量（其继承来自File）不该重复？</p>
<p>两个阵营，而C++在此表示中立（都可以）。于是引出虚基类的概念，即防止同一基类成员因不同相通路线而被复制多次。当然，虚继承是要付出相应代码代价。</p>
<p>具体做法如下，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputFile</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> File &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OutFile</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> File &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOFile</span> :<span class="keyword">public</span> InputFile,<span class="keyword">public</span> OutFile &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>从正确行为的观点看，public继承 应该总是 virtual。但是正确性并不是唯一观点，为避免继承来的成员变量重复，编译器必须提供一些成本：</p>
<ul>
<li>使用 virtual 继承的那些类所产生的对象往往比使用 non-virtual 继承的兄弟们体积大</li>
<li>访问 virtual base class 的成员变量时，比访问 non-virtual base class 的成员变量速度慢</li>
<li>支配“virtual base class 初始化 ”的规则比 non-virtual base情况复杂且不直观</li>
</ul>
<p>对virtual base classes的忠告：</p>
<ul>
<li>非必要不使用virtual bases。平常请使用non-virtual继承。</li>
<li>如果必须使用virtual base classes，尽可能避免在其中放置数据。这样就不需担心classes身上的初始化（和赋值）所带来的诡异事情。</li>
</ul>
<p>以下举例实现一个public和private并存的多重继承，public继承是is-a关系，而private继承是is implement in terms of关系，具体举例见下代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseID</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IPerson</span> &#123;<span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">IPerson</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">birthDate</span><span class="params">()</span><span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//factory function，根据一个独一无二的数据库ID创建一个Person对象</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;IPerson&gt; <span class="title">makePerson</span><span class="params">(DatabaseID personIdentifier)</span></span>;</span><br><span class="line"><span class="function">DatabaseID <span class="title">askUserForDatabaseID</span><span class="params">()</span></span>;<span class="comment">//这个函数从使用者手上取得一个数据库ID</span></span><br><span class="line"><span class="function">DatabaseID <span class="title">id</span><span class="params">(askUserForDatabaseID())</span></span>;</span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;IPerson&gt; <span class="title">pp</span><span class="params">(makePerson(id))</span></span>;<span class="comment">//创建一个对象支持Iperson接口，</span></span><br><span class="line">                                                 <span class="comment">//借由Iperson成员函数处理*pp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//与数据库相关的class，名为PersonInfo,提供Cperson所需要的实质东西：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PersonInfo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">PersonInfo</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">theName</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">theBirthDate</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>于是下面所要给出的CPerson和PersonInfo的关系是，PersonInfo刚好有若干函数可帮助CPerson比较容易实现出来，而IPerson则提供给CPerson接口，运用多重继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cperson</span> :<span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Cperson</span><span class="params">(DatabaseID pid)</span>:PersonInfo(pid)&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">name</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> PersonInfo::<span class="built_in">theName</span>();<span class="comment">//实现必要的IPerson成员函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">birthDate</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> PersonInfo::<span class="built_in">theBirthDate</span>();<span class="comment">//实现必要的IPerson成员函数</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;<span class="comment">//重新定义继承而来的virtual&quot;界限函数&quot;</span></span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法就是：将“public继承自某接口”和“private继承自某实现”结合在一起。</p>
<p>最后，如果有一个单一继承的设计，而它几乎等价于一个多重继承的设计方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候的确是完成任务之最简结、最易维护、最合理的做法，果真如此就别害怕使用它。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性、以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相组合。</li>
</ul>
</blockquote>
<h1 id="条款41"><a href="#条款41" class="headerlink" title="条款41"></a>条款41</h1><blockquote>
<p>了解隐式接口和编译期多态。</p>
</blockquote>
<p>面向对象编程总是以显式接口和运行期多态来解决问题。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Widget</span>(); </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>(); </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">normalize</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)&#123; </span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>; </span><br><span class="line">        temp.<span class="built_in">normalize</span>(); </span><br><span class="line">        temp.<span class="built_in">swap</span>(w); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所谓的显式接口：由于w的类型被声明为Widget，因此w需要Widget接口，并且我们可以在源码中找到这个接口，看到源码的样子，所以称为是显式接口。</li>
<li>所谓的运行期多态：由于Widget的某些函数是虚函数，因此w的某些函数在运行期间才可以根据w的类型动态调用相关版本的函数，这就是所谓的运行期多态。</li>
</ul>
<p>在泛型编程中，显式接口与运行期多态仍有使用，但是其主要应用的是隐式接口和编译期多态。</p>
<p>例如将刚才的函数改为函数模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span> <span class="comment">//w需要支持的操作都是隐式接口</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)&#123; </span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>; </span><br><span class="line">        temp.<span class="built_in">normalize</span>(); </span><br><span class="line">        temp.<span class="built_in">swap</span>(w); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候w发生了什么样的改变呢？</p>
<ul>
<li>隐式接口：w所需要支持的接口需要当函数模板具现化时执行于w身上的操作决定（执行了什么操作，说明w一定需要支持这些接口），例子中w使用了size、normalize、swap函数、copy构造函数、不等比较。并且if语句中还有一个长表达式。这所有的函数与长表达式便是T必须支持的一组隐式接口（其实就是w需要被约束的东西）。(w.size() &gt; 10 &amp;&amp; w !&#x3D; someNastyWidget)</li>
<li>编译期多态：使用到w的任何函数调用，都可能会造成模板具现化，这样的函数具现化发生在编译期，而且不同的模板参数导致不同的模板函数，这就是所谓的编译期多态。</li>
</ul>
<p>通常显式接口是由函数的签名式（函数名称、参数类型、返回类型）构成。但是隐式接口不是基于签名式的，而是由有效表达式组成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.<span class="built_in">size</span>()&gt;<span class="number">10</span>&amp;&amp;w!=someNastyWidget<span class="comment">//这就是所谓的隐式接口，是一组有效表达式。</span></span><br></pre></td></tr></table></figure>

<p>w的隐式接口似乎有下述的约束：</p>
<ul>
<li>提供size()函数，返回整数值</li>
<li>支持！&#x3D; 操作符重载，用来比较两个T对象</li>
</ul>
<p>但是由于操作符重载的关系，隐式接口实际上不需要满足这两个约束。原因如下：</p>
<ul>
<li>w可能继承自base class的size 函数，因此不需要有size函数</li>
<li>并且size函数也没必要返回一个整数，只要它能够返回一个类型为X的对象，并且X和10 能够调用&gt; 符号函数即可。</li>
<li>‘&gt;’不需要非得是对象X的成员函数(可以是全局的一个函数。)</li>
<li>再退一步，并且符号函数&gt;也并不是非得取得一个X对象和一个10才可以，它也可以取得类型Y的参数，只要存在一个隐式转换能够将类型X的对象转换为类型Y的对象。</li>
</ul>
<p>同样，T不必支持operator!&#x3D;，因为operator!&#x3D;也可以接受类型为X和Y的对象，只要T可以被转换为X，someNastyWidget的类型可以被转换成Y就行。</p>
<p>总之，隐式接口就是一组表达式，不管中间过程怎么样，只要最终的结果是一个满足类似于上述if语句中的表达式应该有的结果就行，比如if的条件表达式应该是bool类型的，只要括号里的表达式最终的结果是bool类型即可。表达式中间的接口可能并不需要w去支持。这些就是所谓的隐式接口。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>classes和templates都支持接口和多态。</li>
<li>对classes而言接口是显式的，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li>
</ul>
</blockquote>
<h1 id="条款42"><a href="#条款42" class="headerlink" title="条款42"></a>条款42</h1><blockquote>
<p>了解typename的双重意义。</p>
</blockquote>
<p>在模板的的声明中，class与typename是没有什么区别的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">func1</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T <span class="title">func2</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是在模板的定义中typename有时候却会派上用场。为了说明问题，我们先了解一下：模板中依赖于模板参数的名称称为从属名称（dependent name）， 当一个从属名称嵌套在一个类里面时，称为嵌套从属名称（nested dependent name）。 其实<code>C::const_iterator</code>还是一个嵌套从属类型名称（nested dependent type name）。</p>
<p>有了这两个基本概念之后我们就可以看一下例子：假设我们要打印一个容器（里面为）中的第二个元素，那么函数应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span>    <span class="comment">// 打印容器内第二个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;                                    <span class="comment">// 注意这不是有效C++代码</span></span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;    <span class="comment">// 取得第一元素的迭代器</span></span><br><span class="line">        ++iter;                                       <span class="comment">// 将iter移往第二元素</span></span><br><span class="line">        <span class="type">int</span> value = *iter;                            <span class="comment">// 将该元素复制到某个int</span></span><br><span class="line">        std::cout &lt;&lt; value;                           <span class="comment">// 打印那个int</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中特别强调两个local变量和itemvalue。iter的类型是C::const_iterator，实际是什么必须取决于template参数C。</p>
<p>print2nd内的另一个local变量value，其类型是int。int是一个并不依赖任何template参数的名称。这样的名称是非从属名称。</p>
<p> 嵌套从属名称有可能导致解析困难。举个例子，假设我们令print2nd更愚蠢些，这样起头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来好像我们声明x为一个local变量，它是个指针，指向一个C::const_iterator。但它之所以被那么认为，只因为我们“已经知道”C::const_iterator是个类型。如果C有个static成员变量而碰巧被命名为const_iterator，或如果x碰巧是个global变量名称呢？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作：C::const_iterator乘以x。当然，这听起来有点疯狂，但却是可能的，而撰写C++解析器的人必须操心所有可能的输入，甚至是这么疯狂的输入。</p>
<hr>
<p>在我们知道C是什么之前，没有任何办法可以知道C::const_iterator是否为一个类型。而当编译器开始解析template print2nd时，尚未确知C是什么东西。C++有个规则可以解析此一歧义状态：如果解析器在template中遭遇一个嵌套从属名称，它便假设这个名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。此规则有个例外，稍后会提到。</p>
<p>现在再次看看print2nd起始处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;                                    </span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;    <span class="comment">// 这个名称被假设为非类型</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>现在应该很清楚为什么这不是有效的C++代码了吧。iter声明式只有在C::const_iterator是个类型时才合理，但我们并没有告诉C++说它是，于是C++假设它不是。若要矫正这个形势，我们必须告诉C++说C::const_iterator是个类型。只要紧临它之前放置关键字typename即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;                 <span class="comment">// 这是合法的C++代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2nd</span><span class="params">(<span class="type">const</span> C&amp; container)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;                                    </span><br><span class="line">    <span class="keyword">if</span> (container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;    </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>一般性规则很简单：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。</p>
<p>typename只被用来验明嵌套从属类型名称：其他名称不该有它存在。例如下面这个function template，接受一个容器和一个“指向该容器”的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;                     <span class="comment">// 允许使用“typename”(或“class”)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> C&amp; container,               <span class="comment">// 不允许使用“typename”</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> C::iterator iter)</span></span>;      <span class="comment">// 一定要使用“typename”</span></span><br></pre></td></tr></table></figure>

<p>上述的C并不是嵌套从属类型名称（它并非嵌套于任何“取决于template参数”的东西内），所以声明container时并不需要以typename为前导，但C::iterator是个嵌套从属类型名称，所以必须以typename为前导。</p>
<p>“typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是，typename不可以出现在base classes list内的嵌套从属类型名称之前，也不可在member initialization list（成员初始列）中作为base class修饰符。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;    <span class="comment">// base class list中不允许“typename”</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    : Base&lt;T&gt;::Nested(x)                   // mem.init.list中不允许“typename”</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;     <span class="comment">// 嵌套从属类型名称，</span></span><br><span class="line">        ...                                <span class="comment">// 既不在base class list中也不再mem.init.list中,</span></span><br><span class="line">    &#125;                                      <span class="comment">// 作为一个base class修饰符需加上typename</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记住：</p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。</li>
</ul>
</blockquote>
<h1 id="条款43"><a href="#条款43" class="headerlink" title="条款43"></a>条款43</h1><blockquote>
<p>学习处理模板化基类内的名称。</p>
</blockquote>
<p>我们需要一个程序，传送信息到不同的公司去。信息要不译成密码，要不就是未加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至那一家公司，就可以采用基于 template 的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyA</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyB</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">...                            <span class="comment">//针对其他公司设计的classes </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgInfo</span>&#123;...&#125;; <span class="comment">//这个class用来保存信息，以备将来产生信息 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClear</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        std::string msg; </span><br><span class="line">        根据info产生信息； </span><br><span class="line">        Company c; </span><br><span class="line">        c.<span class="built_in">sendCleartext</span>(msg); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ...;<span class="comment">//调用c.sendEncrypted，类似sendClear </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个做法行的通。假设我们有时候想要在每次发送出信息的时候志记（log）某些信息。 derived class 可以轻易加上这样的行为，那似乎是个合情理的解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        将传送前信息写至log； </span><br><span class="line">        <span class="built_in">sendClear</span>(info); </span><br><span class="line">        将传送后信息写至log；</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sendClearMsg 避免遮掩 “继承而得的名称”（条款 33），避免重新定义一个继承而得的 non-virtual 函数（条款 36）。但上述代码无法通过编译，编译器看不到 sendClear。</p>
<p>问题在于，编译器遇到 class template LoggingMsgSender 定义式时，并不知道它继承什么样的 class。因为 MsgSender&lt;Company&gt; 中的 Company 是个 template 参数，不到后来（当 LoggingMsgSender 被具现化）无法确切知道它是什么。而如果不知道 Company 是什么，就无法知道 class MsgSender&lt;Company&gt; 看起来是个什么样 —— 更明确的说是没办法知道它是否有个 sendClear 函数。</p>
<hr>
<p>为了让问题具体化，假设有个 class CompanyZ 只是用加密通信：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompanyZ</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般性的 MsgSender template 对 CompanyZ 并不合适，因为那个 template 提供了一个 sendClear 函数（其中针对其类型参数 Company 调用了 sendCleartext 函数），而这对 CompanyZ 对象并不合理。与纠正这个问题，我们可以针对 CompanyZ 产生一个 MsgSender 特化版；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;                                            <span class="comment">//一个全特化的 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MsgSender</span>&lt;CompanyZ&gt;&#123;                <span class="comment">// MsgSender；它和一般 template 相同 </span></span><br><span class="line"><span class="keyword">public</span>:                                                    <span class="comment">//差别只在于它删掉了 sendClear </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendSecret</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意 class 定义式最前头 “template&lt;&gt;” 语法象征这既不是 template 也不是标准 class，而是个特化版的 MsgSender template，在 template 实参是 CompanyZ 时被使用。这事模板全特化（total template specialization）：template MsgSender 针对类型 CompanyZ 特化了，而且其特化是全面性的，也就是说一旦类型参数被定为 CompanyZ，再没有其他 template 参数可供变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        将传送前信息写至log； </span><br><span class="line">        <span class="built_in">sendClear</span>(info); </span><br><span class="line">        将传送后信息写至log；</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那就是为什么 C++ 拒绝这个调用的原因：它知道 base class template 可能被特化，而那个特化版本可能不提供和一般属性 template 相同的接口。因此它往往拒绝在 templatized base class（模板化基类，MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的 SendClear）。从 Object Oriented C++ 跨进 Template C++ 继承就不想以前那般畅通无阻了。</p>
<hr>
<p>我们必须令 C++ “进入 templatized base classes 观察”。有三个办法：</p>
<ul>
<li><p>第一个办法是 base class 函数调用动作之前加上 “this-&gt;”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        将传送前信息写至log； </span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">sendClear</span>(info); <span class="comment">//成立，假设sendClear将被继承 </span></span><br><span class="line">        将传送后信息写至log；</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个办法是使用 using 声明式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;    <span class="comment">// 告诉编译器，请他假设 sendClear 位于 base class 内 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        将传送前信息写至log； </span><br><span class="line">        <span class="built_in">sendClear</span>(info); <span class="comment">//成立，假设sendClear将被继承 </span></span><br><span class="line">        将传送后信息写至log；</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三个做法是，明白指出被调用的函数位于 base class 内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMsgSender</span>: <span class="keyword">public</span> MsgSender&lt;Company&gt;&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="type">const</span> MsgInfo&amp; info)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        将传送前信息写至log； </span><br><span class="line">        MsgSender&lt;Company&gt;::<span class="built_in">sendClear</span>(info); <span class="comment">//成立，假设sendClear将被继承 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但这往往不是令人满意的一个解法，因为如果被调用的是 virtual 函数，上述的明确资格修饰 MsgSender<Company>:: 会关闭 virtual 绑定行为。</p>
</li>
</ul>
<p>从名称可视点的角度出发，上述每个解法做的事情都相同：对编译器承诺 “base class template 的任何特化版本都将支持其一般化版本所提供的接口”。这样一个承诺是编译器在解析（parse）像 LoggingMsgSender 这样的 derived class template 时需要的。但如果这个承诺最终未被实践出来，往后的编译器最终还是会给事实一个公道。例如，如果稍后的源码内含这个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender; </span><br><span class="line">MsgInfo msgData; </span><br><span class="line">zMsgSender.<span class="built_in">sendClearMsg</span>(msgData);        <span class="comment">// 错误！无法通过编译。</span></span><br></pre></td></tr></table></figure>

<p>因为在那个点上，编译器知道 base class 是个 template 特化版本 MsgSender&lt;CompanyZ&gt;，而它们知道那个 class 不提供 sendClear 函数，而这个函数却是 sendClearMsg 尝试调用的函数。</p>
<p>根本而言，面对 “指涉 base class members” 之无效的 references，编译器的诊断时间可能发生在早期（当解析 derived class template 的定义式时），也可能发生在晚期（当那些 templates 被特定之 template 实参具现化时）。C++ 的政策是宁愿早诊断。这就是为什么 “当 base classes 从 templates 中被具现化时” 它假设它对那 base classes 的内容毫无所悉的缘故。</p>
<p>记住：</p>
<blockquote>
<p>可在 derived class template 内通过 “this-&gt;” 指涉 base class template 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成。</p>
<p>附：以及using声明</p>
</blockquote>
<h1 id="条款44"><a href="#条款44" class="headerlink" title="条款44"></a>条款44</h1><blockquote>
<p>将与参数无关的代码抽离templates。</p>
</blockquote>
<p>templates 是节省时间和避免代码重复的奇方妙法。你不再需要键入 20 个类似的 classes 并且每一个都带有 20 个 成员函数，你只需要键入一个 class template，留给编译器去具现化那 20 个你需要的相关 classes 即可，而且对于 20 个函数中未被调用的，编译器不会自动生成。</p>
<p>但是，这也很容易使得代码膨胀（code bloat），templates 产出码带着重复，或者几乎重复的代码，数据，或者两者。你可以通过：共性与变形分析（commonality and variability analysis）来避免代码膨胀。</p>
<p>这个概念其实你早在使用，即使你从未写过一个 templates。当你编写某个函数时，你明白其中某些部分的实现码和另一个函数的实现码实质相同，你会很单纯的重复它们吗？当然不，你会抽出这两个函数相同的部分，放进第三个函数中，然后令原先两个函数调用这个新函数。也就是说：你分析了两个函数的共性和变形，把公共的部分搬到一个新的函数中去，变化的部分保留在原来的函数不动。对于 class 也是这个道理，如果你明白某些 class 和另一个 class 具有相同的部分，你也会把共性搬到一个新的 class。</p>
<hr>
<p>templates 的优化思路也是如此，以相同的方式避免重复，但其中有个窍门。在 non-template 代码中，重复很明确。然而在 template 代码中，重复是隐晦的，毕竟只存在一份 template 代码，所以你必须自己去感受 template 具现化时可能发生的重复。</p>
<p>一种情况是 <code>template class 成员依赖 template 参数值</code>，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TryWithMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SquareMatrix&lt;<span class="type">int</span>,<span class="number">5</span>&gt;SquareMatrixFive;</span><br><span class="line">    SquareMatrixFive.<span class="built_in">Invert</span>();</span><br><span class="line">    SquareMatrix&lt;<span class="type">int</span>,<span class="number">10</span>&gt;SquareMatrixTen;</span><br><span class="line">    SquareMatrixTen.<span class="built_in">Invert</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码用于正方形矩阵求逆矩阵，其 template 接受一个类型参数 T 作为元素类型外，还接受一个类型为 size_t 的参数作为矩阵大小，这是非类型参数（non-type parameter）。这种参数不常见，但它们完全合法，而且相当自然。</p>
<p>在 TryWithMatrix 函数中，我们分别对 5*5 大小和 10*10 大小的矩阵求逆，但除了常量 5 和 10，其他函数的操作部分完全相同，但因为 template 参数不同的，编译器仍然会会具现化两份函数，这是 template 引起代码膨胀的典型例子。</p>
<p>下面是对 SquareMatrix 的一次修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">(std::<span class="type">size_t</span> InSize)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>:<span class="keyword">private</span> SquareMatrixBase&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::Invert;  <span class="comment">// 避免遮掩继承自 base 版的 Invert 函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Invert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Invert</span>(N); <span class="comment">//inline的转调用，基类的不是inline，这才使得代码不会膨胀，如果基类也inline，则没有意义</span></span><br><span class="line">        					<span class="comment">//因为在使用时若是inline，还是会重复代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>就如你所看到的，带参数的 Invert 位于 base class SquareMatrixBase 中。和 SquareMatrix 一样，它也是个 template，不同的是它只对矩阵元素类型参数化，不对矩阵尺寸参数化，因此对于某给定的元素对象，所有的矩阵会共享唯一一个 SquareMatrixBase class，因此它们也因此共享这唯一一个 class 内的 Invert。从而避免了代码不必要的重复。如果元素类型与逆矩阵计算无关的话，甚至可以不对矩阵元素参数化，从而使得所有元素类型共享唯一一份 Invert 函数代码。</p>
<ul>
<li>SquareMatrixBase::invert只是企图成为”避免derived classes代码重复”的一种方法，所以它以protected替换public。</li>
<li>这些函数使用this-&gt;记号，因为若不这样做，便如条款43所说，模板化基类内的函数名称会被derived classes掩盖。（实际上感觉using已经完成了，但using不可被this替代，因为这里是同名的）</li>
<li>SquareMatrix和SquareMatrixBase之间的继承关系是private。这反应一个事实：这里的base class只是为了帮助derived classes实现，不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系。</li>
</ul>
<hr>
<p><code>SquareMatrixBase::invert</code>如何知道该操作什么数据？虽然它从参数中知道矩阵尺寸，但它如何知道哪个特定矩阵的数据在哪里呢。</p>
<p>一个可能的做法是为SquareMatrixBase::invert添加另一个参数，也许是个指针，指向一块用来放置矩阵数据的内存起始点。那行得通，但十之八九invert不是唯一一个可写为”形式与尺寸无关并可移至SquareMatrixBase内”的”SquareMatrix函数。如果有若干这样的函数，我们唯一要做的就是找出保存矩阵元素值的那块内存。我们可以对所有这样的函数添加一个额外参数，却得一次又一次地告诉SquareMatrixBase相同的信息，这样做不是很好。</p>
<p>可以令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存。而只要它存储了那些东西，也就可能存储矩阵的尺寸。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrixBase</span>  &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="type">size_t</span> n, T* pMenu)</span><br><span class="line">    :<span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem)  &#123;  &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span>  </span>&#123;  pData = ptr;  &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> size;</span><br><span class="line">    T* pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这允许derived class决定内存的分配方式，某些实现版本也许会决定将矩阵数据存储在SquareMatrix对象内部：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>(): <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, data)    <span class="comment">// 送出矩阵大小和数据指针给base class</span></span><br><span class="line">    &#123;  &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种类型的对象就不需要动态分配内存，但对象自身可能非常大。另一种做法就是把每一个矩阵的数据放进heap（也就是通过new来分配内存）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="type">size_t</span> n&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareMatrix</span>: <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>(): <span class="built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="number">0</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n*n])    <span class="comment">// 将base class的数据指针设为null，为矩阵内容分配内存</span></span><br><span class="line">    &#123;  <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>());  &#125;    <span class="comment">// 将指向该内存的指针存储起来，然后将它的一个副本交给base class</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::scoped_array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>但注意，之前直接使用模板参数的 Invert 函数，有可能产出比上面共享版本更好的代码，因为模板尺寸是一个编译器常量，因此可以像常量那样被直接生成到指令中成为立即操作数，达到更优化。</p>
<p>从另外一个角度来看，拥有共享的 Invert 函数，可减少执行文件的大小，降低了所需的内存，也提高了高速缓存命中率。这些都可能使得程序执行更快速。</p>
<p>哪一个影响占主要地位？需要进行实际的平台测试和观察面对代表性数据的行为。</p>
<p>类型参数（type parameters）也会导致代码膨胀。例如在许多平台上 int 和 long 二进制表示完全相同，所以像 vector&lt;int&gt; 和 vector&lt;long&gt; 有着相同的代码实现。某些链接器（linkers）会合并完全相同的函数实现码，但有些不会，后者意味着某些 templates 将具现化为 int 和 long 两个版本，从而造成代码膨胀。类似，在大多数平台上，所有指针类型都具有相同的二进制表示，因此凡是 template 拥有指针的，往往应该对每一个函数使用唯一一份底层实现。这很具代表性质，如果你实现某些成员函数而它们操作强型指针（strongly typed pointer）T*，你应该令它们调用另一个操作无类型的指针（untyped pointers，即 void*）的函数，由后者完成实际的工作。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>Templates 生成多个 classes 和多个 functions，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li>
</ul>
</blockquote>
<h1 id="条款45"><a href="#条款45" class="headerlink" title="条款45"></a>条款45</h1><blockquote>
<p>运用成员函数模板接受所有兼容类型。</p>
</blockquote>
<p>从例子入手，所谓智能指针（smart pointer），是行为像指针的对象，并提供指针没有的机能：自动管理资源。但原始指针（raw pointer）做的很好的一件事是：支持隐式转换（implicit conversions）。比如 derived class 指针可以隐式转换为 base class 指针，指向 non-const 的指针可以转换为 指向 const 的指针…下面是可能发生于三层继承体系的一些转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Top</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Middle</span>: <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottom</span>: <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle;                <span class="comment">// 将Middle*转换为Top*</span></span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom;                <span class="comment">// 将Bottom*转换为Top*</span></span><br><span class="line"><span class="type">const</span> Top* pct2 = pt1;                <span class="comment">// 将Top*转换为const Top*</span></span><br></pre></td></tr></table></figure>

<p>  但如果想在用户自定的智能指针中模拟上述转换，稍稍有点麻烦。我们希望以下代码通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:                                          <span class="comment">// 智能指针通常以内置指针完成初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = <span class="built_in">SmartPtr</span>&lt;Middle&gt;(<span class="keyword">new</span> Middle);   <span class="comment">// 将SmartPtr&lt;Middle&gt;转SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = <span class="built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);   <span class="comment">// 将SmartPtr&lt;Bottom&gt;转SmartPtr&lt;Top&gt;</span></span><br><span class="line">SmartPtr&lt;<span class="type">const</span> Top&gt; pct2 = pt1;                     <span class="comment">// 将SmartPtr&lt;Top&gt;转SmartPtr&lt;const Top&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于同一template的不同实例化之间没有直接联系，也就是说对于自定义的智能指针(假设名为SmartPtr)，如果不额外采取手段支持基层层次中派生类指针向基类指针的转换，那么SmartPtr&lt;Base&gt;和SmartPtr&lt;Derived&gt;将会被编译器认为毫无关联，也就不存在SmartPtr&lt;Derived&gt;向SmartPtr&lt;Base&gt;的隐式转换。</p>
<p>在上述智能指针实例中，每一个语句创建了一个新式智能指针对象，所以现在我们应该关注如何编写智能指针的构造函数，使其行为能够满足我们转型需要。一个很关键的观察结果是：我们永远无法写出我们需要的所有构造函数。在上述继承体系中，我们根据一个SmartPtr&lt;Middle&gt;或一个SmartPtr&lt;Bottom&gt;构造出一个SmartPtr&lt;Top&gt;，但如果这个继承体系未来有所扩充，SmartPtr&lt;Top&gt;对象又必须能够根据其他智能指针构造自己。假设日后添加了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BelowBottom</span>: <span class="keyword">public</span> Bottom &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>我们因此必须令SmartPtr&lt;BelowBottom&gt;对象得以生成SmartPtr&lt;Top&gt;对象，但我们当然不希望一再修改SmartPtr template以满足此类需求。</p>
<hr>
<p>就原理而言，此例中我们需要的构造函数数量没有止尽，因为一个template可被无限量具现化，已致生成无限量函数。因此，似乎我们需要的不是为SmartPtr写一个构造函数，而是为它写一个构造模板。这样的模板是所谓member function templates，其作用是为class生成函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;                  <span class="comment">// member template,</span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other);   <span class="comment">// 未来生成copy构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码的意思是，对任何类型T和任何类型U，这里可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;——因为SmartPtr&lt;T&gt;有个构造函数接受一个SmartPtr&lt;U&gt;参数。这一类构造函数根据对象U创建对象T，而U和T的类型是同一个template的不同具现体，有时我们称之为泛化copy构造函数。</p>
<p>上面的泛化copy构造函数并未被声明为explicit。那是蓄意的，因为原始指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，无需明白写出转型动作（cast），所以让智能指针效仿这种行径也属合理。在模板化构造函数中略去explicit就是为了这个目的。</p>
<hr>
<p>完成声明之后，这个为SmartPtr而写的“泛化copy构造函数”提供的东西比我们需要的更多。是的，我们希望根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，却不希望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottom&gt;（根据基类创建派生类），因为那对public继承而言（见条款32）是矛盾的。我们也不希望根据一个SmartPtr&lt;double&gt;创建一个SmartPtr&lt;int&gt;，因为现实中并没有“将int* 转换为double*”的对应隐式转换行为。是的，我们必须从某方面对这一member template所创建的成员函数群进行筛除。</p>
<p>假设SmartPtr遵循auto_ptr和tr1::shared_ptr所提供的榜样，也提供一个get成员函数，返回智能指针对象（见条款15）所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为，使它符合我们的期望：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="type">const</span> SmartPtr&lt;U&gt;&amp; other)</span>  <span class="comment">// 以other的heldPtr初始化this的heldPtr</span></span></span><br><span class="line"><span class="function">    : heldPtr(other.get()) &#123;</span> ... &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;      <span class="comment">// 这个SmartPtr持有内置指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用成员初值列来初始化SmartPtr&lt;T&gt;之内类型为T*的成员变量，并以类型为U*的指针（由SmartPtr&lt;U&gt;持有）作为初值。这个行为只有当“存在某个隐式转换可将一个U*指针转为一个T*指针”时才能通过编译，而那正是我们想要的。最终效益时SmartPtr&lt;T&gt;现在有了一个泛化copy构造函数，这个构造函数只在其所获得的实参隶属适当（兼容）类型时才通过编译。</p>
<hr>
<p>member function templates的效用不限于构造函数，它们常扮演的另一个角色是支持赋值操作。例如TR1的shared_ptr（见条款13）支持所有“来自兼容之内置指针、tr1::shared_ptrs、auto_ptrs和tr1::weak_ptrs(见条款54)”的构造行为，以及所有来自上述各物（tr1::weak_ptrs除外）的赋值操作。下面是TR1规范中关于tr1::shared_ptr的一份摘录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;                 </span><br><span class="line">     <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y* p)</span></span>;                        <span class="comment">// 构造，来自任何兼容的内置指针</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);               <span class="comment">// 或shared_ptr</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(weak_ptr&lt;Y&gt; <span class="type">const</span>&amp; r)</span></span>;        <span class="comment">// 或weak_ptr</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp; r)</span></span>;              <span class="comment">// 或auto_ptr</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;                                 </span><br><span class="line">     shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);    <span class="comment">// 赋值，来自任何兼容的shared_ptr</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp; r);            <span class="comment">// 或auto_ptr </span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述所有构造函数都是explicit，唯有“泛化copy构造函数”除外。那意味从某个shared_ptr类型隐式转换至另一个shared_ptr类型是被允许的，但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可（如果是显示转换和cast强制转型动作倒是可以）。另一个趣味点是传递给tr1::shared_ptr构造函数和assignment操作符的auto_ptrs并未被声明为const，与之形成对比的则是tr1::shared_ptrs和tr1::weak_ptrs都以const传递。这是因为条款13说过，当你复制一个auto_ptrs,它们其实被改动了。</p>
<p>member templates并不改变语言规则，而语言规则说，如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个。在class内声明泛化copy构造函数并不会阻止编译器生成它们自己的copy构造函数，所以如果你想要控制copy构造函数的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值操作。下面是tr1::shared_ptr的一份定义摘要，例证上述所言：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="type">const</span>&amp; r);    <span class="comment">// copy构造函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     <span class="built_in">shared_ptr</span>(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);               <span class="comment">// 泛化copy构造函数</span></span><br><span class="line">                </span><br><span class="line">     shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; r);    <span class="comment">// copy assignment</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt;</span><br><span class="line">     shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="type">const</span>&amp; );     <span class="comment">// 泛化copy assignment</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记住：</p>
<blockquote>
<ul>
<li>请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
</blockquote>
<h1 id="条款46"><a href="#条款46" class="headerlink" title="条款46"></a>条款46</h1><blockquote>
<p>需要类型转换时请为模板定义非成员函数。</p>
</blockquote>
<p>条款24讨论过为什么唯有non-member函数才有能力“在所有实参身上实施隐式类型转换”，该条款并以Rational class的operator*函数为例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Rational</span>(<span class="type">const</span> T&amp; numberator = <span class="number">0</span>, <span class="type">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="type">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p> 像条款24一样，我们希望支持混合式算数运算，所以我们希望以下代码顺利通过编译。我们也预期它会，因为它正是<a target="_blank" rel="noopener" href="https://blog.csdn.net/yj_android_develop/article/details/105460535">条款24</a>所列的同一份代码，唯一不同的是Rational和operator*如今都成了templates：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="type">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="type">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">// 错误！无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>上述失败给我们的启示是，模板化的Rational内的某些东西似乎和其non-template版本不同。事实的确如此。在条款24内，编译器知道我们尝试调用什么函数（就是接受两个Rationals参数的那个operator*），但这里编译器不知道我们想要调用哪个函数。取而代之的是，它们试图想出什么函数被名为operator*的template具现化出来。它们知道它们应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为完成这一具现化行动，必须先算出T是什么。问题是它们没这个能耐。</p>
<hr>
<p>为了推导T，它们看了看operator*调用动作中的实参类型。本例中那些类型分别是Rational&lt;int&gt;(oneHalf的类型)和int(2的类型)。每个参数分开考虑。</p>
<p>以oneHalf进行推导，过程并不困难。operator*的第一个参数被声明为Rational&lt;T&gt;，而传递给operator*的第一实参（oneHalf）的类型是Rational&lt;int&gt;，所以T一定是int。其他参数的推导则没有这么顺利。operator*的第二参数被声明为Rational&lt;T&gt;，但传递给operator*的第二实参（2）类型是int。</p>
<p>编译器如何根据这个推算出？你或许会期盼编译器使用Rational&lt;int&gt;的non-explicit构造函数将2转换为Rational&lt;int&gt;，进而将T推导为int，但它们不那么做，因为在template实参推导过程中从不将隐式类型转换函数纳入考虑（因为这样的转换在函数调用过程中出现，但在调用之前，函数首先得存在）。</p>
<hr>
<p>只要利用一个事实，我们就可以缓和编译器在template实参推导方面受到的挑战：template class内的friend声明式可以指涉某个特定函数。那意味Rational&lt;T&gt;可以声明operator*是它的一个friend函数。Class templates并不依赖template实参推导（后者只施行于function templates身上），所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。因此，令Rational&lt;T&gt; class声明适当的operator*为其friend函数，可简化整个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">friend</span></span><br><span class="line">        <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs); <span class="comment">//这个函数与后面的函数并不相同，这个声明</span></span><br><span class="line">        						 	<span class="comment">//并不是后面那个函数的声明，这个函数的T已经和类绑定在一起了，因此不是相同的函数</span></span><br><span class="line">&#125;;									<span class="comment">//所以也没有定义式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在对operator的混合式调用可以通过编译了，因为当对象 oneHalf被声明为一个Rational&lt;int&gt;, class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非函数模板，因此编译器可在调用它时使用隐式转换函数（例如Rational的non-explicit构造函数），而这便是混合式调用之所以成果的原因。</p>
<p> 但是，此情境下的“成功”是个有趣的字眼，因为虽然这段代码通过编译，却无法连接。稍后我马上回来处理这个问题，首先我要谈谈在Rational内声明operator*的语法。</p>
<p>在一个class template内，template名称可被用来作为“template和其参数”的简略表达方式，所以在Rational&lt;T&gt;内我们可以只写Rational而不必写Rational&lt;T&gt;。本例中这只节省我们少打几个字，但若出现许多参数，或参数名称很长，这可以节省我们的时间，也可以让代码比较干净。我谈这个是因为，本例中的operator*被声明为接受并返回Rationals（而非Rational&lt;T&gt;）。如果它被声明如下，一样有效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">        <span class="type">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="type">const</span> Rational&lt;T&gt;&amp; rhs);</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 然而使用简略表达式比较轻松也比较普遍。</p>
<hr>
<p>现在回头想想我们的问题。混合式代码通过了编译，因为编译器知道我们要调用哪个函数，但哪个函数只被声明与Rational内，并没有被定义出来。我们意图令此class外部的operator* template提供定义式，但是行不通——如果我们自己声明了一个函数，就有责任定义那个函数。既然我们没有提供定义式，连接器当然找不到它！</p>
<p>或许最简单的可行办法就是将operator*函数本体合并至其声明式内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">friend</span></span><br><span class="line">        <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numberator</span>() * rhis.<span class="built_in">numberator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这便如同我们所期望地正常运作了起来：对operator*的混合式调用现在可以编译并执行。</p>
<p>这项技术的趣味点是，虽然我们使用 friend 关键字，却和其传统用途：访问 class 的 non-public 成分不同。我们是为了让类型转换发生在所有可能的实参上，我们需要一个 non-member 函数；而为了使这个函数自动具现化，我们需要将它声明在 class 内部，而在 class 内部声明 non-member 函数的唯一有效方法就是：令它成为一个 friend。</p>
<p>一如条款30所说，<code>定义于 class 内的函数都将暗自 inline</code>，所以一个更好的做法是：令该 friend 函数调用另一个辅助函数（减少代码膨胀）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; RationalOne, <span class="type">const</span> Rational&amp; RationalTwo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">OnMultiply</span>(RationalOne,RationalTwo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Rational&lt;T&gt; <span class="title">OnMultiply</span><span class="params">(<span class="type">const</span> Rational&lt;T&gt;&amp; RationalOne, <span class="type">const</span> Rational&lt;T&gt;&amp; RationalTwo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>&lt;T&gt;(RationalOne.<span class="built_in">numberator</span>() * RationalTwo.<span class="built_in">numberator</span>(),</span><br><span class="line">                     RationalOne.<span class="built_in">numberator</span>() * RationalTwo.<span class="built_in">numberator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住：</p>
<blockquote>
<p>当我们编写一个 class template，而它所提供之“与此 template 相关的”函数支持“所有参数隐式类型转换”时，请将那些函数定义为 “class template 内部的 friend 函数”。</p>
</blockquote>
<h1 id="条款47"><a href="#条款47" class="headerlink" title="条款47"></a>条款47</h1><blockquote>
<p>请使用traits classes 表现类型信息。</p>
</blockquote>
<p>STL主要由容器、迭代器和算法的templates构成，也包含若干工具性templates。当中有一个advance用来将迭代器移动某个给定距离：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>;<span class="comment">//d大于零。向前移动，小于零则向后移动</span></span><br></pre></td></tr></table></figure>

<p>表面上看，仅仅是iterate+&#x3D;d的动作，可是迭代器有5种。仅仅有random access（随机訪问）迭代器才支持+&#x3D;操作。其它类型没这么大威力。仅仅有重复++和–才行。这里也回想一下这5种迭代器。</p>
<ul>
<li>input迭代器。它是read only，仅仅能读取它指向的对象，且仅仅能读取一次。它仅仅能向前移动。一次一步。它模仿指向输入文件的阅读指针（read pointer）；C++程序中的istream_iterators就是这类的代表。</li>
<li>output迭代器，和input迭代器相反。它是write only。它也是仅仅能向前移动，一次一步。且仅仅能涂写一次它指向的对象。它模仿指向输出文件的涂写指针（write pointer）；ostream_iterators是这一类代表。</li>
<li>forward迭代器。这个迭代器派生自input迭代器，所以有input迭代器的全部功能。而且他能够读写指向的对象一次以上。</li>
<li>bidirectional迭代器继承自forward迭代器，它的功能还包含向后移动。STL中的list、set、multiset、map、和multimap迭代器就是这一类迭代器。</li>
<li>random access迭代器继承自bidirectional迭代器。它厉害的地方在于能够向前或向后跳跃随意距离，这点相似原始指针，内置指针就能够当做random access迭代器使用。vector、deque和string的迭代器就是这类。</li>
</ul>
<p>这5中分类。C++标准程序库提供专属卷标结构（tag struct）加以确认：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在了解了迭代器类型后，我们该去实现advance函数了。实现要高效。对于random access迭代器来说，前进d距离要一步完毕。而其它类型则须要重复前进或后退</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IteT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iter is a random access iterator)</span><br><span class="line">        iter+=d;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面实现中要推断iter是否为random access迭代器。即要知道IterT类型是否为random access类型。这就须要traits,它同意我们在编译期间获取某些类型信息。traits是一种技术，是C++程序猿共同遵守的协议。</p>
<p>这个技术要求之中的一个就是，它对内置类型和自己定义类型表现的一样好。如果接受的指针是const char*，advance也必须能够工作。traits必须能够施行于内置类型。意味着“类型内的嵌套信息”这种东西出局了，因为我们无法将信息嵌套于原始指针内。</p>
<p>所以类型的traits信息必须位于类型自身之外。标准技术是把它放进一个template及其一个或多个特化版本号中。这种templates在STL中有若干个，迭代器的为iterator_traits：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;<span class="comment">//用来处理迭代器分类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>;</span><br></pre></td></tr></table></figure>

<p>尽管iterator_traits是个struct，往往称作traits classes。其运作方式是，针对每个类型IterT，在struct iterator_traits内声明某个typedef命名为iterator_category，用来确认IterT的迭代器分类。iterator_traits以两个部分实现上述所言。</p>
<hr>
<p>它要求用户自己定义的迭代器嵌套一个typedef，名为iterator_category。用来确认是哪个卷标结构（tag struct），比如deque和list</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">deque</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">iterator</span>&#123;</span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">           <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">           ……</span><br><span class="line">       &#125;;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">list</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="keyword">class</span> <span class="title class_">iterator</span>&#123;</span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">           <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">           ……</span><br><span class="line">       &#125;;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;<span class="comment">//IterT的iterator_category就是用来表现IterT说自己是什么</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">       <span class="comment">//typedef typename的使用。见条款42</span></span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">       ……</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>这样对用户自己定义类型行得通，可是对指针行不通，指针也是迭代器。可是指针不能嵌套typedef。以下就是iterator_traits的第2部分了。专门用来支持指针。为了支持指针迭代器。iterator_traits特别针对类型提供一个偏特化版本号（partial template specialization）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;IterT*&gt;<span class="comment">//针对内置指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如今能够知道实现一个traits class步骤了</p>
<ul>
<li>确认若干我们希望将来可取得的类型相关信息。对于迭代器来说，就是能够取得其分类。</li>
<li>为该信息选择一个名称。对于迭代器是iterator_category。</li>
<li>提供一个template和一组特化版本号。内含你希望支持的类型和相关信息。</li>
</ul>
<hr>
<p>现在能够实现一下advance了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DisT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category)==</span><br><span class="line">    <span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管逻辑是正确，但并不是是我们想要的。抛开编译问题（条款48），另一个更根本的问题：IterT类型在编译期间获知。所以iterator_traits::iterator_category在编译期间确定。</p>
<p>可是if语句却是在执行期间核定。能够在编译期间完毕的事情推到执行期间，这不仅浪费时间，还造成执行文件膨胀。要在编译期间确定。能够使用重载。重载是在编译期间确定的，编译器会找到最匹配的函数来调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, Dist d, std::random_access_iterator_tag)</span><span class="comment">//tag不需要参数名，没必要</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, Dist d, std::bidirectional_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DisT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, Dist d, std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT,<span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter,DistT d)</span><span class="comment">//上层调用，获取类型信息来供编译器选择重载函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">doAdvance</span>(iter,d,<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于forward_iterator_tag继承自input_iterator_tag，所以input_iterator_tag版本号的函数能够处理forward迭代器。这是由于public继承是is-a关系。实际上，random和bidirectional也是（is-a）input迭代器，但编译器会选择匹配程度最高的。</p>
<p>总结一下怎样使用traits class</p>
<ul>
<li>建立一组重载函数或函数模板（比如doAdvance）。彼此间差异仅仅在于各自的traits參数。每个函数实现与之接受的traits信息像匹配。</li>
<li>建立一个控制函数或函数模板（比如advance），调用上面的函数并传递traits class信息。</li>
</ul>
<hr>
<p>traits 广泛应用于标准库，包括上述iterator_traits，除了iterator_category，iterator_traits还供应四分迭代器相关信息(value_type指明迭代器所指对象类型，difference_type指明迭代器距离类型，pointer指明对象的原生指针类型，reference指明对象的引用类型。此外还有char_traits用于保存字符类型的相关信息，numeric_limits用于保存数值类型相关信息等等。</p>
<p>TR1导入许多新的traits classes用以提供类型信息,包括is_fundamental&lt;T&gt;(判断T是否为内置类型),is_array&lt;T&gt;(判断T是否为数组类型),is_base_of&lt;T1,T2&gt;(判断T1,T2是否相同,抑或T1是T2的base classes).总计TR1一共为C++添加了50个以上的trait classes.</p>
<p>记住：</p>
<blockquote>
<ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。</li>
<li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试。</li>
</ul>
</blockquote>
<h1 id="条款48"><a href="#条款48" class="headerlink" title="条款48"></a>条款48</h1><blockquote>
<p>认识template元编程。</p>
</blockquote>
<p>Template metaprogramming(TMP,模板元编程）是编写template-based C++程序，编译的过程。template metaprogramming是用C++写的模板程序，编译器编译出具体化的过程。也就是说，TMP程序执行后，从templates具体化出来C++源码，不再是模板了。</p>
<p>TMP有两个作用，一是它让某些事更容易。例如编写STL容器，使用模板，可是存放任何类型元素。二是将执行在运行期的某些工作转移到了编译期。还有一个结果是使用TMP的C++程序可能在其他方面更高效：较小的可执行文件、较短的运行期、较少的内存需求。但是将运行期的工作转移到了编译期，编译期可能变长了。</p>
<p>再看一下条款47中的advance伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function">   <span class="type">void</span> <span class="title">advance</span><span class="params">(IteT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(iter is a random access iterator)</span><br><span class="line">           iter+=d;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)</span><br><span class="line">               <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以使用typeid让判断iter类型的伪码运行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iter, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function">   <span class="type">void</span> <span class="title">advance</span><span class="params">(IteT&amp; iter,DistT d)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">       ==<span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">           iter+=d;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)</span><br><span class="line">               <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>typeid-based解法效率比traits解法低，因为在此方案中，1.类型测试发生在运行期而不是编译期，2.运行期类型测试代码在（或被连接于）可执行文件中。这个例子可以说明TMP比正常的C++程序更高效，因为traits解法就是TMP。</p>
<p>一些东西在TMP比在正常的C++更容易，advance提供一个好例子。advance的typeid-based实现方式可能导致编译期问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">advance</span>(iter,<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(std::list&lt;<span class="type">int</span>&gt;::iterator&amp; iter,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">typeid</span>(<span class="keyword">typename</span> std::iterator_traits&lt;std::list&lt;<span class="type">int</span>&gt;::iterator&gt;::iterator_category)</span><br><span class="line">    ==<span class="built_in">typeid</span>(std::random_access_iterator_tag))</span><br><span class="line">        iter+=d;<span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">while</span>(d++) --iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在+&#x3D;这个操作符上是错误调用。因为list::iterator不支持+&#x3D;，它是bidirectional迭代器。我们知道不会执行+&#x3D;那一行，因为typeid那一行总是不相等；但是编译期要确保所有源码都有效，即使是不会执行的代码。traits-based TMP解法针对不同类型执行不同代码，不会出现上述问题。</p>
<hr>
<p>TMP已被证明是个图灵完全机器，也就是说它的威力足以计算任何事物。可以使用TMP声明变量、执行循环、编写调用函数……。有时候这会和正常C++对应物看起来很是不同，例如条款 47展示的TMP if-else是由templas和其特化具体表现出来。不过那是汇编语言级的TMP。针对TMP设计的程序库（例如Boost’s MPL，条款55）提供更高级的语法。</p>
<p>为了再次认识下事物在TMP中如何运作，来看下循环。TMP没有真正循环，循环由递归（recursion）完成。TMP递归甚至不是正常的递归，因为TMP递归不涉及递归函数调用，而是涉及递归模板化（recursive template instantiation）。</p>
<p>TMP的起手程序是在编译期计算阶乘。TMP的阶乘运输示范如何通过递归模板具体化实现循环，以及如何在TMP中创建和使用变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;value=n*Factorial&lt;n<span class="number">-1</span>&gt;::value&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt;&#123; <span class="comment">//特殊情况，Factorial&lt;0&gt;的值是1</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;value=<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了这个template metaprogram，只要指涉Factorial::value就可以得到n阶乘值。循环发生在template具体化Factorial内部指涉另一个template具体化Factorial之时。特殊情况的template特化版本Factorial&lt;0&gt;是递归的结束。</p>
<p>每个Factorial template具体化都是一个struct，每个struct都声明一个名字为value的TMP变量，用来保存当前计算所获得的阶乘值。TMP以递归模板具体化取代循环，每个具体化有自己一份value，每个value有其循环内适当值。</p>
<p>用Factorial示范TMP就像用hello world示范编程语言一样。为了领悟TMP之所以值得学习，就要先对它能够达成什么目标有一个比较好的理解。下面举三个例子：</p>
<ul>
<li><p>确保量度单位正确。使用TMP就可以确保在编译期所有量度单位的组合都正确。</p>
</li>
<li><p>优化矩阵运算。条款 21曾经提到过某些函数包括operator * 必须返回新对象，在条款44中有一个SquareMatrix。如果这样使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SquareMatrix&lt;<span class="type">double</span>,<span class="number">1000</span>&gt; BigMatrix;</span><br><span class="line">BigMatrix m1,m2,m3,m4,m5;</span><br><span class="line">……</span><br><span class="line">BigMatrix result=m1 * m2 * m3 * m4 * m5;</span><br></pre></td></tr></table></figure>

<p>上面乘法会产生四个临时性矩阵，乘法还可能产生了4个作用在矩阵元素身上的循环。如果使用高级、与TMP相关的template（即expression templates），就有可能消除那些临时对象并合并循环。所以TMP使用较少内存，执行速度也有提升。</p>
</li>
<li><p>可以生成客户定制之设计模式（custom design pattern）实现品。使用policy-based design之TMP-based技术，有可能产生一些templates用来表述独立的设计项（所谓policies），然后可以任意结合它们，导致模式实现品带着客户定制的行为。</p>
</li>
</ul>
<p>TMP目前还不完全成熟，语法不直观，支持的工具还不充分。但TMP对难以或甚至不可能于运行期实现出来的行为表现能力很吸引人。虽然TMP不会成为主流，但是会成为一些程序员（特别是程序库的开发人员）的主要粮食。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>Template metaprogramming（TMP，模板元编程）可将工作由运行期移到编译期，因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP可被用来生成“基于政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li>
</ul>
</blockquote>
<h1 id="条款49"><a href="#条款49" class="headerlink" title="条款49"></a>条款49</h1><blockquote>
<p>了解new-handler的行为。</p>
</blockquote>
<p>在operator new抛出异常以前，会先调用一个客户指定的错误处理函数：new-handler。（这其实并非全部事实，operator new 真正做的事更复杂，见条款51）。为了指定这个“用以处理内存不足”的函数，客户必须调用 set_new_handler，那是声明于 &lt;new&gt; 的标准程序库函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;<span class="comment">//*new_handler是个typedef,定义出一个指针指向函数，该函数没有参数也不返回任何东西</span></span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set_new_handler 是“获得一个 new-handler 并返回一个 new-handler ” 的函数，后面的 throw() 是一份异常明细，表示该函数不抛出任何异常。</p>
<p>set_new_handler 的参数是个指针，指向 operator new 无法分配足够内存时该被调用的函数；其返回值也是个指针，指向set_new_handler被调用前正在执行的那个 new-handler 函数。可以这样使用set_new_handler ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span>	<span class="comment">//operator new 无法分配足够内存时该被调用的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cerr&lt;&lt;<span class="string">&quot;Unable to satisfy request for memoryn&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line">    <span class="type">int</span> *pBigDataArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果operator new无法为100000000个整数分配足够空间，outOfMem会被调用，于是程序在发出一个信息之后夭折(abort)。</p>
<p>当operator new无法满足内存申请时，它会不断调用 new-handler 函数，直到找到足够内存。反复调用的代码在条款51讨论。这里先说一下，设计良好的new-handler必须做好以下事情：</p>
<ul>
<li>让更多内存可被使用：这样可以造成operator new内的下一次内存分配动作可能成功。一个做法是，程序一开始就分配一大块内存，当 new-handler 第一次被调用时将它释放。</li>
<li>安装另一个new-handler：当前的 new-handler 无法取得更多可用内存时，或许它知道另外哪个new-handler有此能力。如果真这样，可用使用 set_new_handler 来替换有能力的那个。</li>
<li>卸除 new-handler：即将null指针传给 set_new_handler，一旦没有安装任何 new-handler，operator new 在内存分配不成功时便抛出异常。</li>
<li>抛出 bad_alloc(或派生自bad_alloc)的异常：这样的异常不会被 operator new 捕捉，因此不会被传播到内存索求处。</li>
<li>不返回：通常 abort 或 exit 。</li>
</ul>
<hr>
<p>有时候，我们希望处理内存分配失败的情况和类相关。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMemory</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">outOfMemory</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X* p1 = <span class="keyword">new</span> X;<span class="comment">//分配不成功，调用X::outOfMemory</span></span><br><span class="line">Y* p2 = <span class="keyword">new</span> Y;<span class="comment">//分配不成功，调用Y::outOfMemory</span></span><br></pre></td></tr></table></figure>

<p>C++并不支持类专属的 new-handler，但是我们自己可以实现这种行为。令每一个类提供自己的 set_new_handler 和 operator new即可。其中 set_new_handler 使客户得以指定类专属的 new-handler，operator new则确保在分配类对象内存的过程中以类专属的 new-handler替换 global new-handler。</p>
<p>假设打算处理 Widget 类 内存分配失败的情况。首先要有一个”当 operator new 无法为Widget 分配足够内存时”调用的函数，所以你需要声明一个类型为 new_handler 的 static 成员，用以指向 Widget 的 new-handler，看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line">std::new_handler Widget::currentHandler = <span class="number">0</span>;	<span class="comment">//static成员需要在类外定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;	<span class="comment">//存储之前的new-handler</span></span><br><span class="line">    currentHandler = p;								<span class="comment">//设置新的new-handler</span></span><br><span class="line">    reutrn oldHandler;								<span class="comment">//返回之前的new-handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Widget 的 operator new 做以下事情：</p>
<ul>
<li>调用标准 set_new_handler，告知 Widget 的错误处理函数。这会将 Widget 的 new-handler 安装为 global new-handler。</li>
<li>调用 global operator new 分配内存。如果失败，global operator new 会调用 Widget 的 new-handler，因为那个函数才刚被安装为 global new-handler。如果 global operator new 最终无法分配足够内存，会抛出一个 bad_alloc 异常。这时 Widget 的operator new 必须恢复原本的 global new-handler，之后再传播该异常。为确保原本的 new-handler 总是能够被重新安装回去，使用资源管理对象防止资源泄漏（见条款13）。</li>
<li>如果 global operator new 分配内存成功，Widget 的 operator new 会返回一个指针，指向分配的内存。Widget 析构函数会管理 global new-handler，它会自动将 Widget’s operator new 被调用前的那个 global new-handler 恢复回来。</li>
<li>附：这里无论分配内存成功或失败，都要把旧的的new-handler用std::set_new_handler恢复（实际上安装也是使用set_new_handler，最终使用的都是std的，自定义的版本只是负责安装和回收），这是因为这个new只是针对Widget的，这件事情发生完，Widget安装的new-handler就应该换回去。</li>
</ul>
<p>下面以C++代码再阐述一次，将从资源管理类开始，那里只有基础性RAII操作，再构造过程中获得一笔资源，并在析构中释还（见条款13）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerHolder</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : handlere(nh)&#123;</span>&#125;<span class="comment">//存储旧handler</span></span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123; </span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(handler); <span class="comment">//恢复handler</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="comment">//阻止拷贝</span></span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这使得<code>Widget</code>类的 operator new 函数的实现变得简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用std::set_new_handler()安装Widget的new-handler,并返回global new-handler 存储在资源管理类中</span></span><br><span class="line">    <span class="comment">//分配内存或抛出异常时，在资源管理类的析构函数中恢复global new-handler</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Widget客户应该类似这样使用其new-handling：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;					<span class="comment">//函数声明，此函数在 Widget 对象分配失败时被调用</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(outOfMem);	<span class="comment">//设定 outOfMem 为 Widget 的 new-handling 函数，set_new_handler是静态函数</span></span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;			<span class="comment">//若内存分配失败，则调用 outOfMem 函数</span></span><br><span class="line"></span><br><span class="line">std::string* ps = <span class="keyword">new</span> std::string;	<span class="comment">//内存分配失败则调用 global new-handling（如果有的话）</span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);			<span class="comment">//设定 Widget 专属 new-handling 为 null</span></span><br><span class="line">Widget* pw2 = <span class="keyword">new</span> Widget;			<span class="comment">//若内存分配失败则立刻抛出异常，因为 Widget 没有专属 new-handling函数</span></span><br></pre></td></tr></table></figure>

<hr>
<p>实现这个方案的代码并不因 class 的不同而不同，因此在其它地方也复用这个代码是个合理的构想。一个简单的方式是建立起一个“mixin” 风格的基类，这种基类用来允许派生类继承单一特定能力——在本例中是“设定类专属的 new-handler 能力”。然后将这个基类转换为模板，如此一来每个派生类将获得实体互异的 class data 复件。</p>
<p>这个基类让其派生类继承它获取 set_new_handler和 operator new函数，而模板部分确保每一个派生类获得一个实体互异的currentHandler 成员变量。实现代码和前一个版本的近似，唯一真正意义上不同的是，它现在可被任何有所需要的类使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewHandlerSupport</span>&#123;		<span class="comment">// &quot;mixin&quot; 风格的基类，用以支持类专属的set_new_handler</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...							<span class="comment">//其它的 operator new 版本，见条款52</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="type">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(size);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//以下将每一个实体互异的 currentHandler 初始化为null</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;<span class="comment">//静态变量初始化</span></span></span></span><br></pre></td></tr></table></figure>

<p>有了这个 类模板，为 <code>Widget</code> 添加 <code>set_new_handler</code>支持能力就容易了：只要令 <code>Widget</code> 继承自 <code>NewHandlerSupport&lt;Widget&gt;</code> 就好，像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>:<span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123;</span><br><span class="line">	<span class="comment">//和先前一样，但不必声明 set_new_handler 和 operator new 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>NewHandlerSupport</code> 模板中，从未使用到 类型T，这是为什么呢？</p>
<p>实际上 T 的确不需被使用。我们只希望继承 NewHandlerSupport 的每一个 类 拥有自己的 NewHandlerSupport 复件（其 static 成员变量 currentHandler ），类型参数 T 是用来区分不同的 派生类，模板机制会自动为每一个 T 生成一份 currentHandler 成员变量。</p>
<p>虽然通过继承 <code>NewHandlerSupport</code> ，使得“为任何类添加一个它们专属的new-handler”成为一件很容易的事，但 “mixin” 风格的继承肯定导致 多重继承 的争议，要注意条款40所提到的内容。</p>
<hr>
<p>C++中新一代的 operator new 分配失败抛出异常 bad_alloc，但是旧标准是返回 null 指针，为了兼容以前使用旧标准的C++程序，C++委员会提供了另一种符合旧标准形式的 operator new ， 这个形式被称为 “nothrow” 形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;				<span class="comment">//分配失败，抛出bad_alloc</span></span><br><span class="line"><span class="keyword">if</span>(pw1 == null) &#123; ... &#125;					<span class="comment">//判断是否分配成功。但是这个测试一定失败</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="built_in">new</span> (std::nothrow)Widget;	<span class="comment">//分配失败，返回null</span></span><br><span class="line"><span class="keyword">if</span>(pw2 == null) &#123; ... &#125;					<span class="comment">//这个测试可能成功</span></span><br></pre></td></tr></table></figure>

<p>nothrow new 对 异常的强制保证性（见条款29）并不高。表达式 new (std::nothrow)Widget 会发生两件事：</p>
<p>第一，分配内存给 Widget 对象，如果失败返回 null ；第二，如果成功，调用 Widget 的构造函数，在这个构造函数中可能又 new 一些内存，但没人可以强迫它再次使用 nothrow new。因此，虽然 new (std::nothrow)Widget 调用的 operator new 函数并不抛出异常，但 Widget 的构造函数可能会抛出异常 。</p>
<p>结论是：使用 nothrow new 只能保证 operator new 不抛出异常，不能保证像new (std::nothrow)Widget这样的表达式不抛出异常。所以，并没有使用 nothrow 的需要。</p>
<p>无论使用正常（会抛出异常）的 new，或是不抛出异常的 nothrow new ，重要的是需要了解 new-handler 的行为，因为两种形式都使用到 new-handler。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>set_new_handle 允许用户指定一个函数，在内存分配无法获得满足时被调用</li>
<li>nothrow new 是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是有可能抛出异常</li>
</ul>
</blockquote>
<h1 id="条款50"><a href="#条款50" class="headerlink" title="条款50"></a>条款50</h1><blockquote>
<p>了解new和delete的合理替换时机。</p>
</blockquote>
<p>有人会想要替换掉编译器提供的 operator new 或 operator delete，有三个理由：</p>
<ul>
<li>用来检测运用上的错误：如果将“new 所得内存” delete 掉却失败，会导致内存泄漏。如果在“new 所得内存”身上多次 delete 会导致不确定行为。使用编译器提供的operator new和operator delete不能检测上述行为。如果 operator new 持有一串动态分配所得地址，而 operator delete 将地址从中移走，这样容易检测出上述错误用法。此外各式各样的编程错误可能导致数据 “overruns”（写入点在分配区块尾端之后）或 “underruns”（写入点在分配区块起点之前）。这时可以自己定义operator new 便可超额分配内存，在额外空间（位于用户所得区块之前或之后）写上特定 byte patterns（即签名，signature），自己定义 operator delete 检 测签名是否更改，若被更改了表示在分配区的某个生命时间点发生了 overrun 或 underrun，这时 operator delete 可以记录（log）那个事实以及那个签名被更改的指针。</li>
<li>为了强化效能：我们所用的编译器中自带的operator new和operator delete主要是用于一般的目的能够为各种类型的程序所接受，而不考虑特定的程序类型。它们必须处理一系列需求，必须接纳各种分配形态，必须要考虑破碎问题等等。因此编译器所带的operator new和operator delete采取中庸之道也是没办法的事情。它们的工作对每个人都是适度地好，但不对特定任何人有最佳表现。通常可以发现，定制版之operator new和operator delete性能胜过缺省版本。所谓的’胜过’，就是它们比较快，有时甚至快很多，而且它们需要内存比较少，最高可省50%。所以说对某些运用程序而言，将缺省new和delete替换为定制版本，是获得重大效能提升的办法之一。</li>
<li>为收集使用上的统计数据：在自定义 operator new 和 operator delete 之前，应该首先了解软件如何使用动态内存。分配区块如何分布？寿命分布如何？它们是先进先出（FIFO）还是后进先出（LIFO）顺序或随机顺序来分配和归还？软件在不同执行阶段有不同的分配归还形态吗？任何时刻使用的最大动态分配量是多少？自定义的 operator new 和 operator delete 可以轻松收集到这些信息。</li>
</ul>
<p>写个定制的operator new和operator delete并不难。例如，写个global operator new，用于检测在分配区块的后面或前面写入数据。下面是个初步版本，有小错误，后面在完善。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> Byte;</span><br><span class="line"><span class="comment">//下面代码有些小错误</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>);	<span class="comment">//增加大小，是能够塞入两个 signature </span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* pMem = <span class="built_in">malloc</span>(realSize);</span><br><span class="line">    <span class="keyword">if</span>(!pMem) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 signarure 写入内存的最前段落和最后段落</span></span><br><span class="line">    *(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(pMem)) = signarure;</span><br><span class="line">    <span class="comment">//static_cast&lt;Byte*&gt;(pMem)是为了指针做加法运算时是+1个字节</span></span><br><span class="line">    <span class="comment">//（指针加法运算+1是一个类型的大小，如int* p加1，实际加了4个字节）</span></span><br><span class="line">    *(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="built_in">sizeof</span>(<span class="type">int</span>))) = signature;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in">sizeof</span>(<span class="type">int</span>);	<span class="comment">//返回指针，指向恰位于第一个 signarure 之后的内存位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂且忽略上述代码中没有条款51所说的所有 operator new 都应该内含一个循环，反复调用某个 new-handling 函数。来说一下另外一个主题：对齐。</p>
<hr>
<p>许多计算机体系结构要求特定的类型必须放在特定的内存地址上。例如它可能要求指针的地址必须是4的倍数（four-byte aligned）或double 的地址是8的倍数（eight-byte aligned）。如果没有这些约束条件可能会导致运行期硬件异常。有些体系结构要求没这么严格，而是宣称如果满足对齐条件，便提供更佳的效率。</p>
<p>C++要求所有 operator new 返回的指针都有适当的对齐（取决于数据类型）。malloc 就是在这样的要求下工作，所以令 operator new返回一个得自 malloc 的指针是安全的。但是上面 operator new 返回一个得自 malloc 且偏移一个 int 大小的指针，没人能保证它的安全。如果用户调用 operator new 企图获取足够给一个 double 所用的内存，而我们在一部 “int 为4位 且 double 必须为 8 位 对齐”的机器中跑程序，我们可能会获得没有对齐的指针，那可能造成程序崩溃或执行速度慢。</p>
<p>像对齐这类技术细节，可以区分内存管理器的质量。写一个能够运行的内存管理器并不难，难的是让它总是能够高效优良的运作。一般来说，若非必要，不要去写内存管理器。</p>
<p>很多时候也是非必要的。有些编译器已经在它们的内存管理函数中切换至调试状态（enable debugging）和志记状态（logging）。许多平台上有商业产品可以代替编译器自带的内存管理器，可以用它们来提高机能和改善效率，你唯一需要做的就是 重新链接。</p>
<p>另外一个选择是开源领域中的内存管理器。它们对许多平台都可以用。Boost程序库（见条款 55）的Pool就是这样的一个分配器，它对常见的分配“大量小型对象”很有帮助。一些小型开源内存分配器大多都不完整，缺少移植、线程安全、对齐等考虑。</p>
<hr>
<p>本条款的主题是，了解何时可在“全局性的”或“class专属的”基础上合理替换默认的 new 和 delete：</p>
<ul>
<li>为了检测运用错误（如前所述）</li>
<li>为了手机动态分配内存的使用统计信息（如前所述）</li>
<li>为了增加分配和归还的速度。使用定制的针对特定类型对象的分配器，可以提高效率。类专属分配器是“区块尺寸固定”的分配器实例，例如 Boost 提供的 Pool 程序库便是。如果在单线程程序中，你的编译器所带的内存管理具备线程安全，你可以写个不具备线程安全的分配器而大幅度改善速度。</li>
<li>为了降低默认内存管理器带来的空间额外开销。泛用型内存分配器往往（虽然并非总是）不只比定制型慢，还使用更多内存，因为它们常常在每一个分配区块上招引某些额外开销。针对小型对象开放的分配器（例如 Boost 库的Pool）本质上消除了这样的额外开销。</li>
<li>为了弥补默认分配器中的非最佳对齐。X86体系结构上的 double 访问最快–如果它们是8-byte对齐。但是编译器自带的 operator new 并不保证对动态分配而得的 double 采取8-byte对齐。这种情况下，将默认的 operator new 替换位一个 8-byte 对齐的版本，可使程序效率提升。</li>
<li>为了将相关对象成簇集中。如果特定的某个数据结构往往被一起使用，我们希望在处理这些数据时将“内存页错误”（page faults）的频率降至最低，那么为此数据结构创建另一个 heap 就有意义，这样就可以将它们成簇集中到尽可能少的内存页上。new 和 delete 的 “placement版本”（见条款52）有可能完成这一的集簇行为。</li>
<li>为了获得非传统的行为。有时候我们需要 operator new 和 delete 做编译器附带版没做的某些事情。例如，在归还内存时将其数据覆盖为0，以此增加应用程序的数据安全。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>有许多理由需要写个自定义的 new 和 delete，包括改善效能、对 heap 运用错误进行调试、收集 heap 使用信息。</p>
</blockquote>
<h1 id="条款51"><a href="#条款51" class="headerlink" title="条款51"></a>条款51</h1><blockquote>
<p>编写new和delete时需固守常规。</p>
</blockquote>
<p>从operator new开始：</p>
<ul>
<li>实现一致性 operator new 必须返回正确的值</li>
<li>内存不足时必须调用 new-handling 函数（见条款49）</li>
<li>必须有对付零内存需求的准备</li>
<li>避免不慎掩盖正常形式的 new</li>
</ul>
<p>这比较偏近 class 接口的要求而非实现要求。正常形式的 new 描述于条款 52。</p>
<p>operator new 的返回值十分单纯。如果申请内存成功，就返回指向那块内存的指针，失败则遵循条款 49描述的规则，并抛出 bad_alloc 异常。</p>
<p>然而也不是非常单纯。因为 operator new 实际上不止一次尝试分配内存，并在每次失败后都调用 new-handling 函数。这里假设 new-handling 函数能做某些动作将一些内存释放出来。只有当指向 new-handling 函数的指针为 null，operator new 才会抛出异常。但C++规定，即使客户要求0 byte，operator new 也要返回一个合法指针。下面是个non-member operator new的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)	<span class="comment">//处理0-byte申请,将它视为 1 byte 申请</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        尝试分配size bytes;</span><br><span class="line">        <span class="keyword">if</span>(分配成功）</span><br><span class="line">            <span class="keyword">return</span> 指向分配得来的内存的指针;</span><br><span class="line">           </span><br><span class="line">        <span class="comment">//分配失败，找到当前的 new-handling 函数</span></span><br><span class="line">        new_handler globalHandler = <span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">set_new_handler</span>(globalHandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(globalHandler) </span><br><span class="line">           (*globalHandler)();	<span class="comment">//执行函数指针globalHandler指向的函数</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 0 byte 的内存申请视为 1 byte 的内存申请，做法简单、合法、可行。其中将 new-handling 函数指针设为 null 而后又立刻恢复原样，是因为我们没有任何办法可以直接取得 new-handling 函数指针，所以利用 set_new_handler 函数的返回值是前一个 new-handling 函数指针的特性。这种方法在单线程环境下很有效，但在多线程环境下，还需要某种锁机制，以便处理 new-handling 函数背后的（global）数据结构。</p>
<p>条款49提到 operator new 内含一个无穷循环，而上述代码中的第 6 行（while(true)）就是那个无穷循环。退出此循环唯一办法是：内存分配成功或 new-handling 函数做了一件描述于条款49的事：让更多内存可用、安装另一个 new-handler、卸载 new-handler、抛出 bad_alloc异常（或其派生类），或承认失败直接 return。</p>
<hr>
<p>上面的 operator new 成员函数可能会被derived classes继承。注意分配内存大小size，它是函数接收的实参。条款50提到，定制内存分配器往往是为了特定的 class 对象，以此来优化，而不是为了该 class 的任何派生类。也就是说，针对 class X 而设计的 operator new ，其行为只为大小刚好为 sizeof(X) 的对象而设计。然而一旦被继承，有可能基类的 operator new 被调用用于分配派生类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123; ... &#125;;	<span class="comment">//假设派生类未定义 operator new</span></span><br><span class="line"></span><br><span class="line">Derived* p = <span class="keyword">new</span> Derived;			<span class="comment">//这里调用了Base::operator new</span></span><br></pre></td></tr></table></figure>

<p>如果基类专属的 operator new 并非被设计用来应对上述情况（实际上往往如此），处理这种情况的方法是：将“内存申请量错误”的调用行为改为标准 operator new，就像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base))			<span class="comment">//如果大小错误</span></span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);	<span class="comment">//使用标准的 operator new</span></span><br><span class="line">    ...									<span class="comment">//否则在这处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要再检验size是否为0，C++裁定所有非附属（独立式）对象必须有非零大小（见条款39）。因此sizeof(Base)无论如何不能为零。</p>
<p>如果你打算控制 class 专属的 “arrays 内存分配行为”，那么你需要实现 operator new[]（这个函数通常被称为 “array new”）。编写operator new[] 时，唯一要做的事就是分配一块未加工的内存，因为你无法对 array 之内迄今尚未存在的元素对象做任何事。甚至我们无法知道这个 array 含有多少个元素对象。首先你不知道每个对象多大，毕竟 基类 的 operator new[] 有可能经由继承被调用，将内存分配给 “元素为 派生类 对象” 的 array使用。</p>
<p>因此，你不能在 Base::operator new[] 中假设 array 的每个元素对象大小是 sizeof(Base)，这样就是说你不能假设 array 元素个数是(bytes申请数 &#x2F; sizeof(Base))。此外，传递给 operator new[] 的 size_t 参数，其值有可能比“将被填以对象”的内存更大，因为条款 16提过，动态分配的 arrays 可能包含额外空间用来存放元素个数。</p>
<hr>
<p>上面就是自定义 operator new 需要遵守的规矩。operator delete 情况更简单，你需要记住的唯一事情就是</p>
<ul>
<li>C++保证删除 null 指针永远安全</li>
</ul>
<p>下面是 non-member operator delete的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;	<span class="comment">//如果被删除的是个 null 指针，那就什么都不做</span></span><br><span class="line"></span><br><span class="line">   现在， 归还 rawMemory 所指内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的 member 版本也很简单，只需多加一个动作——检查删除数量。万一你的 class 专属的 operator new 将大小有误的分配行为转交 <code>::operator new</code> 执行，你也必须将大小有误的删除行为转交 <code>operator delete</code> 执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory,std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> rawMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) 					<span class="comment">//检测是否为 null 指针</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Base)) &#123;				<span class="comment">//如果大小错误，让标准 operator delete 处理此一申请</span></span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    现在，归还rawMemory所指内存;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果即将被删除的对象派生自某个基类 ，而后者没有虚析构函数，那么 C++ 传给 operator delete 的 size_t 数值可能不正确。也就是说，如果基类遗漏虚析构函数，operator delete 可能无法正常运作。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>operator new 应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用 new-handler。它也应该有能力处理 0 bytes 申请。class 专属版本的还应该处理“比正确大小更大的（错误）申请”</li>
<li>operator delete 应该在收到 null 指针时不做任何事。class专属版本则还应该处理“比正确大小更大的（错误）申请”</li>
</ul>
</blockquote>
<h1 id="条款52"><a href="#条款52" class="headerlink" title="条款52"></a>条款52</h1><blockquote>
<p>写了placement new也要写placement delete。</p>
</blockquote>
<p>placement new 和 placement delete 在C++中并不常见，如果你不熟悉它们，也不用担心。当你写一个 new 表达式时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure>

<p>共有两个函数被调用：一个是以分配内存的 operator new，一个是 <code>Widget</code> 的默认构造函数。</p>
<p>假如第一个函数调用成功，但第二个函数却抛出异常，这时需要释放第一步分配得到的内存，否则就造成了内存泄漏。这个时候，用户没有能力去归还内存，因为如果 Widget构造函数抛出异常，那么 pw 尚未被赋值，用户手中的指针还没有指向开辟的内存。因此释放第一步分配得到的内存的任务落到了C++运行期系统身上。</p>
<p>运行期系统会调用第一个函数 operator new 所对应的 operator delete 版本，前提当然是它必须知道哪一个 operator delete（因为可能有多个）版本。如果目前面对的是拥有正常签名式的 new 和 delete，这并不是问题，正常的 operator new 和对应于正常的 operator delete：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;	<span class="comment">//正常形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;					<span class="comment">//global 作用域中正常的签名式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* rawMemory,std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;	<span class="comment">//class 作用域中典型的签名式</span></span><br></pre></td></tr></table></figure>

<p>如果使用正常的 operator new 和 operator delete，运行期系统可以找到如何释放 new 开辟内存的 delete 函数。但是如果使用非正常形式的 operator new，究竟使用哪个 delete 的问题就出现了。</p>
<p>举个例子，假设编写一个 class 专属的 operator new，要求接受一个 ostream，用来记录（logged）相关分配信息，同时又写了一个正常形式的 class 专属 operator delete：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//非正常形式的new</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">//正常的class专属delete</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设计有问题，但我们探讨原因之前，需要先绕道，简单讨一些术语。</p>
<p>如果 operator new 接受的参数除了必有的 size_t 之外还有其他，这便是 placement new。因此，上述的 operator new 是个 placement 版本。众多 placement new 版本中，有一个特别有用的是 “接受一个指针指向对象该被构造之处”，vector使用它在未使用的内存上创建对象，那样的 operator new 形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">//placement new</span></span><br></pre></td></tr></table></figure>

<p>placement new 有多重定义，一是带任意额外参数的new ，二是只有一个额外参数 void*。当人们谈到 placement new ，大多数是指后者。</p>
<hr>
<p>现在让我们回到 <code>Widget</code> 的声明式，也就是之前我说设计有问题的那个。这里的难点是，那个类将引起微妙的内存泄漏。看下面的例子，它在动态创建一个 <code>Widget</code> 时将相关的分配信息记录(logs)于 cerr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="built_in">new</span> (std:cerr) Widget;<span class="comment">//调用operator new并传递cerr作为ostream实参,</span></span><br><span class="line">				<span class="comment">//这个动作会在Widget构造函数抛出异常时泄漏内存</span></span><br></pre></td></tr></table></figure>

<p>如果内存分配成功，而 Widget 构造函数抛出异常，运行期系统要释放 operator new 开辟的内存。但运行期系统不知道真正被调用的 operator new 如何运作，因此它无法释放内存。所以上述做法行不通。取而代之的是，运行期系统寻找参数个数和类型都与 operator new 相同的 operator delete，如果找到，那就是它的调用对象。上述代码中调用的 operator new 对应的 operator delete为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, std::ostream&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>类似于 new 的 placement 版本，operator delete 如果接收额外参数，便称为 placement delete。上面 Widget 没有 placement 版本的operator delete，所以运行期系统不知道如何释放 operator new 开辟的内存，于是什么都不做。所以，如果 Widget 构造函数抛出异常，不会有任何的 operator delete 被调用。</p>
<p>为了解决上述问题，<code>Widget</code> 有必要声明一个 placement delete，对应那个有记录功能（logging）的 placement new：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样改变之后，如果以下语句导致<code>Widget</code> 构造函数抛出异常，就不会造成内存泄漏了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = <span class="built_in">new</span> (std:cerr) Widget;		<span class="comment">//这次内存不在泄漏</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>Widget</code> 构造函数抛出异常，就会调用对应版本的placement delete；如果没有异常，就会调用正常形式的 operator delete，如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pw;<span class="comment">//客户调用</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：placement delete 只有在 placement new 调用构造函数抛出异常时才会被调用。对着一个指针（例如上述的pw）施行 delete 绝不会导致调用 placement delete。</p>
<p>这意味着：如果要对所有与 placement new 相关的内存泄漏宣战，我们必须同时提供一个正常的 operator delete （用于构造期间无任何异常被抛出）和一个 placement 版本（用于构造期间有异常被抛出）， placement 版本的额外参数必须和 operator new 一样。</p>
<hr>
<p>需要注意的是，因为成员函数的名称会掩盖其外围作用域中相同名称的函数（见条款33），所以要小心避免 class 专属的 new 掩盖用户希望调用的 new。例如，你有一个 Base class，其中声明唯一一个 placement，用户会发现他们无法使用正常形式的 new：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//这个new会掩盖正常的global new</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base* pb = <span class="keyword">new</span> Base;				<span class="comment">//错误，因为正常形式的operator new被掩盖</span></span><br><span class="line">Base* pb1 = <span class="built_in">new</span> (std::cerr) Base;	<span class="comment">//正确，调用Base的placement new</span></span><br></pre></td></tr></table></figure>

<p>同样道理，派生类 的 operator new 会掩盖继承而来的 operator new 和 global 版本的 new：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;			<span class="comment">//继承自先前的Base</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;<span class="comment">//重新声明正常形式的new</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Derived* pd = <span class="built_in">new</span> (std::clog) Derived;	<span class="comment">//错误，因为Base的placement new被掩盖了</span></span><br><span class="line">Derived* pd1 = <span class="keyword">new</span> Derived;				<span class="comment">//正确,调用了 Derived 的 operator new</span></span><br></pre></td></tr></table></figure>

<p>条款33更详细讨论了这种名称遮掩问题。对于撰写内存分配函数，你需要记住的是，默认情况下C++在 global 作用域内提供以下形式的operator new：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;				<span class="comment">//normal new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;						<span class="comment">//placement new</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;		<span class="comment">//nothrow new(见条款49)</span></span><br></pre></td></tr></table></figure>

<p>如果你在 class 内声明任何形式的 operator new ，它都遮掩上述这些标准形式。除非你想要阻止 class 的用户使用这些形式，否则请确保它们在你所生成的任何自定义 operator new 之外还可用。对于每一个可用的 operator new，也要确保提供了对应形式的 operator delete。如果你希望这些函数有着平常的行为，只要令你的 class 专属版本调用 global 版本即可。</p>
<p>完成上面所说的一个简单的做法是，建立一个基类，内含所有正常形式的new和delete</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StadardNewDeleteForms</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//normal</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//placement</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory, ptr)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nothrow</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp; nt)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size,nt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想以自定义方式扩充标准形式，可以使用继承机制和using声明式（见条款33）取得标准形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>: <span class="keyword">public</span> StandardNewDeleteForms&#123;		<span class="comment">//继承标准形式</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//让这些形式可见</span></span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//添加自己定义的 new/delete</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">(std:;bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pMemory, std::ostream&amp; logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>记住：</p>
<blockquote>
<ul>
<li>当你写一个 placement operator new，请确定也写出了对应的 placement operator delete。如果没有这样做，就可能造成隐蔽的内存泄漏。</li>
<li>当你声明 placement new 和 placement delete ，请确定不要无意识（非故意）地遮掩了它们的正常版本。</li>
</ul>
</blockquote>
<h1 id="条款53"><a href="#条款53" class="headerlink" title="条款53"></a>条款53</h1><blockquote>
<p>不要轻忽编译器的警告。</p>
</blockquote>
<p>许多程序员习惯性的忽略编译器的警告。他们认为，如果问题很严重，那么编译器应该给一个错误而不是警告。这种想法在C++是不可取的，以一个例子来说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里希望 <code>D::f()</code>重新定义 虚函数 <code>B::f()</code>，但其中有个错误，<code>B::f()</code> 是个 const成员函数，而 D 不是。编译器不会报错，可能会给如下警告：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: D::<span class="built_in">f</span>() <span class="function">hides <span class="keyword">virtual</span> <span class="title">B::f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>经验不足的程序员认为这是 “D::f 遮掩了 B::f” ，这正是他们想要的。但这是错的，编译器是在告诉你声明于 B 中 的 f 并未在 D 中被重新声明，而是被整个遮掩了（条款33解释为什么会这样）。如果忽略这个警告，几乎肯定导致错误的程序行为，然后为了找出这个编译器已经告诉你的错误而进行许多调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++多态规定，基类和派生类中同名虚函数的函数名、返回值类型、函数参数个数及参数类型等必须完全相同。</span><br><span class="line"></span><br><span class="line">如果基类的虚函数后面没有加const，派生类同名的函数后面加了const，那么派生类的函数没有起到虚函数的作用(前提是除了const外，函数的其他参数一样)；同理，如果基类的虚函数后面加了const，而派生类同名函数后面没有加const，派生类的同名函数也没有起到虚函数的作用；如果基类的虚函数后面加了const，派生类同名函数也加了const，那么派生类同名函数起到了虚函数的作用。</span><br><span class="line"></span><br><span class="line">c++规定，同一个函数加不加const，经过编译器编译之后是两个不同的函数，所以基类和派生类的同一个函数，后面加不加const，编译后是两个不同的函数，也就不存在多态。</span><br></pre></td></tr></table></figure>

<p>一旦从编译器的警告信息中获得经验，你将学会了解不同的警告信息意味什么，那往往和它们“看起来“的意义并十分不同。一般认为，写出一个在最高警告级别下也没有任何警告信息的程序是最理想的，然而你一旦对警告信息有了深刻理解，可以选择忽略某些警告信息。但是一定记住在忽略这个警告之前，一定要了解它的真正意义。</p>
<p>警告信息和编译器相依，不同的编译器有不同的警告标准。所以，草率编程然后倚赖编译器为你指出错误的行为并不可取。例如上面代码中的函数遮掩在另一个编译器中编译，可能没有任何警告。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器最高警告级别下争取”无任何警告“。</li>
<li>不要过度依赖编译器的报警能力，因为不同编译器对待事情的态度并不相同。一段有警告的代码，移植到另一个编译器上，可能没有任何警告。</li>
</ul>
</blockquote>
<h1 id="条款54"><a href="#条款54" class="headerlink" title="条款54"></a>条款54</h1><blockquote>
<p>让自己熟悉包括TR1在内的标准程序库。</p>
</blockquote>
<p> C++98列入的C++标准 程序库有哪些主要成分：</p>
<ul>
<li>STL(Standard Template Library)：覆盖容器、迭代器、算法、函数对象、各种容器适配器和函数对象适配器。</li>
<li>Iostreams：覆盖用户自定缓冲功能、国际化I&#x2F;O，以及预先定义好的对象cin，cout，cerr和clog。</li>
<li>国际化支持：包括多区域能力，像wchar_t和wstring等类型都对促进unicode有所帮助。</li>
<li>数值处理：包括复数模板和纯数值数组。</li>
<li>异常阶层体系：包括base class exception及其derived classes logic_error和runtime_error，以及更深继承的各个classes。</li>
<li>C89标准程序库：1989 C标准程序库内的每个东西也都被覆盖于C++内。</li>
</ul>
<p>TR1详细叙述了14个新组件，统统都放在std命名空间内，更正确地说是在其嵌套命名空间tr1内。因此TR1组件shared_ptr的全名是std::tr1::shared_ptr。本书通常在讨论标准程序库组件时略而不写std::，但我总是会在TR1组件之前加上tr1::。</p>
<p>本书展示以下TR1组件实例：</p>
<ul>
<li><p>智能指针tr1::shared_ptr和tr1::weak_ptr。前者的作用有如内置指针，但会记录有多少个tr1::shared_ptrs共同指向同一个对象。所谓的reference counting（引用计数）。一旦最后一个这样的指针被销毁，这个对象被自动删除。但是如果两个或多个这样的指针形成环，这会造成每个对象的引用次数都超过0——即使这个环形的指所有指针都已被销毁。tr1::weak_ptr的设计使其表现像是“非环形tr1::shared_ptr-based数据结构”中的环形感生指针（cycle-including pointers）。tr1::weak_ptr并不参与引用计数的计算；当最后一个指向某对象的tr1::shared_ptr被销毁，纵使还有个tr1::weak_ptrs继续指向同一对象，该对象仍旧会被删除。这种情况下的tr1::weak_ptr会被自动标示无效。</p>
</li>
<li><p>tr1::function：此物得以表示任何callable entity（可调用物，也就是任何函数或函数对象），只要其签名符合目标。假设我们想注册一个callback函数，该函数接受一个int并返回一个string，我们可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(string func(<span class="type">int</span>))</span></span>; <span class="comment">//参数类型是函数，该函数接受一个int并返回一个string</span></span><br></pre></td></tr></table></figure>

<p>其中参数名称func可有可无，所以上述的registerCallback也可以这样声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(string (<span class="type">int</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>tr1::function使上述的RegisterCallback有可能更富弹性地接受可调用物，只要这个可调用物接受一个int或任何可转换为int的东西，并返回一个string或任何可被转换为string的东西。tr1::function是个template，以其目标函数的签名为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(tr1::function&lt;string (<span class="type">int</span>)&gt;func)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tr1::bind：它能够做STL绑定器bindlst和bind2nd所作的每一件事，而又更多。</p>
</li>
</ul>
<p>其他TR1组件划分为两组。第一组提供彼此不相干的独立机能：</p>
<ul>
<li>Hash tables：用来实现sets，multisets，maps和multi-maps。每个新容器的接口都以前任（TR1之前的）对应容器塑膜而成。</li>
<li>正则表达式：包括以正则表达式为基础的字符串查找和替换，或是从某个匹配字符串到另一个匹配字符串的逐一迭代等等。</li>
<li>Tuples：这是标准程序库中的pair_template的新一代制品。pair只能持有两个对象，tr1::tuple可持有任意个数的对象。</li>
<li>tr1::array：本质上是个“STL化”数组，即一个支持成员函数如begin和end的数组，不过tr1::array的大小固定，并不适用动态内存。</li>
<li>tr1::mem_fn：这是个语句构造上与成员函数指针一致的东西。tr1::mem_fn纳入并扩充了C++98的men_fun和mem_fun_ref的能力。</li>
<li>tr1::reference_wrapper：一个“让references的行为更像对象”的设施。它可以造成容器“犹如持有references”。而容器实际上只能持有对象或指针。</li>
<li>随机数生成工具：它大大超越了rand，那是C++继承自C标准程序库的一个函数。</li>
<li>数学特殊函数：包括Lagnuerre多项式、Bessel函数、完全椭圆积分，以及更多数学函数。</li>
<li>C99兼容扩充：这是一大堆函数和模板，用来将许多新的C99程序库特性带进C++。</li>
</ul>
<p>第二组TR1组件由更精巧的template编程技术（包括template metaprogramming）构成：</p>
<ul>
<li>Type traits：一组traits class，用以提供类型的编译期信息。（见条款47）</li>
<li>tr1::result_of：这是个template，用来推导函数调用的返回类型。当我们编写template时，能够“指涉函数调用动作所返回的对象的类型”往往很重要，但是该类型有可能以复杂的方式取决于函数的参数类型。tr1::result_of使得“指涉函数返回类型”变得十分容易。</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。</li>
<li>TR1添加了智能指针、一般化函数指针、hash-based容器、正则表达式以及另外10个组件的支持。</li>
<li>TR1自身只是一份规范，为获得TR1提供的好处，你需要一份实物。一个好的实物来源是Boost。</li>
</ul>
</blockquote>
<h1 id="条款55"><a href="#条款55" class="headerlink" title="条款55"></a>条款55</h1><blockquote>
<p>让自己熟悉Boost。</p>
</blockquote>
<p>你正在寻找一个高质量，源码开放，平台独立，编译器独立的程序库吗？看看 Boost 吧。有兴趣加入一个由雄心勃勃，充满才干的 C++ 开发人员组成的社群，致力发展当前最高技术水平的程序库吗？看看 Boost 吧。想要一瞥未来 C++ 的面目吗？看看 Boost 吧。</p>
<p>Boost网址：<a target="_blank" rel="noopener" href="https://www.boost.org/">Boost C++ Libraries</a></p>
<p>Boost有两点被认为是其它组织所不能比拟的：</p>
<ul>
<li>Boost 委员会和 C++ 标准委员会成员有很密切的关系，并对其有着深刻的影响能力。Boost 由标准委员会创立，因此两者成员有着很大重叠。Boost 有个目标：作为一个可被加入到标准 C++ 的功能测试场。这层关系造就的结果是：以 TR1 为例，进入标准 C++ 的 14个新程序库中，超过三分之二奠基于 Boost 的工作成果。</li>
<li>Boost 接纳新程序库的过程也很有意思。它以公开进行的同僚复审为基础。如果你有意贡献一个程序库给 Boost，首先要对 Boost 开发者邮递开发作品，在评价这个程序库的重要性之后，启动初步审查程序。<ul>
<li>当你最终正式提交时，你要满足一些最低条件。例如它必须通过至少两个编译器，以展示至此微不足道的可移植性，你必须证明你的程序库是在一个可接受的授权许可下是可用的，例如必须免费商业化和非商业化用途…</li>
<li>进入复审阶段，会有志愿者查看你的程序库和各种素材，例如源码，设计文档，使用说明等，并考虑以下问题：<ul>
<li>这份设计和实现有多么好？</li>
<li>这些代码可跨编译器和操作系统吗？</li>
<li>这个程序库有可能被它所设定的用户使用吗？</li>
</ul>
</li>
<li>这些对于阻挡低劣的程序库很有帮助，并且<code>启发程序库作者认真考虑一个工业强度，跨平台的程序库设计，实现和文档工程</code>。</li>
</ul>
</li>
</ul>
<p>Boost 程序库涉及的领域很多：</p>
<ul>
<li><p>字符串和文本处理：包括类型安全(type-safe) 的形如printf的格式化库，正则表达式(TR1中相似的功能的基础，看条款54)，tokenizing 和 parsing 。</p>
</li>
<li><p>容器：包括STL风格接口的大小固定的数组(fixed-size arrays)，可变大小bitsets,和多维数组(multidimensional arrays.)。</p>
</li>
<li><p>函数对象(Function objects)和高阶编程(higher-order programming)：包括几个TR1中作为功能性基础使用的库。一个有趣的库是 Lambda, 它使得凭空创建一个函数对象(function objects)如此容易，你甚至不需要知道到你做了什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::lambda;    <span class="comment">//使 boost::lambda可见</span></span><br><span class="line">          std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">          ...</span><br><span class="line">          std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),     <span class="comment">//遍历v中的元素x，</span></span><br><span class="line">          std::cout &lt;&lt; _1 * <span class="number">2</span> + <span class="number">10</span> &lt;&lt; <span class="string">&quot;n&quot;</span>); <span class="comment">//输出 x*2+10;</span></span><br><span class="line">                                                              <span class="comment">// &quot;_1&quot;是Lambda</span></span><br><span class="line">                                                              <span class="comment">//为当前元素设置的置位符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型编程(Generic programming)：包括一个traits类的扩展集(看条款 47关于traits 的资料)。 </p>
</li>
<li><p>模板元编程(Template metaprogramming TMP 看条款 48)：包括一个Boost MPL 这样的编译期断言库(compile-time assertions)。在MPL极好事情之一是支持STL风格的形如类型(types)的编译期实体的数据结构。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个形如list(list-like)的编译期容器，容器包括3种数据类型（float, double 和 long double），并命名为&quot;floats&quot;。</span></span><br><span class="line"><span class="keyword">typedef</span> boost::mpl::list&lt;<span class="type">float</span>, <span class="type">double</span>, <span class="type">long</span> <span class="type">double</span>&gt; floats;</span><br><span class="line"><span class="comment">//创建一个新的编译期的由&quot;floats&quot;及在其前端插入的&quot;int&quot;所组成类型的list；并命名新的容器为&quot;types&quot;。</span></span><br><span class="line"><span class="keyword">typedef</span> boost::mpl::push_front&lt;floats, <span class="type">int</span>&gt;::type types; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这样的“类型容器”（经常被称为typelists，虽然他们也基于mpl::list和mpl::vector创建) </span></span><br><span class="line"><span class="comment">打开了通向强大且重要的TMP应用的广阔天地。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数学和数值(Math and numerics)：包括有理数库(rational numbers)；octonions和四元数(quaternions)；最大公约数(greatest common divisor)和最小公倍数(common multiple computations)；随机数(另一个影响TR1相关功能的库)。</p>
</li>
<li><p>正确性和测试(Correctness and testing)：包括形式化隐式模板接口(formalizing implicit template interfaces (阅读条款 41)) 方便测试优先(test-first) 编程。</p>
</li>
<li><p>数据结构(Data structures)：包括类型安全的unions库(例：存储变量的”any”类型)和导致相应TR1功能的tuple库。</p>
</li>
<li><p>交互语言支持(Inter-language support)：包括充许在C++和Python之间进行无缝协作的库。</p>
</li>
<li><p>内存：包括高性能的固定大小分配的Pool库；多样的智能指针，包括(但不限于)在TR1中的智能指针。非TR1智能指针是scoped array, 为动态分配数组的auto_ptr风格的智能指针; 条款44展示一个使用的例子。</p>
</li>
</ul>
<p>请记住，这只是一份抽样，并不是一份详尽清单。</p>
<p>Boost 提供的程序库可做的事情有很多，但它并未覆盖编程的所有领域，不过纵使你没能找到刚好符合需求的作品，也一定会在其中发现<code>一些有趣的东西</code>。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>Boost 是一个社群，也是一个网站。致力于免费，源码开放，同僚复审的 C++ 程序库开发。 Boost 在 C++ 标准化过程中扮演深具影响力的角色。</li>
<li>Boost 提供许多 TR1 组件实现品，以及其他许多程序库。</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 21:38:06 / 修改时间：23:49:03" itemprop="dateCreated datePublished" datetime="2022-08-08T21:38:06+08:00">2022-08-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>lambda 表达式是 C++11 最重要也最常用的一个特性之一，C#3.5 和 Java8 中就引入了 lambda 表达式。</p>
<p>lambda 来源于函数式编程的概念，也是现代编程语言的一个特点。C++11 这次终于把 lambda 加进来了。</p>
<p>lambda表达式有如下优点：</p>
<ul>
<li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，好的可读性和可维护性。</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<h1 id="lambda-表达式的概念和基本用法"><a href="#lambda-表达式的概念和基本用法" class="headerlink" title="lambda 表达式的概念和基本用法"></a>lambda 表达式的概念和基本用法</h1><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。</span></span><br><span class="line">[ capture ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure>

<p>因此，一个完整的 lambda 表达式看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。</p>
<p>在 C++11 中，lambda 表达式的返回值是通过前面介绍的《C++返回值类型后置》语法来定义的。其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>这样编译器就会根据 return 语句自动推导出返回值类型。</p>
<p>需要注意的是，初始化列表不能用于返回值的自动推导：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i; &#125;;  <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []()&#123; <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure>

<p>这时我们需要显式给出具体的返回值类型。</p>
<p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;  <span class="comment">// 省略空参数表</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-lambda-表达式捕获列表"><a href="#使用-lambda-表达式捕获列表" class="headerlink" title="使用 lambda 表达式捕获列表"></a>使用 lambda 表达式捕获列表</h1><p>lambda 表达式还可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[] 不捕获任何变量。</li>
<li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[&#x3D;] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获，无法修改）。</li>
<li>[&#x3D;，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li>
<li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li>
<li>[this] 捕获当前类中的 this <a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li>
</ul>
<p>下面看一下它的具体用法，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                    <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                <span class="comment">// OK，捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">// error，没有捕获x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;  <span class="comment">// OK，捕获this指针、x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;              <span class="comment">// OK，捕获this指针，并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          <span class="comment">// error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure>

<p>从上例中可以看到，lambda 表达式的捕获列表精细地控制了 lambda 表达式能够访问的外部变量，以及如何访问这些变量。</p>
<p>需要注意的是，默认状态下 lambda 表达式<strong>无法修改通过复制方式捕获的外部变量</strong>。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。</p>
<hr>
<p>一个容易出错的细节是关于 lambda 表达式的<strong>延迟调用</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">// 按值捕获外部变量</span></span><br><span class="line">a += <span class="number">1</span>;                         <span class="comment">// a被修改了</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;  <span class="comment">// 输出？</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p>
<p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。</p>
<p>从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被<strong>复制了一份</strong>存储在 lambda 表达式变量中。虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却<strong>仍然无法修改它们</strong>。</p>
<p>那么如果希望去修改按值捕获的外部变量应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]&#123; <span class="keyword">return</span> a++; &#125;;             <span class="comment">// error，修改按值捕获的外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，mutable</span></span><br></pre></td></tr></table></figure>

<p>需要注意的一点是，被 mutable 修饰的 lambda 表达式<strong>就算没有参数也要写明参数列表</strong>。</p>
<h1 id="lambda-表达式的类型"><a href="#lambda-表达式的类型" class="headerlink" title="lambda 表达式的类型"></a>lambda 表达式的类型</h1><p>最后，介绍一下 lambda 表达式的类型。</p>
<p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。</p>
<p>因此，我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 <strong>std::function</strong> 和 <strong>std::bind</strong> 来存储和操作 lambda 表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt;  f1 = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>关于std::function和std::bind，在后面章节介绍。</p>
<p>另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="type">func_t</span> f = [](<span class="type">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p>
<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() <strong>默认是 const 的</strong>。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p>
<p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而<strong>捕获变量的 lambda 表达式则不能转换为函数指针</strong>。看看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Ptr)</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line">Ptr p = [](<span class="type">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针</span></span><br><span class="line">Ptr p1 = [&amp;](<span class="type">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 错误，有状态的lambda不能直接转换为函数指针</span></span><br></pre></td></tr></table></figure>

<p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>
<h1 id="声明式的编程风格，简洁的代码"><a href="#声明式的编程风格，简洁的代码" class="headerlink" title="声明式的编程风格，简洁的代码"></a>声明式的编程风格，简洁的代码</h1><p>就地定义匿名函数，不再需要定义函数对象，大大简化了标准库算法的调用。比如，在 C++11 之前，我们要调用 for_each 函数将 vector 中的偶数打印出来，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountEven</span> <span class="comment">//一个仿函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>&amp; count_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CountEven</span>(<span class="type">int</span>&amp; count) : <span class="built_in">count_</span>(count) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))       <span class="comment">// val % 2 == 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++ count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">CountEven</span>(even_count));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这样写既烦琐又容易出错。有了 lambda 表达式以后，我们可以使用真正的闭包概念来替换掉这里的仿函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> even_count = <span class="number">0</span>;</span><br><span class="line">for_each( v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;even_count](<span class="type">int</span> val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(val &amp; <span class="number">1</span>))  <span class="comment">// val % 2 == 0</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++ even_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The number of even is &quot;</span> &lt;&lt; even_count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>lambda 表达式的价值在于，就地封装短小的功能闭包，可以极其方便地表达出我们希望执行的具体操作，并让上下文结合得更加紧密。</p>
<h1 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::function，其中Rp是返回类型，ArgTypes是参数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Rp</span>, <span class="keyword">class</span> ..._ArgTypes&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">    : <span class="keyword">public</span> __function::__maybe_derive_from_unary_function&lt;_Rp(_ArgTypes...)&gt;,</span><br><span class="line">      <span class="keyword">public</span> __function::__maybe_derive_from_binary_function&lt;_Rp(_ArgTypes...)&gt;</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.std::function对象实例包装函数指针</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; callback;<span class="comment">//定义一个std::function&lt;int(int)&gt;对象实例</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*fun_ptr)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    fun_ptr = fun1; <span class="comment">//函数指针fun_ptr指向fun1函数</span></span><br><span class="line">    callback = fun_ptr; <span class="comment">//std::function对象包装函数指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.std::function包装函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = fun1; <span class="comment">//std::function包装函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">42</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.std::function包装模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fun2</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = fun2&lt;<span class="type">int</span>&gt;; <span class="comment">//std::function包装模板函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.std::function包装函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">add</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    callback = <span class="built_in">add</span>(); <span class="comment">//std::function包装对象函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.std::function包装lamda表达式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun3 = [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a * <span class="number">2</span>;&#125;; <span class="comment">//lamda表达式</span></span><br><span class="line">    callback = fun3; <span class="comment">//std::function包装lamda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">9</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h1><p>C++11中提供了<code>std::bind</code>。bind()函数的意义就像它的函数名一样，是用来绑定函数调用的某些参数的。</p>
<p>bind的思想实际上是一种延迟计算的思想，将可调用对象保存起来，然后在需要的时候再调用。而且这种绑定是非常灵活的，不论是普通函数、函数对象、还是成员函数都可以绑定，而且其参数可以支持占位符，比如你可以这样绑定一个二元函数<code>auto f = bind(&amp;func, _1, _2);</code>，调用的时候通过f(1,2)实现调用。</p>
<p>简单的认为就是<code>std::bind</code>就是<code>std::bind1st</code>和<code>std::bind2nd</code>的加强版。</p>
<hr>
<p>使用（与this指针相关）：</p>
<p><code>std::function</code>可以绑定全局函数，静态函数，但是绑定类的成员函数时，需要借助<code>std::bind</code>的帮忙。但是话又说回来，不借助<code>std::bind</code>也是可以完成的，只需要传一个*this变量进去就好了，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onClick</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;X : &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, Y : &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义function类型, 三个参数</span></span><br><span class="line">function&lt;<span class="type">void</span>(View, <span class="type">int</span>, <span class="type">int</span>)&gt; clickCallback;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    View button;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 指向成员函数</span></span><br><span class="line">    clickCallback = &amp;View::onClick;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 进行调用方法1</span></span><br><span class="line">    <span class="built_in">clickCallback</span>(button, <span class="number">10</span>, <span class="number">123</span>);<span class="comment">//成员函数第一个参数是this指针，这里把this指针传进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行调用方法2.使用bind，第一个参数绑定成员函数，第二个参数为this指针</span></span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(&amp;View::onClick,<span class="keyword">this</span>,std::placeholders::_1,std::placeholders::_2);</span><br><span class="line">    <span class="built_in">bindFunc</span>(<span class="number">10</span>,<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他使用std::bind代码的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> c, <span class="type">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> bindFunc1 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_1, <span class="string">&#x27;A&#x27;</span>, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc1</span>(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> bindFunc2 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_2, std::placeholders::_1, <span class="number">100.1</span>);</span><br><span class="line">    <span class="built_in">bindFunc2</span>(<span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=================================\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> bindFunc3 = <span class="built_in">bind</span>(TestFunc, std::placeholders::_2, std::placeholders::_3, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">bindFunc3</span>(<span class="number">100.1</span>, <span class="number">30</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码主要说的是bind中std::placeholders的使用。 std::placeholders是一个占位符。当使用bind生成一个新的可调用对象时，std::placeholders表示新的可调用<strong>对象的第几个参数和原函数的第几个参数进行匹配</strong>。</p>
<p>以下是使用std::bind的一些需要注意的地方：</p>
<ul>
<li>bind预先绑定的参数需要传具体的变量或值进去，对于预先绑定的参数，是pass-by-value的；</li>
<li>对于不事先绑定的参数，需要传std::placeholders进去，从_1开始，依次递增。placeholder是pass-by-reference的；</li>
<li>bind的返回值是可调用实体，可以直接赋给std::function对象；</li>
<li>对于绑定的指针、引用类型的参数，使用者需要保证在可调用实体调用之前，这些参数是可用的；</li>
<li>类的this可以通过对象或者指针来绑定。</li>
</ul>
<p>当我们厌倦了使用<code>std::bind1st</code>和<code>std::bind2nd</code>的时候，现在有了<code>std::bind</code>，你完全可以放弃使用<code>std::bind1st</code>和<code>std::bind2nd</code>了。<code>std::bind</code>绑定的参数的个数不受限制，绑定的具体哪些参数也不受限制，由用户指定，这个bind才是真正意义上的绑定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/08/c++stringTOint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/c++stringTOint/" class="post-title-link" itemprop="url">将string类型转换为int类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-08 19:36:18 / 修改时间：20:04:43" itemprop="dateCreated datePublished" datetime="2022-08-08T19:36:18+08:00">2022-08-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先提出解决方案：</p>
<ul>
<li>atoi（头文件<code>&lt;stdlib.h&gt;</code>）：<ul>
<li><code>int atoi(const char *str)</code>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。</li>
</ul>
</li>
<li>strtol（头文件<code>&lt;stdlib.h&gt;</code>）：<ul>
<li><code>long int strtol(const char *str, char **endptr, int base)</code>该函数返回转换后的长整数，如果没有执行有效的转换，则返回一个零值。</li>
<li><strong>str</strong> – 要转换为长整数的字符串。</li>
<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中数值后的下一个字符。（即把整数部分后面的字符串返回）</li>
<li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li>
</ul>
</li>
<li>stoi（头文件<code>&lt;string&gt;</code>）：<ul>
<li><code>int stoi (const string&amp; str, size_t* idx = 0, int base = 10);</code></li>
</ul>
</li>
</ul>
<p>这几个有什么不同呢？下面测试对比。</p>
<blockquote>
<p>C语言风格函数</p>
</blockquote>
<p>atoi与strtol对比：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;16s&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atoi的结果为:<span class="number">16</span></span><br><span class="line">strtol的结果为:<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>这两个函数都是从字符串开始寻找数字或者正负号或者小数点，遇到非法字符终止（<strong>即匹配第一个出现的连续的数字</strong>）。</p>
<p>所以到上述s字符就不输出了，提前结束，也就是说<strong>当你的字符串不是数字的时候，或者小数点等非数字，不会报异常！直接输出0</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;asdsa&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>strtol相比与atoi来说，支持多种进制转换,例如8进制等</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="built_in">strtol</span>(str.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C++风格</p>
</blockquote>
<p>在C++中可以使用stoi来转int，这个函数相比于前两个一个最大特点是：<strong>异常</strong>！</p>
<p>我们知道C++相比于C语言多了异常，这也是这个函数在C++中具有的最显著功能。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;asq,&quot;</span>;</span><br><span class="line"><span class="comment">//    int c = stoi(str1);    // 报异常</span></span><br><span class="line">string str2 = <span class="string">&quot;12312&quot;</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">stoi</span>(str2);     <span class="comment">// ok</span></span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>异常如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::invalid_argument&#x27;</span></span><br><span class="line"><span class="built_in">what</span>():  stoi</span><br></pre></td></tr></table></figure>

<ul>
<li>stoi()会检查输入是否越界，默认范围也是在int的范围内，越界后则会报错runtime error！</li>
<li>atoi()没有安全性检查<br>如果我们输入的这个字符串转换成int超出了int范围[-2147483648, 2147483647],则会输出错误<br>如果结果超出了int的上界，则输出为上界的值2147483647<br>如果结果超出了下界，则输出为下界的值-2147483647<br>如果字符串无法转换为一个int或这个字符串为空，则会返回0。</li>
</ul>
<blockquote>
<p>自定义，更推荐这种方法</p>
</blockquote>
<p>也就是自己写，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringToInt</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; s;</span><br><span class="line">    ss &gt;&gt; v;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">stringToInt</span>(<span class="string">&quot;2.3&quot;</span>);</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里介绍一下stringstream</p>
<p><code>&lt;sstream&gt; </code>定义了三个<strong>类</strong>：<strong>istringstream</strong>、<strong>ostringstream</strong> 和 <strong>stringstream</strong>，分别用来进行流的输入、输出和输入输出操作。</p>
<p><code>&lt;sstream&gt;</code> 主要用来进行数据类型转换，由于 <code>&lt;sstream&gt; </code>使用 string 对象来代替字符数组（snprintf 方式），避免了缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符号的问题。简单说，相比 C 编程语言库的数据类型转换，<code>&lt;sstream&gt;</code> 更加安全、自动和直接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 转 string</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream sstream;</span><br><span class="line">    string strResult;</span><br><span class="line">    <span class="type">int</span> nValue = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将int类型的值放入输入流中</span></span><br><span class="line">    sstream &lt;&lt; nValue;</span><br><span class="line">    <span class="comment">// 从sstream中抽取前面插入的int类型的值，赋给string类型</span></span><br><span class="line">    sstream &gt;&gt; strResult;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[cout]strResult is: &quot;</span> &lt;&lt; strResult &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[printf]strResult is: %s\n&quot;</span>, strResult.<span class="built_in">c_str</span>());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转任意类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> out_type, <span class="keyword">typename</span> in_value&gt;</span></span><br><span class="line"><span class="function">out_type <span class="title">convert</span><span class="params">(<span class="type">const</span> in_value &amp; t)</span></span>&#123;</span><br><span class="line">	stringstream stream;</span><br><span class="line">　　 stream&lt;&lt;t;<span class="comment">//向流中传值</span></span><br><span class="line">　　 out_type result;<span class="comment">//这里存储转换结果</span></span><br><span class="line">　　 stream&gt;&gt;result;<span class="comment">//向result中写入值</span></span><br><span class="line">　　 <span class="keyword">return</span> result;</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">c++智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:12:13" itemprop="dateCreated datePublished" datetime="2022-08-07T21:12:13+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 12:12:27" itemprop="dateModified" datetime="2022-08-10T12:12:27+08:00">2022-08-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>先看一组类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">shape_type</span> &#123;<span class="comment">//枚举类</span></span><br><span class="line">    circle,</span><br><span class="line">    triangle,</span><br><span class="line">    rectangle,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;shape&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am shape&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">triangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;triangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am triangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rectangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;rectangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am rectangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态 上转 如果返回值为shape,会存在对象切片问题（强制转换，损失数据）。</span></span><br><span class="line"><span class="comment">// 使用基类指针指向派生类</span></span><br><span class="line"><span class="function">shape *<span class="title">create_shape</span><span class="params">(shape_type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> shape_type::circle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">triangle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">shape_wrapper</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shape* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shape_wrapper这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ul>
<li>这个类只适用于 shape 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为</li>
</ul>
<h1 id="手写auto-ptr与scope-ptr"><a href="#手写auto-ptr与scope-ptr" class="headerlink" title="手写auto_ptr与scope_ptr"></a>手写auto_ptr与scope_ptr</h1><p>针对”这个类只适用于 shape 类”，我们想到了模板，于是改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smater_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">smater_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”该类对象的行为不够像指针”，我们想到了指针的基本操作有<code>*</code>，<code>-&gt;</code>，布尔表达式。</p>
<p>于是添加三个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	...</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;<span class="comment">//返回引用，作为左值</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;<span class="comment">//返回目的类型的指针</span></span><br><span class="line">    				<span class="comment">//语句 sp-&gt;m 被解释为 (sp.operator-&gt;())-&gt;m，即ptr_-&gt;m，通过对sp类操作就可以调用ptr_类的成员</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”拷贝该类对象会引发程序行为”，我们想到了拷贝构造和赋值。</p>
<p>现考虑如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr1</span><span class="params">(create_shape(shape_type::circle))</span></span>;<span class="comment">//create...表示new一个对象</span></span><br><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查 一下各种可能性。</p>
<p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以设为private。</p>
<p>禁用这两个函数非常简单，但却解决了一种可能出错的情况：<code>smart_ptr&lt;shape&gt; ptr2(ptr1);</code> 在编译时不会出错，但在运行时却会有未定义行为——<strong>由于会对同一内存释放两次，通常情况下会导致程序崩溃。</strong></p>
<blockquote>
<p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。在 C++ 里没有像 Java 的clone 方法这样的约定；<strong>一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</strong></p>
</blockquote>
<p>那关键点就来了，<strong>所有权！</strong>，我们可以拷贝时转移指针的所有权！下面实现便是<code>auto_ptr</code>的核心实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回值为T&amp;，允许*ptr=10操作</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造,被复制放释放原来指针的所有权,交给复制方</span></span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr &amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap</span></span><br><span class="line">    auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr &amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="comment">//        auto_ptr tmp(rhs.release());拷贝构造copy</span></span><br><span class="line"><span class="comment">//        tmp.swap(*this);交换swap</span></span><br><span class="line">        <span class="comment">// s上述两行等价于下面一行</span></span><br><span class="line">        <span class="built_in">auto_ptr</span>(rhs.<span class="built_in">release</span>()).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr&lt;T&gt; &amp;lhs, auto_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr2.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造：ptr1释放了所有权,ptr2获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr1 = ptr1;</span><br><span class="line"></span><br><span class="line">    auto_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr3.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述通过copy-swap技术完成了避免自我赋值与保证了强异常安全！</p>
<p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 auto_ptr 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<strong>auto_ptr 在 C++17 时已经被正式从C++ 标准里删除了</strong>。</p>
<p>上面会导致什么问题呢？</p>
<p>看一下输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">拷贝构造：ptr1释放了所有权,ptr2获得了所有权</span><br><span class="line">shape</span><br><span class="line">rectangle</span><br><span class="line">赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权</span><br></pre></td></tr></table></figure>

<p>shape与circle是在create_shape时候输出的，我们重点关注最后一句话，发现了一个很大的问题：<strong>它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 auto_ptr，你就不再拥有这个对象了。</strong></p>
<p>针对这个问题，在C++11标准出来之前，C++98标准中都一直只有一个智能指针auto_ptr，我们知道，这是一个失败的设计。它的本质是<strong>管理权的转移</strong>，这有许多问题。而这时就有一群人开始扩展C++标准库的关于智能指针的部分，他们组成了boost社区，他们负责boost库的开发和维护。其目的是为C++程序员提供免费的、同行审查的、可移植的程序库。boost库可以和C++标准库完美的共同工作，并且为其提供扩展功能。现在的<strong>C++11标准库</strong>的智能指针很大程度上“借鉴”了boost库。</p>
<p>boost::scoped_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt; </code>可以使用。scoped_ptr 跟 auto_ptr 一样，可以方便的管理单个堆内存对象，特别的是，scoped_ptr <strong>独享所有权</strong>，避免了auto_ptr恼人的几个问题。</p>
<p>scope_ptr是一种简单粗暴的设计，它本质就是<strong>防拷贝</strong>，避免出现管理权的转移。这是它的最大特点，所以他的拷贝构造函数和赋值运算符重载函数都只是声明而不定义，而且为了<strong>防止有的人在类外定义</strong>，所以<strong>将函数声明为private</strong>。但这也是它最大的问题所在，就是<strong>不能赋值拷贝，也就是说功能不全</strong>。但是这种设计比较高效、简洁。没有 release() 函数，不会导致先前的内存泄露问题。下面我也将模拟实现scoped_ptr的管理机制(实际上就是前面提到的禁止拷贝)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_ptr</span> <span class="comment">// noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">(T *ptr = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : ptr_(ptr) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scoped_ptr</span>(p).<span class="built_in">swap</span>(*<span class="keyword">this</span>);<span class="comment">//使用构造函数构造一个临时对象，然后交换指针，让临时对象把原来的空间析构掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    <span class="comment">//在private里禁用，也可以delete</span></span><br><span class="line">    <span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;);<span class="comment">//只需声明，然后不提供实现即可</span></span><br><span class="line">    scoped_ptr &amp;<span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&lt;T&gt; &amp;lhs, scoped_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scoped_ptr特点总结：</p>
<ul>
<li><p>与auto_ptr类似，采用<strong>栈上的指针去管理堆上的内容</strong>，从而<strong>使得堆上的对象随着栈上对象销毁时自动删除（栈自动删除-&gt;析构函数-&gt;释放堆空间）</strong>；</p>
</li>
<li><p>scoped_ptr有着更严格的使用限制——<strong>不能拷贝</strong>，这也意味着scoped_ptr<strong>不能转换其所有权</strong>，所以它管理的对象不能作为<strong>函数的返回值</strong>，对象生命周期仅仅局限于一定区间（该指针所在的{}区间，因为不允许拷贝和赋值，对象<strong>与scoped_ptr紧紧地绑定在了一起</strong>，受限于{}的栈，而std::auto_ptr管理的对象可以在不同的区间存活）；</p>
</li>
<li><p>由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>，这与std::auto_ptr类似（一个是独享，一个是转移，都不是共享），这一特点使该指针简单易用，但也<strong>造成了功能的薄弱</strong>。</p>
</li>
</ul>
<h1 id="手写unique-ptr之子类向基类转换"><a href="#手写unique-ptr之子类向基类转换" class="headerlink" title="手写unique_ptr之子类向基类转换"></a>手写unique_ptr之子类向基类转换</h1><p>在上述auto_ptr基础上，我们把拷贝构造与拷贝赋值，改为移动构造与移动赋值（参考语法记录内的相关内容）。</p>
<ul>
<li>noexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&lt;T&gt; &amp;lhs, unique_ptr&lt;T&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，没有拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok，使用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，此时赋值构造函数通过拷贝构造函数实现（ptr3是左值），但没有</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok，使用赋值构造函数通过移动构造函数实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::move将对象转化为右值</span></span><br></pre></td></tr></table></figure>

<p>把拷贝构造函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr&amp;&amp;；现在它成了移动构造函数。 把赋值函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象（<strong>相当于传入参数时，就构造了临时对象</strong>）。现在赋值函数的行为是移动还是拷贝，<strong>完全依赖于构造参数时走的是移动构造还是拷贝构造</strong>。</p>
<p>最后，一个<code> circle*</code> 是可以隐式转换成 <code>shape*</code>的，但上面的 <code>unique_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>unique_ptr&lt;shape&gt;</code>（基类转子类，即<code>unique_ptr&lt;circle&gt; = shape*</code>是非法的，不能自动转换）。</p>
<hr>
<p>现在我们考虑两种情况：</p>
<p><strong>（1）第一种：当我们只是在原先的移动构造上面添加<code>template &lt;typename U&gt;</code>，此时情况是移动构造变为带模板的移动构造，可以进行子类向基类转换，但是与移动构造相关的，则调用的是默认移动构造，除非是子类向基类转换，才调用带模板的移动构造。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;U&gt; &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>六个特殊的成员函数其生成规则如下：</strong></p>
<ul>
<li><strong>默认构造函数，生成规则和C++98一样，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成。</strong></li>
<li><strong>析构函数，生成规则和C++98一样，在C++11中有点不同的是，析构函数默认是noexcept。</strong></li>
<li><strong>拷贝构造函数，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其它和C++98的行为一致。</strong></li>
<li><strong>拷贝赋值操作符，用户自定义了移动操作会导致不生成默认的拷贝赋值操作，其它和C++98的行为一致。</strong></li>
<li><strong>移动构造函数和移动赋值操作符，仅仅在没有用户自定义的拷贝操作、析构操作，移动操作的时候才会生成。因为默认移动构造函数出现应该在是在你需要它且能保证内存不被泄露的前提下才会出现。析构函数被显示定义的一个隐含说明就是说需要回收内存。</strong></li>
</ul>
<p>根据《Effective Modern C++》Item17 P115页提到，当类中含有特殊成员函数变为模板特殊成员函数的时候，此时不满足上述生成规则，也就是针对当前例子来说，编译器<strong>会默认生成拷贝构造</strong>，因为移动构造是模板函数（且没有非模板函数版本），所以此时上述main调用里面为error的都可以正常运行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; <span class="comment">// 由于带模板的移动构造函数引发编译器会默认生成拷贝构造</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)      <span class="comment">// bitwise copy 此时ptr1不为NULL</span></span><br><span class="line">        ptr2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// 调用的是默认的移动构造,而不是带模板的移动构造 bitwise move</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)   <span class="comment">// ptr1 不为空</span></span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;    <span class="comment">// ok  根据形参先调用默认拷贝（ptr3是左值）,再调用拷贝赋值</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok 根据形参先调用默认移动构造（使用move后是右值），而不是带参数的移动构造,再调用移动赋值</span></span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr4</span><span class="params">(std::move(<span class="keyword">new</span> circle))</span></span>;  <span class="comment">// ok 调用带模板的移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）第二种：移动构造与带模板的移动构造同时存在，可以完成子类向基类的转换，此时满足上述生成规则，但此时不会生成拷贝函数！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，无拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，无拷贝构造函数，无法使用赋值构造函数（左值）</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//    unique_ptr&lt;circle&gt; cl&#123;create_shape(shape_type::circle)&#125;;  // error 因为create_shape返回的是shape 不能基类转子类</span></span><br><span class="line">    unique_ptr&lt;circle&gt; cl&#123;<span class="keyword">new</span> <span class="built_in">circle</span>()&#125;;</span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr5</span><span class="params">(std::move(cl))</span></span>;  <span class="comment">// ok unique&lt;circle&gt;转unique&lt;circle&gt;（即不用转换）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<ul>
<li><p>我们需要了解子类向基类的隐式转换，通过将移动构造函数变为带模板的移动构造函数，要明白两者共存情况与只有带模板的移动或者其他构造函数<strong>对编译器生成规则的影响</strong>！上述代码，此时还不能完成基类向子类的转换！例如:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<ul>
<li>如果只有带模板的拷贝&#x2F;移动构造函数，则还是会生成默认的拷贝&#x2F;移动构造函数，优先供<strong>同类型</strong>的对象使用，而带模板的供不同类型的对象使用。</li>
</ul>
</li>
<li><p>auto_ptr与unique_ptr都是独占所有权，每次只能被单个对象所拥有，unique_ptr与auto_ptr不同的是<strong>使用移动语义来显式的编写</strong>。</p>
</li>
<li><p>auto_ptr是可以说你随便赋值，但赋值完了之后原来的对象就不知不觉的报废，搞得你莫名其妙。而unique_ptr就干脆不让你可以随便去复制，赋值。如果实在想传个值就哪里显式的说明内存转移<strong>std:move</strong>一下。然后这样传值完了之后，之前的对象也同样报废了。只不过整个move你让<strong>明显的知道这样操作后会导致之前的unique_ptr对象失效</strong>。</p>
</li>
<li><p>scope_ptr则是直接<strong>不允许拷贝</strong>。由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>。</p>
</li>
</ul>
<h1 id="shared-ptr之引用计数"><a href="#shared-ptr之引用计数" class="headerlink" title="shared_ptr之引用计数"></a>shared_ptr之引用计数</h1><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 shared_ptr 了。</p>
<p>两者区别如下：</p>
<p>多个shared_ptr不仅<strong>共享一个对象，同时还得共享同一个计数</strong>。<strong>当最后一个指向对象(和共享计数)的shared_ptr析构时，它需要删除对象和共享计数。</strong></p>
<p>首先需要一个共享计数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>() : <span class="built_in">count_</span>(<span class="number">1</span>) &#123;<span class="comment">//一旦初始化，赋1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来实现引用计数智能指针：</p>
<p>构造与析构、swap实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();<span class="comment">//初始化一个计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个shared_ptr再去删除对象与共享计数</span></span><br><span class="line">        <span class="comment">// ptr_不为空且此时共享计数减为0的时候,再去删除</span></span><br><span class="line">        <span class="keyword">if</span>(ptr_&amp;&amp;!shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);   </span><br><span class="line">        <span class="built_in">swap</span>(shared_count_,rhs.shared_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&lt;T&gt; &amp;lhs, shared_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的赋值函数，编译器可以根据调用来决定是调拷贝构造还是移动构造函数，所以不变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">shared_ptr &amp;<span class="keyword">operator</span>=(shared_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造与移动构造需要改变：</p>
<p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把<strong>引用数加一</strong>，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 other.ptr_ 置为空，<strong>认为 other 不再指向该共享对象即可</strong></p>
<p>实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">    ptr_ = other.ptr_; <span class="comment">//1.数据指针共享</span></span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();<span class="comment">//3.计数+1</span></span><br><span class="line">        shared_count_ = other.shared_count_;<span class="comment">//2.计数指针共享</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;U&gt; &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//移动构造</span></span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;<span class="comment">//移除数据指针</span></span><br><span class="line">        other.shared_count_ = <span class="literal">nullptr</span>;<span class="comment">//移除计数指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行的时候，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘circle* shared_ptr&lt;circle&gt;::ptr_’ is private</span><br></pre></td></tr></table></figure>

<p>错误原因是<strong>模板的各个实例间并不天然就有 friend 关系</strong>，因而不能互访私有成员 <code>ptr_ </code>和<code>shared_count_</code>。我们需要在 shared_ptr 的定义中显式声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;<span class="comment">//使得可以直接在不同模板实例间互相访问，不需要指定shared_ptr&lt;U&gt;。</span></span><br><span class="line">	<span class="comment">//声明一个模板函数作为友元也是，不需要加&lt;U&gt;</span></span><br><span class="line">	<span class="comment">//若是声明一种特例，直接friend class A&lt;int&gt;; 函数则 friend void fun&lt;int&gt;();</span></span><br></pre></td></tr></table></figure>

<p>对于这个问题，需要进一步解释：</p>
<p>类的private成员，只能由这个类所访问（不论是这个类的哪个实例，在类的作用域就行）。而对于模板类，实际上不同模板的实例并不属于一个类，比如说<code>A&lt;int&gt;</code>和<code>A&lt;double&gt;</code>就不能互相访问，一个私有成员 x 是属于<code>A&lt;int&gt;</code>这个类的，那么就不属于<code>A&lt;double&gt;</code>这个类，但是<code>A&lt;int&gt;</code>这个类的不同实例是可以互相访问 x 的。</p>
<p>因此在shared_ptr这个类中声明友元，也就声明了所有这个类的模板，都是友元。</p>
<hr>
<p>此外，在当前引用计数实现中，我们应该删除release释放所有权函数，编写一个返回引用计数值的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> circle())</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 was &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">ptr2 = ptr1;        <span class="comment">// shared_ptr&lt;circle&gt;隐式转换shared_ptr&lt;shape&gt; 调用带模板的拷贝构造</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    ptr3 = ptr2;        // 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 ptr3=ptr2</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line">ptr3 = ptr1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时3个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (ptr1)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 会先调用赋值函数,由编译器决定调用的是拷贝构造还是移动构造,造出一个新的临时对象出来,临时对象会在跳出作用域后被析构掉。</span></span><br><span class="line"><span class="comment">// 在析构函数中,会先判断该临时对象的是否指向资源,如果没有,析构结束。否则,对引用计数减1,判断引用计数是否为0,如果为0,删除共享引用计数指针,否则不操作。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时2个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line"><span class="keyword">if</span> (!ptr1 &amp;&amp; ptr2) &#123;      <span class="comment">// 调用的是bool重载操作符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 move to ptr2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">use count of ptr1 is <span class="number">1</span></span><br><span class="line">use count of ptr2 was <span class="number">0</span></span><br><span class="line">此时<span class="number">3</span>个shared_ptr指向同一个资源</span><br><span class="line">use count of ptr1 is now <span class="number">3</span></span><br><span class="line">use count of ptr2 is now <span class="number">3</span></span><br><span class="line">use count of ptr3 is now <span class="number">3</span></span><br><span class="line">ptr1 is <span class="keyword">not</span> empty</span><br><span class="line">此时<span class="number">2</span>个shared_ptr指向同一个资源</span><br><span class="line">ptr1 move to ptr2</span><br><span class="line">use count of ptr1 is now <span class="number">0</span></span><br><span class="line">use count of ptr2 is now <span class="number">2</span></span><br><span class="line">use count of ptr3 is now <span class="number">2</span></span><br><span class="line">~circle</span><br><span class="line">~shape</span><br></pre></td></tr></table></figure>

<p>有几点注意事项：</p>
<ul>
<li>上述代码没有考虑线程安全性，这里只是简化版</li>
<li>&#x3D;赋值重载函数不加<code>&amp;</code>，编译器决定调用拷贝构造还是移动构造，来造出一个临时对象出来。</li>
<li>根据前面提到的，当类中特殊函数变为带模板的函数，编译器仍然会生成默认拷贝构造与默认移动构造。</li>
</ul>
<p>针对第一点：例如：<code>ptr2 = std::move(ptr1);</code></p>
<p>会先调用赋值函数，由编译器决定调用的是拷贝构造还是移动构造，造出一个新的临时对象出来，临时对象会在跳出作用域后被析构掉。在析构函数中，会先判断该临时对象的是否指向资源，如果没有，析构结束。否则，对引用计数减1，判断引用计数是否为0，如果为0，删除共享引用计数指针，否则不操作。</p>
<p>针对第二点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;<span class="comment">//两个引用计数</span></span><br><span class="line">ptr3 = ptr2;        <span class="comment">// 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 </span></span><br></pre></td></tr></table></figure>

<p>两者都是<strong>一种类型</strong>，所以在调用赋值操作后，不会调用带模板的拷贝构造来创建临时变量，而是调用编译器生成的<strong>默认拷贝构造</strong>，所以此时引用计数不会增加。</p>
<h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>对应于 C++ 里的不同的类型强制转：</p>
<ul>
<li>dynamic_cast</li>
<li>static_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>在上述<code>unique_ptr</code>处实现了子类向基类的转换，但是却没有实现基类向子类的转换，例如：:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<p>实现这种，需要使用<code>dynamic_cast</code>，实现如下：</p>
<p>首先为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现强制类型转换需要的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other, T *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，就是实现转换函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">dynamic_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());<span class="comment">//强制转换为T*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);<span class="comment">//使用上述的构造函数，返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用dynamic_cast转换后，指针为空。此时资源还是被dptr2拥有，dptr1为0</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; dptr1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; dptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; dptr1_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1_1 is now &quot;</span> &lt;&lt; dptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3 is now &quot;</span> &lt;&lt; dptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">dptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; dptr2_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;shape&gt;(dptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2_1 is now &quot;</span> &lt;&lt; dptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3_1 is now &quot;</span> &lt;&lt; dptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。</p>
<ul>
<li>下行转换，基类转换为子类（派生类指针指向基类对象），例如：智能指针转换类似于<code>shape*</code> 转换为<code>circle*</code> 使用dynamic_cast转换后,，<strong>指针为空</strong>。此时资源还是被<strong>dptr2拥有，dptr1为0</strong>。比static_cast安全。</li>
<li>平行转换，指向一致的相互转换，例如：智能指针转换类似于<code>circle*</code>转换为<code>circle*</code>。此时引用计数为<strong>两者共享</strong>。</li>
<li>上行转换，子类转基类，例如：智能指针转换类似于<code>circle*</code>转换为<code>shape*</code>，此时引用技术为<strong>两者共享</strong>。等价于static_cast。</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>同样，编写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">static_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">static_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用static_cast转换后,指针为空  与dynamic_cast相比,不安全</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; sptr1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; sptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; sptr1_1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1_1 is now &quot;</span> &lt;&lt; sptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3 is now &quot;</span> &lt;&lt; sptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用static_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2 等价于dynamic_cast</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">sptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; sptr2_1 = <span class="built_in">static_pointer_cast</span>&lt;shape&gt;(sptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2_1 is now &quot;</span> &lt;&lt; sptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3_1 is now &quot;</span> &lt;&lt; sptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>输出结果同上dynamic_cast，不同之处，在下行转换的时候(基类转子类)，是不安全的！</p>
<p>还可以将non-const对象强制转换为const：<code>static_cast&lt;const A&amp;&gt;(*this)</code>：将本身（A&amp;）转换为const A&amp;。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去掉const属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">const_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">const_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;circle&gt; s = <span class="built_in">const_pointer_cast</span>&lt;circle&gt;(<span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> circle&gt;(<span class="keyword">new</span> circle));</span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>例如：想把一个指针转为整数，就可以用reinterpret_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">reinterpret_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">reinterpret_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">reinterpret_pointer_cast</span>&lt;<span class="type">int</span>&gt;(s);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/06/c++%E6%83%AF%E7%94%A8%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/c++%E6%83%AF%E7%94%A8%E6%B3%95/" class="post-title-link" itemprop="url">c++编程风格惯用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-06 23:31:21" itemprop="dateCreated datePublished" datetime="2022-08-06T23:31:21+08:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 17:11:51" itemprop="dateModified" datetime="2022-08-08T17:11:51+08:00">2022-08-08</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在基本的语法学习差不多学习完之后，来学一下编程风格惯用法。因为c++的语法支持我们以多种形式编写代码，但有些语法内容还需要进一步探讨，应该有一个明确的规范，这就是惯用法的作用。实际上有些部分在语法内容也有提到，这里再总结一下。当我们在编写这类代码时，应当遵循惯用法。</p>
<p>参考自GitHub项目：CPlusPlusThings</p>
<h1 id="初始化列表与赋值"><a href="#初始化列表与赋值" class="headerlink" title="初始化列表与赋值"></a>初始化列表与赋值</h1><p>本章学习编程过程中，何时用初始化列表，何时直接赋值。</p>
<p>总结：</p>
<ul>
<li><strong>const成员</strong>的初始化只能在构造函数初始化列表中进行。</li>
<li><strong>引用成员</strong>的初始化也只能在构造函数初始化列表中进行。</li>
<li><strong>对象成员</strong>（对象成员所对应的类<strong>没有默认构造函数</strong>）的初始化，也只能在构造函数初始化列表中进行（调用拷贝构造函数）。</li>
</ul>
<p>下面具体学习一下：</p>
<h2 id="类之间嵌套"><a href="#类之间嵌套" class="headerlink" title="类之间嵌套"></a>类之间嵌套</h2><p>这个比较重要，后面介绍的继承关系一律用初始化列表构造。</p>
<h3 id="第一种：-使用初始化列表"><a href="#第一种：-使用初始化列表" class="headerlink" title="第一种： 使用初始化列表"></a>第一种： 使用初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(animal) &#123;<span class="comment">//第一种方式，调用拷贝构造</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Animal __animal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal animal;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(animal)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="built_in">Animal</span>() is called</span><br><span class="line"><span class="comment">//构造，先构造成员对象（如果有多，按照声明的顺序），再调用类自己的构造函数</span></span><br><span class="line"><span class="built_in">Animal</span> (<span class="type">const</span> Animal &amp;) <span class="function">is called</span></span><br><span class="line"><span class="function"><span class="title">Dog</span><span class="params">(<span class="type">const</span> Animal &amp;animal)</span> is called</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//析构，后定义的先析构；调用析构函数后再析构成员变量</span></span></span><br><span class="line"><span class="function">~<span class="title">Dog</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br><span class="line"><span class="function">~<span class="title">Animal</span><span class="params">()</span> is called</span></span><br></pre></td></tr></table></figure>

<p>依次分析从上到下：</p>
<p>main函数中<code>Animal animal;</code>调用默认构造。</p>
<p><code>Dog d(animal);</code>且初始化对象是一个类成员对象，等价于定义同时初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal __animal = animal;</span><br></pre></td></tr></table></figure>

<p>实际上就是调用了拷贝构造，因此输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal (const Animal &amp;) is called</span><br></pre></td></tr></table></figure>

<p>再然后打印Dog的构造函数里面的输出。</p>
<p>最后调用析构，程序结束。</p>
<p><strong>在初始化列表中不一定要调用拷贝构造，也可以调用默认构造函数或者有参构造函数。</strong>比如这里调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal()<span class="comment">//第二种方式，默认构造函数</span></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) : __animal(<span class="number">5</span>)<span class="comment">//第二种方式，有参构造函数（如果有）</span></span><br><span class="line"><span class="built_in">Dog</span>(<span class="type">int</span> x) : __animal(x)<span class="comment">//第二种方式，有参构造函数，进一步指定变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal() is called</span><br><span class="line"></span><br><span class="line">Animal() is called</span><br><span class="line">Dog(const Animal &amp;animal) is called</span><br><span class="line"></span><br><span class="line">~Dog() is called</span><br><span class="line">~Animal() is called</span><br><span class="line">~Animal() is called</span><br></pre></td></tr></table></figure>

<p>也就是说，在初始化列表中初始化，等同于定义同时初始化（因此既能够使用构造函数（传入其他类型）、也能使用拷贝构造函数（传入类自己的类型）），而不是先声明。</p>
<h3 id="第二种：构造函数赋值来初始化对象"><a href="#第二种：构造函数赋值来初始化对象" class="headerlink" title="第二种：构造函数赋值来初始化对象"></a>第二种：构造函数赋值来初始化对象</h3><p>构造函数修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Dog</span>(<span class="type">const</span> Animal &amp;animal) &#123;</span><br><span class="line">    __animal = animal;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dog(const Animal &amp;animal) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal() is called</span><br><span class="line"></span><br><span class="line">Animal() is called</span><br><span class="line">Animal &amp; operator=(const Animal &amp;) is called</span><br><span class="line">Dog(const Animal &amp;animal) is called</span><br><span class="line"></span><br><span class="line">~Dog() is called</span><br><span class="line">~Animal() is called</span><br><span class="line">~Animal() is called</span><br></pre></td></tr></table></figure>

<p>于是得出：</p>
<p>当调用<code>Dog d(animal);</code>时，等价于：</p>
<p>先定义对象，再进行赋值，因此先调用了默认构造（<strong>因此如果没有默认构造函数会出错</strong>），再调用&#x3D;操作符重载函数（如果没重载赋值构造函数，使用默认的）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 假设之前已经有了animal对象</span><br><span class="line">Animal __animal;</span><br><span class="line">__animal = animal;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上述我们得出如下结论：</p>
<ul>
<li><strong>类中包含其他自定义的class或者struct，采用初始化列表，实际上就是创建对象同时并初始化（可用构造和拷贝构造，取决于参数类型）</strong></li>
<li><strong>而采用类中赋值方式，等价于先定义对象，再进行赋值，一般会先调用默认构造，在调用&#x3D;操作符重载函数。</strong></li>
</ul>
<h2 id="无默认构造函数的继承关系"><a href="#无默认构造函数的继承关系" class="headerlink" title="无默认构造函数的继承关系"></a>无默认构造函数的继承关系</h2><p>现考虑把上述嵌套的关系改为继承，并修改Animal与Dog的构造函数，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age) &#123;<span class="comment">//有参，非默认构造函数，且编译器不提供默认构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">const</span> Animal &amp; animal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal (const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Animal &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Animal &amp; amimal) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal &amp; operator=(const Animal &amp;) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Animal() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Dog</span>(<span class="type">int</span> age) : <span class="built_in">Animal</span>(age) &#123;<span class="comment">//继承构造的标准形式，如果无参或默认构造，使用Animal()</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Dog</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;~Dog() is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述是通过初始化列表给<strong>基类带参构造传递参数</strong>，如果不通过初始化列表传递，会发生什么影响？</p>
<p>去掉初始化列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dog(int age)  &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Dog(int age) is called&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function for call to ‘Animal::Animal()’</span><br></pre></td></tr></table></figure>

<p>由于在Animal中没有默认构造函数，所以报错，遇到这种问题属于灾难性的，我们应该尽量避免，可以通过初始化列表给基类的构造初始化。</p>
<h2 id="类中const数据成员、引用数据成员"><a href="#类中const数据成员、引用数据成员" class="headerlink" title="类中const数据成员、引用数据成员"></a>类中const数据成员、引用数据成员</h2><p>特别是引用数据成员，必须用初始化列表初始化，而不能通过赋值初始化！</p>
<p>例如：在上述的Animal中添加私有成员，并修改构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>(<span class="type">int</span> age,std::string name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> &amp;age_;<span class="comment">//引用，定义同时必须初始化</span></span><br><span class="line">    <span class="type">const</span> std::string name_;<span class="comment">//const类型，定义同时必须初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>报下面错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: uninitialized reference member in ‘int&amp;’</span><br></pre></td></tr></table></figure>

<p>应该改为下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Animal</span>(<span class="type">int</span> age, std::string name) : <span class="built_in">age_</span>(age), <span class="built_in">name_</span>(name) &#123;<span class="comment">//使用初始化列表，相当于定义同时初始化</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Animal(int age) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="枚举类与命名空间"><a href="#枚举类与命名空间" class="headerlink" title="枚举类与命名空间"></a>枚举类与命名空间</h1><p>在Effective modern C++中Item 10: Prefer scoped enums to unscoped enum，<strong>要用有范围的enum class代替无范围的enum</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;circle,retangle&#125;;</span><br><span class="line"><span class="keyword">auto</span> circle = <span class="number">10</span>;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>上述错误是因为两个circle在同一范围。 对于enum等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> circle 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> retangle 1</span></span><br></pre></td></tr></table></figure>

<p>因此后面再去定义circle就会出错。</p>
<p>所以不管枚举名是否一样，里面的成员只要有一致的,就会出问题。 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">A</span> &#123;a,b&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">B</span> &#123;c,a&#125;;</span><br></pre></td></tr></table></figure>

<p>a出现两次，在enum B的a处报错。</p>
<p>根据前面我们知道，enum名在范围方面没有什么作用，因此我们想到了namespace，如下例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建枚举时，将它们放在名称空间中，以便可以使用有意义的名称访问它们:</span></span><br><span class="line"><span class="keyword">namespace</span> EntityType &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">        Ground = <span class="number">0</span>,</span><br><span class="line">        Human,</span><br><span class="line">        Aerial,</span><br><span class="line">        Total</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(EntityType::Enum entityType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entityType == EntityType::Ground) &#123;<span class="comment">//使得Ground在EntityType空间才是全局的</span></span><br><span class="line">        <span class="comment">/*code*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将命名空间起的有意思点，就可以达到想要的效果。</p>
<p>但是不断的使用命名空间，势必太繁琐，而且如果我不想使用namespace，要达到这样的效果，便会变得不安全，也没有约束。</p>
<p>因此在c++11后，引入<strong>enum class</strong>。</p>
<p>enum class 解决了为enum成员定义类型、类型安全、约束等问题。 回到上述例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum class</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EntityType</span> &#123;</span><br><span class="line">    Ground = <span class="number">0</span>,</span><br><span class="line">    Human,</span><br><span class="line">    Aerial,</span><br><span class="line">    Total</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(EntityType entityType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entityType == EntityType::Ground) &#123;<span class="comment">//Ground已非全局，属于枚举类的成员</span></span><br><span class="line">        <span class="comment">/*code*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这便是这一节要阐述的惯用法：enum class。</p>
<h1 id="资源获取即初始化方法-RAII"><a href="#资源获取即初始化方法-RAII" class="headerlink" title="资源获取即初始化方法(RAII)"></a>资源获取即初始化方法(RAII)</h1><blockquote>
<p>RAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父 Bjarne Stroustrup 提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。</p>
</blockquote>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>在C语言中，有三种类型的内存分配:静态、自动和动态。静态变量是嵌入在源文件中的常数，因为它们有已知的大小并且从不改变，所以它们并不那么有趣。自动分配可以被认为是堆栈分配——当一个词法块进入时分配空间，当该块退出时释放空间。它最重要的特征与此直接相关。在C99之前，自动分配的变量需要在编译时知道它们的大小。这意味着任何字符串、列表、映射以及从这些派生的任何结构都必须存在于堆中的动态内存中。</p>
<p>程序员使用四个基本操作明确地分配和释放动态内存:malloc、realloc、calloc和free。前两个不执行任何初始化，内存可能包含碎片。除了自由，他们都可能失败。在这种情况下，它们返回一个空指针，其访问是未定义的行为。</p>
<p>例如：	</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">7</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>(str, <span class="string">&quot;toptal&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char array = \&quot;%s\&quot; @ %u\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">   str = (<span class="type">char</span> *) <span class="built_in">realloc</span>(str, <span class="number">11</span>);</span><br><span class="line">   <span class="built_in">strcat</span>(str, <span class="string">&quot;.com&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char array = \&quot;%s\&quot; @ %u\n&quot;</span>, str, str);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(str);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> array = <span class="string">&quot;toptal&quot;</span> @ <span class="number">2762894960</span></span><br><span class="line"><span class="type">char</span> array = <span class="string">&quot;toptal.com&quot;</span> @ <span class="number">2762894960</span></span><br></pre></td></tr></table></figure>

<p>尽管代码很简单，但它已经包含了一个反模式和一个有问题的决定。在现实生活中，你不应该直接写字节数，而应该使用sizeof函数。类似地，我们将char *数组精确地分配给我们需要的字符串大小的两倍(比字符串长度多一倍，以说明空终止)，这是一个相当昂贵的操作。一个更复杂的程序可能会构建一个更大的字符串缓冲区，允许字符串大小增长。</p>
<h2 id="RAII的发明：新希望"><a href="#RAII的发明：新希望" class="headerlink" title="RAII的发明：新希望"></a>RAII的发明：新希望</h2><p>至少可以说，所有手动管理都是令人不快的。 在80年代中期，Bjarne Stroustrup为他的全新语言C ++发明了一种新的范例。 他将其称为“资源获取即初始化”，其基本见解如下：<strong>可以指定对象具有构造函数和析构函数，这些构造函数和析构函数在适当的时候由编译器自动调用，这为管理给定对象的内存提供了更为方便的方法。</strong> 并且该技术对于不是内存的资源也很有用。</p>
<p>意味着上面的例子在c++中更简洁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   std::string str = std::<span class="built_in">string</span> (<span class="string">&quot;toptal&quot;</span>);</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;string object: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   str += <span class="string">&quot;.com&quot;</span>;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;string object: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string object: toptal @ <span class="number">0x7fffa67b9400</span></span><br><span class="line">string object: toptal.com @ <span class="number">0x7fffa67b9400</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们没有手动内存管理！构造string对象，调用重载方法，并在函数退出时自动销毁。不幸的是，同样的简单也会导致其他问题。让我们详细地看一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; lines;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines.<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">size</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File makefile contains <span class="number">37</span> lines.</span><br></pre></td></tr></table></figure>

<p>这看起来很简单。<code>vector</code>被填满、返回和调用。然而，作为关心性能的高效程序员，这方面的一些问题困扰着我们:在return语句中，由于使用了值语义，<code>vector</code>在销毁之前不久就被复制到一个新<code>vector</code>中（伴随main函数一直存在）。</p>
<blockquote>
<p>在现代C ++中，这不再是严格的要求了。 C ++ 11引入了移动语义的概念，其中将原点保留在有效状态（以便仍然可以正确销毁）但未指定状态。 对于编译器而言，返回调用是最容易优化以优化语义移动的情况，因为它知道在进行任何进一步访问之前不久将销毁源。 但是，该示例的目的是说明为什么人们在80年代末和90年代初发明了一大堆垃圾收集的语言，而在那个时候C ++ move语义不可用。</p>
</blockquote>
<p>对于数据量比较大的文件，这可能会变得昂贵。 让我们对其进行优化，只返回一个指针。 语法进行了一些更改，但其他代码相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; * <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; * lines;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">size</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>程序崩溃！我们只需要将上述的<code>lines</code>进行内存分配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; * lines = <span class="keyword">new</span> vector&lt;string&gt;;</span><br></pre></td></tr></table></figure>

<p>这样就可以运行了！</p>
<p>不幸的是，尽管这看起来很完美，但它仍然有一个缺陷：它会泄露内存。在C++中，指向堆的指针在不再需要后必须手动删除（此时类对象的析构函数无法帮忙）；否则，一旦最后一个指针超出范围，该内存将变得不可用，并且直到进程结束时操作系统对其进行管理后才会恢复。惯用的现代C++将在这里使用<code>unique_ptr</code>，它实现了期望的行为。它删除指针超出范围时指向的对象。然而，这种行为直到C++11才成为语言的一部分。</p>
<p>在这里，可以直接使用C++11之前的语法，只是把main中改一下即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; * <span class="title">read_lines_from_file</span><span class="params">(string &amp;file_name)</span> </span>&#123;</span><br><span class="line">	vector&lt;string&gt; * lines = <span class="keyword">new</span> vector&lt;string&gt;;</span><br><span class="line">	string line;</span><br><span class="line">	</span><br><span class="line">	<span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">		<span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">		lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	file_handle.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	vector&lt;string&gt; * file_lines = <span class="built_in">read_lines_from_file</span>(file_name);</span><br><span class="line">	<span class="type">int</span> count = file_lines-&gt;<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">delete</span> file_lines;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动去分配内存与释放内存。</p>
<p><strong>不幸的是，随着程序扩展到上述范围之外，很快就变得更加难以推理指针应该在何时何地被删除。当一个函数返回指针时，你现在拥有它吗？您应该在完成后自己删除它，还是它属于某个稍后将被一次性释放的数据结构？一方面出错，内存泄漏，另一方面出错，你已经破坏了正在讨论的数据结构和其他可能的数据结构，因为它们试图取消引用现在不再有效的指针。</strong></p>
<h2 id="“使用垃圾收集器，flyboy！”"><a href="#“使用垃圾收集器，flyboy！”" class="headerlink" title="“使用垃圾收集器，flyboy！”"></a>“使用垃圾收集器，flyboy！”</h2><p>垃圾收集器不是一项新技术。 它们由John McCarthy在1959年为Lisp发明。 1980年，随着Smalltalk-80的出现，垃圾收集开始成为主流。 但是，1990年代代表了该技术的真正发芽：在1990年至2000年之间，发布了多种语言，所有语言都使用一种或另一种垃圾回收：Haskell，Python，Lua，Java，JavaScript，Ruby，OCaml 和C＃是最著名的。</p>
<p>什么是垃圾收集？ 简而言之，这是一组用于<strong>自动执行手动内存管理的技术</strong>。 它通常作为具有手动内存管理的语言（例如C和C ++）的库提供，但在需要它的语言中更常用。 最大的优点是程序员根本不需要考虑内存。 都被抽象了。 例如，相当于我们上面的文件读取代码的Python就是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_lines_from_file</span>(<span class="params">file_name</span>):</span><br><span class="line">	lines = []</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> fp: </span><br><span class="line">		<span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">			lines.append(line)</span><br><span class="line">	<span class="keyword">return</span> lines</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="keyword">import</span> sys</span><br><span class="line">	file_name = sys.argv[<span class="number">1</span>]</span><br><span class="line">	count = <span class="built_in">len</span>(read_lines_from_file(file_name))</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;File &#123;&#125; contains &#123;&#125; lines.&quot;</span>.<span class="built_in">format</span>(file_name, count))</span><br></pre></td></tr></table></figure>

<p>行数组是在第一次分配给它时出现的，并且不复制到调用范围就返回。 由于时间不确定，它会在超出该范围后的某个时间被垃圾收集器清理。 有趣的是，在Python中，用于非内存资源的RAII不是惯用语言。 允许我们可以简单地编写<code>fp = open（file_name）</code>而不是使用with块，然后让GC（Garbage Collection，垃圾回收）清理。 但是建议的模式是在可能的情况下使用上下文管理器，以便可以在确定的时间释放它们。</p>
<p>尽管简化了内存管理，但要付出很大的代价。 在引用计数垃圾回收中，所有变量赋值和作用域出口都会获得少量成本来更新引用。在标记清除系统中，在GC清除内存的同时，所有程序的执行都<strong>以不可预测的时间间隔暂停</strong>。 这通常称为<strong>世界停止事件（stop the world）</strong>。「具体来说，<strong>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行</strong>。」 同时使用这两种系统的Python之类的实现都会受到两种惩罚。 这些问题降低了垃圾收集语言在性能至关重要或需要实时应用程序的情况下的适用性。 即使在以下玩具程序上，也可以看到实际的性能下降：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ make cpp &amp;&amp; time ./c++ makefile</span><br><span class="line">g++ -o c++ c++.cpp</span><br><span class="line">File makefile contains <span class="number">38</span> lines.</span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.016</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.015</span>s</span><br><span class="line"></span><br><span class="line">$ time python3 python3.py makefile</span><br><span class="line">File makefile contains <span class="number">38</span> lines.</span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.041</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.015</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.015</span>s</span><br></pre></td></tr></table></figure>

<p>Python版本的实时时间几乎是C ++版本的三倍。 尽管并非所有这些差异都可以归因于垃圾收集，但它仍然是可观的。</p>
<p>GC算法和特点参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/piwenjun/p/5482855.html">GC算法 - 寐语者 - 博客园 (cnblogs.com)</a></p>
<h2 id="所有权：RAII觉醒"><a href="#所有权：RAII觉醒" class="headerlink" title="所有权：RAII觉醒"></a>所有权：RAII觉醒</h2><p>我们知道对象的生存期由其范围决定。 但是，有时我们需要创建一个对象，该对象与创建对象的作用域无关，这是有用的，或者很有用。 在C ++中，运算符new用于创建这样的对象。 为了销毁对象，可以使用运算符delete。 由new操作员创建的对象是动态分配的，即在动态内存（也称为堆或空闲存储）中分配。 因此，由new创建的对象将继续存在，直到使用delete将其明确销毁为止。</p>
<p>使用new和delete时可能发生的一些错误是：</p>
<ul>
<li><p>对象（或内存）泄漏：使用new分配对象，而忘记删除该对象。</p>
</li>
<li><p>过早删除（或悬挂引用）：持有指向对象的另一个指针，删除该对象，然而还有其他指针在引用它。</p>
</li>
<li><p>双重删除：尝试两次删除一个对象。</p>
</li>
</ul>
<p>通常，范围变量是首选。 但是，RAII可以用作new和delete的替代方法，以使对象独立于其范围而存在。 这种技术包括将指针分配到在堆上分配的对象，并将其（堆空间&#x2F;对象）放在<strong>句柄&#x2F;管理器对象</strong>中。 后者具有一个<strong>析构函数</strong>，将负责销毁该对象。 这将确保该对象可用于任何想要访问它的函数，并且该对象<strong>在句柄对象的生存期结束时将被销毁</strong>，而无需进行显式清理。</p>
<p>来自C ++标准库的使用RAII的示例为std :: string和std :: vector。</p>
<p>考虑这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">        vec.<span class="built_in">push_back</span>(c);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建<code>vector</code>,并将元素推入<code>vector</code>时，您不必担心分配和取消分配此类元素内存。 <code>vector</code>使用new为其堆上的元素分配空间，并使用delete释放该空间。 作为vector的用户，您无需关心实现细节，并且会相信vector不会泄漏。 在这种情况下，vector是其元素的句柄对象。</p>
<p>标准库中使用RAII的其他示例是std :: shared_ptr，std :: unique_ptr和std :: lock_guard。</p>
<p>该技术的另一个名称是SBRM，是范围绑定资源管理的缩写。</p>
<p>现在，我们将上述读取文件例子，进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/unique_ptr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">unique_ptr&lt;vector&lt;string&gt;&gt; <span class="built_in">read_lines_from_file</span>(string &amp;file_name) &#123;</span><br><span class="line">    unique_ptr&lt;vector&lt;string&gt;&gt; <span class="built_in">lines</span>(<span class="keyword">new</span> vector&lt;string&gt;);</span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">file_handle</span> <span class="params">(file_name.c_str())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (file_handle.<span class="built_in">good</span>() &amp;&amp; !file_handle.<span class="built_in">eof</span>() &amp;&amp; file_handle.<span class="built_in">peek</span>()!=EOF) &#123;</span><br><span class="line">        <span class="built_in">getline</span>(file_handle, line);</span><br><span class="line">        lines-&gt;<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file_handle.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lines;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// get file name from the first argument</span></span><br><span class="line">	<span class="function">string <span class="title">file_name</span> <span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">read_lines_from_file</span>(file_name).<span class="built_in">get</span>()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;File &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot; contains &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; lines.&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只有在最后，你才意识到RAII的真正力量。"><a href="#只有在最后，你才意识到RAII的真正力量。" class="headerlink" title="只有在最后，你才意识到RAII的真正力量。"></a>只有在最后，你才意识到RAII的真正力量。</h2><p>自从编译器发明以来，手动内存管理是程序员一直在想办法避免的噩梦。 RAII是一种很有前途的模式，但由于没有一些奇怪的解决方法，它根本无法用于堆分配的对象，因此在C ++中会受到影响。 因此，在90年代出现了垃圾收集语言的爆炸式增长，旨在使程序员生活更加愉快，即使以性能为代价。</p>
<p>最后，RAII总结如下：</p>
<ul>
<li><p>资源<strong>在析构函数中被释放</strong></p>
</li>
<li><p>该类的实例是<strong>堆栈分配的</strong></p>
</li>
<li><p>资源是<strong>在构造函数中获取的</strong>。</p>
</li>
</ul>
<p>RAII代表“资源获取是初始化”。</p>
<p>常见的例子有：</p>
<ul>
<li><p>文件操作</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>互斥量</p>
</li>
</ul>
<h1 id="拷贝交换copy-swap"><a href="#拷贝交换copy-swap" class="headerlink" title="拷贝交换copy-swap"></a>拷贝交换copy-swap</h1><p>这部分内容比较难懂，但特别巧妙。我花了挺长时间（起码比前面部分要多得多）理解，期间收集了多方的资料，并根据自己的理解整合（缝合）了一下，形成了一个比较完好、比较易懂的逻辑块，最后进行了一下总结。</p>
<p>首先介绍一下异常安全的概念（主要是针对析构函数，也可以直接跳到copy and swap惯用法章节）</p>
<h2 id="异常安全"><a href="#异常安全" class="headerlink" title="异常安全"></a>异常安全</h2><p>当异常发生时，会进行栈展开stack unwinding，具体步骤为：</p>
<blockquote>
<p>将暂停当前函数的执行，开始查找匹配的 catch 子句。首先检查 throw 本身是否在 try 块内部，如果是，检查与该 try 相关的 catch 子句，看是否有匹配的catch。如果不能处理，就退出当前函数，并且释放当前函数的局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 catch 。这个过程称为栈展开(stack unwinding)。当处理该异常的 catch 结束之后，紧接着该 catch 之后的点继续执行。</p>
</blockquote>
<p>显然栈展开跟对象离开函数作用域，自动析构的功能一样，是为了避免内存泄漏。而stack unwinding只能对栈上的变量析构，堆上动态分配的new不会自动析构。<strong>所以当发生异常时，要特别当心内存泄漏的发生</strong>。</p>
<p>异常处理威力很大，是处理错误的不二之选，但有时我们并不希望在有些函数中抛出异常，如：</p>
<ul>
<li><p><strong>析构函数不可以抛出异常，详见下文</strong>；</p>
</li>
<li><p><strong>构造函数可以抛出异常；</strong></p>
<ul>
<li>如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，根据栈展开的原理，会把已经构造好的对象自动析构；</li>
</ul>
</li>
<li><p><strong>移动赋值函数不应该抛出异常；</strong></p>
<ul>
<li>在STL标准库中很多容器在resize时都会通过<code>std::move_if_noexcept</code>模板来判断元素是否提供了noexcept（无异常）的移动赋值，如果提供那么move，否则调用拷贝赋值函数。所以不抛出异常的移动赋值函数效率会更高。</li>
</ul>
</li>
<li><p><strong>拷贝赋值函数可以抛出异常</strong>；</p>
</li>
<li><p><strong>swap不应该抛出异常</strong>；</p>
<ul>
<li>根据copy and swap惯用法，swap是移动赋值函数的基石。swap不抛出异常，移动赋值才不会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>note：未捕获的异常将会终止程序。</strong>如果找不到匹配的catch，程序就会调用库函数std::terminate。</p>
<h3 id="析构中的异常安全"><a href="#析构中的异常安全" class="headerlink" title="析构中的异常安全"></a>析构中的异常安全</h3><p>提问：析构函数可以抛出异常吗？答案是：不应该也不能。</p>
<p>理由有二，假设某类能抛出异常：</p>
<ol>
<li>vector析构所有元素时，<strong>那么当有一个元素抛出异常，此时catch之后的处理显然是继续销毁剩下的元素，但是假设运气很不好，又有一个元素抛出异常</strong>，c++此时无能为力，要么结束执行，要么发生不预期的行为。</li>
<li>析构函数往往不仅仅释放一个资源，<strong>当前一个资源释放时抛出异常，此时跳过异常点后面的代码，使得后一块资源没有释放，造成内存泄漏</strong>。</li>
</ol>
<p>因此得出结论，即便析构函数抛出了异常，程序猿catch后也无法处理这烫手山芋。不抛出异常是一种及时止损，如果抛会引起其他不可以预期的行为。<strong>c++资源释放不许失败。如果失败了，也不去管它，不抛异常让他去，let it go。</strong>（因为其他不可预期行为比资源释放失败更难以接受）</p>
<p>那么当析构函数发生错误时，该怎么办呢：</p>
<ul>
<li>只好忍气吞声（吞下异常）；</li>
<li>直接终止程序；</li>
<li>其他释放会失败的资源，建议释放不要放析构，放第三方函数，让程序员手工操作；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DBConn::~<span class="built_in">DBConn</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 直接终止</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        记录日志;</span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//吞下异常</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;db.<span class="built_in">close</span>();&#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        记录日志;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管吞下异常是个坏主意，但是没有办法的办法。</p>
<p>其他释放会失败的资源，建议释放不要放析构，放第三方函数，让程序锁手工操作</p>
<p>比如数据库连接断开操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">                记录日志;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBconnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把数据库连接释放这样可能出错的操作交给程序员自行释放，如果程序猿没有自行释放，但由析构函释放。那么此时析构函数出错，程序员也无话可说。</p>
<p>此外c++11之后，默认会把析构函数看成<code>noexcept(true)</code>，这意味着**如果析构函数抛出异常，直接<code>std::terminal</code>**。</p>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>本节是copy and swap的铺垫。</p>
<p>交换函数是一种不抛异常函数，它交换一个类的两个对象或者成员。我们可能很想使用std :: swap而不是提供我们自己的方法，但这是不可能的。 std :: swap在实现中使用了copy-constructor和copy-assignment运算符，我们最终将尝试根据自身定义赋值运算符。</p>
<p>（不仅如此，对swap的无条件调用将使用我们的自定义swap运算符，从而跳过了std :: swap会导致的不必要的类构造和破坏。）</p>
<p>std中的swap是这么写的，应尽可能地<strong>对类的成员变量使用std::swap，而不是对整个类使用std::swap</strong>（如注释所写，若对整个类使用，在内部会调用拷贝构造和赋值构造，会导致的不必要的类构造和破坏）。实际上若使用copy-swap，赋值构造函数会需要调用swap函数，也就是说<strong>在使用swap函数时，赋值构造函数并没有完成。</strong></p>
<p><strong>swap必须注重安全，不允许抛出异常。（std::swap是安全的）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>; <span class="comment">//拷贝构造，如果对象是类</span></span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;<span class="comment">//赋值构造，如果对象是类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="copy-and-swap惯用法"><a href="#copy-and-swap惯用法" class="headerlink" title="copy and swap惯用法"></a>copy and swap惯用法</h2><blockquote>
<p>为什么我们需要复制和交换习惯？</p>
</blockquote>
<p>任何管理资源的类（包装程序，如智能指针）都需要实现big three。尽管拷贝构造函数和析构函数的目标和实现很简单。</p>
<p>big three（亦即下列三个成员函数缺一不可）：</p>
<ul>
<li>析构函数（Destructor）</li>
<li>拷贝构造函数（copy constructor）</li>
<li>赋值构造函数（copy assignment operator）</li>
</ul>
<p>但是赋值构造函数无疑是最细微和最困难的。</p>
<blockquote>
<p>应该怎么做？需要避免什么陷阱？</p>
</blockquote>
<p>copy-swap是解决方案，可以很好地协助赋值运算符实现两件事：<strong>避免代码重复</strong>，并提供强大的<strong>异常保证</strong>。</p>
<blockquote>
<p>它是如何工作的？</p>
</blockquote>
<p><strong>从概念上讲，它通过使用拷贝构造函数的功能来创建数据的本地副本，然后使用交换功能获取复制的数据，将旧数据与新数据交换来工作。然后，临时副本将销毁，并随身携带旧数据。我们剩下的是新数据的副本。</strong></p>
<p>为了使用copy-swap，我们需要三件事：</p>
<ul>
<li>一个有效的拷贝构造函数</li>
<li>一个有效的析构函数（两者都是任何包装程序的基础，因此无论如何都应完整）以及交换功能（swap）。</li>
</ul>
<hr>
<p><strong>实现方式对比</strong></p>
<p>我们先不考虑存在继承关系的类的赋值运算符重写，只考虑最简单的情况。我们知道，按照C++ primer的理解，赋值运算符应该实现两个方面的工作：</p>
<ul>
<li>拷贝构造函数</li>
<li>析构函数。</li>
</ul>
<p>只有完整实现了上述两步工作，赋值运算才能够正确进行。</p>
<p>首先介绍自赋值安全和异常安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当是自赋值的时候，pb已经先被删除了，那么后面的new就会为空，这是未知的计算。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异常安全是指当异常发生时：</span></span><br><span class="line"><span class="comment">	1) 不会泄漏资源，</span></span><br><span class="line"><span class="comment">	2) 也不会使系统处于不一致的状态。</span></span><br><span class="line"><span class="comment"> 通常有三个异常安全级别：基本保证、强烈保证、不抛异常（nothrow）保证。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个自赋值安全，但是没有异常安全，如果new处出现了异常，那么pb仍旧指向空。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb;                   <span class="comment">// stop using current bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">// start using a copy of rhs&#x27;s bitmap</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                <span class="comment">// see Item 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出类A的定义，注意到类A中数据成员的数据类型，分别是内置整型以及整型指针。据此给出了构造以及析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp;rhs):<span class="built_in">a</span>(rhs.a),<span class="built_in">b</span>(rhs.b==<span class="literal">nullptr</span>?<span class="literal">nullptr</span>:<span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b))&#123;&#125;;<span class="comment">//拷贝</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;<span class="comment">//析构</span></span><br><span class="line">        <span class="keyword">delete</span> b;</span><br><span class="line">        b = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值运算符包括拷贝构造以及析构两方面，因此给出第一种定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;rhs) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span> b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b);<span class="comment">// 可能失败</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;a = rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回this对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们的代码几乎是对拷贝构造函数和析构函数的完全复制，此外，上述代码虽然完成了自赋值的验证，但并未保障异常安全。一旦new失败，原this对象的b已经被删除，因此会<strong>引发异常</strong>（若再使用b取值）。</p>
<p>effective C++ 关于本节的条款提到，无须在意自赋值，更多地考虑异常安全，异常安全得到保证，则自赋值自然得到处理。回到当前的例子，异常不安全主要在于，<strong>b对应的对象可能在异常到来之前被删除</strong>。因此我们首先保存该对象的副本，从而保证了异常安全特性，无论new是否成功，this对象中的b指针都会指向已知对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">auto</span> orign = <span class="keyword">this</span>-&gt;b;</span><br><span class="line">    <span class="keyword">this</span>-&gt;b = <span class="keyword">new</span> <span class="built_in">int</span>(*rhs.b);</span><br><span class="line">    <span class="keyword">delete</span> orign;</span><br><span class="line">    <span class="keyword">this</span>-&gt;a = rhs.a;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该写法<strong>不仅是异常安全</strong>的，同时也<strong>能够处理自赋值</strong>，但<strong>冗余代码</strong>的问题仍未得到解决，在effective C++中提到，可以写一个private函数进行调用，可是，这种写法并未解决根本问题：我们在赋值运算中<strong>重复实现了拷贝构造函数和析构函数</strong>。</p>
<p>上述方法事实上是致命的。在不考虑继承关系的复杂情况下，如果更改类A，添加数据成员，我们<strong>在修改其它构造&#x2F;析构函数的同时，也必须修改赋值运算符</strong>。copy and swap技术则可以做到完全规避这一点，此外，所有调用工作由编译器自动完成，无需再做任何额外操作。</p>
<p>该技术的核心就是不再使用引用作为赋值运算符参数，<strong>形参将直接是对象</strong>，这样的写法将会使编译器<strong>自动调用拷贝构造函数</strong>，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生，因为所有的swap是安全、不抛出异常的）。<strong>经过swap后的对象在离开函数体后会自动销毁</strong>，因此也就自动调用了析构函数，具体写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种写法，copy-swap</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;a,rhs.a);<span class="comment">//赋值或调用赋值构造函数（如果a是一个类对象），这导致rhs被销毁后，类本身的数据仍然存在</span></span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;b,rhs.b);<span class="comment">//浅拷贝，把指针内容（地址）交换，</span></span><br><span class="line">    			<span class="comment">//使得rhs调用析构函数时，释放的空间是原来的this-&gt;b的，而新的数据空间仍可以使用，一举两得</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(A rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的代码有着显而易见的优势：所有需要考虑的问题会由编译器处理，我们无需考虑任何事项，关键是，它的正确性是显而易见而且符合逻辑的。对于类的扩展，我们除了构造函数&#x2F;析构函数外，只需要修改swap函数即可。</p>
<hr>
<p><strong>考虑存在继承的复杂情形</strong></p>
<p>本节对应的内容是<em>effective C++ 条款12，<strong>复制对象时勿忘记复制其每一成分。</strong></em> 假设有如下类B继承自上述类A：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ab;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>():<span class="built_in">ab</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B&amp;rhs):<span class="built_in">ab</span>(rhs.ab)&#123;&#125; <span class="comment">// copy constructor</span></span><br><span class="line">    B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp;rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ab = rhs.ab;      <span class="comment">// assignment operator</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述写法有两个错误，首先，B的拷贝构造函数只复制了B的数据成员，对于父类A中的私有成员，并没有进行复制，因此没有做到<strong>复制所有成员</strong>，对此拷贝构造函数需要修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp;rhs):<span class="built_in">A</span>(rhs),<span class="built_in">ab</span>(rhs.ab)&#123;&#125; <span class="comment">// copy constructor</span></span><br></pre></td></tr></table></figure>

<p>同理：赋值运算符也应修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B&amp; <span class="keyword">operator</span>=(<span class="type">const</span> B&amp;rhs)&#123;</span><br><span class="line">        A::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="keyword">this</span>-&gt;ab = rhs.ab;      <span class="comment">// assignment operator</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于采用拷贝交换技术的类，我们则调用其父类的swap函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(B&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    A::<span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;ab,rhs.ab);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>=(B rhs) &#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>copy-swap惯用法实际上是利用编译器调用拷贝构造函数和析构函数来实现赋值构造函数（大前提是赋值构造函数的动作基本与拷贝构造函数（数据复制）和析构函数（原数据清除）相似）。</p>
<ul>
<li>基本的操作是通过传入函数的形参<strong>不是引用</strong>完成的（不是引用的话，则传入的参数会调用拷贝构造，当离开作用域时又会调用析构函数，使得赋值构造函数本身不用重复写这些代码）。<ul>
<li>这同时使得赋值构造函数<strong>避免了自赋值</strong>（因为传入的形参是一个临时对象）；</li>
<li>同时保证<strong>异常安全</strong>，由于拷贝构造函数的调用，异常安全将在进入函数体之前被避免（若拷贝失败则什么都不会发生，因为所有的swap是安全、不抛出异常的）。</li>
</ul>
</li>
<li>然后把拷贝构造函数产生的对象拿来swap，为什么是swap而非继续直接赋值呢？<ul>
<li>这主要是考虑对象中有指针与堆空间的释放，如果将指针直接赋值，则在临时对象析构后，赋值后指向的空间立马就释放了，做了无用功；同时又不保证异常安全了（空指针）。</li>
<li>更重要的是，对象自身的指针也指向堆空间，直接赋值就导致内存空间未释放就丢失，明显是不行的。</li>
<li>使用<strong>swap即可一举两得</strong>，swap一方面把自身指针的地址交换给临时对象的指针地址，当对方调用析构函数时释放掉这块空间；同时使原来拷贝构造出来的数据空间不会丢失。</li>
</ul>
</li>
</ul>
<h1 id="指向实现的指针"><a href="#指向实现的指针" class="headerlink" title="指向实现的指针"></a>指向实现的指针</h1><p>“指向实现的指针”或“pImpl”是一种 C++ 编程技巧，它将类的实现细节从对象表示中移除，<strong>放到一个分离的类中</strong>，并以一个不透明的指针进行访问。</p>
<p>使用pImpl惯用法的原因如下：</p>
<p>考虑如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  C c;</span><br><span class="line">  D d;  </span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>变成pImpl就是下面这样子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">XImpl</span>;</span><br><span class="line">  XImpl* pImpl;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CPP定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>::XImpl</span><br><span class="line">&#123;</span><br><span class="line">  C c;</span><br><span class="line">  D d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>二进制兼容性</li>
</ul>
<p>开发库时，可以在不破坏与客户端的二进制兼容性的情况下向XImpl添加&#x2F;修改字段（这将导致崩溃！）。 由于在向Ximpl类添加新字段时X类的二进制布局不会更改，因此可以安全地在次要版本更新中向库添加新功能。</p>
<p>当然，也可以在不破坏二进制兼容性的情况下向X &#x2F; XImpl添加新的公共&#x2F;私有非虚拟方法，但这与标准的标头&#x2F;实现技术相当。</p>
<ul>
<li>数据隐藏</li>
</ul>
<p>如果您正在开发一个库，尤其是专有库，则可能不希望公开用于实现库公共接口的其他库&#x2F;实现技术。 要么是由于知识产权问题，要么是因为认为用户可能会被诱使对实现进行危险的假设，或者只是通过使用可怕的转换技巧来破坏封装。 PIMPL解决&#x2F;缓解了这一难题。</p>
<ul>
<li>编译时间</li>
</ul>
<p>编译时间减少了，因为当向XImpl类添加&#x2F;删除字段和&#x2F;或方法时（仅映射到标准技术中添加私有字段&#x2F;方法的情况），仅需要重建X的源（实现）文件。 实际上，这是一种常见的操作。</p>
<p>使用标准的标头&#x2F;实现技术（没有PIMPL），当向X添加新字段时，曾经重新分配X（在堆栈或堆上）的每个客户端都需要重新编译，因为它必须调整分配的大小 。 好吧，每个从未分配X的客户端也都需要重新编译，但这只是开销（客户端上的结果代码是相同的）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/03/c++%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/03/c++%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">c++语法记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-03 10:10:09" itemprop="dateCreated datePublished" datetime="2022-08-03T10:10:09+08:00">2022-08-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 21:54:21" itemprop="dateModified" datetime="2022-08-13T21:54:21+08:00">2022-08-13</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h1><p>在 C++ 中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就<strong>只能调用</strong>类的 <strong>const 成员（包括 const 成员变量和 const 成员函数）</strong>了。</p>
<p>定义常对象的语法和定义常量的语法类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span>  <span class="keyword">class</span>  <span class="title">object</span><span class="params">(params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="type">const</span> <span class="title">object</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当然你也可以定义 const 指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> *p = <span class="keyword">new</span> <span class="built_in">class</span>(params);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">const</span> *p = <span class="keyword">new</span> <span class="built_in">class</span>(params);</span><br></pre></td></tr></table></figure>

<p><code>class</code>为类名，<code>object</code>为对象名，<code>params</code>为实参列表，<code>p</code>为指针名。两种方式定义出来的对象都是常对象。</p>
<p>一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p>
<p>虽然常对象中的数据成员不能被修改，但是如果想要修改可以通过修改数据成员声明为<strong>mutable</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>(<span class="type">int</span> x) :<span class="built_in">n</span>(x) &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CTest::display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n++;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">const</span> CTest <span class="title">test</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	test.<span class="built_in">display</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用于区分重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span></span><br><span class="line">&#123;    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">R</span>(<span class="type">int</span> r1, <span class="type">int</span> r2)&#123;R1=r1;R2=r2;&#125;</span><br><span class="line">         <span class="comment">//const区分成员重载函数</span></span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">int</span> R1,R2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常成员函数说明格式：类型说明符  函数名（参数表）const;</span></span><br><span class="line"><span class="comment">这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字。</span></span><br><span class="line"><span class="comment">const关键字可以被用于参与对重载函数的区分</span></span><br><span class="line"><span class="comment">通过常对象只能调用它的常成员函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;普通调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;R1&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;R2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化也需要带上const</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;常对象调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;R1&lt;&lt;<span class="string">&quot;;&quot;</span>&lt;&lt;R2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">print</span>();  <span class="comment">//调用void print()</span></span><br><span class="line">    <span class="comment">//通过常对象只能调用它的常成员函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>,<span class="number">52</span>)</span></span>;  </span><br><span class="line">    b.<span class="built_in">print</span>();  <span class="comment">//调用void print() const</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const成员函数的总结：</p>
<ul>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员（但不对任何数据作修改，除非是mutable的）；</li>
<li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li>
<li>作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。</li>
<li>如果只有const成员函数，非const对象是可以调用const成员函数的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数。</li>
</ul>
<h1 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">testClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testClass</span>();                    <span class="comment">/* 默认构造函数 */</span></span><br><span class="line">    <span class="built_in">testClass</span>(<span class="type">int</span> a, <span class="type">char</span> b);        <span class="comment">/* 构造函数 */</span></span><br><span class="line">    <span class="built_in">testClass</span>(<span class="type">int</span> a=<span class="number">10</span>,<span class="type">char</span> b=<span class="string">&#x27;c&#x27;</span>);    <span class="comment">/* 默认构造函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>  m_a;</span><br><span class="line">    <span class="type">char</span> m_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认构造函数主要是用来完成如下形式的初始化的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 testClass classA;</span><br><span class="line">2 // 或者  testClass *classA = new testClass;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果没有提供默认构造函数，编译器会报错；</p>
<p>非默认构造函数在调用时接受参数，如以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 testClass classA(12,&#x27;H&#x27;);</span><br><span class="line">2 //或者  testClass *classA = new testClass(12,&#x27;H&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有定义<strong>任何构造函数</strong>，则编译器会自动定义默认构造函数，其形式如 testClass() {};  (比如定义了拷贝构造函数，也就不会自动生成默认构造函数)</li>
<li>定义默认构造函数有两种方式，如上述代码展示的，一是定义一个<strong>无参的构造函数</strong>，二是定义<strong>所有参数都有默认值的构造函数</strong> ；</li>
<li>注意：一个类<strong>只能有一个默认构造函数</strong>！也就是说上述两种方式不能同时出现，一般选择 testClass(); 这种形式的默认构造函数 ；</li>
<li><strong>只要定义了构造函数</strong>，编译器就不会再提供默认构造函数了，所以，最好再<strong>手动定义一个默认构造函数</strong>，以防出现 testClass a; 这样的错误。</li>
</ul>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，参数类型是本类的引用。</p>
<p>复制构造函数的参数可以是 <strong>const 引用</strong>，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。</p>
<p>如果类的设计者不写复制构造函数，编译器就会<strong>自动生成复制构造函数</strong>。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。</p>
<p>注意，<strong>默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在</strong>。</p>
<p>复制构造函数在以下三种情况下会被调用。</p>
<ul>
<li><p>1.当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，<strong>赋值语句不会引发复制构造函数的调用</strong>。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c1, c2; c1 = c2 ;</span><br><span class="line">c1=c2;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>2.如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(A &amp; a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Copy constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(A a)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">Func</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这样，如果形参是一个对象，那么形参的值<strong>是否等于</strong>实参，取决于该对象所属的类的复制构造函数是如何实现的。</p>
</li>
<li><p>以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。</p>
</li>
<li><p>如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> Complex &amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种情况下，只能调用c的const成员函数和const成员。</p>
</li>
</ul>
</li>
<li><p>3.如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。例如下面的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123; v = n; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp; a) &#123;</span><br><span class="line">        v = a.v;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Func</span>().v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="构造函数的default和delete"><a href="#构造函数的default和delete" class="headerlink" title="构造函数的default和delete"></a>构造函数的default和delete</h1><p>C++11中，当类中含有不能默认初始化的成员变量时，可以禁止默认构造函数的生成，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>()=<span class="keyword">delete</span>;<span class="comment">//表示删除默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myClass</span>()=<span class="keyword">default</span>;<span class="comment">//表示默认存在构造函数</span></span><br></pre></td></tr></table></figure>

<p>当类中含有不能默认拷贝成员变量时，可以禁止默认构造函数的生成，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myClass</span>(<span class="type">const</span> myClass&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示删除默认拷贝构造函数，即不能进行默认拷贝</span></span><br><span class="line"></span><br><span class="line">myClass &amp; <span class="keyword">operator</span>=(<span class="type">const</span> myClass&amp;)=<span class="keyword">delete</span>;<span class="comment">//表示删除默认赋值构造函数，即不能进行默认赋值</span></span><br></pre></td></tr></table></figure>

<p>同时C++规定，一旦程序员实现了这些函数的自定义版本，则编译器不会再自动生产默认版本。注意只是不自动生成默认版本，当然还是可手动生成默认版本的。当我们自己定义了待参数的构造函数时，我们最好是声明不带参数的版本以完成无参的变量初始化，此时编译是不会再自动提供默认的无参版本了。我们可以通过使用关键字default来控制默认构造函数的生成，显式地指示编译器生成该函数的默认版本。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;  <span class="comment">//同时提供默认版本和带参版本，类型是POD的</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i):<span class="built_in">data</span>(i)&#123;&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有些时候我们希望限制默认函数的生成。典型的是禁止使用拷贝构造函数，<strong>以往的做法是将拷贝构造函数声明为private的，并不提供实现</strong>，这样当拷贝构造对象时编译不能通过，C++11则使用delete关键字显式指示编译器不生成函数的默认版本。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">     <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; )=<span class="keyword">delete</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，一旦函数被delete过了，<strong>那么重载该函数也是非法的</strong>，该函数我们习惯上称为<strong>删除函数</strong>。</p>
<hr>
<p><strong>default和delete的其他用途</strong></p>
<p> 上面我们已经看到在类中我们可用default和delete修饰成员函数，使之成为缺省函数或者删除函数，在类的外面，也可以在类定义之外修饰成员函数，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">MyClass</span>() &amp;<span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; );</span><br><span class="line">);</span><br><span class="line"><span class="comment">//在类的定义外用default来指明缺省函数版本</span></span><br><span class="line"><span class="keyword">inline</span> MyClass&amp; MyClass::<span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; )=<span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>而关于<em><strong>delete</strong></em>的显式删除，<em><strong>并非局限于成员函数</strong></em>，由此我们也知<strong>default是只局限作用于类的部分成员函数的</strong>。于是我们还可用delete来<strong>避免不必要的隐式数据类型转换</strong>。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="built_in">MyClsss</span>(<span class="type">char</span> c)=<span class="keyword">delete</span>;  <span class="comment">//删除char版本的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(MyClass m)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//编译不能通过，否则会自动把&#x27;a&#x27;转换成int</span></span><br><span class="line">  <span class="function">MyClass <span class="title">m1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">MyClass <span class="title">m2</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">//编译不能通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为char版本的构造函数被删除后，试图从char构造MyClass对象的方式是不允许的了。但去掉这句的函数删除后，编译器会<strong>隐式的将a转换为整型</strong>使得编译通过，调用的是整型构造函数，这可能并不是你所想要的。但是如果这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClsss</span><span class="params">(<span class="type">char</span> c)</span></span>=<span class="keyword">delete</span>;  <span class="comment">//删除explicit的char版本的构造函数</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(MyClass m)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;a&#x27;</span>);  <span class="comment">//编译可通过</span></span><br><span class="line">  <span class="function">MyClass <span class="title">m1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">MyClass <span class="title">m2</span><span class="params">(<span class="string">&#x27;a&#x27;</span>)</span></span>;  <span class="comment">//编译不能通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将构造函数explicit后，<strong>构造函数一样的还是不能发生char的构造</strong>，因为char构造版本被删除了，但在Func的调用用，<strong>编译器会尝试将c转换为int</strong>，即Func(‘a’)会调用一次MyClass(int )构造，顺利通过编译。于是我们<strong>不提倡explicit和delete混用</strong>。</p>
<p><strong>对与普通函数delete也有类型的效果</strong>。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">char</span> c)</span></span>=<span class="keyword">delete</span>;  <span class="comment">//显式删除char版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">Func</span>(<span class="string">&#x27;c);  //无法编译通过</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里因为Func的char版本已经被删除，故Func(‘c’)会编译失败。</p>
<p><strong>delete的有趣的用法还有删除operator new操作符</strong>，编码在堆上分配该类的对象如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span></span>=<span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>另外析构函数也是可以delete的</strong></p>
<p>这样做的目的是我们在指定内存位置进行内存分配时并不需要析构函数来完成对象级别的清理，这时我们可显式删除析构函数来限制自定义类型在栈上或者静态的构造。</p>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><blockquote>
<p>C++11中引入了移动构造函数，对象发生拷贝时不需要重新分配空间而是使用被拷贝对象的内存，从而<strong>提高代码运行效率</strong></p>
</blockquote>
<ul>
<li>C++中对象发生拷贝的场景可以分为两种，一种是被拷贝的对象还要继续使用，另一种是被拷贝的对象不再使用；第二种一般可以认为是对右值的拷贝<ul>
<li>&amp;&amp;是右值引用（即将消亡的值就是右值，函数返回的临时变量也是右值），右值可以匹配const &amp;</li>
<li>&amp;可以绑定左值（左值是指表达式结束后依然存在的持久对象，可被赋值）</li>
</ul>
</li>
<li>移动构造函数的第一个参数必须是自身类型的右值引用（不需要const，右值使用const没有意义），若存在额外的参数，任何额外的参数都必须有默认实参</li>
<li>移动构造函数<strong>构造对象时</strong>不再分配新内存，而是接管源对象的内存，移动后源对象进入<strong>可被销毁的状态</strong>，所以源对象中如果有<strong>指针数据成员</strong>，那么它们应该在移动构造函数中应该<strong>赋值为NULL</strong></li>
<li>因为移动操作不分配内存，所以不会抛出任何异常，因此可以用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Joezzz/p/9706769.html">noexcept</a>指定（如果定义在类的外面，那么定义也要用noexcept指定）</li>
</ul>
<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象初始化当前类的对象</strong>，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会<strong>退而求其次，调用拷贝构造函数</strong>。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 <strong>std::move()</strong> 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;<span class="comment">//修改源对象内部指针，指向NULL，使得析构后目标数据空间不会被释放</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">construct!</span></span><br><span class="line"><span class="comment">move construct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">move construct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">class destruct!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<h1 id="移动赋值函数"><a href="#移动赋值函数" class="headerlink" title="移动赋值函数"></a>移动赋值函数</h1><p>与移动构造函数类似，移动构造函数是拷贝函数的替代，移动赋值函数则是赋值构造函数的替代。</p>
<p>也是将原对象的东西赋值给新对象，然后原对象指向空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span> = (A &amp;&amp; x)&#123;<span class="comment">//正常情况下，返回值为A&amp;</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;num = x.num;</span><br><span class="line">    x.num = <span class="literal">NULL</span>;<span class="comment">//修改指针指向NULL</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动赋值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> = (A &amp; x)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = <span class="keyword">new</span> <span class="built_in">int</span>(*x.num);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h1><p>初始化类的成员有两种方式，一是使用初始化列表，二是在构造函数体内进行赋值操作。</p>
<p>使用初始化列表的原因：</p>
<ul>
<li><p>推荐使用初始化列表，它会比在函数体内初始化派生类成员更快，这是因为在分配内存后，在函数体内又多进行了一次赋值操作。</p>
</li>
<li><p>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</p>
</li>
<li><p>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</p>
</li>
<li><p>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接<strong>调用拷贝构造函数初始化</strong></p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test1</span>(<span class="type">int</span> a):<span class="built_in">i</span>(a)&#123;&#125;<span class="comment">//定义了构造函数，没有默认的</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test1 test1 ;<span class="comment">//因为在类Test2中，会根据Test2的构造函数来决定这句话到底只是声明，还是要用构造函数</span></span><br><span class="line"><span class="built_in">Test2</span>(Test1 &amp;t1)</span><br><span class="line">&#123;test1 = t1 ;&#125;<span class="comment">//这里表明test1已经构造好了，所以前面会执行默认构造函数，然后再执行赋值构造函数，会报错（注意这不是在声明时赋值，不是拷贝构造）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以上代码无法通过编译，因为Test2的构造函数中test1 = t1这一行实际上分成两步执行：</span></span><br><span class="line"><span class="comment">1. 调用Test1的默认构造函数来初始化test1，2.执行赋值构造函数</span></span><br><span class="line"><span class="comment">由于Test1没有默认的构造函数，所以1 无法执行，故而编译错误。正确的代码如下，使用初始化列表代替赋值操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test1 test1 ;<span class="comment">//在类Test2中，会根据Test2的构造函数来决定这句话到底只是声明，还是要用构造函数</span></span><br><span class="line"><span class="built_in">Test2</span>(Test1 &amp;t1):<span class="built_in">test1</span>(t1)&#123;&#125;<span class="comment">//这里对编译器强调了“初始化”，即前面只是声明，真正的初始化在这里，所以在这里调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line"><span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">i</span>(x), <span class="built_in">j</span>(i)&#123;&#125;; <span class="comment">// ok, 先初始化i，后初始化j</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> i ;<span class="type">int</span> j ;</span><br><span class="line"><span class="built_in">foo</span>(<span class="type">int</span> x):<span class="built_in">j</span>(x), <span class="built_in">i</span>(j)&#123;&#125; <span class="comment">// i值未定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="派生类对象赋值给基类对象"><a href="#派生类对象赋值给基类对象" class="headerlink" title="派生类对象赋值给基类对象"></a>派生类对象赋值给基类对象</h1><p>c++中经常会发生数据类型的转换，例如将 int 类型的数据赋值给 float 类型的变量时，编译器会先把 int 类型的数据转换为 float 类型再赋值；反过来，float 类型的数据在经过类型转换后也可以赋值给 int 类型的变量。</p>
<p>类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，包括将派生类对象赋值给基类对象、将派生类<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/80/">指针</a>赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为<strong>向上转型</strong>（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。</p>
<p><strong>向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class A: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">A</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class B: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">66</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line">    <span class="comment">//赋值前</span></span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//赋值后</span></span><br><span class="line">    a = b;</span><br><span class="line">    a.<span class="built_in">display</span>();</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">10</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br><span class="line">----------------------------</span><br><span class="line">Class A: m_a=<span class="number">66</span></span><br><span class="line">Class B: m_a=<span class="number">66</span>, m_b=<span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>本例中 A 是基类， B 是派生类，a、b 分别是它们的对象，由于派生类 B 包含了从基类 A 继承来的成员，因此可以将派生类对象 b 赋值给基类对象 a。</p>
<p><strong>赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。</strong></p>
<p>实际上，为了执行赋值，派生类必须初始化好基类的成员变量。</p>
<h1 id="派生类指针（引用）赋值给基类指针（引用）"><a href="#派生类指针（引用）赋值给基类指针（引用）" class="headerlink" title="派生类指针（引用）赋值给基类指针（引用）"></a>派生类指针（引用）赋值给基类指针（引用）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a): <span class="built_in">m_a</span>(a)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class A: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间派生类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">A</span>(a), <span class="built_in">m_b</span>(b)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class B: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基类C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> c): <span class="built_in">m_c</span>(c)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class C: m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终派生类D</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">D::<span class="built_in">D</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d): <span class="built_in">B</span>(a, b), <span class="built_in">C</span>(c), <span class="built_in">m_d</span>(d)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class D: m_a=&quot;</span>&lt;&lt;m_a&lt;&lt;<span class="string">&quot;, m_b=&quot;</span>&lt;&lt;m_b&lt;&lt;<span class="string">&quot;, m_c=&quot;</span>&lt;&lt;m_c&lt;&lt;<span class="string">&quot;, m_d=&quot;</span>&lt;&lt;m_d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *pa = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">    B *pb = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">    C *pc = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">3</span>);</span><br><span class="line">    D *pd = <span class="keyword">new</span> <span class="built_in">D</span>(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>);</span><br><span class="line">    pa = pd;</span><br><span class="line">    pa -&gt; <span class="built_in">display</span>();</span><br><span class="line">    pb = pd;</span><br><span class="line">    pb -&gt; <span class="built_in">display</span>();</span><br><span class="line">    pc = pd;</span><br><span class="line">    pc -&gt; <span class="built_in">display</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pa=&quot;</span>&lt;&lt;pa&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pb=&quot;</span>&lt;&lt;pb&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pc=&quot;</span>&lt;&lt;pc&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pd=&quot;</span>&lt;&lt;pd&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br><span class="line">-----------------------</span><br><span class="line">pa=<span class="number">0x9b17f8</span></span><br><span class="line">pb=<span class="number">0x9b17f8</span></span><br><span class="line">pc=<span class="number">0x9b1800</span></span><br><span class="line">pd=<span class="number">0x9b17f8</span></span><br></pre></td></tr></table></figure>

<p>本例中定义了多个对象指针，并尝试将派生类指针赋值给基类指针。与对象变量之间的赋值不同的是，对象指针之间的赋值并没有拷贝对象的成员，也没有修改对象本身的数据，仅仅是改变了指针的指向。</p>
<p>将派生类指针 pd 赋值给了基类指针 pa，从运行结果可以看出，调用 display() 函数时虽然使用了派生类的成员变量，但是 display() 函数本身却是基类的。也就是说，将派生类指针赋值给基类指针时，通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数。</p>
<p>概括起来说就是：<strong>编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。</strong>（注意一个是指针，一个是指针类型）</p>
<p>执行<code>pc = pd;</code>语句后，pc 和 pd 的值并不相等。这是因为D类先继承了B再继承了C，在内存模型中，<strong>D类实例的空间先存储了B类、再存储了C类</strong>，因此pa、pb直接指向内存空间的起始，而pc要指向C类的那一块空间， 因此在稍后一些的位置（B的结束、C的开始）。</p>
<p>引用在本质上是通过指针的方式实现的，基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">40</span>, <span class="number">400</span>, <span class="number">4000</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">    A &amp;ra = d;</span><br><span class="line">    B &amp;rb = d;</span><br><span class="line">    C &amp;rc = d;</span><br><span class="line">   </span><br><span class="line">    ra.<span class="built_in">display</span>();</span><br><span class="line">    rb.<span class="built_in">display</span>();</span><br><span class="line">    rc.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class A: m_a=<span class="number">4</span></span><br><span class="line">Class B: m_a=<span class="number">4</span>, m_b=<span class="number">40</span></span><br><span class="line">Class C: m_c=<span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>ra、rb、rc 是基类的引用，它们都引用了派生类对象 d，并调用了 display() 函数，从运行结果可以发现，虽然使用了派生类对象的成员变量，但是却没有使用派生类的成员函数，这和指针的表现是一样的。</p>
<p>最后需要注意的是，向上转型后通过基类的对象、指针、引用只能访问从基类继承过去的成员（包括成员变量和成员函数），不能访问派生类新增的成员。</p>
<h1 id="类、派生类的构造"><a href="#类、派生类的构造" class="headerlink" title="类、派生类的构造"></a>类、派生类的构造</h1><ul>
<li><p>类对象成员的构造：<strong>先构造成员变量中的对象，再构造自身对象（调用构造函数）</strong> </p>
</li>
<li><p>派生类构造函数：派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要<strong>调用基类和成员对象的构造函数</strong>，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。</p>
<ul>
<li><p><strong>派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数</strong>，形式如下：</p>
<p><code>派生类构造函数名(参数表):基类构造函数名(参数表),成员对象名1(参数表),…&#123; //…… &#125;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*子类的拷贝构造函数和拷贝赋值函数*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> Age,string Name):<span class="built_in">m_nAge</span>(Age),<span class="built_in">m_strName</span>(Name)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Person:基类的代参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nAge;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> Age,string Name,<span class="type">int</span> Num):<span class="built_in">Person</span>(Age,Name),<span class="built_in">m_nNum</span>(Num)&#123;<span class="comment">//初始化列表传入参数，调用构造</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Student:子类的代参构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp;stu):<span class="built_in">Person</span>(stu),<span class="built_in">m_nNum</span>(stu.m_nNum)&#123;<span class="comment">//初始化列表传入stu，调用拷贝构造</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Student:子类的拷贝构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Student&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Student&amp;stu)&#123; <span class="comment">// 子类的拷贝赋值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;stu)</span><br><span class="line">        &#123;   </span><br><span class="line">            Person::<span class="keyword">operator</span>= (stu);<span class="comment">//显式调用基类的operator</span></span><br><span class="line">            m_nNum = stu.m_nNum;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_nNum;</span><br><span class="line">————————————————</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/whh_1218/article/details/8442734</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>构造函数和析构函数调用次序：</p>
<ul>
<li>先构造基类</li>
<li>再构造成员</li>
<li>最后构造自身（调用构造函数）</li>
</ul>
</li>
<li><p>基类构造顺序由派生层次决定：<strong>最远的基类最先构造</strong> 成员构造顺序和定义顺序符合 析构函数的析构顺序与构造相反</p>
</li>
</ul>
<h1 id="继承访问权限"><a href="#继承访问权限" class="headerlink" title="继承访问权限"></a>继承访问权限</h1><p>基类中protected的成员：</p>
<ul>
<li>类内部：可以访问； 类的使用者：不能访问； 类的派生类成员：可以访问（protected相比private就是能给派生类访问）</li>
<li>派生类不可访问基类的private成员，可访问基类的protected成员，可访问基类的public成员</li>
</ul>
<h2 id="公有（public）继承"><a href="#公有（public）继承" class="headerlink" title="公有（public）继承"></a>公有（public）继承</h2><p>在派生类中，基类成员在派生类的权限为：</p>
<ul>
<li>public -&gt; public</li>
<li>protected -&gt; protected</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="私有（private）继承"><a href="#私有（private）继承" class="headerlink" title="私有（private）继承"></a>私有（private）继承</h2><p>在派生类中，基类成员在派生类的权限为：</p>
<ul>
<li>public -&gt; private</li>
<li>protected -&gt; private</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="保护（protected）继承"><a href="#保护（protected）继承" class="headerlink" title="保护（protected）继承"></a>保护（protected）继承</h2><p>派生方式为protected的继承称为保护继承，在这种继承方式下， 基类的public成员在派生类中会变成protected成员， 基类的protected和private成员在派生类中保持原来的访问权限。注意点：当采用保护继承的时候，由于public成员变为protected成员，因此类的使用者不可访问，而派生类可访问。</p>
<p>在派生类中，基类成员在派生类的权限为</p>
<ul>
<li>public -&gt; protected</li>
<li>protected -&gt; protected</li>
<li>private -&gt; 不可访问</li>
</ul>
<h2 id="派生类对基类成员的访问形式"><a href="#派生类对基类成员的访问形式" class="headerlink" title="派生类对基类成员的访问形式"></a>派生类对基类成员的访问形式</h2><ul>
<li>通过派生类对象直接访问基类成员</li>
<li>在派生类成员函数中直接访问基类成员</li>
<li>通过基类名字限定访问被重载的基类成员名</li>
</ul>
<h1 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h1><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为<strong>虚拟继承</strong>，而A就成了<strong>虚拟基类</strong>。实现的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B1,<span class="keyword">public</span> B2;</span><br></pre></td></tr></table></figure>

<p>虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p>
<h2 id="为什么需要虚继承？"><a href="#为什么需要虚继承？" class="headerlink" title="为什么需要虚继承？"></a>为什么需要虚继承？</h2><p>由于C++支持多重继承，那么在这种情况下会出现重复的基类这种情况，也就是说可能出现将一个类两次作为基类的可能性。比如这里D继承B1和B2，B1继承A，B2也继承A，实际上有两条继承路径：D-&gt;B1-&gt;A，以及D-&gt;B2-&gt;A，D是一样的，但这<strong>两个A在直接继承的情况下是不一样的</strong>。当存在歧义的时候就会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedA</span>:<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DerivedA</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in DerivedA&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedB</span>: <span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DerivedB</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in DerivedB&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:DerivedA,DerivedB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;in MyClass&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下会造成在MyClass中访问value时出现路径不明确的编译错误，要访问数据，就需要显示地加以限定。变成DerivedA::value或 者DerivedB::value，以消除歧义性。并且，通常情况下，像Base这样的公共基类不应该表示为两个分离的对象，而要解决这种问题就可以用虚 基类加以处理。如果使用虚继承，编译便正常了。</p>
<p><strong>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示。</strong></p>
<h2 id="引入虚继承和直接继承的区别"><a href="#引入虚继承和直接继承的区别" class="headerlink" title="引入虚继承和直接继承的区别"></a>引入虚继承和直接继承的区别</h2><p>由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同：</p>
<ul>
<li><strong>时间：</strong>在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。</li>
<li><strong>空间：</strong>由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承会节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。因此，它需要多出一个<strong>指向基类子对象的指针</strong>。</li>
</ul>
<h2 id="内存考虑"><a href="#内存考虑" class="headerlink" title="内存考虑"></a>内存考虑</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一种情况：　　　　　　　　   第二种情况：　　　　　　　　　　  第三种情况　　　　　　　　　　　　 第四种情况：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　 <span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　　  <span class="keyword">class</span> <span class="title class_">a</span>　　　　　　　　　　　　　　<span class="keyword">class</span> <span class="title class_">a</span></span><br><span class="line">&#123;　　　　　　　　　　　　　   &#123;　　　　　　　　　　　　　　　   &#123;　　　　　　　　　　　　　　　　　 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　　　	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;　　　　　　　<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　　  <span class="type">char</span> x;　　　　　　　　　　　　　　 <span class="type">char</span> x;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> a　 <span class="keyword">class</span> <span class="title class_">b</span> :<span class="keyword">public</span> a　　　　　　　 &#125;;　　　　　　　　　　　　　　　　  &#125;;</span><br><span class="line">&#123;　　　　　　　　　　　　　　 &#123;　　　　　　　　　　　　　　 　  <span class="keyword">class</span> <span class="title class_">b</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> a　　　　　 <span class="keyword">class</span> <span class="title class_">b</span>:<span class="function"><span class="keyword">public</span> a</span></span><br><span class="line"><span class="function">    <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　 	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　　　 &#123;　　　　　　　　　　　　　　　　   &#123;</span><br><span class="line">&#125;;　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　	  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;　　　　　　　　<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　  &#125;;　　　　　　　　　　　　　　　　  &#125;;</span><br></pre></td></tr></table></figure>

<p>对这四种情况分别求sizeof(a）, sizeof(b)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种：4，12</span><br><span class="line">第二种：4，4</span><br><span class="line">第三种：8，16</span><br><span class="line">第四种：8，8</span><br></pre></td></tr></table></figure>

<p><strong>每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表</strong>，所以每种情况的类a所占的字节数应该是没有什么问题的，那么类b的字节数怎么算呢？“第一种”和“第三种”情况采用的是虚继承，那么这时候就要有这样的一个指针vptr_b_a，这个指针叫<strong>虚类指针</strong>，指向虚拟基类，也是四个字节；还要包括类a的字节数，所以类b的字节数就求出来了。而“第二种”和“第四种”情况则不包括vptr_b_a这个指针。</p>
<p>注：关于虚函数表的内容，需要结合图片理解，推荐参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaokang01/p/12394420.html">虚函数和虚函数表 - Lucky&amp; - 博客园 (cnblogs.com)</a>。</p>
<h1 id="构造函数和析构函数的构造规则"><a href="#构造函数和析构函数的构造规则" class="headerlink" title="构造函数和析构函数的构造规则"></a>构造函数和析构函数的构造规则</h1><p>构造函数中有默认参数的情况：<strong>既可以在类的声明中，也可以在函数定义中声明缺省参数，但不能既在类声明中又在函数定义中同时声明缺省参数。</strong></p>
<ul>
<li><p>当具有下述情况之一时，派生类可以不定义构造函数：</p>
<ul>
<li><p>基类没有定义任何构造函数</p>
</li>
<li><p>基类具有缺省参数的构造函数</p>
</li>
<li><p>基类具有无参构造函数。</p>
</li>
</ul>
</li>
<li><p>派生类必须定义构造函数的情况：</p>
<ul>
<li>当基类或成员对象所属类只含有带参数的构造函数时，即使派生类本身没有数据成员要初始化，它也必须定义构造函数，并以构造函数<strong>初始化列表</strong>的方式向基类和成员对象的构造函数传递参数，以实现基类子对象和成员对象的初始化。</li>
</ul>
</li>
<li><p>派生类的构造函数只负责直接基类的初始化</p>
</li>
</ul>
<p>C++语言标准有一条规则：如果派生类的基类同时也是另外一个类的派生类，则<strong>每个派生类只负责它的直接基类的构造函数调用</strong>。 这条规则表明当派生类的直接基类只有带参数的构造函数，但没有默认构造函数时（包括缺省参数和无参构造函数），它必须在构造函数的初始化列表中调用其直接基类的构造函数，并向基类的构造函数传递参数，以实现派生类对象中的基类子对象的初始化。 这条规则有一个例外情况，<strong>当派生类存在虚基类时，所有虚基类都由最后的派生类负责初始化。</strong></p>
<p>总结： </p>
<ul>
<li>当有多个基类时，将按照它们在继承方式中的声明次序调用，与它们在构造函数初始化列表中的次序无关。当基类A本身又是另一个类B的派生类时，则先调用基类B的构造函数，再调用基类A的构造函数。</li>
<li>当有多个对象成员时，将按它们在派生类中的声明次序调用，与它们在构造函数初始化列表中的次序无关。</li>
<li>当构造函数初始化列表中的基类和对象成员的构造函数调用完成之后，才执行派生类构造函数体中的程序代码。</li>
</ul>
<h1 id="虚函数与抽象类"><a href="#虚函数与抽象类" class="headerlink" title="虚函数与抽象类"></a>虚函数与抽象类</h1><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态就是在同一个类或继承体系结构的基类与派生类中，用<strong>同名函数</strong>来实现各种不同的功能。</p>
<ul>
<li><strong>静态绑定又称静态联编</strong>：是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。</li>
<li><strong>动态绑定又称动态联编</strong>：是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</li>
<li><strong>编译时多态性</strong>（静态联编(连接)）：系统在编译时就决定如何实现某一动作,即对某一消息如何处理。静态联编具有执行<strong>速度快</strong>的优点。在C++中的编译时多态性是通过<strong>函数重载和运算符重载</strong>实现的。</li>
<li><strong>运行时多态性</strong>（动态联编(连接)）：系统在运行时动态实现某一动作,即对某一消息在运行过程实现其如何响应。动态联编为系统提供了<strong>灵活和高度问题抽象</strong>的优点,在C++中的运行时多态性是通过<strong>继承和虚函数</strong>实现的。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的意义：</p>
<ul>
<li>首先派生类对象可以赋值给基类对象。 派生类对象的地址可以赋值给指向基类对象的指针。 派生类对象可以作为基类对象的引用。 赋值相容的问题： 不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中<strong>继承到的成员</strong>， <strong>不能借此访问派生类定义的成员</strong>。</li>
<li>虚函数使得可以通过基类对象的指针或引用<strong>访问派生类定义的成员</strong>。</li>
<li>virtual关键字其实质是告知编译系统，被指定为virtual的函数采用动态联编的形式编译。</li>
<li>虚函数的虚特征：基类指针指向派生类的对象时，通过该指针访问其虚函数将<strong>调用派生类的版本</strong>。</li>
</ul>
<p>要点：</p>
<ul>
<li>一旦将某个成员函数声明为虚函数后，它在继承体系中就<strong>永远</strong>为虚函数了。（派生类在定义时可以不加virtual关键字）</li>
<li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们<strong>实际所指对象中的虚函数版本</strong>。</li>
<li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，<strong>才能体现虚函数的特性</strong>。</li>
<li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的<strong>函数原型完全相同</strong>，<strong>否则就是普通的重载函数</strong>，与基类的虚函数无关。</li>
<li>派生类通过<strong>从基类继承的成员函数调用虚函数</strong>时，将<strong>访问到派生类中的版本</strong>。</li>
<li>只有类的<strong>非静态成员函数</strong>才能被定义为虚函数，类的<strong>构造函数和静态成员函数不能定义为虚函数</strong>。原因是虚函数在继承层次结构中才能够发生作用，而<strong>构造函数、静态成员是不能够被继承的</strong>。</li>
<li><strong>内联函数也不能是虚函数</strong>（多态时）。因为<strong>内联函数采用的是静态联编</strong>的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使<strong>虚函数在类体内被定义，C++编译器也将它视为非内联函数</strong>。 <ul>
<li>类中定义的函数是内联函数，类中声明、类外定义且都没用inline关键字的是普通函数（注：inline要起作用，inline要与<strong>函数定义</strong>放在一起。inline是一种“用于实现的关键字，而不是用于声明的关键字）</li>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
</li>
<li>基类<strong>析构函数几乎总是为虚析构函数</strong>。假定使用delete和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚，就如一个普通成员函数，delete函数调用的就是基类析构函数（<strong>而不是调用该派生类的析构函数</strong>）。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底。（如果是虚析构函数，则会先调用派生类的析构函数再调用基类的析构函数）</li>
</ul>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>纯虚函数：仅定义函数原型而不定义其实现的虚函数。</p>
<p>实用角度：占位手段place-holder。</p>
<p>方法学：接口定义手段，抽象表达手段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ret_type <span class="title">func_name</span> <span class="params">(param)</span> </span>= <span class="number">0</span>; <span class="comment">//virtual与‘=0’就构成纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类：包含一个或多个纯虚函数的类。</p>
<p><strong>不能实例化抽象类</strong>，但可以定义抽象类的<strong>指针和引用</strong>。定义一个抽象类的派生类，必须定义<strong>所有纯虚函数</strong>，否则该派生类仍然是一个抽象类。</p>
<p>总结：</p>
<ul>
<li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li>
<li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li>
<li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li>
</ul>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载是C++的一项强大功能。通过重载，可以扩展C++运算符的功能，使它们能够操作用户自定义的数据类型，增加程序代码的直观性和可读性。</p>
<h2 id="重载二元运算符"><a href="#重载二元运算符" class="headerlink" title="重载二元运算符"></a>重载二元运算符</h2><p>二元运算符的调用形式与解析：a@b 可解释成 <code>a.operator@(b)</code> 或解释成 <code>operator@(a,b)</code>(@表示运算符)</p>
<p>如果两者都有定义,就按照重载解析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>+(<span class="type">int</span>);<span class="comment">//实际上是X+int</span></span><br><span class="line">	<span class="built_in">X</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(X,X);<span class="comment">//X+x</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+(X,<span class="type">double</span>);<span class="comment">//X+double</span></span><br></pre></td></tr></table></figure>

<h2 id="类运算符重载形式"><a href="#类运算符重载形式" class="headerlink" title="类运算符重载形式"></a>类运算符重载形式</h2><ul>
<li><p>非静态成员运算符重载：以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以this指针隐式传递的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">		<span class="type">double</span> real,image;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		Complex <span class="keyword">operator</span>+(Complex b)&#123;……&#125;<span class="comment">//实际上是Complex+Complex，*this+b</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元运算符重载：如果将运算符函数作为类的友元重载，它需要的参数个数就与运算符实际需要的参数个数相同。</p>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">……</span><br><span class="line">		<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex a,Complex b);<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实际上就是Complex+Complex，a+b</span></span><br><span class="line">Complex  <span class="keyword">operator</span>+(Complex a,Complex b)&#123;……&#125;<span class="comment">//定义，注意定义必须在类声明完成后实现，否则编译器不知道Complex是一个类的类型</span></span><br></pre></td></tr></table></figure>

<h2 id="重载一元运算符"><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h2><ul>
<li><p>一元运算符：只需要一个运算参数，如取地址运算符（&amp;）、负数（?）、自增加（++）等。</p>
</li>
<li><p>一元运算符常见调用形式如下，其中的@代表一元运算符，a代表操作数。</p>
<ul>
<li>隐式调用形式：@a 或 a@ ，@a代表前缀一元运算，如“++a”；a@表示后缀运算，如“a++”。</li>
<li>显式调用一元运算符@：a.operator@()</li>
</ul>
</li>
<li><p>一元运算符作为类成员函数重载时不需要参数，其形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		T <span class="keyword">operator</span>@()&#123;……&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//T是运算符@的返回类型。从形式上看，作为类成员函数重载的一元运算符没有参数</span></span><br><span class="line"><span class="comment">//但实际上它包含了一个隐含参数，即调用对象的this指针。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>前自增(减)与后自增(减)：C++编译器可以通过在运算符函数参数表中是否插入关键字int 来区分这两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀</span></span><br><span class="line"><span class="keyword">operator</span> ++ ();</span><br><span class="line"><span class="keyword">operator</span> ++ (X &amp; x);<span class="comment">//这里的X代表其他的类型，可能有其他操作</span></span><br><span class="line"><span class="comment">//后缀</span></span><br><span class="line"><span class="keyword">operator</span> ++ (<span class="type">int</span>);</span><br><span class="line"><span class="keyword">operator</span> ++ (X &amp; x, <span class="type">int</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="重载赋值运算符-x3D"><a href="#重载赋值运算符-x3D" class="headerlink" title="重载赋值运算符&#x3D;"></a>重载赋值运算符&#x3D;</h2><p>当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符。</p>
<p><strong>即使我们没有显式的重载赋值运算符，编译器也会以默认地方式重载它。默认重载的赋值运算符功能很简单，就是将原有对象的所有成员变量一一赋值给新对象，这和默认拷贝构造函数的功能类似。</strong></p>
<p>对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//变长数组类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> len);</span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array &amp;arr);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（读取）</span></span><br><span class="line">    <span class="type">int</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i)&#123; <span class="keyword">return</span> m_p[i]; &#125;  <span class="comment">//获取元素（写入）</span></span><br><span class="line">    Array &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array &amp;arr);  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_len; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_len;</span><br><span class="line">    <span class="type">int</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="type">int</span> len): <span class="built_in">m_len</span>(len)&#123;</span><br><span class="line">    m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line">Array::<span class="built_in">Array</span>(<span class="type">const</span> Array &amp;arr)&#123;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">&#125;</span><br><span class="line">Array::~<span class="built_in">Array</span>()&#123; <span class="built_in">free</span>(m_p); &#125;</span><br><span class="line"></span><br><span class="line">Array &amp;Array::<span class="keyword">operator</span>=(<span class="type">const</span> Array &amp;arr)&#123;  <span class="comment">//重载赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">this</span> != &amp;arr)&#123;  <span class="comment">//判断是否是给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_len = arr.m_len;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;m_p);  <span class="comment">//释放原来的内存</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_p = (<span class="type">int</span>*)<span class="built_in">calloc</span>( <span class="keyword">this</span>-&gt;m_len, <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">        <span class="built_in">memcpy</span>( <span class="keyword">this</span>-&gt;m_p, arr.m_p, m_len * <span class="built_in">sizeof</span>(<span class="type">int</span>) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>operator&#x3D;() 的返回值类型为<code>Array &amp;</code>，这样不但能够<strong>避免在返回数据时调用拷贝构造函数</strong>，还能够达到<strong>连续赋值</strong>的目的。下面的语句就是连续赋值：arr4 &#x3D; arr3 &#x3D; arr2 &#x3D; arr1;</li>
<li><code>if( this != &amp;arr)</code>语句的作用是<strong>「判断是否是给同一个对象赋值」</strong>：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。</li>
<li><code>return *this</code>表示返回当前对象（新对象）。</li>
<li>operator&#x3D;() 的形参类型为<code>const Array &amp;</code>，这样不但<strong>能够避免在传参时调用拷贝构造函数</strong>，还能够<strong>同时接收 const 类型和非 const 类型的实参</strong>。</li>
<li>赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是<strong>其它参数必须给出默认值</strong>，例如：<code>Array &amp; operator=(const Array &amp;arr, int a = 100);</code></li>
</ul>
<h2 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符[]"></a>重载赋值运算符[]</h2><ul>
<li><p>[ ]是一个二元运算符，其重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		X&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//调用：X[n]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载[]需要注意的问题</p>
<ul>
<li>[]是一个二元运算符，其第1个参数是通过对象的this指针传递的，第2个参数代表数组的下标</li>
<li>由于[]既可以出现在赋值符“&#x3D;”的左边，也可以出现在赋值符“&#x3D;”的右边，所以重载运算符[]时常<strong>返回引用</strong>。（既能作为左值赋值也能作为右值读取，如果不是引用，作为左值时函数只是返回了一个临时对象，赋值写入没用意义）</li>
<li><strong>[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数</strong>。</li>
</ul>
</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载( )"></a>重载( )</h2><ul>
<li><p>运算符( )是函数调用运算符，也能被重载。且<strong>只能被重载为类的成员函数</strong>。</p>
</li>
<li><p>运算符( )的重载形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">……</span><br><span class="line">		<span class="function">X&amp; <span class="title">operator</span><span class="params">( )</span><span class="params">(参数表)</span></span>;<span class="comment">//其中的参数表可以包括任意多个参数。</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符( )的调用形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X Obj; <span class="comment">//对象定义</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Obj</span>()(参数表); <span class="comment">//调用形式1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Obj</span>(参数表); <span class="comment">//调用形式2，普遍用这种形式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类强制转换的重载"><a href="#类强制转换的重载" class="headerlink" title="类强制转换的重载"></a>类强制转换的重载</h2><ul>
<li>类型转换函数<strong>没有参数</strong>。</li>
<li>类型转换函数<strong>没有返回类型</strong>。</li>
<li>类型转换函数<strong>必须返回将要转换成的type类型数据</strong>。</li>
</ul>
<p>看一下实例便知：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有一个类Circle，设计该类的类型转换函数，当将Circle对象转换成int型时，返回圆的半径；当将它转换成double型时，就返回圆的周长；当将它转换成float型时，就返回圆的面积。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x,y,r;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> x1,<span class="type">double</span> y1,<span class="type">double</span> r1)&#123;x=x1;y=y1;r=r1;	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">int</span>(r);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*<span class="number">3.14</span>*r;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (<span class="type">float</span>)<span class="number">3.14</span>*r*r;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> r=c;        <span class="comment">//因为r是int类型，会导致c主动调用operator int()，将Circle类型转换成int，然后给r赋值。</span></span><br><span class="line">    <span class="type">double</span> length=c;   <span class="comment">//调用operator double()，转换成double</span></span><br><span class="line">    <span class="type">float</span> area=c;   <span class="comment">//调用operator float()，将Circle类型转换成float</span></span><br><span class="line">    <span class="type">double</span> len=(<span class="type">double</span>) c;	<span class="comment">//将Cirlce类型对象强制转换成double</span></span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;length&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;area&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">15.7</span></span><br><span class="line"><span class="comment">15.7</span></span><br><span class="line"><span class="comment">19.625</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板（template）是C++实现代码重用机制的重要工具，是泛型技术（即与数据类型无关的通用程序设计技术）的基础。 模板是C++中相对较新的语言机制，它实现了与具体数据类型无关的通用算法程序设计，能够提高软件开发的效率，是程序代码复用的强有力工具。</p>
<p>模板概念：模板是对具有相同特性的函数或类的再抽象，模板是一种参数多态性的工具，可以为逻辑功能相同而类型不同的程序提供一种代码共享的机制。 一个模板并非一个实实在在的函数或类，仅仅是一个函数或类的<strong>描述</strong>，是参数化的函数和类。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板提供了一种通用的函数行为，该函数行为可以用多种不同的数据类型进行调用，编译器会据调用类型自动将它实例化为具体数据类型的函数代码，也就是说函数模板代表了一个<strong>函数家族</strong>。 与普通函数相比，函数模板中某些函数元素的数据类型是未确定的，这些元素的类型将在使用时被参数化；与重载函数相比，函数模板<strong>不需要程序员重复编写函数代码</strong>，它可以自动生成许多功能相同但参数和返回值类型不同的函数。当实例化一个函数模板时，编译器自动生成一份具有相应类型的代码。</p>
<p>函数模板的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>,…&gt;</span><br><span class="line">返回类型 函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">   	…… <span class="comment">//函数模板定义体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>template是定义模板的关键字；写在一对&lt;&gt;中的T1，T2，…是模板参数，其中的class表示其后的参数可以是任意类型。</p>
<p>注意事项 :</p>
<ul>
<li><p>在定义模板时，不允许template语句与函数模板定义之间有任何其他语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> x;                 <span class="comment">//错误，不允许在此位置有任何语句</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板可以有多个类型参数，但每个类型参数都必须用关键字class或typename限定。此外，模板参数中还可以出现确定类型参数，称为非类型参数（<em><strong>浮点数和类对象是不允许作为非类型模板参数的</strong></em>）。例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="keyword">class</span> <span class="title class_">T3</span>,<span class="type">int</span> T4&gt;<span class="comment">//在传递实参时，非类型参数T4只能使用常量</span></span><br><span class="line"><span class="function">T1 <span class="title">fx</span><span class="params">(T1 a, T <span class="number">2</span> b, T3 c)</span></span>&#123;…&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> Val, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">addValue</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + Val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用，这种情况必须像类一样显式实例化</span></span><br><span class="line"><span class="built_in">addValue</span>&lt;<span class="number">5</span>,<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要把这里的class与类的声明关键字class混淆在一起，虽然它们由相同的字母组成，但含义是不同的。这里的class表示T是一个类型参数，可以是任何数据类型，如int、float、char等，或者用户定义的struct、enum或class等自定义数据类型。</p>
</li>
<li><p>为了区别类与模板参数中的类型关键字class，标准C++用typename作为模板参数的类型关键字，同时也支持使用class。比如，把min定义的template 写成下面的形式是完全等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a,T b)</span></span>&#123;…&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数模板的实例化：</p>
<ul>
<li><p>实例化发生的时机 模板实例化发生在调用模板函数时。当编译器遇到程序中对函数模板的调用时，它才会根据调用语句中实参的具体类型，确定模板参数的数据类型，并<strong>用此类型替换函数模板中的模板参数，生成能够处理该类型的函数代码</strong>，即<strong>模板函数</strong>。</p>
</li>
<li><p>当多次发生类型相同的参数调用时，只在第1次进行实例化。假设有下面的函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="built_in">min</span>(<span class="number">2</span>,<span class="number">3</span>);     </span><br><span class="line"><span class="type">int</span> y=<span class="built_in">min</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> z=<span class="built_in">min</span>(<span class="number">8.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器只在第1次调用时生成模板函数，当之后遇到相同类型的参数调用时，不再生成其他模板函数，</span></span><br><span class="line"><span class="comment">//它将调用第1次实例化生成的模板函数。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>实例化方式：</p>
<ul>
<li><p><strong>隐式实例化</strong>：编译器能够判断模板参数类型时，自动实例化函数模板为模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式实例化，表面上是在调用模板，实际上是调用其实例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T, T)</span></span>;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span> (<span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line"><span class="type">float</span> f = <span class="built_in">max</span> (<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="type">char</span> ch = <span class="built_in">max</span> (‘a’, ‘A’);</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示实例化explicit instantiation</strong> ：编译器不能判断模板参数类型或常量值，需要使用特定数据类型实例化 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法形式：模板名称&lt;数据类型,…,常量值,…&gt; (参数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function">T <span class="title">max</span> <span class="params">(T, T)</span></span>;</span><br><span class="line">…</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span> (<span class="number">1</span>, ‘<span class="number">2</span>’); <span class="comment">// error: data type can’t be deduced</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">max</span>&lt;<span class="type">int</span>&gt; (<span class="number">1</span>, ‘<span class="number">2</span>’);<span class="comment">//将&#x27;2‘强制转化为int类型</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数模板的特化(<strong>函数模板的特化，只能全特化</strong>）：</p>
<ul>
<li><p>特化的原因：在某些情况下，模板描述的通用算法<strong>不适合特定的场合</strong>（数据类型等） 比如：如max函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * cp = <span class="built_in">max</span> (“abcd”, “<span class="number">1234</span>”);</span><br><span class="line">实例化为：</span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">max</span> <span class="params">(<span class="type">char</span> * a, <span class="type">char</span> * b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br></pre></td></tr></table></figure>

<p>这肯定是有问题的，因为字符串的比较为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">max</span> <span class="params">(<span class="type">char</span> * a, <span class="type">char</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b)&gt;<span class="number">0</span> ? a : b;   &#125;</span><br></pre></td></tr></table></figure>

<p>因此需要写出一份特化版本的max函数，在遇到字符串时使用特化版本而不使用泛型版本。</p>
</li>
<li><p>所谓特化，就是针对模板不能处理的特殊数据类型，编写与模板同名的特殊函数专门处理这些数据类型。 </p>
<p><strong>模板特化的定义形式</strong>：<code>template &lt;&gt; 返回类型 函数名&lt;特化的数据类型&gt;(参数表) &#123; …… &#125;</code></p>
<p>说明： ① template &lt; &gt;是模板特化的关键字，&lt; &gt;中不需要任何内容； ② 函数名后的&lt; &gt;中是需要特化处理的数据类型，实际上，这是对泛型版本说明该函数要特化的形式（即显式告知泛型中的T）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对于该函数模板，当实参为两个char指针时，比较的是指针的大小，而不是指针指向内容的大小，</span></span><br><span class="line"><span class="comment">//此时就需要为该函数模板定义一个特化版本，即特殊处理的版本：</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//为实参类型 const char * 提供特化版本</span></span><br><span class="line"><span class="comment">//template &lt;&gt; int compare(const char * const &amp;v1, const char * const &amp;v2) </span></span><br><span class="line"><span class="comment">//省略了函数名后边的显示模板实参，因为可以从函数形参表推断出来，本定义与下边的定义都是正确的；</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">int</span> <span class="built_in">compare</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v1, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;template &lt;&gt; int compare&lt;const char *&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//为实参类型 char * 提供特化版本</span></span><br><span class="line"><span class="comment">//template &lt;&gt; int compare(char * const &amp;v1, char * const &amp;v2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">int</span> <span class="built_in">compare</span>&lt;<span class="type">char</span> *&gt;(<span class="type">char</span> * <span class="type">const</span> &amp;v1, <span class="type">char</span> * <span class="type">const</span> &amp;v2)</span><br><span class="line">&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;template &lt;&gt; int compare&lt;char *&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>当程序中同时存在模板和它的特化时，特化将被优先调用；</li>
<li>在同一个程序中，除了函数模板和它的特化外，还<strong>可以有同名的普通函数</strong>。其区别在于C++会对普通函数的调用实参进行隐式的类型转换，但<strong>不会对模板函数及特化函数的参数进行任何形式的类型转换</strong>（需要匹配或者显式实例）。</li>
<li>当同一程序中具有模板与普通函数时，其匹配顺序（调用顺序）如下： <ul>
<li>1.完全匹配的非模板函数</li>
<li>2.完全匹配的模板函数</li>
<li>3.类型相容的非模板函数</li>
</ul>
</li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板可用来设计结构和成员函数完全相同，但所处理的数据类型不同的通用类。</p>
<p>类模板的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,…&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    	…… <span class="comment">// 类成员的声明与定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中T1、T2是类型参数。类模板中可以有多个模板参数，包括类型参数和非类型参数</p>
<p>非类型参数是指某种具体的数据类型，在调用模板时只能为其提供用相应类型的常数值。非类型参数是受限制的，通常可以是整型、枚举型、对象或函数的引用，以及对象、函数或类成员的指针，<strong>但不允许用浮点型（或双精度型）、类对象或void作为非类型参数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,<span class="type">int</span> T3&gt;</span><br><span class="line"><span class="comment">//在实例化时，必须为T1、T2提供一种数据类型，为T3指定一个整常数（如10），该模板才能被正确地实例化。</span></span><br></pre></td></tr></table></figure>

<p>类模板的成员函数的定义：</p>
<ul>
<li><p>类内成员函数定义，与常规成员函数的定义类似，另外 “模板参数列表”引入的“类型标识符”直接作为数据类型使用，“模板参数列表”引入的“普通数据类型常量”直接作为常量使用。</p>
</li>
<li><p>在类模板外定义，语法：</p>
<p>template &lt;模板参数列表&gt; [返回值类型] [类模板名&lt;模板参数名表&gt;::] [成员函数名] ([参数列表]){…};</p>
<p>就比普通的模板函数多了 <code> [类模板名&lt;模板参数名表&gt;::]</code>。</p>
</li>
</ul>
<p>类可以特化，与函数模板不同的是，类不仅可以全特化，也可以<strong>偏特化</strong>。</p>
<p>偏特化是指提供另一份template定义式，而其本身仍为<code>templatized</code>，这是针对于<code>template</code>参数更进一步的条件限制所设计出来的一个特化版本。也就是如果这个模板有多个类型，那么<strong>只限定其中的一部分</strong>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;<span class="comment">//泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(T1 a, T2 b):_a(a),_b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T1 _a;</span><br><span class="line"> T2 _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) :_a(a), _b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板全特化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line"> <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板偏特化，只限定一个参数类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">int</span>,T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Test</span>(<span class="type">int</span> a, T b) :_a(a), _b(b)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板偏特化&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _a;</span><br><span class="line"> T _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">double</span>, <span class="type">double</span>&gt; <span class="title">t1</span><span class="params">(<span class="number">1.01</span>, <span class="number">1.01</span>)</span></span>;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"> <span class="function">Test&lt;<span class="type">int</span>, <span class="type">char</span>*&gt; <span class="title">t3</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>)</span></span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板成员函数的全特化（不能偏特化）</span></span><br><span class="line"><span class="comment">//实际上也是对类模板的特化，因为作为类的成员函数，当类的类型确定下来了自然就知道要调用哪个类型的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE;i++)&#123;</span><br><span class="line">                array[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">()</span></span>;<span class="comment">//特化</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T array[MAXSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//泛型</span></span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">Sort</span>()&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;fanxing&quot;</span>&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span> p,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;MAXSIZE;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[p]&lt;array[j])</span><br><span class="line">                p=j;</span><br><span class="line">        &#125;</span><br><span class="line">        T t;</span><br><span class="line">        t=array[i];</span><br><span class="line">        array[i]=array[p];</span><br><span class="line">        array[p]=t;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">//特化</span></span><br><span class="line"><span class="type">void</span> Array&lt;<span class="type">char</span> *&gt;::<span class="built_in">Sort</span>()&#123; <span class="comment">//注意是对Array类模板特化</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;tehua&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> p,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;MAXSIZE;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(array[p],array[j])&lt;<span class="number">0</span>)</span><br><span class="line">                p=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* t=array[i];</span><br><span class="line">        array[i]=array[p];</span><br><span class="line">        array[p]=t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强调：</p>
<ul>
<li>函数模板只有特化，没有偏特化；</li>
<li>模板、模板的特化和模板的偏特化都存在的情况下，编译器在编译阶段进行匹配，优先匹配特殊的（如能匹配全特化就不会匹配偏特化）；</li>
<li>模板函数不能是虚函数；因为每个包含虚函数的类具有一个virtual table,包含该类的所有虚函数的地址，因此vtable的大小是确定的。模板只有被使用时才会被实例化，将其声明为虚函数会使vtable的大小不确定。所以，成员函数模板不能为虚函数。</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p>
<p>提供<strong>异常</strong>的<strong>基本目的</strong>就是为了处理上面的问题。<strong>基本思想</strong>是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。也就是《C++ primer》中说的：将<strong>问题检测</strong>和<strong>问题处理</strong>相分离。</p>
<p>优点有以下几点：</p>
<ul>
<li>异常处理可以在调用<strong>跳级</strong>。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的<strong>栈展开</strong>机制，只需要在一处进行处理就可以了，不需要每级函数都处理。<ul>
<li>栈展开：如果在一个函数内部抛出异常（throw），而此异常并未在该函数内部被捕捉（catch），就将导致该函数的运行在抛出异常处结束，所有已经分配在<strong>栈</strong>上的局部变量都要被释放。然后会接着向下线性的搜索函数调用栈，来寻找异常处理者，并且带有异常处理的函数（也就是有catch捕捉到）之前的所有实体（每级函数），都会从函数调用栈中删除。</li>
<li>栈展开危害：在栈展开的过程中，如果被释放的局部变量中有指针，而该指针在此前已经用new运算申请了空间，就有可能导致内存泄露。因为栈展开的时候并不会自动对指针变量执行delete（或delete[]）操作。</li>
</ul>
</li>
<li>整型返回值没有任何语义信息。而异常却<strong>包含语义信息</strong>，有时你从类名就能够体现出来。</li>
<li>整型返回值缺乏相关的<strong>上下文信息</strong>。异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。</li>
</ul>
<p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会<strong>抛出一个异常</strong>。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序<strong>捕获异常</strong>。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 try 块在不同的情境下会抛出不同的异常，</span></span><br><span class="line"><span class="comment">//这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p>
<p>以下是尝试除以零时抛出异常的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。</p>
<p>析构的顺序与构造的顺序相反，这一过程称为栈的<strong>解旋</strong>(unwinding).</p>
<ul>
<li><p>在try中抛出的异常被相应的catch捕获</p>
</li>
<li><p>在catch中抛出的异常可以被上层函数调用的catch捕获</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;yichang&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;in fun&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">throw</span> <span class="number">1</span>; <span class="comment">// throw to main</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fun</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;in main, get it&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理 ExceptionName 异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码会捕获一个类型为 ExceptionName 的异常。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 保护代码</span></span><br><span class="line">&#125;<span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>catch的匹配过程是找<strong>最先匹配</strong>的，不是最佳匹配。</li>
<li>catch的匹配过程中，对类型的要求比较<strong>严格</strong>。<strong>不</strong>允许<strong>标准算术转换</strong>和<strong>类类型的转换</strong>。（类类型的转化包括<strong>两</strong>种：通过构造函数的<strong>隐式类型转化</strong>和通过<strong>转化操作符</strong>的类型转化）。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;<span class="comment">//被throw的是const char* 类型的</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">50</span>;</span><br><span class="line">   <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">   <span class="type">double</span> z = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     z = <span class="built_in">division</span>(x, y);</span><br><span class="line">     cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">   &#125;<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">     cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：<code>Division by zero condition!</code></p>
<h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在<code>&lt;exception&gt;</code>中，我们可以在程序中使用这些标准的异常。</p>
<table>
<thead>
<tr>
<th><strong>std::exception</strong></th>
<th>该异常是所有标准 C++ 异常的父类。</th>
</tr>
</thead>
<tbody><tr>
<td>std::bad_alloc</td>
<td>该异常可以通过 <strong>new</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_cast</td>
<td>该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td>
</tr>
<tr>
<td>std::bad_exception</td>
<td>这在处理 C++ 程序中无法预期的异常时非常有用。</td>
</tr>
<tr>
<td>std::bad_typeid</td>
<td>该异常可以通过 <strong>typeid</strong> 抛出。</td>
</tr>
<tr>
<td><strong>std::logic_error</strong></td>
<td>理论上可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::domain_error</td>
<td>当使用了一个无效的数学域时，会抛出该异常。</td>
</tr>
<tr>
<td>std::invalid_argument</td>
<td>当使用了无效的参数时，会抛出该异常。</td>
</tr>
<tr>
<td>std::length_error</td>
<td>当创建了太长的 std::string 时，会抛出该异常。</td>
</tr>
<tr>
<td>std::out_of_range</td>
<td>该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td>
</tr>
<tr>
<td><strong>std::runtime_error</strong></td>
<td>理论上不可以通过读取代码来检测到的异常。</td>
</tr>
<tr>
<td>std::overflow_error</td>
<td>当发生数学上溢时，会抛出该异常。</td>
</tr>
<tr>
<td>std::range_error</td>
<td>当尝试存储超出范围的值时，会抛出该异常。</td>
</tr>
<tr>
<td>std::underflow_error</td>
<td>当发生数学下溢时，会抛出该异常。</td>
</tr>
</tbody></table>
<h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>这部分看看就行，比较冷门且不常用。</p>
<ul>
<li><strong>建议</strong>自己的异常类要<strong>继承标准异常类</strong>。因为C++中可以抛出任何类型的异常，所以我们的异常类<strong>可以不继承</strong>自标准异常，但是这样可能会导致程序混乱，尤其是当我们多人协同开发时。 </li>
<li>当继承标准异常类时，应该重载父类的<strong>what函数</strong>和<strong>虚析构函数</strong>。 </li>
<li>因为栈展开的过程中，要<strong>复制</strong>异常类型，那么要根据你在类中添加的成员考虑是否提供自己的<strong>复制构造函数</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span> <span class="params">()</span> <span class="type">const</span> <span class="title">throw</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C++ Exception&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(MyException&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(std::exception&amp; e)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//其他的错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyException caught</span><br><span class="line">C++ Exception</span><br></pre></td></tr></table></figure>

<h2 id="函数声明后面加throw"><a href="#函数声明后面加throw" class="headerlink" title="函数声明后面加throw()"></a>函数声明后面加throw()</h2><p>C++函数后面加关键字throw(<em>something</em>)限制，是对这个函数的<strong>异常安全作出限制</strong>；这是一种异常规范，只会出现在声明函数时，表示这个函数可能抛出任何类型的异常。</p>
<ul>
<li>void fun() throw();      &#x2F;&#x2F;表示fun函数不允许抛出任何异常，即fun函数是异常安全的，一旦异常，将是意想不到的严重错误。</li>
<li>void fun() throw(…);    &#x2F;&#x2F;表示fun函数可以抛出任何形式的异常。</li>
<li>void fun() throw(exceptionType);    &#x2F;&#x2F; 表示fun函数只能抛出exceptionType类型的异常。</li>
</ul>
<p>例如：</p>
<ul>
<li>void GetTag() throw(int);                     &#x2F;&#x2F; 表示只抛出int类型异常</li>
<li>void GetTag() throw(int，char);         &#x2F;&#x2F; 表示抛出int，char类型异常</li>
<li>void GetTag() throw();                         &#x2F;&#x2F; 表示不会抛出任何类型异常，一旦异常，将是意想不到的严重错误</li>
<li>void GetTag() throw(…);                      &#x2F;&#x2F; 表示抛出任何类型异常</li>
</ul>
<p>void GetTag() throw(int); 表示只抛出int类型异常，并不表示一定会抛出异常，但是一旦抛出异常只会抛出int类型，如果抛出非int类型异常，调用unexsetpion()函数，退出程序。</p>
<h2 id="来自C-之父Bjarne-Stroustrup的建议"><a href="#来自C-之父Bjarne-Stroustrup的建议" class="headerlink" title="来自C++之父Bjarne Stroustrup的建议"></a>来自C++之父Bjarne Stroustrup的建议</h2><ul>
<li>当局部的控制能够处理时，不要使用异常； </li>
<li>使用“资源分配即初始化”技术去管理资源； </li>
<li>尽量少用try-catch语句块，而是使用“资源分配即初始化”技术。 </li>
<li>如果构造函数内发生错误，通过抛出异常来指明。</li>
<li>避免在析构函数中抛出异常。 </li>
<li>保持普通程序代码和异常处理代码分开。 </li>
<li>小心通过new分配的内存在发生异常时，可能造成内存泄露。 </li>
<li>如果一个函数可能抛出某种异常，那么我们调用它时，就要假定它一定会抛出该异常，即要进行处理。 </li>
<li>要记住，不是所有的异常都继承自exception类。 </li>
<li>编写的供别人调用的程序库，不应该结束程序，而应该通过抛出异常，让调用者决定如何处理（因为调用者必须要处理抛出的异常）。</li>
</ul>
<h1 id="文件与流"><a href="#文件与流" class="headerlink" title="文件与流"></a>文件与流</h1><h2 id="文件流的分类"><a href="#文件流的分类" class="headerlink" title="文件流的分类"></a>文件流的分类</h2><p>文件流是以外存文件未输入输出对象的数据流。输出文件流是从内存流向外存文件的数据，输入文件流是从外存文件流向内存的数据。每一个文件流都有一个内存缓冲区与之对应。</p>
<p>C++有三个用于文件操作的文件类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream <span class="comment">//文件的写操作（输出），主要是从内存写入存储设备（如磁盘），继承了istream类</span></span><br><span class="line">ifstream <span class="comment">//文件的读操作（输入），主要是从存储设备中读取数据到内存，继承了ostream类</span></span><br><span class="line">    </span><br><span class="line">fstream <span class="comment">//文件的读写操作，对打开的文件可进行读写操作，继承了iostream类，</span></span><br><span class="line">    	<span class="comment">//这意味着它可以创建文件，向文件写入信息，从文件读取信息。</span></span><br></pre></td></tr></table></figure>

<p>想要使用文件流对文件进行操作，修必须要先定义它。<br>定义时须包含头文件<code>#include&lt; fstream &gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;	<span class="comment">// 声明命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1》</span></span><br><span class="line">	<span class="comment">// 声明输出文件流，用于创建文件并向文件写入信息。</span></span><br><span class="line">	ofstream outFile;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2》</span></span><br><span class="line">	<span class="comment">// 声明输入文件流，用于从文件读取信息。</span></span><br><span class="line">	ifstream inFIle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3》</span></span><br><span class="line">	<span class="comment">// 声明输入和输出文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</span></span><br><span class="line">	fstream stream;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p><strong>打开文件操作主要是把我们的文件流类对象和一个文件相关联起来，这样这个被打开的文件可以用类对象表示，之后我们对文件流类对象所做的输入和输出操作其实就是对这个文件所做的操作。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,ios_base::openmode mode)</span></span>;</span><br><span class="line"><span class="comment">//参数的含义：</span></span><br><span class="line">   filename：　　要打开的文件名</span><br><span class="line">　　mode：　　　　要打开文件的方式</span><br></pre></td></tr></table></figure>

<p>其中<code>mode</code>定义在所有<code>IO</code>的基类中：即<code>ios</code>类，它包括如下几种方式：</p>
<table>
<thead>
<tr>
<th>模式标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>读方式打开文件（ifstream对象默认方式）</td>
</tr>
<tr>
<td>ios::out</td>
<td>写方式打开文件 （ofstream对象默认）</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果此文件已经存在, 就会打开文件之前把文件长度设置为0</td>
</tr>
<tr>
<td>ios::app</td>
<td>尾部最加方式(在尾部写入)</td>
</tr>
<tr>
<td>ios::ate</td>
<td>文件打开后, 定位到文件尾</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式(默认是文本方式)</td>
</tr>
<tr>
<td>ios::nocreate</td>
<td>不建立文件，所以文件不存在时打开失败</td>
</tr>
<tr>
<td>ios::noreplace</td>
<td>不覆盖文件，所以打开文件时如果文件存在失败</td>
</tr>
</tbody></table>
<p>mode参数可以组合起来使用，但是两个参数之间必须要用操作符|隔开，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;  <span class="comment">//声明一个ofstream对象out</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app);  <span class="comment">//往text.txt文件中输入内容,输入方式在文件的末尾追加内容，且不清空原有的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个声明方式是调用了ofstream有参构造函数，该构造函数会自动调用open函数。</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app)</span>；</span></span><br></pre></td></tr></table></figure>

<h2 id="判断文件是否打开成功"><a href="#判断文件是否打开成功" class="headerlink" title="判断文件是否打开成功"></a>判断文件是否打开成功</h2><p>使用is_open()函数进行文件的判断<br>当成功打开文件返回真（true），失败返回假（false）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fstream stream;</span><br><span class="line"></span><br><span class="line">stream.<span class="built_in">open</span>(<span class="string">&quot;demo.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 判断文件是否打开成功</span></span><br><span class="line"><span class="keyword">if</span> (!stream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当我们完成对文件的操作后，需要调用成员函数<code>close</code>来关闭我们的文件流，<code>close</code>函数的作用其实就是清空该类对象在缓存中的内容并且关闭该对象和文件的关联关系，然后该对象可以和其他文件进行关联。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofstream file;  <span class="comment">//声明一个ofstream对象file</span></span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>,ios::out|ios::app);  </span><br><span class="line">file.<span class="built_in">close</span>();  <span class="comment">//关闭&quot;text.txt&quot;文件</span></span><br></pre></td></tr></table></figure>

<p>为了防止一个类对象被销毁后，还和某个文件保留关联关系，所以文件流类的析构函数都会自动调用<code>close</code>函数。</p>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h3><p>文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">插入器(&lt;&lt;) 向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write</span><br><span class="line">Stdout”&lt;&lt;‘n’;就表示把字符串&quot;Write Stdout&quot;和换行字符(‘n’)输出到标准输出流。</span><br><span class="line"></span><br><span class="line">析取器(&gt;&gt;)</span><br><span class="line">从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据</span><br></pre></td></tr></table></figure>

<p>比如读取写入txt文件，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;d:\\test.txt&quot;</span>, ios::out)</span></span>;<span class="comment">//定义了一个对象f，只写，&quot;d:\\test.txt&quot;文件不存在则创建，存在则清空原内容</span></span><br><span class="line">    f &lt;&lt; <span class="number">1234</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">3.14</span> &lt;&lt; <span class="string">&#x27;A&#x27;</span> &lt;&lt; <span class="string">&quot;How are you&quot;</span>; <span class="comment">//写入数据，这是c++一般的写入形式</span></span><br><span class="line">    f.<span class="built_in">close</span>();<span class="comment">//关闭文件以使其重新变为可访问，函数一旦调用，原先的流对象就可以被用来打开其它的文件</span></span><br><span class="line">    f.<span class="built_in">open</span>(<span class="string">&quot;d:\\test.txt&quot;</span>,ios::in);<span class="comment">//打开文件，只读</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line">    f &gt;&gt; i &gt;&gt; d &gt;&gt; c;   <span class="comment">//读取数据，从左向右读取相应类型的数据，比如int就读1234，因为后面空格截断了(输入中无法包含空格)</span></span><br><span class="line">    					<span class="comment">//char就读一个&#x27;A&#x27;。每次读完游标都指向读完的地方，因此能继续读。</span></span><br><span class="line">    f.<span class="built_in">getline</span>(s, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;    <span class="comment">//显示各数据</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;   <span class="comment">//endl是一种格式，表示输出一个换行符，并刷新此流，ends只输出一个空字符</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    f.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="头文件-lt-iomanip-gt"><a href="#头文件-lt-iomanip-gt" class="headerlink" title="头文件&lt;iomanip&gt;"></a>头文件&lt;iomanip&gt;</h3><table>
<thead>
<tr>
<th>控  制  符</th>
<th>作       用</th>
</tr>
</thead>
<tbody><tr>
<td>dec</td>
<td>设置整数为十进制</td>
</tr>
<tr>
<td>hex</td>
<td>设置整数为十六进制</td>
</tr>
<tr>
<td>oct</td>
<td>设置整数为八进制</td>
</tr>
<tr>
<td>setbase(n)</td>
<td>设置整数为n进制(n&#x3D;8,10,16)</td>
</tr>
<tr>
<td>setfill(n)</td>
<td>设置字符填充，c可以是字符常或字符变量</td>
</tr>
<tr>
<td>setprecision(n)</td>
<td>设置浮点数的有效数字为n位</td>
</tr>
<tr>
<td>setw(n)</td>
<td>设置字段宽度为n位</td>
</tr>
<tr>
<td>setiosflags(ios::fixed)</td>
<td>设置浮点数以固定的小数位数显示</td>
</tr>
<tr>
<td>setiosflags(ios::scientific)</td>
<td>设置浮点数以科学计数法表示</td>
</tr>
<tr>
<td>setiosflags(ios::left)</td>
<td>输出左对齐</td>
</tr>
<tr>
<td>setiosflags(ios::right)</td>
<td>输出右对齐</td>
</tr>
<tr>
<td>setiosflags(ios::skipws)</td>
<td>忽略前导空格</td>
</tr>
<tr>
<td>setiosflags(ios::uppercase)</td>
<td>在以科学计数法输出E与十六进制输出X以大写输出，否则小写。</td>
</tr>
<tr>
<td>setiosflags(ios::showpos)</td>
<td>输出正数时显示”+”号</td>
</tr>
<tr>
<td>setiosflags(ios::showpoint)</td>
<td>强制显示小数点</td>
</tr>
<tr>
<td>resetiosflags()</td>
<td>终止已经设置的输出格式状态，在括号中应指定内容</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对一个数操作时，先对输出流（ostream）进行格式化，最后再输出目标。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>]=<span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line">    <span class="type">double</span> digit=<span class="number">-36.96656</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">30</span>)&lt;&lt;left&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;digit&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;<span class="number">15</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//setbase(int x)设置进制后，后面所有操作都是按照这个进制来计算！</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setbase</span>(<span class="number">10</span>)&lt;&lt;<span class="number">15</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//四舍五入,并保留2位有效数组</span></span><br><span class="line">    <span class="type">float</span> x=<span class="number">6.6937</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">float</span>(<span class="built_in">int</span>(x*<span class="number">1000</span>+<span class="number">0.5</span>)/<span class="number">1000.0</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">this is a string**************</span></span><br><span class="line"><span class="comment">-36.97</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">6.694</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前缀0表示八进制 前缀0x表示十六进制 不带前缀表示十进制</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">22.0</span>/<span class="number">7.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setbase(n) 设置整数为n进制(n=8,10,16)</span></span><br><span class="line">    <span class="comment">// oct 八进制 dec 十进制 hex 十六进制</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::showbase) 显示进制的前缀</span></span><br><span class="line">    <span class="comment">// 数值默认十进制显示输出</span></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;oct: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">8</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::oct &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dec: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">10</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::dec &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hex: &quot;</span> &lt;&lt; std::showbase &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::hex &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setprecision(n) 设置浮点数的有效数字为n位</span></span><br><span class="line">    <span class="comment">// 有效位数默认是6位，即setprecision(6)，即小数点前面和小数点后面加起来的位数为6个有效数字（注意会四舍五入）</span></span><br><span class="line">    std::cout &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setfill(n) 设置字符填充，c可以是字符常或字符变量</span></span><br><span class="line">    <span class="comment">// setw(n) 设置字段宽度为n位, 若是实际宽度大于被设置的，则setw函数此时失效, 只针对其后的第一个输出项有效</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::left) 输出左对齐</span></span><br><span class="line">    <span class="comment">// setiosflags(ios::right) 输出右对齐 默认右对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; std::right &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; std::left &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示</span></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setiosflags(ios::scientific)  设置浮点数以科学计数法表示 科学计数法输出E与十六进制输出默认是以小写的，要换成大写需添加uppercase</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; std::uppercase &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resetiosflags() 终止已经设置的输出格式状态，在括号中应指定内容</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::scientific) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; pi &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; std::<span class="built_in">resetiosflags</span>(std::ios::scientific) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">oct: 0173 0173</span></span><br><span class="line"><span class="comment">dec: 123 123</span></span><br><span class="line"><span class="comment">hex: 0x7b 0x7b</span></span><br><span class="line"><span class="comment">3.14286</span></span><br><span class="line"><span class="comment">3.14285714286</span></span><br><span class="line"><span class="comment">*******3.14285714286</span></span><br><span class="line"><span class="comment">*******3.14285714286</span></span><br><span class="line"><span class="comment">3.14285714286*******</span></span><br><span class="line"><span class="comment">3.142857142857</span></span><br><span class="line"><span class="comment">3.142857142857e+00</span></span><br><span class="line"><span class="comment">3.142857142857E+00</span></span><br><span class="line"><span class="comment">3.142857142857E+00   3.14285714286</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h3><p>二进制文件的操作需要在打开文件的时候指定打开方式为<code>ios::binary</code>，并且还可以指定为既能输入又能输出的文件，我们通过成员函数 <code>read</code>和 <code>write</code>来读写二进制文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里 buffer 是一块内存的地址，用来存储或读出数据。参数size 是一个整数值，表示要从缓存（buffer）中读出或写入的字符数。</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span> <span class="params">( <span class="type">char</span> * buffer, streamsize size)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span> <span class="params">(<span class="type">char</span> * buffer, streamsize size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function">fstream <span class="title">f</span><span class="params">(<span class="string">&quot;d:\\test.txt&quot;</span>, ios::out|ios::binary)</span></span>;</span><br><span class="line">f.<span class="built_in">read</span>(buffer,size);<span class="comment">//读完指针会到下一个位置，因此下一个read读出的数据是不同的</span></span><br><span class="line">f.<span class="built_in">write</span>(buffer,size);</span><br></pre></td></tr></table></figure>

<h3 id="eof"><a href="#eof" class="headerlink" title="eof()"></a>eof()</h3><p>infile.eof()判断读入文件是否达到文件尾部，若是则返回true。while(!infile.eof())就常常用来判断是否达到文件尾部，注意要在while循环体内不断地read，向下读，否则会死循环，因为eof()本身并不读取数据。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">person</span>(<span class="type">char</span> *name, <span class="type">char</span> *id, <span class="type">int</span> math, <span class="type">int</span> chinese, <span class="type">int</span> english)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(Name,name);</span><br><span class="line">		<span class="built_in">strcpy</span>(Id,id);</span><br><span class="line">		Math = math;</span><br><span class="line">		Chinese = chinese;</span><br><span class="line">		English = english;</span><br><span class="line">		Sum = Math+Chinese+English;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;Name&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Id&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Math&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Chinese&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;English&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> Id[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> Math;</span><br><span class="line">	<span class="type">int</span> Chinese;</span><br><span class="line">	<span class="type">int</span> English;</span><br><span class="line">	<span class="type">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">char</span> Name[<span class="number">20</span>],Id[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> Math, Chinese, English;</span><br><span class="line">	</span><br><span class="line">	fstream ioFile;</span><br><span class="line">	ioFile.<span class="built_in">open</span>(<span class="string">&quot;./ex10_info.dat&quot;</span>,ios::out|ios::app);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;-----------------building students&#x27; infomation-----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the name: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Name;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the id: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Id;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the math score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Math;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the chinese score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;Chinese;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;enter the english score: &quot;</span>;</span><br><span class="line">		cin&gt;&gt;English;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//输入好了之后构建一个对象，然后要把对象的地址送给文件的内存缓冲区指针，使得文件可以从地址里读取per的内容（根据sizeof指定，因为地址只是给了初始的位置，必须知道大小）写到文件里。</span></span><br><span class="line">        <span class="comment">//&amp;per 不是 char * 类型，因此要进行强制类型转换（都是8个字节），使得能以字符形式读取内容</span></span><br><span class="line">        <span class="comment">//sizeof返回值类型为size_t，write函数会获得具体的大小</span></span><br><span class="line">		<span class="function">person <span class="title">per</span><span class="params">(Name,Id,Math,Chinese,English)</span></span>;</span><br><span class="line">		ioFile.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;per,<span class="built_in">sizeof</span>(per));<span class="comment">//不是写入地址，而是写入地址处的内容，每个per的地址都是一样的（复用了），但是内容不一样</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;continue to enter infomation?(y/n)&quot;</span>;</span><br><span class="line">		cin&gt;&gt;ch;</span><br><span class="line">	&#125;<span class="keyword">while</span>(ch==<span class="string">&#x27;y&#x27;</span>||ch==<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	ioFile.<span class="built_in">close</span>();</span><br><span class="line">	</span><br><span class="line">	ioFile.<span class="built_in">open</span>(<span class="string">&quot;./ex10_info.dat&quot;</span>,ios::in);</span><br><span class="line">	person p;</span><br><span class="line">	ioFile.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));<span class="comment">//再从文件中读取对象的内容，给出p的地址把内容送入到地址对应的缓冲区中，这里的每个p的地址是一样的（复用了）</span></span><br><span class="line">		<span class="comment">//&amp;p 不是 char * 类型，因此要进行强制类型转换，使得能以字符形式读取内容</span></span><br><span class="line">	vector&lt;person&gt; v;</span><br><span class="line">	vector&lt;person&gt;::iterator vt;</span><br><span class="line">	<span class="keyword">while</span>(!ioFile.<span class="built_in">eof</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(p);<span class="comment">//然后把p放入vector中，</span></span><br><span class="line">        	<span class="comment">//注意vector实际上是另开了一块空间，把p的内容存入，所以这里就导致每个内容（最后存在的对象）对应的地址都不一样了，因此前面的复用不会引发覆盖</span></span><br><span class="line">		ioFile.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p,<span class="built_in">sizeof</span>(p));</span><br><span class="line">	&#125;</span><br><span class="line">	ioFile.<span class="built_in">close</span>();</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;the infomation is:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(vt=v.<span class="built_in">begin</span>();vt!=v.<span class="built_in">end</span>();vt++)</span><br><span class="line">		(*vt).<span class="built_in">display</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h2><p><strong>istream</strong> 和 <strong>ostream</strong> 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 <strong>seekg</strong>（”seek get”）和关于 ostream 的 <strong>seekp</strong>（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 <strong>ios::beg</strong>（默认的，从流的开头开始定位），也可以是 <strong>ios::cur</strong>（从流的当前位置开始定位），也可以是 <strong>ios::end</strong>（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::cur );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( n, ios::end );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定位到 fileObject 的末尾</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>( <span class="number">0</span>, ios::end );</span><br></pre></td></tr></table></figure>

<h2 id="getline、get、gets和put函数"><a href="#getline、get、gets和put函数" class="headerlink" title="getline、get、gets和put函数"></a>getline、get、gets和put函数</h2><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>由于流提取运算符(&gt;&gt;)会以空白符分割，所以我们的输入中无法包含空格。而使用getline函数可以指定分隔符，这样就可以读入包含空格的文本了（如：New York）。getline函数定义在头文件<string>中，f.getline()定义在<iostream>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(ifstream&amp; input, string s, <span class="type">char</span> delimitChar)<span class="comment">//getline接受的字符串长度不受限制</span></span><br><span class="line"><span class="comment">//input是输入的对象，可以是一个文件，也可以是标准输入（cin）</span></span><br><span class="line"><span class="comment">//s是接受字符串，所读取的信息存储在s中</span></span><br><span class="line"><span class="comment">//delimitChar是分隔符，默认是&#x27;\n&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">getline</span>(cin, city, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="comment">//从标准输入（键盘）读入到字符串city中，并使用换行作为分隔符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为流的成员函数：getline(&lt;字符数组chs&gt;，&lt;读取字符的个数n&gt;，&lt;终止符&gt;)</span></span><br><span class="line">f.<span class="built_in">getline</span>(str,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>当函数读到分隔符或文件末尾时，就会停止。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get函数会从输入对象读取<strong>一个字符</strong>，而put函数会向输出对象写入一个字符。</p>
<p>get函数有三个版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//无参数的，返回从输入对象读取的一个字符。</span></span></span><br><span class="line"><span class="function">ifstream* <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; ch)</span> <span class="comment">//有一个参数的，将字符存在字符ch中，并返回输入对象的引用</span></span></span><br><span class="line"><span class="function">ifstream* <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; ch, <span class="type">int</span> n, <span class="type">char</span> delimitChar=<span class="string">&#x27;\n&#x27;</span>)</span> <span class="comment">//有三个参数的，读取n-1个字符，</span></span></span><br><span class="line"><span class="function">    <span class="comment">//赋给指定的字符数组(或字符指针指向的数组)，如果在读取n-1个字符之前遇到指定的终止字符，则提前结束读取</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//调用，这里使用cin标准输入流，也可以是其他文件输入流</span></span></span><br><span class="line"><span class="function">cin.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line">cin.<span class="built_in">get</span>(ch,<span class="number">10</span>);<span class="comment">//相当于cin.get(ch,10,&#x27;\n&#x27;);</span></span><br><span class="line">cin.<span class="built_in">get</span>(ch,<span class="number">10</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用getline函数从输入流读字符时，遇到终止标志字符时结束，指针移到该终止标志字符之后，<strong>下一个getline函数将从该终止标志的下一个字符开始接着读入，</strong>如本程序运行结果所示那样。如果用cin.get()函数从输入流读字符时，遇终止标志字符时停止读取，指针不向后移动，仍然停留在原位置。下一次读取时仍从该终止标志字符开始。这是getline函数和get函数不同之处。</p>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><p>引入cstdio头文件（#include <cstdio>），才能进行调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">gets</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br></pre></td></tr></table></figure>

<p>从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<p>如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> <span class="comment">//这个头文件包含gets()函数</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本函数可以无限读取，不会判断上限，所以程序员应该确保 buffer的空间足够大，以便在执行读操作时不发生溢出。如果溢出，多出来的字符将被写入到 堆栈中，这就 <strong>覆盖了堆栈原先的内容</strong>，破坏一个或多个不相关变量的值。这个事实导致gets函数只适用于玩具程序,为了避免这种情况，我们可以用fgets(stdin) </p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p> fstream 和 ofstream 类对象都可以调用 put() 方法。</p>
<p>当 fstream 和 ofstream 文件流对象调用 put() 方法时，该方法的功能就变成了向指定文件中写入单个字符。put() 方法的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span> <span class="params">(<span class="type">char</span> c)</span></span>;<span class="comment">//c 用于指定要写入文件的字符。</span></span><br><span class="line"><span class="comment">//该方法会返回一个调用该方法的对象的引用形式。例如，obj.put() 方法会返回 obj 这个对象的引用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">//以二进制形式打开文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">        <span class="comment">//将字符 c 写入 out.txt 文件</span></span><br><span class="line">        outFile.<span class="built_in">put</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="cstring库常用函数"><a href="#cstring库常用函数" class="headerlink" title="cstring库常用函数"></a>cstring库常用函数</h1><h2 id="字符数组复制"><a href="#字符数组复制" class="headerlink" title="字符数组复制"></a>字符数组复制</h2><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p><code>strcpy</code>的作用是复制整个字符数组到另一个字符数组，因此也就非常简洁，只有两个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个参数是要复制到的目标数组起始位置，后一个是被复制的源数组起始位置。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Sample string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str2, str1);</span><br><span class="line">    <span class="built_in">strcpy</span> (str3, <span class="string">&quot;copy successful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3><p><code>strncpy</code>与<code>strcpy</code>很类似，只是可以指定复制多少个字符。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前两个参数的含义与strcpy相同，第三个参数num就是要复制的字符个数。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncpy</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line">						<span class="comment">//size_t表示无符号整数，为方便系统移植定义的，32位为unsigned int，64位为unsigned long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;To be or not to be&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 整个字符串进行复制: */</span></span><br><span class="line">    <span class="built_in">strncpy</span> ( str2, str1, <span class="built_in">sizeof</span>(str2) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 部分复制(这里是复制5个字符): */</span></span><br><span class="line">    <span class="built_in">strncpy</span> ( str3, str2, <span class="number">5</span> );</span><br><span class="line">    str3[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">/* 部分复制不会自动添加结尾，添加结尾符 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span> (str1);</span><br><span class="line">    <span class="built_in">puts</span> (str2);</span><br><span class="line">    <span class="built_in">puts</span> (str3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符数组连接"><a href="#字符数组连接" class="headerlink" title="字符数组连接"></a>字符数组连接</h2><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><p><code>strcat</code>的功能是把一个字符数组连接到另一个字符数组的后面。它的原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是目标数组，后一个是要添加到后面的源数组。</span></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str, <span class="string">&quot;these &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;strings &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;are &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span> (str, <span class="string">&quot;concatenated.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果是：these strings are concatenated.</span></span><br></pre></td></tr></table></figure>

<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h3><p>指定字符数的拼接，原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strncat</span> <span class="params">( <span class="type">char</span> * destination, <span class="type">const</span> <span class="type">char</span> * source, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (str1, <span class="string">&quot;To be &quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (str2, <span class="string">&quot;or not to be&quot;</span>);</span><br><span class="line">    <span class="built_in">strncat</span> (str1, str2, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符数组比较"><a href="#字符数组比较" class="headerlink" title="字符数组比较"></a>字符数组比较</h2><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较方式是：（字典序）两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇’\0’为止。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>str1&gt;str2：则返回值&gt;0；</li>
<li>str1&lt;str2：则返回值&lt;0；</li>
<li>str1&#x3D;str2：则返回值&#x3D;0；</li>
</ul>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2, <span class="type">size_t</span> num )</span></span></span><br></pre></td></tr></table></figure>

<p>比较ptr1、ptr2指向的字符串，直到遇到不相同的字符或者空字符结束<strong>或者比较完前面的num bytes结束</strong>。如果都相同则返回0，如果第一个不同byte ptr1的小于ptr2的，返回负数，否则返回正数。</p>
<h2 id="字符数组查找"><a href="#字符数组查找" class="headerlink" title="字符数组查找"></a>字符数组查找</h2><h3 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h3><p><code>strchr</code>函数可以在一个字符数组里找某个字符第一次出现的位置，如果未找到该字符则返回 NULL。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是原字符数组，后一个是要查找的字符。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">strchr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str, <span class="type">int</span> character )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> str[] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> ch = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">   <span class="type">char</span> *ret;</span><br><span class="line"></span><br><span class="line">   ret = <span class="built_in">strchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;|%c| 之后的字符串是 - |%s|\n&quot;</span>, ch, ret);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：|.| 之后的字符串是 - |.runoob.com|</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码将 st 指针指向的字符串在换行的地方加入文本结束字符，else 将多余的换行符消耗掉：</span></span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);  <span class="comment">//查找换行符</span></span><br><span class="line"><span class="keyword">if</span> (find)  <span class="comment">//如果地址不是NULL</span></span><br><span class="line">    *find = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//在此处放置一个空字符</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getchar</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h3><p><code>strstr</code>函数可以在一个字符数组里查找另一个字符数组第一次出现的位置。它的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前一个是文本串，后一个是模式串。</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">strstr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str1, <span class="type">const</span> <span class="type">char</span> * str2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;This is a simple string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *pch;</span><br><span class="line">    pch = <span class="built_in">strstr</span>(str, <span class="string">&quot;simple&quot;</span>);</span><br><span class="line">    <span class="built_in">strncpy</span> (pch, <span class="string">&quot;sample&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">puts</span> (str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向同一个字符串，但pch的位置在simple的s处，然后替换</span></span><br><span class="line"><span class="comment">//输出结果：This is a sample string</span></span><br></pre></td></tr></table></figure>

<h2 id="字符数组长度"><a href="#字符数组长度" class="headerlink" title="字符数组长度"></a>字符数组长度</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p><code>strlen</code>用于求一个字符数组的长度，注意它是从给定的起始位置开始不断往后尝试，直到遇到’\0’为止的，因此<strong>它的时间复杂度并不是常数级别的，而是取决于字符数组的长度，在字符数组没有变动的情况下请务必不要重复调用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szInput[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Enter a sentence: &quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span> (szInput);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;The sentence entered is %u characters long.\n&quot;</span>, (<span class="type">unsigned</span>)<span class="built_in">strlen</span>(szInput));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Enter sentence: just testing</span></span><br><span class="line"><span class="comment">//The sentence entered is 12 characters long.</span></span><br></pre></td></tr></table></figure>

<h2 id="内存复制"><a href="#内存复制" class="headerlink" title="内存复制"></a>内存复制</h2><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><p>从source指向的地址拷贝num <strong>bytes</strong>到destination指向的地址。不检查source中的空字符，总是拷贝num bytes，可能产生溢出，当destination和source的大小小于num时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* destination,<span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str1</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li><strong>str2</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li><strong>n</strong> – 要被复制的字节数。</li>
<li>该函数返回一个指向目标存储区 str1 的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串复制到数组 dest 中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> src[<span class="number">50</span>] = <span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">   <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;dest = %s\n&quot;</span>, dest);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：dest = http://www.runoob.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 s 中第 11 个字符开始的 6个连续字符复制到 d 中:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *s=<span class="string">&quot;http://www.runoob.com&quot;</span>;</span><br><span class="line">  <span class="type">char</span> d[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(d, s+<span class="number">11</span>, <span class="number">6</span>);<span class="comment">// 从第 11 个字符(r)开始复制，连续复制 6 个字符(runoob)</span></span><br><span class="line">  <span class="comment">// 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));</span></span><br><span class="line">  d[<span class="number">6</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：runoob</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//覆盖原有部分数据:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> src[] = <span class="string">&quot;***&quot;</span>;</span><br><span class="line">  <span class="type">char</span> dest[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 前: %s\n&quot;</span>, dest);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用 memcpy 后: %s\n&quot;</span>, dest);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//使用 memcpy 前: abcdefg</span></span><br><span class="line"><span class="comment">//使用 memcpy 后: ***defg</span></span><br></pre></td></tr></table></figure>

<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h3><p>从source指向的地址拷贝num bytes到destination指向的地址。常用于同一字符串的改变。不检查source中的空字符，总是拷贝num bytes，可能产生溢出，当destination和source的大小小于num时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* destination,<span class="type">const</span> <span class="type">void</span>* source, <span class="type">size_t</span> num)</span></span></span><br></pre></td></tr></table></figure>

<p>在重叠内存块这方面，memmove() 是比 memcpy() 更安全的方法。如果目标区域和源区域有重叠的话，memmove() 能够<strong>保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中</strong>，复制后源区域的内容会被更改。如果目标区域与源区域没有重叠，则和 memcpy() 函数功能相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如一个字符串123abc456，拷贝123abc到abc456的位置，当顺序覆盖时，abc先被覆盖成了123即123123456，</span><br><span class="line">接下来原本456是要被abc覆盖的，但是abc变成了123，就产生了问题。</span><br><span class="line"></span><br><span class="line">memcpy函数会出现上面的问题，因为没有中间变量。</span><br><span class="line">而memmove不会出现问题，使用了一个中间变量先保存好原来的字符串123abc456，这样就不会被覆盖掉正确的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> dest[] = <span class="string">&quot;oldstring&quot;</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> src[]  = <span class="string">&quot;newstring&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Before memmove dest = %s, src = %s\n&quot;</span>, dest, src);</span><br><span class="line">   <span class="built_in">memmove</span>(dest, src, <span class="number">9</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;After memmove dest = %s, src = %s\n&quot;</span>, dest, src);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Before memmove dest = oldstring, src = newstring</span></span><br><span class="line"><span class="comment">//After memmove dest = newstring, src = newstring</span></span><br></pre></td></tr></table></figure>

<h2 id="内存比较"><a href="#内存比较" class="headerlink" title="内存比较"></a>内存比较</h2><h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span> <span class="params">( <span class="type">const</span> <span class="type">void</span> * ptr1, <span class="type">const</span> <span class="type">void</span> * ptr2, <span class="type">size_t</span> num )</span></span></span><br></pre></td></tr></table></figure>

<p>比较ptr1、ptr2指向的内存块的前面num bytes，如果都相同则返回0，如果第一个不同byte ptr1的小于ptr2的，返回负数，否则返回正数。如果前面都相同，<strong>即使中间遇到空字符，也会继续比较下去，直到比较完所有的num bytes</strong>。</p>
<h2 id="内存检索"><a href="#内存检索" class="headerlink" title="内存检索"></a>内存检索</h2><h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memchr</span> <span class="params">( <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ptr</strong> – 指向要执行搜索的内存块。</li>
<li><strong>value</strong> – 以 int 形式传递的值，但是函数在每次字节搜索时是使用该值的无符号字符形式。</li>
<li><strong>num</strong> – 要被分析的字节数。</li>
</ul>
<p>在ptr指向的内存中的前num bytes中搜索值value，返回第一个value的指针，如果没有找到返回空指针。</p>
<h2 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h2><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置ptr指向的内存的前面num bytes的值为value</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memset</span> <span class="params">( <span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> num )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">  <span class="type">char</span> str[] = <span class="string">&quot;almost every programmer should know memset!&quot;</span>;</span><br><span class="line">  <span class="built_in">memset</span> (str,<span class="string">&#x27;-&#x27;</span>,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">puts</span> (str);</span><br><span class="line"><span class="comment">//输出：------ every programmer should know memset!</span></span><br></pre></td></tr></table></figure>

<h1 id="cmath库常用函数"><a href="#cmath库常用函数" class="headerlink" title="cmath库常用函数"></a>cmath库常用函数</h1><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>std::abs: 计算绝对值，包括整数类型；</p>
<p>std::fabs: 计算绝对值，不包括整数类型；</p>
<p>std::sqrt: 计算平方根；</p>
<p>std::cbrt: 计算立方根；</p>
<p>std::hypot: 计算两个数平方的和的平方根；</p>
<p>std::pow：幂运算；</p>
<p>std::exp: e^x;</p>
<p>std::exp2: 2^x;</p>
<p>std::log: ln(x);</p>
<p>std::log2: log2(x);</p>
<p>std::log10: log10(x);</p>
<p>std::fmod: 两数除法操作的余数(rounded towards zero)；</p>
<p>std::remainder: 两数除法操作的余数(rounded to nearest)；</p>
<p>std::remquo: 两数除法操作的余数；</p>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>std::ceil: 不小于给定值的最近整数；</p>
<p>std::floor: 不大于给定值的最近整数；</p>
<p>std::trunc: 不大于给定值的最近整数；</p>
<p>std::modf: 将一个浮点数分解为整数及小数部分；</p>
<p>std::round: 舍入取整；</p>
<p>std::lround: 舍入取整, 返回long int；</p>
<p>std::llround: 舍入取整, 返回long long int；</p>
<h2 id="角度"><a href="#角度" class="headerlink" title="角度"></a>角度</h2><p>std::sin: 正弦；</p>
<p>std::asin: 反正弦；</p>
<p>std::cos: 余弦；</p>
<p>std::acos: 反正弦；</p>
<p>std::tan：正切；</p>
<p>std::atan：反正切；</p>
<p>std::atan2: 反正切；</p>
<p>std::sinh: 双曲正弦；</p>
<p>std::asinh: 双曲反正弦；</p>
<p>std::cosh: 双曲余弦；</p>
<p>std::acosh: 双曲反余弦；</p>
<p>std::tanh: 双曲正切；</p>
<p>std::atanh: 双曲反正切；</p>
<h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><p>std::nan: Generatequiet NaN;</p>
<p>std::isfinite: 检测是否是有限值；</p>
<p>std::isinf: 检测是否是无穷大值；</p>
<p>std::isnan: 检测是否是非数型；</p>
<p>std::isnormal: 检测是否是normal值，neitherinfinity, NaN, zero or subnormal；</p>
<p>std::signbit: 检测是否是负数；</p>
<p>std::isgreater: 检测第一个数是否大于第二个数；</p>
<p>std::isgreaterequal:检测第一个数是否大于或等于第二个数；</p>
<p>std::isless: 检测第一个数是否小于第二个数；</p>
<p>std::islessequal:检测第一个数是否小于或等于第二个数；</p>
<p>std::islessgreater:检测第一个数是否不等于第二个数；</p>
<p>std::isunordered:检测两个浮点数是否是无序的.</p>
<h2 id="其他不常用"><a href="#其他不常用" class="headerlink" title="其他不常用"></a>其他不常用</h2><p>std::fma(x,y,z):x*y+z;</p>
<p>std::nearbyint: 使用当前的舍入模式取整(fegetround())；</p>
<p>std::rint: 使用当前的舍入模式取整(fegetround())；</p>
<p>std::lrint: 使用当前的舍入模式取整(fegetround()),返回long int；</p>
<p>std::llrint: 使用当前的舍入模式取整(fegetround())，返回long longint；</p>
<p>std::frexp: 将一个浮点数分解为有效数(significand)及以2为底的幂(x &#x3D; significand* 2exp);</p>
<p>std::ldexp: x *2exp;</p>
<p>std::expm1: ex-1;</p>
<p>std::scalbn: x *FLT_RADIXn;</p>
<p>std::scalbln: x* FLT_RADIXn;</p>
<p>std::ilogb: 返回以FLT_RADIX为底，|x|的对数值，返回值为整数；</p>
<p>std::log1p: ln(1+x);</p>
<p>std::logb: 返回以FLT_RADIX为底，|x|的对数值，返回值为浮点数；</p>
<p>std::erf: 误差函数；</p>
<p>std::erfc: 互补(complementary)误差函数；</p>
<p>std::tgamma: 伽玛函数；</p>
<p>std::lgamma: log-伽玛函数；</p>
<p>std::copysign(x,y):返回x的值及y的正负符号组成的浮点数；</p>
<p>std::nextafter(x,y): 返回x之后y方向上的下一个可表示值；</p>
<p>std::nexttoward(x,y): 返回x之后y方向上的下一个可表示值；</p>
<p>std::fdim(x,y): Thefunction returns x-y if x&gt;y, and zero otherwise;</p>
<p>std::fmax: 返回较大的值;</p>
<p>std::fmin: 返回较小的值;</p>
<p>std::fpclassify:为浮点值归类，返回一个类型为int的值；</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmath.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fenv.h&gt;</span> <span class="comment">// fegetround, FE_*</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;float.h&gt;</span> <span class="comment">// FLT_RADIX</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// reference: http://www.cplusplus.com/reference/cmath/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> cmath_ &#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_abs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::abs: double/float/long double/T</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs (3.141611111) = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>(<span class="number">3.141611111</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3.14161</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs (-10.6)  = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>(<span class="number">-10.6f</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10.6</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;abs ((int)-10)  = &quot;</span> &lt;&lt; std::<span class="built_in">abs</span>((<span class="type">int</span>)<span class="number">-10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fabs: double/float/long double/T</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;fabs (3.141611111) = &quot;</span> &lt;&lt; std::<span class="built_in">fabs</span>(<span class="number">3.141611111</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3.14161</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;fabs (-10.6)  = &quot;</span> &lt;&lt; std::<span class="built_in">fabs</span>(<span class="number">-10.6f</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 10.6</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fma: Returns x*y+z</span></span><br><span class="line">	<span class="type">double</span> x, y, z, result;</span><br><span class="line">	x = <span class="number">10.0</span>, y = <span class="number">20.0</span>, z = <span class="number">30.0</span>;</span><br><span class="line"> </span><br><span class="line">	result = std::<span class="built_in">fma</span>(x, y, z);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;10.0 * 20.0 + 30.0 = %f\n&quot;</span>, result); <span class="comment">// 230.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_triangle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::sin: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">30.0</span>;</span><br><span class="line">	result = std::<span class="built_in">sin</span>(param*PI / <span class="number">180</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The sine of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 0.5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::asin: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">0.5</span>;</span><br><span class="line">	result = std::<span class="built_in">asin</span>(param) * <span class="number">180.0</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc sine of %f is %f degrees\n&quot;</span>, param, result); <span class="comment">// 30.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::sinh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">sinh</span>(param);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The hyperbolic sine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 0.75</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::asinh double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">exp</span>(<span class="number">2</span>) - std::<span class="built_in">cosh</span>(<span class="number">2</span>);</span><br><span class="line">	result = std::<span class="built_in">asinh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic sine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 2.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cos double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">60.0</span>;</span><br><span class="line">	result = std::<span class="built_in">cos</span>(param * PI / <span class="number">180.0</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The cosine of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 0.5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;<span class="comment">// std::acos: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">0.5</span>;</span><br><span class="line">	result = std::<span class="built_in">acos</span>(param) * <span class="number">180.0</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc cosine of %f is %f degrees.\n&quot;</span>, param, result); <span class="comment">// 60.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cosh double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">cosh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The hyperbolic cosine of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 1.25</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::acosh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">exp</span>(<span class="number">2</span>) - std::<span class="built_in">sinh</span>(<span class="number">2</span>);</span><br><span class="line">	result = std::<span class="built_in">acosh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic cosine of %f is %f radians.\n&quot;</span>, param, result); <span class="comment">// 2.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::tan: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">45.0</span>;</span><br><span class="line">	result = std::<span class="built_in">tan</span>(param * PI / <span class="number">180.0</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The tangent of %f degrees is %f.\n&quot;</span>, param, result); <span class="comment">// 1.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atan: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">1.0</span>;</span><br><span class="line">	result = std::<span class="built_in">atan</span>(param) * <span class="number">180</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc tangent of %f is %f degrees\n&quot;</span>, param, result); <span class="comment">// 45.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atan2: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> x, y, result;</span><br><span class="line">	x = <span class="number">-10.0</span>;</span><br><span class="line">	y = <span class="number">10.0</span>;</span><br><span class="line">	result = std::<span class="built_in">atan2</span>(y, x) * <span class="number">180</span> / PI;</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The arc tangent for (x=%f, y=%f) is %f degrees\n&quot;</span>, x, y, result); <span class="comment">// 135.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::tanh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">	result = std::<span class="built_in">tanh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The hyperbolic tangent of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 0.6</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::atanh: double/float/long double/T</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = std::<span class="built_in">tanh</span>(<span class="number">1</span>);</span><br><span class="line">	result = std::<span class="built_in">atanh</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;The area hyperbolic tangent of %f is %f.\n&quot;</span>, param, result); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_pow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::sqrt(x): Returns the square root of x</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">1024.0</span>;</span><br><span class="line">	result = std::<span class="built_in">sqrt</span>(param);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sqrt(%f) = %f\n&quot;</span>, param, result); <span class="comment">// 32.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::cbrt: Compute cubic root</span></span><br><span class="line">	<span class="type">double</span> param, result;</span><br><span class="line">	param = <span class="number">27.0</span>;</span><br><span class="line">	result = std::<span class="built_in">cbrt</span>(param);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;cbrt (%f) = %f\n&quot;</span>, param, result); <span class="comment">// 3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::hypot(x, y): sqrt(x^2+y^2)</span></span><br><span class="line">	<span class="type">double</span> leg_x, leg_y, result;</span><br><span class="line">	leg_x = <span class="number">3</span>;</span><br><span class="line">	leg_y = <span class="number">4</span>;</span><br><span class="line">	result = std::<span class="built_in">hypot</span>(leg_x, leg_y);</span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;%f, %f and %f form a right-angled triangle.\n&quot;</span>, leg_x, leg_y, result); <span class="comment">// 5.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::pow(x, y): x^y</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;7 ^ 3 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">7.0</span>, <span class="number">3.0</span>)); <span class="comment">// 343.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;4.73 ^ 12 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">4.73</span>, <span class="number">12.0</span>)); <span class="comment">// 125410439.217423</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;32.01 ^ 1.54 = %f\n&quot;</span>, std::<span class="built_in">pow</span>(<span class="number">32.01</span>, <span class="number">1.54</span>)); <span class="comment">// 208.036691</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;4 ^ 3 = %f\n&quot;</span>, std::<span class="built_in">pow</span>((<span class="type">int</span>)<span class="number">4</span>, (<span class="type">int</span>)<span class="number">3</span>)); <span class="comment">// 64.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_cmath_integer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123; <span class="comment">// std::ceil(x): returning the smallest integral value that is not less than x</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of 2.3 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">2.3</span>)); <span class="comment">// 3.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of 3.8 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">3.8</span>)); <span class="comment">// 4.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of -2.3 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;ceil of -3.8 is %.1f\n&quot;</span>, std::<span class="built_in">ceil</span>(<span class="number">-3.8</span>)); <span class="comment">// -3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::floor returning the largest integral value that is not greater than x</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of 2.3 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">2.3</span>)); <span class="comment">// 2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of 3.8 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">3.8</span>)); <span class="comment">// 3.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of -2.3 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, <span class="string">&quot;floor of -3.8 is %.1lf\n&quot;</span>, std::<span class="built_in">floor</span>(<span class="number">-3.8</span>)); <span class="comment">// -3.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::fmod: Returns the floating-point remainder of numer/denom(rounded towards zero)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fmod of 5.3 / 2 is %f\n&quot;</span>, std::<span class="built_in">fmod</span>(<span class="number">5.3</span>, <span class="number">2</span>)); <span class="comment">// fmod of 5.3 / 2 is 1.3</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fmod of 18.5 / 4.2 is %f\n&quot;</span>, std::<span class="built_in">fmod</span>(<span class="number">18.5</span>, <span class="number">4.2</span>)); <span class="comment">// fmod of 18.5 / 4.2 is 1.7</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::trunc(x): Rounds x toward zero, returning the nearest integral value that is not larger in magnitude than x.</span></span><br><span class="line">  <span class="comment">// std::round(x): Returns the integral value that is nearest to x</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> * format = <span class="string">&quot;%.1f \t%.1f \t%.1f \t%.1f \t%.1f\n&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value\tround\tfloor\tceil\ttrunc\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----\t-----\t-----\t----\t-----\n&quot;</span>);				 <span class="comment">// round  floor  ceil  trunc</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">2.3</span>, std::<span class="built_in">round</span>(<span class="number">2.3</span>), std::<span class="built_in">floor</span>(<span class="number">2.3</span>), std::<span class="built_in">ceil</span>(<span class="number">2.3</span>), std::<span class="built_in">trunc</span>(<span class="number">2.3</span>));	 <span class="comment">// 2.0     2.0    3.0   2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">3.8</span>, std::<span class="built_in">round</span>(<span class="number">3.8</span>), std::<span class="built_in">floor</span>(<span class="number">3.8</span>), std::<span class="built_in">ceil</span>(<span class="number">3.8</span>), std::<span class="built_in">trunc</span>(<span class="number">3.8</span>));	 <span class="comment">// 4.0     3.0    4.0   3.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">5.5</span>, std::<span class="built_in">round</span>(<span class="number">5.5</span>), std::<span class="built_in">floor</span>(<span class="number">5.5</span>), std::<span class="built_in">ceil</span>(<span class="number">5.5</span>), std::<span class="built_in">trunc</span>(<span class="number">5.5</span>));	 <span class="comment">// 6.0     5.0    6.0   5.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-2.3</span>, std::<span class="built_in">round</span>(<span class="number">-2.3</span>), std::<span class="built_in">floor</span>(<span class="number">-2.3</span>), std::<span class="built_in">ceil</span>(<span class="number">-2.3</span>), std::<span class="built_in">trunc</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0    -3.0   -2.0  -2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-3.8</span>, std::<span class="built_in">round</span>(<span class="number">-3.8</span>), std::<span class="built_in">floor</span>(<span class="number">-3.8</span>), std::<span class="built_in">ceil</span>(<span class="number">-3.8</span>), std::<span class="built_in">trunc</span>(<span class="number">-3.8</span>)); <span class="comment">// -4.0    -4.0   -3.0  -3.0</span></span><br><span class="line">	<span class="built_in">printf</span>(format, <span class="number">-5.5</span>, std::<span class="built_in">round</span>(<span class="number">-5.5</span>), std::<span class="built_in">floor</span>(<span class="number">-5.5</span>), std::<span class="built_in">ceil</span>(<span class="number">-5.5</span>), std::<span class="built_in">trunc</span>(<span class="number">-5.5</span>)); <span class="comment">// -6.0    -6.0   -5.0  -5.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::lround: Returns the integer value that is nearest in value to x</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (2.3) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">2.3</span>)); <span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (3.8) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">3.8</span>)); <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (-2.3) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">-2.3</span>)); <span class="comment">// -2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;lround (-3.8) = %ld\n&quot;</span>, std::<span class="built_in">lround</span>(<span class="number">-3.8</span>)); <span class="comment">// -4</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::llround(x): Returns the integer value that is nearest in value to x</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (2.3) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">2.3</span>)); <span class="comment">// 2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (3.8) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">3.8</span>)); <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (-2.3) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">-2.3</span>)); <span class="comment">// -2</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;llround (-3.8) = %lld\n&quot;</span>, std::<span class="built_in">llround</span>(<span class="number">-3.8</span>)); <span class="comment">// -4</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::nearbyint: Round to nearby integral value</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rounding using &quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (<span class="built_in">fegetround</span>()) &#123;</span><br><span class="line">	<span class="keyword">case</span> FE_DOWNWARD: <span class="built_in">printf</span>(<span class="string">&quot;downward&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FE_TONEAREST: <span class="built_in">printf</span>(<span class="string">&quot;to-nearest&quot;</span>); <span class="keyword">break</span>; <span class="comment">// to-nearest</span></span><br><span class="line">	<span class="keyword">case</span> FE_TOWARDZERO: <span class="built_in">printf</span>(<span class="string">&quot;toward-zero&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> FE_UPWARD: <span class="built_in">printf</span>(<span class="string">&quot;upward&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; rounding:\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (2.3) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">2.3</span>)); <span class="comment">// 2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (3.8) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">3.8</span>)); <span class="comment">// 4.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (-2.3) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">-2.3</span>)); <span class="comment">// -2.0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;nearbyint (-3.8) = %.1f\n&quot;</span>, std::<span class="built_in">nearbyint</span>(<span class="number">-3.8</span>)); <span class="comment">// -4.0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::remainder: Returns the floating-point remainder of numer/denom(rounded to nearest)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;remainder of 5.3 / 2 is %f\n&quot;</span>, std::<span class="built_in">remainder</span>(<span class="number">5.3</span>, <span class="number">2</span>)); <span class="comment">// remainder of 5.3 / 2 is -0.7</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;remainder of 18.5 / 4.2 is %f\n&quot;</span>, std::<span class="built_in">remainder</span>(<span class="number">18.5</span>, <span class="number">4.2</span>)); <span class="comment">// remainder of 18.5 / 4.2 is 1.7</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123; <span class="comment">// std::remquo: Returns the same as remainder, but it additionally stores the quotient</span></span><br><span class="line">  <span class="comment">// internally used to determine its result in the object pointed by quot</span></span><br><span class="line">	<span class="type">double</span> numer = <span class="number">10.3</span>;</span><br><span class="line">	<span class="type">double</span> denom = <span class="number">4.5</span>;</span><br><span class="line">	<span class="type">int</span> quot;</span><br><span class="line">	<span class="type">double</span> result = std::<span class="built_in">remquo</span>(numer, denom, <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>numerator: %f\n<span class="string">&quot;, numer); // 10.3</span></span><br><span class="line"><span class="string">	printf(&quot;</span>denominator: %f\n<span class="string">&quot;, denom); // 4.5</span></span><br><span class="line"><span class="string">	printf(&quot;</span>remainder: %f\n<span class="string">&quot;, result); // 1.3</span></span><br><span class="line"><span class="string">	printf(&quot;</span>quotient: %d\n<span class="string">&quot;, quot); // 2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::rint: Round to integral value</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">2.3</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(2.3)); // 2.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">3.8</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(3.8)); // 4.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">-2.3</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(-2.3)); // -2.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">rint</span> (<span class="number">-3.8</span>) = %<span class="number">.1</span>f\n<span class="string">&quot;, std::rint(-3.8)); // -4.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::lrint: Rounds x to an integral value, and returns it as a value of type long int.</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">2.3</span>) = %ld\n<span class="string">&quot;, std::lrint(2.3)); // 2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">3.8</span>) = %ld\n<span class="string">&quot;, std::lrint(3.8)); // 4</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">-2.3</span>) = %ld\n<span class="string">&quot;, std::lrint(-2.3)); // -2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lrint</span> (<span class="number">-3.8</span>) = %ld\n<span class="string">&quot;, std::lrint(-3.8)); // -4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::llrint: Rounds x to an integral value,returns it as a value of type long long int</span></span><br><span class="line"><span class="string">	printf(&quot;</span>rounding <span class="keyword">using</span> <span class="string">&quot;);</span></span><br><span class="line"><span class="string">	switch (fegetround()) &#123;</span></span><br><span class="line"><span class="string">		case FE_DOWNWARD: printf(&quot;</span>downward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_TONEAREST: printf(&quot;</span>to-nearest<span class="string">&quot;); break; // to-nearest</span></span><br><span class="line"><span class="string">		case FE_TOWARDZERO: printf(&quot;</span>toward-zero<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FE_UPWARD: printf(&quot;</span>upward<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		default: printf(&quot;</span>unknown<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	printf(&quot;</span> rounding:\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">2.3</span>) = %lld\n<span class="string">&quot;, std::llrint(2.3)); // 2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">3.8</span>) = %lld\n<span class="string">&quot;, std::llrint(3.8)); // 4</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">-2.3</span>) = %lld\n<span class="string">&quot;, std::llrint(-2.3)); // -2</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">llrint</span> (<span class="number">-3.8</span>) = %lld\n<span class="string">&quot;, std::llrint(-3.8)); // -4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_exp()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::exp: Returns the base-e exponential function of x, e^x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::exp(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>The exponential value of %f is %f.\n<span class="string">&quot;, param, result); // 1.0 2.718282</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::frexp(x, int* exp):Breaks the floating point number x into its binary significand</span></span><br><span class="line"><span class="string">  // (a floating point with an absolute value between 0.5(included) and 1.0(excluded)) and an integral exponent for 2</span></span><br><span class="line"><span class="string">  // x = significand * (2 ^ exponent)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 8.0;</span></span><br><span class="line"><span class="string">	result = std::frexp(param, &amp;n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f = %f * <span class="number">2</span>^%d\n<span class="string">&quot;, param, result, n); // 8.0 = 0.5 * 2^4</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::ldexp: Returns the result of multiplying x (the significand) by 2 raised to the power of exp (the exponent)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 0.95;</span></span><br><span class="line"><span class="string">	n = 4;</span></span><br><span class="line"><span class="string">	result = std::ldexp(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * <span class="number">2</span>^%d = %f\n<span class="string">&quot;, param, n, result); // 0.95 * 2^4 = 15.2</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::exp2: Returns the base-2 exponential function of x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 8.0;</span></span><br><span class="line"><span class="string">	result = std::exp2(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="number">2</span> ^ %f = %f.\n<span class="string">&quot;, param, result); // 2^8 = 256</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::expm1: Compute exponential minus one</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::expm1(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">expm1</span> (%f) = %f.\n<span class="string">&quot;, param, result); // expm1(1.0) = 1.718282</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::scalbn: Scales x by FLT_RADIX raised to the power of n</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	int n;</span></span><br><span class="line"><span class="string">	param = 1.50;</span></span><br><span class="line"><span class="string">	n = 4;</span></span><br><span class="line"><span class="string">	result = std::scalbn(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * %d^%d = %f\n<span class="string">&quot;, param, FLT_RADIX, n, result); // 1.5 * 2^4 = 24.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::scalbln: Scales x by FLT_RADIX raised to the power of n</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	long n;</span></span><br><span class="line"><span class="string">	param = 1.50;</span></span><br><span class="line"><span class="string">	n = 4L;</span></span><br><span class="line"><span class="string">	result = std::scalbln(param, n);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f * %d^%d = %f\n<span class="string">&quot;, param, FLT_RADIX, n, result); // 1.5 * 2^4 = 24.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_log()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::log: Returns the natural logarithm of x</span></span><br><span class="line"><span class="string">  // The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp)</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 5.5;</span></span><br><span class="line"><span class="string">	result = std::log(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log</span>(%f) = %f\n<span class="string">&quot;, param, result); // ln(5.5) = 1.704748</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log10: Returns the common (base-10) logarithm of x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1000.0;</span></span><br><span class="line"><span class="string">	result = std::log10(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log10</span>(%f) = %f\n<span class="string">&quot;, param, result); // log10(1000.0) = 3.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::modf: Breaks x into an integral and a fractional part</span></span><br><span class="line"><span class="string">	double param, fractpart, intpart;</span></span><br><span class="line"><span class="string">	param = 3.14159265;</span></span><br><span class="line"><span class="string">	fractpart = std::modf(param, &amp;intpart);</span></span><br><span class="line"><span class="string">	printf(&quot;</span>%f = %f + %f \n<span class="string">&quot;, param, intpart, fractpart); // 3.14159265 = 3.0 + 0.141593</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::ilogb: Returns the integral part of the logarithm of |x|, using FLT_RADIX as base for the logarithm.</span></span><br><span class="line"><span class="string">	double param;</span></span><br><span class="line"><span class="string">	int result;</span></span><br><span class="line"><span class="string">	param = 10.0;</span></span><br><span class="line"><span class="string">	result = std::ilogb(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">ilogb</span>(%f) = %d\n<span class="string">&quot;, param, result); // ilogb(10.0) = 3</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log1p: Returns the natural logarithm of one plus x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::log1p(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log1p</span> (%f) = %f.\n<span class="string">&quot;, param, result); // log1p(1.0) = 0.693147</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::log2: Returns the binary (base-2) logarithm of x.</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1024.0;</span></span><br><span class="line"><span class="string">	result = std::log2(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">log2</span> (%f) = %f.\n<span class="string">&quot;, param, result); // log2(1024.0) = 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::logb: Returns the logarithm of |x|, using FLT_RADIX as base for the logarithm</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1024.0;</span></span><br><span class="line"><span class="string">	result = std::logb(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">logb</span> (%f) = %f.\n<span class="string">&quot;, param, result); // logb(1024.0) = 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_error()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::erf: Returns the error function value for x.</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::erf(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">erf</span> (%f) = %f\n<span class="string">&quot;, param, result); // erf(1.0) = 0.842701</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::erfc: Returns the complementary error function value for x</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 1.0;</span></span><br><span class="line"><span class="string">	result = std::erfc(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">erfc</span>(%f) = %f\n<span class="string">&quot;, param, result); // erfc(1.0) = 0.157299</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::tgamma: Compute gamma function</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 0.5;</span></span><br><span class="line"><span class="string">	result = std::tgamma(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">tgamma</span>(%f) = %f\n<span class="string">&quot;, param, result); // tgamma(0.5) = 1.772454</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::lgamma: Compute log-gamma function</span></span><br><span class="line"><span class="string">	double param, result;</span></span><br><span class="line"><span class="string">	param = 0.5;</span></span><br><span class="line"><span class="string">	result = std::lgamma(param);</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">lgamma</span>(%f) = %f\n<span class="string">&quot;, param, result); // lgamma(0.5) = 0.572365</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_1()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::copysign: Returns a value with the magnitude of x and the sign of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> ( <span class="number">10.0</span>,<span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::copysign(10.0, -1.0)); // -10.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> (<span class="number">-10.0</span>,<span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::copysign(-10.0, -1.0)); // -10.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">copysign</span> (<span class="number">-10.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::copysign(-10.0, 1.0)); // 10.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nan: Returns a quiet NaN (Not-A-Number) value of type double.</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nextafter: Returns the next representable value after x in the direction of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value greater than zero: %e\n<span class="string">&quot;, std::nextafter(0.0, 1.0)); // 4.940656e-324</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value less than zero: %e\n<span class="string">&quot;, std::nextafter(0.0, -1.0)); // -4.940656e-324</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::nexttoward: Returns the next representable value after x in the direction of y</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value greater than zero: %e\n<span class="string">&quot;, std::nexttoward(0.0, 1.0L)); // 4.940656e-324</span></span><br><span class="line"><span class="string">	printf(&quot;</span>first representable value less than zero: %e\n<span class="string">&quot;, std::nexttoward(0.0, -1.0L)); // -4.940656e-324</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_2()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::fdim: The function returns x-y if x&gt;y, and zero otherwise.</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">2.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fdim(2.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">1.0</span>, <span class="number">2.0</span>) = %f\n<span class="string">&quot;, std::fdim(1.0, 2.0)); // 0.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">-2.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fdim(-2.0, -1.0)); // 0.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fdim</span> (<span class="number">-1.0</span>, <span class="number">-2.0</span>) = %f\n<span class="string">&quot;, std::fdim(-1.0, -2.0)); // 1.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::fmax: Returns the larger of its arguments: either x or y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmax(100.0, 1.0)); // 100.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">-100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmax(-100.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmax</span> (<span class="number">-100.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fmax(-100.0, -1.0)); // -1.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::fmin: Returns the smaller of its arguments: either x or y</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmin(100.0, 1.0)); // 1.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">-100.0</span>, <span class="number">1.0</span>) = %f\n<span class="string">&quot;, std::fmin(-100.0, 1.0)); // -100.0</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">fmin</span> (<span class="number">-100.0</span>, <span class="number">-1.0</span>) = %f\n<span class="string">&quot;, std::fmin(-100.0, -1.0)); // -100.0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_classify()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&#123; // std::fpclassify: Returns a value of type int that matches one of the classification</span></span><br><span class="line"><span class="string">  // macro constants, depending on the value of x</span></span><br><span class="line"><span class="string">	double d = std::sqrt(-1.0); // 1.0 / 0.0;</span></span><br><span class="line"><span class="string">	switch (std::fpclassify(d)) &#123;</span></span><br><span class="line"><span class="string">		case FP_INFINITE:  printf(&quot;</span>infinite<span class="string">&quot;);  break;</span></span><br><span class="line"><span class="string">		case FP_NAN:       printf(&quot;</span>NaN<span class="string">&quot;);       break; // NaN</span></span><br><span class="line"><span class="string">		case FP_ZERO:      printf(&quot;</span>zero<span class="string">&quot;);      break;</span></span><br><span class="line"><span class="string">		case FP_SUBNORMAL: printf(&quot;</span>subnormal<span class="string">&quot;); break;</span></span><br><span class="line"><span class="string">		case FP_NORMAL:    printf(&quot;</span>normal<span class="string">&quot;);    break;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	if (std::signbit(d)) printf(&quot;</span> negative\n<span class="string">&quot;); // negative</span></span><br><span class="line"><span class="string">	else printf(&quot;</span> positive <span class="keyword">or</span> <span class="type">unsigned</span>\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isfinite: Returns whether x is a finite value</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isfinite(0.0)); // 1</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isfinite(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isfinite</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isfinite(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isfinite</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isfinite(std::sqrt(-1.0))); // 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isinf: Returns whether x is an infinity value </span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isinf(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isinf(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isinf</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isinf(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isinf</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isinf(std::sqrt(-1.0))); // 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isnan: Returns whether x is a NaN (Not-A-Number) value.</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::isnan(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::isnan(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnan</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::isnan(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnan</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::isnan(std::sqrt(-1.0))); // 1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isnormal: Returns whether x is a normal value</span></span><br><span class="line"><span class="string">  // i.e., whether it is neither infinity, NaN, zero or subnormal</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">1.0</span>)    : %d\n<span class="string">&quot;, std::isnormal(1.0)); // 1</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">0.0</span>)    : %d\n<span class="string">&quot;, std::isnormal(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">isnormal</span>(<span class="number">1.0</span>/<span class="number">0.0</span>): %d\n<span class="string">&quot;, std::isnormal(1.0 / 0.0));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::signbit: Returns whether the sign of x is negative</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">0.0</span>)       : %d\n<span class="string">&quot;, std::signbit(0.0)); // 0</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">1.0</span>/<span class="number">0.0</span>)   : %d\n<span class="string">&quot;, std::signbit(1.0 / 0.0));</span></span><br><span class="line"><span class="string">	//printf(&quot;</span><span class="built_in">signbit</span>(<span class="number">-1.0</span>/<span class="number">0.0</span>)  : %d\n<span class="string">&quot;, std::signbit(-1.0 / 0.0));</span></span><br><span class="line"><span class="string">	printf(&quot;</span><span class="built_in">signbit</span>(<span class="built_in">sqrt</span>(<span class="number">-1.0</span>)): %d\n<span class="string">&quot;, std::signbit(std::sqrt(-1.0))); // 1</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int test_cmath_compare()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	double result;</span></span><br><span class="line"><span class="string">	result = std::log(10.0);</span></span><br><span class="line"><span class="string">&#123; // std::isgreater: Returns whether x is greater than y</span></span><br><span class="line"><span class="string">	if (std::isgreater(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is positive\n<span class="string">&quot;); // log(10.0) is positive</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> positive\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isgreaterequal: Returns whether x is greater than or equal to y</span></span><br><span class="line"><span class="string">	if (std::isgreaterequal(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> negative\n<span class="string">&quot;); // log(10.0) is not negative</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is negative\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isless: Returns whether x is less than y</span></span><br><span class="line"><span class="string">	if (std::isless(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is negative\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> negative\n<span class="string">&quot;); // log(10.0) is not negative</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::islessequal: Returns whether x is less than or equal to y</span></span><br><span class="line"><span class="string">	if (std::islessequal(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> positive\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is positive\n<span class="string">&quot;); // log(10.0) is positive</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::islessgreater: Returns whether x is less than or greater than y</span></span><br><span class="line"><span class="string">	if (islessgreater(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is <span class="keyword">not</span> zero\n<span class="string">&quot;); // log(10.0) is not zero</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">log</span>(<span class="number">10.0</span>) is zero\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#123; // std::isunordered: Returns whether x or y are unordered values</span></span><br><span class="line"><span class="string">	double result;</span></span><br><span class="line"><span class="string">	result = std::sqrt(-1.0);</span></span><br><span class="line"><span class="string">	if (std::isunordered(result, 0.0))</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">sqrt</span>(<span class="number">-1.0</span>) <span class="keyword">and</span> <span class="number">0.0</span> cannot be ordered\n<span class="string">&quot;); // sqrt(-1.0) and 0.0 cannot be ordered</span></span><br><span class="line"><span class="string">	else</span></span><br><span class="line"><span class="string">		printf(&quot;</span><span class="built_in">sqrt</span>(<span class="number">-1.0</span>) <span class="keyword">and</span> <span class="number">0.0</span> can be ordered\n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; // namespace cmath_</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">290k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
