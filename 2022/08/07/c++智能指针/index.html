<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="导入先看一组类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;mutex&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="c++智能指针">
<meta property="og:url" content="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="导入先看一组类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;mutex&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-07T13:12:13.610Z">
<meta property="article:modified_time" content="2022-08-10T04:12:27.894Z">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>c++智能指针 | JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          c++智能指针
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-07 21:12:13" itemprop="dateCreated datePublished" datetime="2022-08-07T21:12:13+08:00">2022-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 12:12:27" itemprop="dateModified" datetime="2022-08-10T12:12:27+08:00">2022-08-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>先看一组类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">shape_type</span> &#123;<span class="comment">//枚举类</span></span><br><span class="line">    circle,</span><br><span class="line">    triangle,</span><br><span class="line">    rectangle,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;shape&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am shape&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;circle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am circle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">triangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;triangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am triangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rectangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;rectangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am rectangle&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------子类-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态 上转 如果返回值为shape,会存在对象切片问题（强制转换，损失数据）。</span></span><br><span class="line"><span class="comment">// 使用基类指针指向派生类</span></span><br><span class="line"><span class="function">shape *<span class="title">create_shape</span><span class="params">(shape_type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> shape_type::circle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">triangle</span>();</span><br><span class="line">        <span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">rectangle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">shape_wrapper</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shape* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>shape_wrapper这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ul>
<li>这个类只适用于 shape 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为</li>
</ul>
<h1 id="手写auto-ptr与scope-ptr"><a href="#手写auto-ptr与scope-ptr" class="headerlink" title="手写auto_ptr与scope_ptr"></a>手写auto_ptr与scope_ptr</h1><p>针对”这个类只适用于 shape 类”，我们想到了模板，于是改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">smater_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">smater_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”该类对象的行为不够像指针”，我们想到了指针的基本操作有<code>*</code>，<code>-&gt;</code>，布尔表达式。</p>
<p>于是添加三个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smater_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	...</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;<span class="comment">//返回引用，作为左值</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;<span class="comment">//返回目的类型的指针</span></span><br><span class="line">    				<span class="comment">//语句 sp-&gt;m 被解释为 (sp.operator-&gt;())-&gt;m，即ptr_-&gt;m，通过对sp类操作就可以调用ptr_类的成员</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对”拷贝该类对象会引发程序行为”，我们想到了拷贝构造和赋值。</p>
<p>现考虑如下调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr1</span><span class="params">(create_shape(shape_type::circle))</span></span>;<span class="comment">//create...表示new一个对象</span></span><br><span class="line"><span class="function">smart_ptr&lt;shape&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查 一下各种可能性。</p>
<p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    smart_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，也可以设为private。</p>
<p>禁用这两个函数非常简单，但却解决了一种可能出错的情况：<code>smart_ptr&lt;shape&gt; ptr2(ptr1);</code> 在编译时不会出错，但在运行时却会有未定义行为——<strong>由于会对同一内存释放两次，通常情况下会导致程序崩溃。</strong></p>
<blockquote>
<p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。在 C++ 里没有像 Java 的clone 方法这样的约定；<strong>一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</strong></p>
</blockquote>
<p>那关键点就来了，<strong>所有权！</strong>，我们可以拷贝时转移指针的所有权！下面实现便是<code>auto_ptr</code>的核心实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回值为T&amp;，允许*ptr=10操作</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造,被复制放释放原来指针的所有权,交给复制方</span></span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr &amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap</span></span><br><span class="line">    auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr &amp;rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line"><span class="comment">//        auto_ptr tmp(rhs.release());拷贝构造copy</span></span><br><span class="line"><span class="comment">//        tmp.swap(*this);交换swap</span></span><br><span class="line">        <span class="comment">// s上述两行等价于下面一行</span></span><br><span class="line">        <span class="built_in">auto_ptr</span>(rhs.<span class="built_in">release</span>()).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(auto_ptr&lt;T&gt; &amp;lhs, auto_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    auto_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr2.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造：ptr1释放了所有权,ptr2获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ptr1 = ptr1;</span><br><span class="line"></span><br><span class="line">    auto_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr3.<span class="built_in">get</span>() == <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述通过copy-swap技术完成了避免自我赋值与保证了强异常安全！</p>
<p>如果你觉得这个实现还不错的话，那恭喜你，你达到了 C++ 委员会在 1998 年时的水平：上面给出的语义本质上就是 C++98 的 auto_ptr 的定义。如果你觉得这个实现很别扭的话，也恭喜你，因为 C++ 委员会也是这么觉得的：<strong>auto_ptr 在 C++17 时已经被正式从C++ 标准里删除了</strong>。</p>
<p>上面会导致什么问题呢？</p>
<p>看一下输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">拷贝构造：ptr1释放了所有权,ptr2获得了所有权</span><br><span class="line">shape</span><br><span class="line">rectangle</span><br><span class="line">赋值操作：始终只有一个对象管理一个区块!ptr3释放了所有权,ptr1获得了所有权</span><br></pre></td></tr></table></figure>

<p>shape与circle是在create_shape时候输出的，我们重点关注最后一句话，发现了一个很大的问题：<strong>它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 auto_ptr，你就不再拥有这个对象了。</strong></p>
<p>针对这个问题，在C++11标准出来之前，C++98标准中都一直只有一个智能指针auto_ptr，我们知道，这是一个失败的设计。它的本质是<strong>管理权的转移</strong>，这有许多问题。而这时就有一群人开始扩展C++标准库的关于智能指针的部分，他们组成了boost社区，他们负责boost库的开发和维护。其目的是为C++程序员提供免费的、同行审查的、可移植的程序库。boost库可以和C++标准库完美的共同工作，并且为其提供扩展功能。现在的<strong>C++11标准库</strong>的智能指针很大程度上“借鉴”了boost库。</p>
<p>boost::scoped_ptr 属于 boost 库，定义在 namespace boost 中，包含头文件<code>#include&lt;boost/smart_ptr.hpp&gt; </code>可以使用。scoped_ptr 跟 auto_ptr 一样，可以方便的管理单个堆内存对象，特别的是，scoped_ptr <strong>独享所有权</strong>，避免了auto_ptr恼人的几个问题。</p>
<p>scope_ptr是一种简单粗暴的设计，它本质就是<strong>防拷贝</strong>，避免出现管理权的转移。这是它的最大特点，所以他的拷贝构造函数和赋值运算符重载函数都只是声明而不定义，而且为了<strong>防止有的人在类外定义</strong>，所以<strong>将函数声明为private</strong>。但这也是它最大的问题所在，就是<strong>不能赋值拷贝，也就是说功能不全</strong>。但是这种设计比较高效、简洁。没有 release() 函数，不会导致先前的内存泄露问题。下面我也将模拟实现scoped_ptr的管理机制(实际上就是前面提到的禁止拷贝)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_ptr</span> <span class="comment">// noncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_ptr</span><span class="params">(T *ptr = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> : ptr_(ptr) &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">scoped_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T *p = <span class="number">0</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="built_in">scoped_ptr</span>(p).<span class="built_in">swap</span>(*<span class="keyword">this</span>);<span class="comment">//使用构造函数构造一个临时对象，然后交换指针，让临时对象把原来的空间析构掉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    <span class="comment">//在private里禁用，也可以delete</span></span><br><span class="line">    <span class="built_in">scoped_ptr</span>(scoped_ptr <span class="type">const</span> &amp;);<span class="comment">//只需声明，然后不提供实现即可</span></span><br><span class="line">    scoped_ptr &amp;<span class="keyword">operator</span>=(scoped_ptr <span class="type">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(scoped_ptr&lt;T&gt; &amp;lhs, scoped_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scoped_ptr特点总结：</p>
<ul>
<li><p>与auto_ptr类似，采用<strong>栈上的指针去管理堆上的内容</strong>，从而<strong>使得堆上的对象随着栈上对象销毁时自动删除（栈自动删除-&gt;析构函数-&gt;释放堆空间）</strong>；</p>
</li>
<li><p>scoped_ptr有着更严格的使用限制——<strong>不能拷贝</strong>，这也意味着scoped_ptr<strong>不能转换其所有权</strong>，所以它管理的对象不能作为<strong>函数的返回值</strong>，对象生命周期仅仅局限于一定区间（该指针所在的{}区间，因为不允许拷贝和赋值，对象<strong>与scoped_ptr紧紧地绑定在了一起</strong>，受限于{}的栈，而std::auto_ptr管理的对象可以在不同的区间存活）；</p>
</li>
<li><p>由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>，这与std::auto_ptr类似（一个是独享，一个是转移，都不是共享），这一特点使该指针简单易用，但也<strong>造成了功能的薄弱</strong>。</p>
</li>
</ul>
<h1 id="手写unique-ptr之子类向基类转换"><a href="#手写unique-ptr之子类向基类转换" class="headerlink" title="手写unique_ptr之子类向基类转换"></a>手写unique_ptr之子类向基类转换</h1><p>在上述auto_ptr基础上，我们把拷贝构造与拷贝赋值，改为移动构造与移动赋值（参考语法记录内的相关内容）。</p>
<ul>
<li>noexcept：该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。<br>如果在运行时，noexecpt函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的指针释放所有权</span></span><br><span class="line">    <span class="function">T *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        T *ptr = ptr_;</span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);    <span class="comment">// 转移指针所有权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&lt;T&gt; &amp;lhs, unique_ptr&lt;T&gt; &amp;rhs)</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，没有拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok，使用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，此时赋值构造函数通过拷贝构造函数实现（ptr3是左值），但没有</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok，使用赋值构造函数通过移动构造函数实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::move将对象转化为右值</span></span><br></pre></td></tr></table></figure>

<p>把拷贝构造函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr&amp;&amp;；现在它成了移动构造函数。 把赋值函数中的参数类型 unique_ptr&amp; 改成了 unique_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象（<strong>相当于传入参数时，就构造了临时对象</strong>）。现在赋值函数的行为是移动还是拷贝，<strong>完全依赖于构造参数时走的是移动构造还是拷贝构造</strong>。</p>
<p>最后，一个<code> circle*</code> 是可以隐式转换成 <code>shape*</code>的，但上面的 <code>unique_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>unique_ptr&lt;shape&gt;</code>（基类转子类，即<code>unique_ptr&lt;circle&gt; = shape*</code>是非法的，不能自动转换）。</p>
<hr>
<p>现在我们考虑两种情况：</p>
<p><strong>（1）第一种：当我们只是在原先的移动构造上面添加<code>template &lt;typename U&gt;</code>，此时情况是移动构造变为带模板的移动构造，可以进行子类向基类转换，但是与移动构造相关的，则调用的是默认移动构造，除非是子类向基类转换，才调用带模板的移动构造。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;U&gt; &amp;&amp;other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>六个特殊的成员函数其生成规则如下：</strong></p>
<ul>
<li><strong>默认构造函数，生成规则和C++98一样，在用户没有声明自定义的构造函数的时候并且编译期需要的时候生成。</strong></li>
<li><strong>析构函数，生成规则和C++98一样，在C++11中有点不同的是，析构函数默认是noexcept。</strong></li>
<li><strong>拷贝构造函数，用户自定义了移动操作会导致不生成默认的拷贝构造函数，其它和C++98的行为一致。</strong></li>
<li><strong>拷贝赋值操作符，用户自定义了移动操作会导致不生成默认的拷贝赋值操作，其它和C++98的行为一致。</strong></li>
<li><strong>移动构造函数和移动赋值操作符，仅仅在没有用户自定义的拷贝操作、析构操作，移动操作的时候才会生成。因为默认移动构造函数出现应该在是在你需要它且能保证内存不被泄露的前提下才会出现。析构函数被显示定义的一个隐含说明就是说需要回收内存。</strong></li>
</ul>
<p>根据《Effective Modern C++》Item17 P115页提到，当类中含有特殊成员函数变为模板特殊成员函数的时候，此时不满足上述生成规则，也就是针对当前例子来说，编译器<strong>会默认生成拷贝构造</strong>，因为移动构造是模板函数（且没有非模板函数版本），所以此时上述main调用里面为error的都可以正常运行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; <span class="comment">// 由于带模板的移动构造函数引发编译器会默认生成拷贝构造</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)      <span class="comment">// bitwise copy 此时ptr1不为NULL</span></span><br><span class="line">        ptr2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// 调用的是默认的移动构造,而不是带模板的移动构造 bitwise move</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() != <span class="literal">nullptr</span>)   <span class="comment">// ptr1 不为空</span></span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line">    ptr1 = ptr3;    <span class="comment">// ok  根据形参先调用默认拷贝（ptr3是左值）,再调用拷贝赋值</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok 根据形参先调用默认移动构造（使用move后是右值），而不是带参数的移动构造,再调用移动赋值</span></span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr4</span><span class="params">(std::move(<span class="keyword">new</span> circle))</span></span>;  <span class="comment">// ok 调用带模板的移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）第二种：移动构造与带模板的移动构造同时存在，可以完成子类向基类的转换，此时满足上述生成规则，但此时不会生成拷贝函数！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unique_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line"><span class="comment">//    unique_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;; // error，无拷贝构造函数</span></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr2_2&#123;std::<span class="built_in">move</span>(ptr1)&#125;;    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">if</span> (ptr2_2.<span class="built_in">get</span>() != <span class="literal">nullptr</span> &amp;&amp; ptr1.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">        ptr2_2.<span class="built_in">get</span>()-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    unique_ptr&lt;shape&gt; ptr3&#123;<span class="built_in">create_shape</span>(shape_type::rectangle)&#125;;</span><br><span class="line"><span class="comment">//    ptr1 = ptr3;    // error，无拷贝构造函数，无法使用赋值构造函数（左值）</span></span><br><span class="line">    ptr3 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">//    unique_ptr&lt;circle&gt; cl&#123;create_shape(shape_type::circle)&#125;;  // error 因为create_shape返回的是shape 不能基类转子类</span></span><br><span class="line">    unique_ptr&lt;circle&gt; cl&#123;<span class="keyword">new</span> <span class="built_in">circle</span>()&#125;;</span><br><span class="line">    <span class="function">unique_ptr&lt;shape&gt; <span class="title">ptr5</span><span class="params">(std::move(cl))</span></span>;  <span class="comment">// ok unique&lt;circle&gt;转unique&lt;circle&gt;（即不用转换）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<ul>
<li><p>我们需要了解子类向基类的隐式转换，通过将移动构造函数变为带模板的移动构造函数，要明白两者共存情况与只有带模板的移动或者其他构造函数<strong>对编译器生成规则的影响</strong>！上述代码，此时还不能完成基类向子类的转换！例如:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<ul>
<li>如果只有带模板的拷贝&#x2F;移动构造函数，则还是会生成默认的拷贝&#x2F;移动构造函数，优先供<strong>同类型</strong>的对象使用，而带模板的供不同类型的对象使用。</li>
</ul>
</li>
<li><p>auto_ptr与unique_ptr都是独占所有权，每次只能被单个对象所拥有，unique_ptr与auto_ptr不同的是<strong>使用移动语义来显式的编写</strong>。</p>
</li>
<li><p>auto_ptr是可以说你随便赋值，但赋值完了之后原来的对象就不知不觉的报废，搞得你莫名其妙。而unique_ptr就干脆不让你可以随便去复制，赋值。如果实在想传个值就哪里显式的说明内存转移<strong>std:move</strong>一下。然后这样传值完了之后，之前的对象也同样报废了。只不过整个move你让<strong>明显的知道这样操作后会导致之前的unique_ptr对象失效</strong>。</p>
</li>
<li><p>scope_ptr则是直接<strong>不允许拷贝</strong>。由于防拷贝的特性，使其管理的对象<strong>不能共享所有权</strong>。</p>
</li>
</ul>
<h1 id="shared-ptr之引用计数"><a href="#shared-ptr之引用计数" class="headerlink" title="shared_ptr之引用计数"></a>shared_ptr之引用计数</h1><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 shared_ptr 了。</p>
<p>两者区别如下：</p>
<p>多个shared_ptr不仅<strong>共享一个对象，同时还得共享同一个计数</strong>。<strong>当最后一个指向对象(和共享计数)的shared_ptr析构时，它需要删除对象和共享计数。</strong></p>
<p>首先需要一个共享计数的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_count</span>() : <span class="built_in">count_</span>(<span class="number">1</span>) &#123;<span class="comment">//一旦初始化，赋1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> --count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来实现引用计数智能指针：</p>
<p>构造与析构、swap实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            T *ptr = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">            : ptr_(ptr) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();<span class="comment">//初始化一个计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个shared_ptr再去删除对象与共享计数</span></span><br><span class="line">        <span class="comment">// ptr_不为空且此时共享计数减为0的时候,再去删除</span></span><br><span class="line">        <span class="keyword">if</span>(ptr_&amp;&amp;!shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">            <span class="keyword">delete</span> ptr_;</span><br><span class="line">            <span class="keyword">delete</span> shared_count_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(ptr_, rhs.ptr_);   </span><br><span class="line">        <span class="built_in">swap</span>(shared_count_,rhs.shared_count_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr_;</span><br><span class="line">    shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&lt;T&gt; &amp;lhs, shared_ptr&lt;T&gt; &amp;rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    lhs.<span class="built_in">swap</span>(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的赋值函数，编译器可以根据调用来决定是调拷贝构造还是移动构造函数，所以不变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy and swap  始终只有一个对象有管理这块空间的权限</span></span><br><span class="line">shared_ptr &amp;<span class="keyword">operator</span>=(shared_ptr rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝构造与移动构造需要改变：</p>
<p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把<strong>引用数加一</strong>，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 other.ptr_ 置为空，<strong>认为 other 不再指向该共享对象即可</strong></p>
<p>实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;T&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//拷贝构造</span></span><br><span class="line">    ptr_ = other.ptr_; <span class="comment">//1.数据指针共享</span></span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();<span class="comment">//3.计数+1</span></span><br><span class="line">        shared_count_ = other.shared_count_;<span class="comment">//2.计数指针共享</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;U&gt; &amp;&amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;<span class="comment">//移动构造</span></span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>;<span class="comment">//移除数据指针</span></span><br><span class="line">        other.shared_count_ = <span class="literal">nullptr</span>;<span class="comment">//移除计数指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行的时候，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘circle* shared_ptr&lt;circle&gt;::ptr_’ is private</span><br></pre></td></tr></table></figure>

<p>错误原因是<strong>模板的各个实例间并不天然就有 friend 关系</strong>，因而不能互访私有成员 <code>ptr_ </code>和<code>shared_count_</code>。我们需要在 shared_ptr 的定义中显式声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;<span class="comment">//使得可以直接在不同模板实例间互相访问，不需要指定shared_ptr&lt;U&gt;。</span></span><br><span class="line">	<span class="comment">//声明一个模板函数作为友元也是，不需要加&lt;U&gt;</span></span><br><span class="line">	<span class="comment">//若是声明一种特例，直接friend class A&lt;int&gt;; 函数则 friend void fun&lt;int&gt;();</span></span><br></pre></td></tr></table></figure>

<p>对于这个问题，需要进一步解释：</p>
<p>类的private成员，只能由这个类所访问（不论是这个类的哪个实例，在类的作用域就行）。而对于模板类，实际上不同模板的实例并不属于一个类，比如说<code>A&lt;int&gt;</code>和<code>A&lt;double&gt;</code>就不能互相访问，一个私有成员 x 是属于<code>A&lt;int&gt;</code>这个类的，那么就不属于<code>A&lt;double&gt;</code>这个类，但是<code>A&lt;int&gt;</code>这个类的不同实例是可以互相访问 x 的。</p>
<p>因此在shared_ptr这个类中声明友元，也就声明了所有这个类的模板，都是友元。</p>
<hr>
<p>此外，在当前引用计数实现中，我们应该删除release释放所有权函数，编写一个返回引用计数值的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> circle())</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 was &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">ptr2 = ptr1;        <span class="comment">// shared_ptr&lt;circle&gt;隐式转换shared_ptr&lt;shape&gt; 调用带模板的拷贝构造</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    ptr3 = ptr2;        // 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 ptr3=ptr2</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;=======&quot;&lt;&lt;endl;</span></span><br><span class="line">ptr3 = ptr1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时3个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (ptr1)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 is not empty&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 会先调用赋值函数,由编译器决定调用的是拷贝构造还是移动构造,造出一个新的临时对象出来,临时对象会在跳出作用域后被析构掉。</span></span><br><span class="line"><span class="comment">// 在析构函数中,会先判断该临时对象的是否指向资源,如果没有,析构结束。否则,对引用计数减1,判断引用计数是否为0,如果为0,删除共享引用计数指针,否则不操作。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;此时2个shared_ptr指向同一个资源&quot;</span> &lt;&lt; endl;</span><br><span class="line">ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line"><span class="keyword">if</span> (!ptr1 &amp;&amp; ptr2) &#123;      <span class="comment">// 调用的是bool重载操作符</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1 move to ptr2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr1 is now &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr2 is now &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use count of ptr3 is now &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shape</span><br><span class="line">circle</span><br><span class="line">use count of ptr1 is <span class="number">1</span></span><br><span class="line">use count of ptr2 was <span class="number">0</span></span><br><span class="line">此时<span class="number">3</span>个shared_ptr指向同一个资源</span><br><span class="line">use count of ptr1 is now <span class="number">3</span></span><br><span class="line">use count of ptr2 is now <span class="number">3</span></span><br><span class="line">use count of ptr3 is now <span class="number">3</span></span><br><span class="line">ptr1 is <span class="keyword">not</span> empty</span><br><span class="line">此时<span class="number">2</span>个shared_ptr指向同一个资源</span><br><span class="line">ptr1 move to ptr2</span><br><span class="line">use count of ptr1 is now <span class="number">0</span></span><br><span class="line">use count of ptr2 is now <span class="number">2</span></span><br><span class="line">use count of ptr3 is now <span class="number">2</span></span><br><span class="line">~circle</span><br><span class="line">~shape</span><br></pre></td></tr></table></figure>

<p>有几点注意事项：</p>
<ul>
<li>上述代码没有考虑线程安全性，这里只是简化版</li>
<li>&#x3D;赋值重载函数不加<code>&amp;</code>，编译器决定调用拷贝构造还是移动构造，来造出一个临时对象出来。</li>
<li>根据前面提到的，当类中特殊函数变为带模板的函数，编译器仍然会生成默认拷贝构造与默认移动构造。</li>
</ul>
<p>针对第一点：例如：<code>ptr2 = std::move(ptr1);</code></p>
<p>会先调用赋值函数，由编译器决定调用的是拷贝构造还是移动构造，造出一个新的临时对象出来，临时对象会在跳出作用域后被析构掉。在析构函数中，会先判断该临时对象的是否指向资源，如果没有，析构结束。否则，对引用计数减1，判断引用计数是否为0，如果为0，删除共享引用计数指针，否则不操作。</p>
<p>针对第二点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;shape&gt; ptr2, ptr3;<span class="comment">//两个引用计数</span></span><br><span class="line">ptr3 = ptr2;        <span class="comment">// 调用的是编译器生成的默认拷贝构造 所以引用计数不会增加 </span></span><br></pre></td></tr></table></figure>

<p>两者都是<strong>一种类型</strong>，所以在调用赋值操作后，不会调用带模板的拷贝构造来创建临时变量，而是调用编译器生成的<strong>默认拷贝构造</strong>，所以此时引用计数不会增加。</p>
<h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>对应于 C++ 里的不同的类型强制转：</p>
<ul>
<li>dynamic_cast</li>
<li>static_cast</li>
<li>const_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>在上述<code>unique_ptr</code>处实现了子类向基类的转换，但是却没有实现基类向子类的转换，例如：:<code>unique_ptr&lt;circle&gt;</code>转<code>unique_ptr&lt;shape&gt;</code>。</p>
<p>实现这种，需要使用<code>dynamic_cast</code>，实现如下：</p>
<p>首先为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现强制类型转换需要的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other, T *ptr)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">        other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">        shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，就是实现转换函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">dynamic_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());<span class="comment">//强制转换为T*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);<span class="comment">//使用上述的构造函数，返回临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用dynamic_cast转换后，指针为空。此时资源还是被dptr2拥有，dptr1为0</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; dptr1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">dptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; dptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; dptr1_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;circle&gt;(dptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr1_1 is now &quot;</span> &lt;&lt; dptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3 is now &quot;</span> &lt;&lt; dptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">dptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; dptr2_1 = <span class="built_in">dynamic_pointer_cast</span>&lt;shape&gt;(dptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr2_1 is now &quot;</span> &lt;&lt; dptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of dptr3_1 is now &quot;</span> &lt;&lt; dptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。</p>
<ul>
<li>下行转换，基类转换为子类（派生类指针指向基类对象），例如：智能指针转换类似于<code>shape*</code> 转换为<code>circle*</code> 使用dynamic_cast转换后,，<strong>指针为空</strong>。此时资源还是被<strong>dptr2拥有，dptr1为0</strong>。比static_cast安全。</li>
<li>平行转换，指向一致的相互转换，例如：智能指针转换类似于<code>circle*</code>转换为<code>circle*</code>。此时引用计数为<strong>两者共享</strong>。</li>
<li>上行转换，子类转基类，例如：智能指针转换类似于<code>circle*</code>转换为<code>shape*</code>，此时引用技术为<strong>两者共享</strong>。等价于static_cast。</li>
</ul>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>同样，编写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">static_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">static_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shape* -&gt; circle* 使用static_cast转换后,指针为空  与dynamic_cast相比,不安全</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr2</span><span class="params">(<span class="keyword">new</span> shape)</span></span>;</span><br><span class="line">shared_ptr&lt;circle&gt; sptr1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr2);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1 is now &quot;</span> &lt;&lt; dptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2 is now &quot;</span> &lt;&lt; dptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用dynamic_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2</span></span><br><span class="line"><span class="function">shared_ptr&lt;shape&gt; <span class="title">sptr3</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line"><span class="comment">//    shared_ptr&lt;circle&gt; sptr3(new circle);     // 上面或者当前行,后面输出一样！</span></span><br><span class="line">shared_ptr&lt;circle&gt; sptr1_1 = <span class="built_in">static_pointer_cast</span>&lt;circle&gt;(sptr3);      <span class="comment">// 基类转子类</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr1_1 is now &quot;</span> &lt;&lt; sptr1_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3 is now &quot;</span> &lt;&lt; sptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// circle* -&gt; circle* 使用static_cast转换后,指针不为空,此时资源被两者共同使用,引用计数为2 等价于dynamic_cast</span></span><br><span class="line"><span class="function">shared_ptr&lt;circle&gt; <span class="title">sptr3_1</span><span class="params">(<span class="keyword">new</span> circle)</span></span>;</span><br><span class="line">shared_ptr&lt;shape&gt; sptr2_1 = <span class="built_in">static_pointer_cast</span>&lt;shape&gt;(sptr3_1);      <span class="comment">// 子类转基类 上行转换,安全！</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr2_1 is now &quot;</span> &lt;&lt; sptr2_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use count of sptr3_1 is now &quot;</span> &lt;&lt; sptr3_1.<span class="built_in">use_count</span>() &lt;&lt; endl;    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>输出结果同上dynamic_cast，不同之处，在下行转换的时候(基类转子类)，是不安全的！</p>
<p>还可以将non-const对象强制转换为const：<code>static_cast&lt;const A&amp;&gt;(*this)</code>：将本身（A&amp;）转换为const A&amp;。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>去掉const属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">const_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">const_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;circle&gt; s = <span class="built_in">const_pointer_cast</span>&lt;circle&gt;(<span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> circle&gt;(<span class="keyword">new</span> circle));</span><br></pre></td></tr></table></figure>

<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>例如：想把一个指针转为整数，就可以用reinterpret_cast。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">reinterpret_pointer_cast</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> shared_ptr&lt;U&gt; &amp;other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T *ptr = <span class="built_in">reinterpret_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">reinterpret_pointer_cast</span>&lt;<span class="type">int</span>&gt;(s);</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jysama.cn/2022/08/07/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="c++智能指针">https://jysama.cn/2022/08/07/c++智能指针/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/06/c++%E6%83%AF%E7%94%A8%E6%B3%95/" rel="prev" title="c++编程风格惯用法">
      <i class="fa fa-chevron-left"></i> c++编程风格惯用法
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/08/c++stringTOint/" rel="next" title="将string类型转换为int类型">
      将string类型转换为int类型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjM2Ny8zMjgzMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5"><span class="nav-number">1.</span> <span class="nav-text">导入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%86%99auto-ptr%E4%B8%8Escope-ptr"><span class="nav-number">2.</span> <span class="nav-text">手写auto_ptr与scope_ptr</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%86%99unique-ptr%E4%B9%8B%E5%AD%90%E7%B1%BB%E5%90%91%E5%9F%BA%E7%B1%BB%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">手写unique_ptr之子类向基类转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#shared-ptr%E4%B9%8B%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">shared_ptr之引用计数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.</span> <span class="nav-text">指针类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">5.1.</span> <span class="nav-text">dynamic_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-cast"><span class="nav-number">5.2.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-cast"><span class="nav-number">5.3.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">5.4.</span> <span class="nav-text">reinterpret_cast</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">192k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
