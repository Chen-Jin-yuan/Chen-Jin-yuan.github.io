<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="day1数组中重复数字很简单的一道题，用哈希映射可以做出来，需要额外空间，另一种解法比较难想，是“原地交换”的方法。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3   123">
<meta property="og:type" content="article">
<meta property="og:title" content="刷刷力扣">
<meta property="og:url" content="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="day1数组中重复数字很简单的一道题，用哈希映射可以做出来，需要额外空间，另一种解法比较难想，是“原地交换”的方法。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3   123">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-23T12:14:54.017Z">
<meta property="article:modified_time" content="2022-09-04T13:49:47.781Z">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>刷刷力扣 | JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          刷刷力扣
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 20:14:54" itemprop="dateCreated datePublished" datetime="2022-08-23T20:14:54+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-04 21:49:47" itemprop="dateModified" datetime="2022-09-04T21:49:47+08:00">2022-09-04</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>很简单的一道题，用哈希映射可以做出来，需要额外空间，另一种解法比较难想，是“原地交换”的方法。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地交换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==i)</span><br><span class="line">                &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]]==nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="built_in">swap</span>(nums[nums[i]],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：24 ms, 在所有 C++ 提交中击败了96.40%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.4 MB, 在所有 C++ 提交中击败了66.33%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> array[n];<span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            array[i]=<span class="number">-1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(array[nums[i]]==<span class="number">-1</span>)</span><br><span class="line">                array[nums[i]]=<span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时: 32 ms</span></span><br><span class="line"><span class="comment">内存消耗: 22.9 MB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>蛮简单的，但是有些细节需要注意。从左下角看上去就类似是一个二叉搜索树。按照这个性质，从左下角开始比较，目标元素小就往上找，大就往右找，每次都能消去一行。</p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target = 20，返回 false。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意，必须先判断大小即数组合不合法，因为如果n=0.说明是空数组，这样取m就是错误的了，因为根本没有matrix[0]这个元素</span></span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;=m<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：20 ms, 在所有 C++ 提交中击败了79.82%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.7 MB, 在所有 C++ 提交中击败了51.61%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上上面的if判断有冗余，可以利用bool表达式的形式来简化代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>())<span class="comment">//一旦i&lt;0说明n&lt;=0，此时已经是false，不会判断后面的j，也就不会取matrix[0]</span></span><br><span class="line">            				<span class="comment">//这样一个n的if在while里判断了，一个m的if省略掉了</span></span><br><span class="line">            				<span class="comment">//不能写成j&lt;=matrix[0].size()-1，不造为啥，力扣编译器的问题？</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[i][j])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[i][j])</span><br><span class="line">                i--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.12%的用户</span></span><br><span class="line"><span class="comment">内存消耗：12.8 MB, 在所有 C++ 提交中击败了5.28%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>这题主要是对string要有了解。首先需要一个更长的sting，这是我们替换字符（字符数变多）的前提。string可以原地腾出空间，即用resize弄出空位，这给了一个不用额外多一个辅助空间的条件。</p>
<p>所以首先要算出长度，即先遍历一遍sting看空格数，然后resize。</p>
<p>接着重点是，两个指针<strong>从尾向前遍历</strong>、替换。正是因为从后往前才不会影响到原有的元素（对尾部操作是由于尾部都是空的）。并且从后往前，当两个指针位置相等时就可以停止，因为不可能再替换。</p>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="comment">//变换大小，变换后是替换后的大小，尾部那些是空位</span></span><br><span class="line">        s.<span class="built_in">resize</span>(len+count*<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//从两个尾部开始，一个是原先的尾部，一个是现在的尾部</span></span><br><span class="line">        <span class="type">int</span> i = len<span class="number">-1</span>, j = len+count*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">&#x27; &#x27;</span>)<span class="comment">//不用换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=s[i];</span><br><span class="line">                i--;</span><br><span class="line">                j--;<span class="comment">//减了刚好进行下一个if判断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//要替换</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j<span class="number">-2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                j-=<span class="number">3</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了83.37%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>因为是从尾到头，有种先进后出的意思，那么可以用一个辅助栈来存储。如果不允许额外的空间，则可以先反转链表，再顺序取出。</p>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助栈</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.6 MB, 在所有 C++ 提交中击败了35.04%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        </span><br><span class="line">        ListNode* cur = head;<span class="comment">//当前指针</span></span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;<span class="comment">//前向指针，注意head的next变为NULL，故pre初始化为nullptr</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了73.73%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.3 MB, 在所有 C++ 提交中击败了93.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>将栈分为一个主栈一个辅助栈，这样就能将插入和删除更具有目的性，因此插入就很简单，直接push主栈里，而不去考虑位置，这个问题留到删除来解决。</p>
<p>对于删除，主要是要删头部也就是第一个进来的，但在栈中它位于底部。因此要把主栈元素都倒出来，放辅助栈里，这样辅助栈就是一个按顺序的队列。因此：如果辅助栈不是空的，说明它被倒进来了，顶部元素就是第一个元素，删掉它；如果辅助栈是空的，则元素都在主栈里，如果主栈是空的，返回-1；如果主栈不是空的，就需要把元素倒出来给辅助栈，然后删顶部元素。</p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        smain.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!shelp.<span class="built_in">empty</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=shelp.<span class="built_in">top</span>();</span><br><span class="line">            shelp.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smain.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!smain.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            shelp.<span class="built_in">push</span>(smain.<span class="built_in">top</span>());</span><br><span class="line">            smain.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = shelp.<span class="built_in">top</span>();</span><br><span class="line">        shelp.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; smain;<span class="comment">//主栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; shelp;<span class="comment">//辅助栈</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：248 ms, 在所有 C++ 提交中击败了76.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：101 MB, 在所有 C++ 提交中击败了72.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>简单的动态规划，注意要在运算过程中取模，不然会越界。</p>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">0</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.1%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><p>一次跳1或2，则到第n个台阶为从n-1或从n-2；因此f(n)&#x3D;f(n-1)+f(n-2)，本质也是斐波那契问题，用动态规划。不同的是初值不同，f(0)&#x3D;f(1)&#x3D;1。</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;<span class="comment">//从f1和f0开始</span></span><br><span class="line">        <span class="keyword">while</span>(--n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (a+b)%max;<span class="comment">//tmp相当于fn</span></span><br><span class="line">            b=a;<span class="comment">//fn-2向前变成fn-1</span></span><br><span class="line">            a=tmp;<span class="comment">//fn-1向前变成fn</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了93.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>这题的数组在某种程度上是有序的，因此用二分。但二分是用中间值和target比较，这里的target在哪呢？就用两个端点值，而且只能用右端点的值，这样才能缩小区间。为何要用右端点呢，是因为右端点是截断点，根据比较能缩小区间，左端点则不行。原则上将数组分成两个有序数组（左边段和右边段），就可以缩小区间了。</p>
<p>在比较之后，如果中间大于右端点，说明中间在左边段，而最小值一定在右边段，即在low之后，因此可以缩小区间，把low变成mid，而此时mid不可能是最小值，因此可以变成mid+1。并且必须这样，不然假如是5，1，那么low&#x3D;mid，一直死循环。</p>
<p>如果中间小于右端点，则中间点在右边段了，最小值位置在mid及mid以前，缩小区间high&#x3D;mid，因为mid也可能是最小值，因此high不能mid-1。</p>
<p>如果中间和右端点相等，这是因为这里的数组元素可以相等，此时high不能直接&#x3D;mid，因为左边段可以和右边段相等，如3，3，1，3。直接相等就越过了1。也不能让low&#x3D;mid，因为右段也可以和右端点相等。1，3，3的情况下，就越过了1。因此，直接将high-1就可以了，这样可以保证不越过又可以慢慢缩小区间，如果high是最小值，那么mid也是最小值，不会越过。</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid]&lt;numbers[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&gt;numbers[high]) low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了86.65%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.7 MB, 在所有 C++ 提交中击败了71.43%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>这道题找路径的，就可以用深度优先搜索（dfs），由于每个元素都可以当开头，因此要对每个元素都用一次dfs。然后考虑一下剪枝，在dfs的过程中每个位置都可以继续向上下左右出发（用逻辑或连接起来），因此第一个要考虑的部分就是越界问题；其次，每次dfs都向后探一个字符串单词的字母，如果正确才能继续，因此第二个要考虑的就是当这个位置的字母不正确就返回false。这样就可以保证找到所有的可能。</p>
<p>还要考虑标记的问题，因为矩阵的元素不能重复使用，当这个元素正确要向后dfs时，必须先把这个元素标记不可用，在c++中用’\0’就可以。在dfs之后，还要标记回来。</p>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        n = board.<span class="built_in">size</span>();</span><br><span class="line">        m = board[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//初始化行列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,word,i,j,<span class="number">0</span>))<span class="comment">//对每个位置都dfs，0表示单词开始，如果找到则直接返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, m;<span class="comment">//声明行列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=n||j&gt;=m||board[i][j]!=word[k]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//越界或不对应则剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(k==word.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没越界且对应，长度也对应，成功</span></span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//向上下左右出发，k+1</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(board, word, i+<span class="number">1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j+<span class="number">1</span>, k+<span class="number">1</span>)||</span><br><span class="line">            <span class="built_in">dfs</span>(board, word, i<span class="number">-1</span>, j, k+<span class="number">1</span>)||<span class="built_in">dfs</span>(board, word, i, j<span class="number">-1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];<span class="comment">//标记回来</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：520 ms, 在所有 C++ 提交中击败了18.67%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了98.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><h2 id="I-剪绳子"><a href="#I-剪绳子" class="headerlink" title="I-剪绳子"></a>I-剪绳子</h2><p>这种题首先是求最大值，然后因为乘积是可分解的，因此这个问题可以缩小规模，就可以考虑用动态规划，实际上有更简单的数学解法。对于动态规划，n是从2开始的，然后当长度是n的时候，可以将乘积分两段，要么直接乘，要么对前一段再分（也就是小规模的再动态规划），后一段的长度通过遍历解决，就不用动态规划了。因此长度n时有两种选择，两段乘或再分，然后还要继续遍历，因此要保存好前面求的最大值。</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]*k[1]*…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)<span class="comment">//i从3开始，到n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)<span class="comment">//j从1开始，长度到i-1（最简单的遍历方式），</span></span><br><span class="line">                <span class="comment">//这里j从2开始也可以，长度到i-2也可以，因为长度为1的划分没有意义</span></span><br><span class="line">                <span class="comment">//但不能同时，要确保能进入循环，才有dp的定义</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],<span class="built_in">max</span>((i-j)*j,dp[i-j]*j));<span class="comment">//首先要和之前遍历出来的dp[i]比较。然后看</span></span><br><span class="line">        									<span class="comment">//是直接乘更大还是继续划分，j不用dp，因为是遍历的</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：6 MB, 在所有 C++ 提交中击败了63.63%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h1><h2 id="II-剪绳子"><a href="#II-剪绳子" class="headerlink" title="II-剪绳子"></a>II-剪绳子</h2><p>这题就不方便用动态规划了，因为会溢出。这个问题出自我们是对结果取余，用动态规划max比较时，取余会造成max比较不正确，比如一个大的取余反而小了。因此不能在比较时候取余，那么在计算过程中就会溢出，即使用long long int也存在这个问题。</p>
<p>那么就可以用到数学的解法，因为数学的解法不需要比较，只需要一直运算就可以：</p>
<ul>
<li><p>根据几何不等式，等分时乘积最大；</p>
</li>
<li><p>等分为长x的a段有：x&#x3D;an，则乘积为$x^a$，由于 n 为常数，因此当 $x^{\frac{1}{x}}$ 取最大值时， 乘积达到最大值。因为$x^a&#x3D;x^{\frac{n}{x}}$</p>
</li>
<li><p>因此对$x^{\frac{1}{x}}$求极大值，取对数有lny &#x3D; lnx&#x2F;x，求导得x&#x3D;e。那么x可取2或3，代入一下2和3，同时取6次方发现3^2&#x3D;9大一些，因此最好分成长为3的。</p>
</li>
</ul>
<p>结论：</p>
<p>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。<br>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 $2 \times 2 &gt; 3 \times 1$。</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]*k[1]*…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;<span class="comment">//必须切分一次</span></span><br><span class="line">        <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="number">4</span>;<span class="comment">//最后的4变成2*2</span></span><br><span class="line">            n = n - <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            ret = <span class="number">2</span>;<span class="comment">//最后的2留着</span></span><br><span class="line">            n = n - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            ret = ret * <span class="number">3</span> % <span class="number">1000000007</span>;<span class="comment">//这里可以取模的原因是，跟max不同，ret是已经确定好的答案，只是一直没算完，</span></span><br><span class="line">            						<span class="comment">//先模后模的结果是一样的           </span></span><br><span class="line">            n = n - <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了86.22%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>第一种方法是逐位看是不是1，直接把1左移然后和n与运算那就好。也可以模2来做。</p>
<p>第二种方法是用n&amp;(n-1)，因为n-1会把第一个1右边的0变成1，且这个1变成0，那么再与n做与运算时，实际上就是把n的第一个1消去了（原来的0和1&amp;也是0，但原来的1由于变成了0，&amp;后也是0），因此每做一次这个操作，就有一个1。</p>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逐位比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1</span>&lt;&lt;i))<span class="comment">//不断将1左移i位，也就是和n的第i位对齐，然后取与运算</span></span><br><span class="line">                res++;<span class="comment">//如果结果非0，则是一个1</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.9 MB, 在所有 C++ 提交中击败了33.03%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n&amp;(n-1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n &amp;= n<span class="number">-1</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.8 MB, 在所有 C++ 提交中击败了82.14%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h1><h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>简单的快速幂+迭代，假如数值是x，次方的n，那么就是要分n是奇数还是偶数，这是因为如果是奇数要多一项，偶数则直接x平方。把n看成二进制的话，举个例子，如果n&#x3D;1000，则是$x^8$，把x的二次方再二次方再二次方，整个过程三次即可（因为有三个零），但如果是1001，则要先乘一个x，再乘$x^8$。</p>
<p>也就是说，如果n是奇数，则底数累乘一个“x”。为了循环计算，我们要把n每次除以2（其实就是一位一位看是不是1），然后再看是不是奇数。对应此，所谓的“x”就也是累成的，可以定义一个k存储中间结果。</p>
<p>再注意一下细节，如果n是负数，那么要把x取倒数，然后把n正过来。但是负数的n正过来可能会使int溢出，所以要用longlong来做。</p>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>)<span class="comment">//预处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            N=-N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> k = x;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(N%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                res *= k;<span class="comment">//如果最后一位是1，说明对应的k要乘</span></span><br><span class="line">            k = k*k;<span class="comment">//不管如何，因为N要右移了，k要平方一次</span></span><br><span class="line">            N/=<span class="number">2</span>;<span class="comment">//右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：5.7 MB, 在所有 C++ 提交中击败了82.47%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h1><h2 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h2><p>这题之所以是简单题，是因为题目设计时不需要考虑大数问题，这类题目最好直接以大数的形式来写，这就需要string来辅助。</p>
<p>由于最后要返回vector，因此定义一个vector成员变量，这里面存int；同时使用两个辅助函数，一个用来递增数，一个用来将string转换为int存到vector里。</p>
<p>public内是主函数，由于定义string需要数的大小n，这是主函数的参数，因此string也要在主函数定义，所以辅助函数也需要传入string这个参数（用引用，递增函数要修改number），具体见代码。然后循环递增，每个数都转int放vector，最后返回就可以了。循环的结束判断利用递增函数的返回值来做，如果溢出则结束（溢出表明数已经大于给定的位数了）</p>
<p>对于转int函数，重点是把string前面多余的’0’去掉，从头开始遍历这些0，当不是0时就退出，然后用另一个string用+&#x3D;把剩下的都连接起来，最后用stoi函数转int。</p>
<p>对于递增函数，重点是进位。首先定义一个表示进位的变量，然后就能得出每个位置上应该变成的值了：<code>num = number[i]-&#39;0&#39;+takeOver;//当前位等于原来的加上进位的</code>，当然最低位因为递增要加一。takeOver初始化为0，因为最低位没有进位。然后要循环判断进位，因为有可能是…99999的情况。所以我们的循环从最低位开始，最低位的num得出后要num++，然后如果num&#x3D;&#x3D;10说明要进位，takerOver&#x3D;1，这一位变成0；同时如果是最高位了，就溢出了，返回false。如果没有进位，就到此为止了，设置这一位的string的值就可以了，最后返回true表示可以继续递增。</p>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个能容纳最大值的字符数组，由于需要n，因此在函数里创建而不成为类成员，这导致辅助函数需要传入number这个参数</span></span><br><span class="line">        <span class="function">string <span class="title">number</span><span class="params">(n,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="comment">//初始全部设置为0，因为输出从1开始，后面就先增加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">increment</span>(number))<span class="comment">//在increment的过程中判断是否结束，因为increment既有到哪一位的信息、也有是否进位的信息</span></span><br><span class="line">            <span class="built_in">saveNum</span>(number);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//将string转int，放数组里</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">increment</span><span class="params">(string &amp;number)</span><span class="comment">//运行一次就+1</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> takeOver = <span class="number">0</span>;<span class="comment">//最大的要点就是考虑进位，一开始的进位是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)<span class="comment">//i从最后开始，代表数从最低位开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = number[i]-<span class="string">&#x27;0&#x27;</span>+takeOver;<span class="comment">//当前位等于原来的加上进位的</span></span><br><span class="line">            <span class="keyword">if</span>(i==len<span class="number">-1</span>)</span><br><span class="line">                num++;<span class="comment">//如果是最低位，则要+1，代表增加一个1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">10</span>)<span class="comment">//若要进位</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//最高位，且加上进位是10，溢出了，结束</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    number[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    takeOver = <span class="number">1</span>;<span class="comment">//不用再设回0，因为一旦不用进位就结束了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//不用进位就到此为止</span></span><br><span class="line">            &#123;</span><br><span class="line">                number[i] = num+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveNum</span><span class="params">(string &amp;number)</span><span class="comment">//这个函数主要是把number前面多余的0去掉</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = number.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> notzero = len;<span class="comment">//如果都为0则notzero不会被重新赋值，这会使后面那个循环直接跳过，使得s不变就是&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//找到第一个不为0的地方</span></span><br><span class="line">            &#123;</span><br><span class="line">                notzero = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=notzero;i&lt;len;i++)</span><br><span class="line">            s += number[i];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> resnum = <span class="built_in">stoi</span>(s);</span><br><span class="line">        res.<span class="built_in">push_back</span>(resnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了14.22%的用户</span></span><br><span class="line"><span class="comment">内存消耗：11.6 MB, 在所有 C++ 提交中击败了12.52%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h1><h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><p>简单的双指针应用，一个前一个后，cur指针来判定，pre指针要进行节点越过操作</p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next;<span class="comment">//现在head不是目标节点，从next开始</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val==val)<span class="comment">//如果找到</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre-&gt;next = cur-&gt;next;<span class="comment">//越过</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则两个指针向后</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.51%的用户</span></span><br><span class="line"><span class="comment">内存消耗：8.9 MB, 在所有 C++ 提交中击败了84.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>简单的快排思想的应用，其实就是头尾双指针。这份代码我进行了一些小的细节上的优化，效果不错。</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> i&lt;j)<span class="comment">//这个过程要加i&lt;j的判断，一方面防止全是奇数时nums[i]的i越界了，一方面减少循环次数</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> i&lt;j)</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)<span class="comment">//减少不必要的交换和动作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="comment">//手动推进，可以减少大while或小while的一次判断</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了99.32%的用户</span></span><br><span class="line"><span class="comment">内存消耗：17.5 MB, 在所有 C++ 提交中击败了87.78%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h1><h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p>用快慢双指针就很简单了，快指针先走k步（指向第k+1个节点），然后两个指针再一起走直至快指针为null，此时快指针又走了n-k步，慢指针也走了n-k步，倒数过来就是倒数第k个。</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *quick = head, *slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(quick)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            quick = quick-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了68.49%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.2 MB, 在所有 C++ 提交中击败了73.69%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>简单的双指针pre和cur，前面的从尾到头打印链表写过了。感觉也可以用辅助栈，不过不推荐。</p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了95.85%的用户</span></span><br><span class="line"><span class="comment">内存消耗：7.9 MB, 在所有 C++ 提交中击败了93.81%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>简单题，大概是一个merge。使用一个非nullptr的伪头节点能减少代码重复（new一个），当然不用也行，这样还是得要一个head和一个cur，不过先比较l1和l2的头节点大小得出head和cur的指向，然后再进while循环。原因是while内要cur-&gt;next，如果cur没有指向节点而是null则它都没有next，只能在while里面再if判断是不是第一次进入，这样每次又多了一个if。</p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line"></span><br><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于一开始不知道是l1头小还是l2小，因此可以定义一个伪头节点(不是nullptr，所以用new构建一个)，这样可以</span></span><br><span class="line">        <span class="comment">//使头节点的比较也放在while里，和其他节点一样。这样减少了代码重复</span></span><br><span class="line">        ListNode *cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *head = cur;<span class="comment">//head用来保存，cur用来移动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;<span class="comment">//伪头节点后就是</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了92.19%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.6 MB, 在所有 C++ 提交中击败了78.85%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用伪头节点，先比较获得头节点，代码比较臃肿，但是性能不差</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置处理</span></span><br><span class="line">        <span class="keyword">if</span>(!l1)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *head;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">and</span> l2)<span class="comment">//合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l1;<span class="comment">//添加节点并往下</span></span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并尾部</span></span><br><span class="line">        cur-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.83%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了92.94%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>细节在要注意给的矩阵是不是空的，如果是空要直接返回了，否则会有些越界问题。然后我们先获得上下左右四个边界，然后进入一个大的while循环一遍不断地“绕圈”。然后在while内根据边界右、下、左、上遍历元素，同时更新边界，并判断是否越界，越界就可以退出了。总体下来就是根据“边界”，在while(true)里for循环，知道这个就比较简单了。</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, left = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>()<span class="number">-1</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(bottom==<span class="number">-1</span>)<span class="comment">//没有元素</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=top;i&lt;=bottom;i++)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right;i&gt;=left;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top&gt;bottom)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=bottom;i&gt;=top;i--)</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了84.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：9.6 MB, 在所有 C++ 提交中击败了73.13%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h2><p>使用双栈来简化操作，一个主栈就进行push、pop和top（不进行其他操作），另一个辅助栈维护min，这样设计就能明确要做什么。</p>
<p>为了维护min，辅助栈的每次push就需要比较，除了空的时候直接放入，后面的push都只放入不大于栈顶的值。因为大于栈顶的值必然不可能再成为最小值了，它会在最小值被pop之前pop（因为先后顺序的原因），同时相等的元素要放入，因为pop了一个最小值，剩下的也可以是最小值。对于pop，只有当主栈pop出去的是最小值时，辅助栈才pop，因此要判断相不相等。</p>
<p>这样，返回min就只用返回辅助栈的top。实际上，核心是将辅助栈设计成一个升序栈（从顶到底），原理是因为后来的更大的值不可能成为最小值。</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; xstack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; hstack;<span class="comment">//help stack，辅助栈维护升序栈</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        xstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(hstack.<span class="built_in">empty</span>())</span><br><span class="line">            hstack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;=hstack.<span class="built_in">top</span>())</span><br><span class="line">                hstack.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="comment">//辅助栈维护最小值，因此只有更小的才放进去。大的不放是因为辅助栈的顶部一定是最小值，假如说这个最小值被pop出去不存在了</span></span><br><span class="line">    <span class="comment">//那么这个更大的值肯定也更早被pop出去（因为最小值更先存在，大的在更顶上），所以这个最大值不会成为最小值，没必要放进去。</span></span><br><span class="line">        <span class="comment">//使用等于判断是因为可能有多个最小值，pop出一个还有其他的也算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = xstack.<span class="built_in">top</span>();<span class="comment">//要看辅助栈的最小值要不要pop出去</span></span><br><span class="line">        xstack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==hstack.<span class="built_in">top</span>())</span><br><span class="line">            hstack.<span class="built_in">pop</span>();<span class="comment">//如果主栈pop出去的是一个最小值，那么这个最小值也要pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了98.07%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.6 MB, 在所有 C++ 提交中击败了86.44%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><p>这题主要用模拟，根据生活中“手动判断”的过程来模拟。这是怎么样的过程呢：我们一般会跟踪元素一个个push的过程，然后对比poped序列，一旦一个元素可以pop，那就pop并且把前面能pop的也pop。这是因为数字都是不同的，如果错过了pop时机，再有元素进来就不再能pop了，也就错了。</p>
<p>而这里给的两个序列都是vector，我们模拟要不断pop，这不太方便，所以用到一个辅助栈（这也就是我们手动模拟用到的容器）。这样模拟就是：把pushed一个一个放进辅助栈（pushed如同数组，所以用for循环放直观一些），每放进一个就查看poped序列（记录好上次查看的位置），如果相等就pop，然后poped序列向后继续比较看能不能pop（这就用while循环，因为while直接能进行比较判断，并且也不知道for的次数）。</p>
<p>辅助栈不断加入元素，并且在合适时pop，如果最后辅助栈是空的，那么就是正确的了。</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.<span class="built_in">size</span>()!=popped.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//先考虑大小，不同直接false</span></span><br><span class="line">        <span class="type">int</span> n = pushed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果大小为0就true</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//然后开始模拟，pushed和popped是不同排列，所以数字相同</span></span><br><span class="line">        <span class="comment">//如果直接对pushed栈模拟，不好操作，因为pushed是个vector，不对顶操作</span></span><br><span class="line">        <span class="comment">//所以用一个辅助栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> pop_j = <span class="number">0</span>;<span class="comment">//指向popped的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//注意pushed和popped是vector而不是stack，要以数组形式使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pushed[i]);<span class="comment">//不断按顺序放入元素</span></span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() <span class="keyword">and</span> st.<span class="built_in">top</span>()==popped[pop_j])<span class="comment">//然后尝试倒出，如果能倒则一直倒出，</span></span><br><span class="line">                                         <span class="comment">//因为数字不同正确性是唯一的，能倒时不倒，下一个进来时就不可能再倒出了</span></span><br><span class="line">                <span class="comment">//!st.empty()不能漏，因为top()在没有元素时出错、popped[pop_j]可能会越界，也不能直接判断pop_j，</span></span><br><span class="line">                <span class="comment">//因为存在st空了但pop_j还没越界的情况，使用st一举两得</span></span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                pop_j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了70.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：14.8 MB, 在所有 C++ 提交中击败了73.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><p>这题有难度，主要在于没见过不太好想。先从正常的复制开始，如果只是复制next，那么我们遍历一遍原来的链表就可以得到next的信息了。为什么不能得到random呢，原因是random指向的那个节点不知道在哪里，不可能再用一层遍历去找。你可能会想着先遍历复制next的信息，再遍历一遍得到random，这里的关键问题是，我们在第二遍遍历的时候，确实是可以知道原来链表的节点random指向的位置，假设为A，但新的链表的节点random指针要指向的节点在哪呢？假设这个节点叫B，我们的问题是不能从A来找到B，B还是未知的。</p>
<p>因此，重点就是解决这个问题。简单的方法是，就把每个新的节点先放在原来节点的后面，这样就可以用next来找到复制的节点。因此上面的B就是A-&gt;next。于是就建立好了关系：<code>cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</code>。然而random可以指向null，没有next，所以要判空。</p>
<p>最后执行两个链表的拆分即可。整个过程就是：原地拷贝延申、修改random、拆分。注意拷贝要用new。</p>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line"></span><br><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br><span class="line"></span><br><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br><span class="line"></span><br><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置判空</span></span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原地拷贝延申</span></span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            newcur-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur;</span><br><span class="line">            cur = newcur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改random指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random)<span class="comment">//如果这个random不是null才有意义</span></span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;<span class="comment">//cur-&gt;next表示那个新复制的节点，然后-&gt;random表示修改指向，</span></span><br><span class="line">                                                    <span class="comment">//指向的是cur-&gt;random这个节点的next，也就是对应的新复制的节点</span></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        cur = head;</span><br><span class="line">        Node *newhead = head-&gt;next;<span class="comment">//记录下来，因为要用到next，所以head不能为null，因此前面要判断是否为null</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newcur = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newcur-&gt;next;<span class="comment">//cur非null，那么newcur非null，但newcur-&gt;next可能是null，也即这是最后一对节点</span></span><br><span class="line">            <span class="keyword">if</span>(newcur-&gt;next)<span class="comment">//如果不是null</span></span><br><span class="line">                newcur-&gt;next  =cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则直接是null，因为没有null-&gt;next</span></span><br><span class="line">                newcur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了73.50%的用户</span></span><br><span class="line"><span class="comment">内存消耗：10.9 MB, 在所有 C++ 提交中击败了90.72%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p>挺难的一道题，我用的是“下一个排列”的方法。</p>
<p>下一个排列的方法很难理解，一共有四步：1.从后往前找到第一个（严格）升序的元素对，这个元素对的前一个是“较小数”，后面那一段都是降序（非严格，跳过相同的字符，这里面i和j的比较都加”&#x3D;”）的；2.从后往前找到第一个比“较小数”大的数，这个数是“较大数”；3.“较小数”和“较大数”交换；4.交换后，降序的那段依然降序，要反过来变成升序（用reverse函数或前后双指针swap）。在第一步中，我们用i和i+1判断元素对，如果字符串已经是最后一个排列了，或字符串是全相等的（或部分相等，不需要再排列了）时，i会变成-1（找不到），则此时要返回false了。</p>
<p>有了下一个排列，就可以慢慢获得所有排列了，首先就是要把原字符串sort变成最小的排列，然后do-while（因为第一个排列总是要放进去的），注意do-while的while有”;”。</p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">permutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//因为是取下一个排列遍历，所以先排序得到最小排列</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">nextpermutation</span>(s));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">nextpermutation</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="comment">//加等号是因为字符串可能有相同字符，这里要加等号越过它们，表示重复的只有一种情况；</span></span><br><span class="line">        <span class="comment">//否则i会停在重复的字符，j会更向前，导致前面的情况又换回来，进入死循环</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;s[i]&gt;=s[i+<span class="number">1</span>])<span class="comment">//从右向左找到第一个非降序的，即突然凹下去的那里</span></span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果都是降序的，说明已经是最后一个排列了</span></span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]&gt;=s[j])</span><br><span class="line">            j--;<span class="comment">//从右向左找到第一个比a[i]大的</span></span><br><span class="line">        <span class="comment">//if(j&lt;0)</span></span><br><span class="line">            <span class="comment">//return false;//如果字符串都是相等的就可能一直往前走越界，但这种情况已经被i判断了，不用在j这考虑</span></span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        <span class="comment">//现在后面i+1开始那一段是降序的，反转一下变成升序会更小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n=i+<span class="number">1</span>,m=s.<span class="built_in">size</span>()<span class="number">-1</span>;n&lt;m;n++,m--)</span><br><span class="line">            <span class="built_in">swap</span>(s[n],s[m]);</span><br><span class="line">        <span class="comment">//可以调库reverse(s.begin() + i + 1, s.end());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：4 ms, 在所有 C++ 提交中击败了100.00%的用户</span></span><br><span class="line"><span class="comment">内存消耗：16.9 MB, 在所有 C++ 提交中击败了99.15%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>摩尔投票法，记住两个变量：候选者、投票数。如果没有计数就重置候选者，然后通过比较候选者和当前值看票数要加一还是减一。知道这个方法就很简单了。</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的组总是存在多数元素。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常逻辑版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">            &#123;</span><br><span class="line">                cand = num;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==cand)<span class="comment">//如果有计数说明有候选者，相等则计数++</span></span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//即有计数，也不相等</span></span><br><span class="line">                count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了65.56%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了66.76%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cand;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) <span class="comment">//这是python取数组内容的形式，c++11也支持（加个变量类型即可），也可以for(int i=0;i&lt;nums.size();i++)用nums[i]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!count)<span class="comment">//如果没有计数，则重新开始投票</span></span><br><span class="line">                cand = num;</span><br><span class="line">            count+= num==cand?<span class="number">1</span>:<span class="number">-1</span>;<span class="comment">//无论如果都判断一次，这里把count是不是0的情况都包含了</span></span><br><span class="line">            				<span class="comment">//因为count是0也是count++</span></span><br><span class="line">           	<span class="comment">//这种方式也就是把上面的else if的else去掉了，变成两个独立的if而不是一个大if，会快一些。</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand;<span class="comment">//题目说一定有众数，就直接返回；否则要再检验一遍，因为此时不一定是众数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：8 ms, 在所有 C++ 提交中击败了97.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.2 MB, 在所有 C++ 提交中击败了85.24%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><p>方法是快速排序，使用快排的思想，注释写了很多了，能达到O(n)的时间复杂度</p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br><span class="line"></span><br><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size == k)<span class="comment">//刚好就不用排了</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="built_in">quickSelect</span>(arr,k,<span class="number">0</span>,size<span class="number">-1</span>);<span class="comment">//快速选择：把最小的k个放在最前面</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr[i]);<span class="comment">//前k个都是小的了，拷贝一下</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=l,j=r;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)<span class="comment">//先快排</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[j]&gt;=arr[l])</span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;arr[i]&lt;=arr[l])<span class="comment">//加等号使得相同元素相对位置不改变，稳定排序</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i],arr[l]);</span><br><span class="line">        <span class="comment">//快排要把arr[l]放在两段的中间，就需要保证arr[i]是一个不比arr[l]大的数；</span></span><br><span class="line">        <span class="comment">//因此那两个while必须先从j开始，因为当j停下时，要么是碰到了i（上一轮的i已经是小的了），这时全部结束，i是较小的</span></span><br><span class="line">        <span class="comment">//要么是等待置换，此时轮到i走，要结束只能碰到j，j在等待，是较小的</span></span><br><span class="line">        <span class="comment">//如果while先对i做，可以想到i可能停在上一轮的j处，此时j是大的</span></span><br><span class="line">        <span class="comment">//因此如果用左边界，则要从右开始，置换i；用右边界则从左开始，置换j</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此时快排做完，i和i前的元素都是小的，前i+1个元素都是小的，且前i个元素小于第i+1个元素（i代表第i+1个元素）</span></span><br><span class="line">        <span class="comment">//与快排不相同的是，这里分情况再排，而不是两段直接排</span></span><br><span class="line">        <span class="keyword">if</span>(i==k||i==k<span class="number">-1</span>) <span class="keyword">return</span>;<span class="comment">//i=k或者i+1=k</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;k)  <span class="built_in">quickSelect</span>(arr,k,l,i<span class="number">-1</span>);<span class="comment">//i左边元素有些多，对左边再排，i本身不用排了，不可能是</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">quickSelect</span>(arr,k,i+<span class="number">1</span>,r);<span class="comment">//i&lt;k-1，这里只用排k-i-1个元素了，但为什么参数仍然是k呢？</span></span><br><span class="line">        							<span class="comment">//因为我们是从左边界i+1开始的</span></span><br><span class="line">                                      <span class="comment">//排序只对l-r之间的元素，但位置i仍是整体的，并不是从左边界开始从0算起，因此参数仍是k</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了97.66%的用户</span></span><br><span class="line"><span class="comment">内存消耗：18.5 MB, 在所有 C++ 提交中击败了52.99%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h1><h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><p>动态规划，递推方程是：<code>dp[i] = max(dp[i-1],0)+nums[i];</code>。dp[i]的意思是前i个数的子数组的最大和，则dp[i]是前面的最大值加上nums[i]，其中如果前面的最大值是一个负数就从头开始，就是0+nums[i]。加上nums[i]才使得这样的递推的子数组是连续的，因为dp[i-1]也加上了nums[i-1]，如果大于0，那么使用它的话就是连续的子数组了。</p>
<p>这里面动态规划注意一个要点，如果递推式不利用历史信息的话，只利用前面一项或几项，那就可以用一个或几个变量代替dp数组，能把空间复杂度从O(n)变成O(1)。</p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划普通版本，使用dp数组递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],<span class="number">0</span>)+nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：16 ms, 在所有 C++ 提交中击败了81.76%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.8 MB, 在所有 C++ 提交中击败了27.27%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这里面呢，实际上dp数组在遍历时只用到前面一项，更之前的信息完全不用，实际上就可以简化为两个变量cur和pre，一个代表dp[i]，一个代表dp[i-1]。更进一步，cur和pre只是前一轮和这一轮的关系，用一个变量完全足够了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = pre;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            等价于：</span></span><br><span class="line"><span class="comment">            cur = max(pre,0)+nums[i];</span></span><br><span class="line"><span class="comment">            pre = cur;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            pre = <span class="built_in">max</span>(pre,<span class="number">0</span>)+nums[i];<span class="comment">//其实就是pre = cur = max(pre,0)+nums[i]; cur完全不需要。</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行用时：12 ms, 在所有 C++ 提交中击败了95.96%的用户</span></span><br><span class="line"><span class="comment">内存消耗：22.3 MB, 在所有 C++ 提交中击败了88.01%的用户</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jysama.cn/2022/08/23/%E5%8A%9B%E6%89%A3/" title="刷刷力扣">https://jysama.cn/2022/08/23/力扣/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/10/effectiveC++/" rel="prev" title="effective c++ 记录">
      <i class="fa fa-chevron-left"></i> effective c++ 记录
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjM2Ny8zMjgzMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#day1"><span class="nav-number">1.</span> <span class="nav-text">day1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-number">1.1.</span> <span class="nav-text">数组中重复数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.</span> <span class="nav-text">二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.3.</span> <span class="nav-text">替换空格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day2"><span class="nav-number">2.</span> <span class="nav-text">day2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">用两个栈实现队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day3"><span class="nav-number">3.</span> <span class="nav-text">day3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">3.1.</span> <span class="nav-text">斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="nav-number">3.2.</span> <span class="nav-text">青蛙跳台阶问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">3.3.</span> <span class="nav-text">旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">3.4.</span> <span class="nav-text">矩阵中的路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day4"><span class="nav-number">4.</span> <span class="nav-text">day4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">4.1.</span> <span class="nav-text">I-剪绳子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day5"><span class="nav-number">5.</span> <span class="nav-text">day5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#II-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">5.1.</span> <span class="nav-text">II-剪绳子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">二进制中1的个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day6"><span class="nav-number">6.</span> <span class="nav-text">day6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">6.1.</span> <span class="nav-text">数值的整数次方</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day7"><span class="nav-number">7.</span> <span class="nav-text">day7</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">打印从1到最大的n位数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day8"><span class="nav-number">8.</span> <span class="nav-text">day8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">8.1.</span> <span class="nav-text">删除链表的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">8.2.</span> <span class="nav-text">调整数组顺序使奇数位于偶数前面</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day9"><span class="nav-number">9.</span> <span class="nav-text">day9</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">9.1.</span> <span class="nav-text">链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">9.2.</span> <span class="nav-text">反转链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day10"><span class="nav-number">10.</span> <span class="nav-text">day10</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">10.1.</span> <span class="nav-text">合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">10.2.</span> <span class="nav-text">顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">10.3.</span> <span class="nav-text">包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">10.4.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day11"><span class="nav-number">11.</span> <span class="nav-text">day11</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">11.1.</span> <span class="nav-text">复杂链表的复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day12"><span class="nav-number">12.</span> <span class="nav-text">day12</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">12.1.</span> <span class="nav-text">字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">12.2.</span> <span class="nav-text">数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-number">12.3.</span> <span class="nav-text">最小的k个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#day13"><span class="nav-number">13.</span> <span class="nav-text">day13</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">13.1.</span> <span class="nav-text">连续子数组的最大和</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">247k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:45</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
