<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言因为电子书只有图片扫描版的，因此基本上都只能自己码字。 我尽可能地详细叙述，但更多的是作为总结复习，在总结之上才进行补充。希望学习的朋友还是尽量看看原书。 条款01 视 c++ 为一个语言联邦。  c++ 已经是个多重范型编程语言，是个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。要如何理解这样一个语言呢？ 最简单的方法是将c++视为一个由相关语言组成的联邦而非单一语言">
<meta property="og:type" content="article">
<meta property="og:title" content="effective c++ 记录">
<meta property="og:url" content="https://jysama.cn/2022/08/10/effectiveC++/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="前言因为电子书只有图片扫描版的，因此基本上都只能自己码字。 我尽可能地详细叙述，但更多的是作为总结复习，在总结之上才进行补充。希望学习的朋友还是尽量看看原书。 条款01 视 c++ 为一个语言联邦。  c++ 已经是个多重范型编程语言，是个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。要如何理解这样一个语言呢？ 最简单的方法是将c++视为一个由相关语言组成的联邦而非单一语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-10T01:41:01.499Z">
<meta property="article:modified_time" content="2022-08-11T12:35:28.523Z">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/2022/08/10/effectiveC++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>effective c++ 记录 | JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/08/10/effectiveC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          effective c++ 记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-10 09:41:01" itemprop="dateCreated datePublished" datetime="2022-08-10T09:41:01+08:00">2022-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-11 20:35:28" itemprop="dateModified" datetime="2022-08-11T20:35:28+08:00">2022-08-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为电子书只有图片扫描版的，因此基本上都只能自己码字。</p>
<p>我尽可能地详细叙述，但更多的是作为总结复习，在总结之上才进行补充。希望学习的朋友还是尽量看看原书。</p>
<h1 id="条款01"><a href="#条款01" class="headerlink" title="条款01"></a>条款01</h1><blockquote>
<p>视 c++ 为一个语言联邦。</p>
</blockquote>
<p>c++ 已经是个多重范型编程语言，是个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。要如何理解这样一个语言呢？</p>
<p>最简单的方法是将c++视为一个由相关语言组成的联邦而非单一语言。在其某个次语言种，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而当你从一个次语言移往另一个次语言，守则可能改变。为了理解c++，你必须认识其主要的次语言，总共只有四个：</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<p>比如，</p>
<ul>
<li>对于内置类型（C-like）而言，pass-by-value通常比pass-by-reference更高效。</li>
<li>在Object-Oriented C++，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好，Template C++也是如此。</li>
<li>然而一旦跨入STL，迭代器和函数对象都是在C指针之上塑造出来的，pass-by-value守则再次适用。</li>
</ul>
<hr>
<p>记住：</p>
<blockquote>
<p>c++高效编程守则视状况而变化，取决于你使用c++的哪个部分。</p>
</blockquote>
<h1 id="条款02"><a href="#条款02" class="headerlink" title="条款02"></a>条款02</h1><blockquote>
<p>尽量以const，enum，inline 替换 #define。</p>
</blockquote>
<p>这个条款事实上为“宁可以编译器替换预处理器”，因为或许 #define 不被视为语言的一部分。</p>
<p>当你作出：<code>#define myconst 1.6</code>时，记号名称myconst也许从未被编译器看见，也许在编译器开始处理源码之前它就被处理器移走了。于是记号名称myconst有可能没进入记号表内。于是当你运用此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到1.6而非myconst（在程序里使用myconst，报错为1.6，因为预处理器会将myconst替换为1.6）。如果mycosnt被定义在一个非你所写的头文件内，你肯定对1.6以及它来自于何处毫无概念，于是你将因为追踪它而浪费时间。这个问题也可能出现在记号式调试器，原因仍是：你所使用的名称可能并未进入记号表。</p>
<p>解决之道是使用const：<code>const double myconst = 1.6;</code>作为一个语言常量，myconst肯定会被编译器看到，当然就会进入记号表内。</p>
<p>以常量替换#define时，有两种特殊情况：</p>
<ul>
<li><p>定义常量指针：由于常量定义式通常放在头文件内，因此有必要将指针（而不只是指针所指之物）声明为const。例如若要在头文件内定义一个常量的char*-base字符串，必须写const两次：</p>
<ul>
<li><code>const char* const authorName = &quot;Scott Meyers&quot;;</code></li>
<li>第一个const说明指向常量字符串，第二个const说明指针本身也是常量（不可改）</li>
<li>string对象通常更合宜，定义成这样往往更好：<code>const std::string authorName(&quot;Scott Meyers&quot;);</code></li>
</ul>
</li>
<li><p>class专属常量：#define 并不重视作用域，不能提供任何封装性。为了将常量的作用域限制于class内，必须让它称为class的一个成员。而为确保此常量至多只有一份实体（不允许不同实例使用不同的值初始化该const变量），必须让它称为一个static成员：</p>
<ul>
<li><code>class GP&#123;private: static const int num = 5;&#125;;</code>然而这是num的声明式而非定义式。通常c++要求对使用的任何东西提供一个定义式，但如果它是个class专属常量又是static且为整数类型，则需特殊处理。只要不取它们的地址，可以声明并使用而无须提供定义式。但如果取某个class的专属常量的地址，或编译器坚持要看到定义式，则必须提供定义：</li>
<li><code>const int GP::num; </code>不必提供数值，因为声明式已经提供初值。</li>
<li>因此<strong>个人感觉</strong>更建议的方式是，在类中声明（在头文件中）但不给予初值，在类外定义时（在实现文件种）再给予初值（这样不会忘记定义式），就不会出错。实际上，旧式编译器不支持在声明时给static成员赋初值。</li>
</ul>
</li>
<li><p>针对第二点，如果在class编译期间需要一个class常量值，比如类中还定义了一个数组<code>int scores[num];</code>，这时如果不允许num在声明时赋值，就可以采用”the enum hack”补偿做法，理论基础是：一个属于枚举类型的数值可权充int被使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span>&#123;num = <span class="number">5</span>&#125;;<span class="comment">//令num成为5的一个记号名称</span></span><br><span class="line">    <span class="type">int</span> scores[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>enum hack的行为某方面说比较像#define 而不像const，有时候这正是想要的。例如取const的地址是合法的，而取enum的地址和#define的地址是不合法的。如果不想让别人获得一个指针或引用指向你的某个整数常量，enum可以帮助你实现这个约束。</li>
<li>此外优秀的编译器不会为”整数型const对象“设定另外的存储空间（除非创建指针或引用指向该对象），但不够优秀的编译器可能会创建对象。enum和#define就绝不会导致非必要的内存分配。</li>
</ul>
</li>
</ul>
<p>另一个常见的#define误用情况是以它实现宏（macros）。宏看起来像函数，但不会招致函数调用带来的额外开销，下面这个宏夹带着宏实参，调用函数f：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))<span class="comment">//宏名没有类型，也没有参数类型。</span></span></span><br></pre></td></tr></table></figure>

<p>无论何时当你写出这种宏，必须记住为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加括号是为了处理表达式参数（即宏的参数可能是个算法表达式）时不出错，因为宏替换就是文本替换，所以如果有以下情况：</span><br><span class="line">	#define COM(A,B) (A)*(B)</span><br><span class="line">那么COM(6+5,3)这个调用会怎么替换呢？它会换成这样:</span><br><span class="line">	(6+5)*(3)</span><br><span class="line">显然这是和COM宏的意图一致的，但是如是去掉了定义中括号，即写成这样：</span><br><span class="line">	#define COM(A,B) A*B</span><br><span class="line">那么COM(6+5,3)这个调用会怎么替换呢？它就会换成这样:</span><br><span class="line">	6+5*3</span><br><span class="line">这样显然就和宏的意图不符合了。</span><br></pre></td></tr></table></figure>

<p>纵使加上小括号，也会出现不可思议的事情：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b);<span class="comment">//a被累加两次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a,b+<span class="number">10</span>);<span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>在这里，调用f之前，a的递增次数竟然取决于它和谁比较。因为宏本质是替换，++a把(a)替换了，就导致比较时累加一次，如果++a更大，则传入f的参数是++a，又累加一次。</p>
<p>幸运的是，只要写出template inline函数，就可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了const、enum、inline，我们对预处理器（特别是#define）的需求降低了，但并非完全消除。#include仍然是必需品，而#ifdef&#x2F;#ifndef也继续扮演控制编译的重要角色。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>对于单纯常量，最好以cosnt对象或enum替换#defines；</li>
<li>对于形似函数的宏（macros），最好改用inline函数替换#define。</li>
</ul>
</blockquote>
<h1 id="条款03"><a href="#条款03" class="headerlink" title="条款03"></a>条款03</h1><blockquote>
<p>尽可能使用const。</p>
</blockquote>
<p>const允许你指定一个语义约束，而编译器会强制实施这项约束。它允许你高速编译器和其他程序员某值应该保持不变。只要某值保持不变是事实，你就该说出来，因为这可以获得编译器的帮助。</p>
<p>如果const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在两边，表示二者都是常量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = greeting;<span class="comment">//不是常量指针、不指向常量数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = greeting;<span class="comment">//不是常量指针，指向常量数据</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//常量指针，不指向常量数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">//常量指针、指向常量数据</span></span><br></pre></td></tr></table></figure>

<p>如果被指物（数据）是常量，const可以在类型之前也可以在类型之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> Widget *pw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(Widget <span class="type">const</span> *pw)</span></span>;<span class="comment">//两种写法都一样</span></span><br></pre></td></tr></table></figure>

<p>在STL内，有const_iterator和iterator两种迭代器：</p>
<ul>
<li>const iterator iter;则iter作用像一个T* const，表示iter本身不可改，所指之物可改</li>
<li>const_iterator citer;则citer作用像一个const T*，表示所指之物不可改，本身可改</li>
</ul>
<p>const最具威力的用法是面对函数声明时的应用，可以和函数返回值、参数、函数自身（作为成员函数）产生关联。</p>
<ul>
<li><p>返回值：如const int f1，使得函数返回后的对象为右值，不可赋值，避免拿返回值再做赋值（f1() &#x3D; 5这样的事情）。const可以预防这些没有意义的赋值动作。</p>
</li>
<li><p>参数：即表示传入参数不可改动，除非有需要改动，否则将它们声明为const。这样可以避免“想要输入‘&#x3D;&#x3D;’却输入成‘&#x3D;’”的错误。</p>
</li>
<li><p>自身（const成员函数）：是为了确认该成员函数可以作用于const对象身上。</p>
<ul>
<li>1.它们使得class接口比较容易理解，能够得知哪个函数可以改动对象内容而哪个不行。</li>
<li>2.它们使“操作const对象（常对象）”成为可能，常对象只能调用const成员。</li>
<li>3.两个成员函数如果只是常量性不同（函数后有无const），也可以被重载。常对象调用const成员函数，而非常对象调用non-const成员函数。</li>
<li>附：真实程序中常对象大多用于以passed by pointer-to-const或passed by reference-to-const形式函数传参，如<code>void print(const A&amp; x);</code>一般都用于读取值。</li>
</ul>
<hr>
</li>
</ul>
<p>对于const成员函数，有两个流行的概念：bitwise constness（又称physical constness）和logcial constness。</p>
<ul>
<li>bitwise constness认为成员函数不更改对象内的任何一个bit，它正是c++对常量性的定义，因此const成员函数不可以改变对象内任何non-static成员变量。<ul>
<li>然而，如果一个类成员为non-const的指针（而非其所指之物），那么一个const成员函数可以仅仅返回该指针而不作任何改变（使得编译器通过）。这也就是说，可以通过常对象调用该const成员函数（返回non-const成员），然后在外部获取这个指针，再修改指针所指之物是合法的。</li>
<li>这其中没有任何错误：创建一个常对象并设某值，而且只对它调用const成员函数。但终究改变了它的值。</li>
</ul>
</li>
<li>这种情况导出logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。</li>
</ul>
<p>可以用mutable关键字释放掉non-static成员变量的bitwise constness约束。</p>
<hr>
<p>当const成员函数和non-const成员函数有实质等价的实现时，都去实现这两个函数就会使得代码重复、膨胀、编译时间、维护等问题。此时真正应该作的是实现const成员函数并让non-const成员函数调用它。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">text</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>&amp; <span class="title">func</span><span class="params">(...)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>&amp; <span class="title">func</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> text&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">func</span>(...));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码有两个转型动作：</p>
<ul>
<li>要让func调用func const，而不是调用自己（会造成无穷尽的递归）。因此必须明确指出是func const，所以这里将*this从原始类型text&amp;转型为const text&amp;，再调用func函数，则此时（是常对象）调用的是func const。<ul>
<li>将non-const对象转为const对象强迫进行了一次安全转型（是安全的），所以需要使用static_cast。</li>
</ul>
</li>
<li>使用const_cast将const func从返回值移除const。</li>
</ul>
<hr>
<p>const版本调用non-const版本并不是该作的事，因为const成员函数承诺绝不改变对象的逻辑状态，而non-const成员函数却没有这般承诺。这就是为什么这里能用static_cast作用于*this：这里并不存在const相关危险。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>
</blockquote>
<h1 id="条款04"><a href="#条款04" class="headerlink" title="条款04"></a>条款04</h1><blockquote>
<p>确定对象被使用前已先被初始化</p>
</blockquote>
<p>读取未初始化我值，有时可能让程序终止运行，更可能的情况是读入一些“半随机”bits。最佳的处理办法就是：永远在使用对象之前先将它初始化。对于无任何成员的内置类型，必须手工完成。而内置类型以外的任何其他东西，都交给构造函数来初始化，其规则是：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>这个规则很简单，但重要的是别混淆了赋值和初始化。如果在类中先声明了成员，然后在构造函数的函数体赋值，则本质上这些成员变量执行的是声明-赋值，先调用默认的构造函数，然后执行赋值构造函数（两步，效率低）。更好的写法是用初始化列表替换赋值动作，对大多数类型而言，这样效率更高（一步，直接调用构造函数），有时甚至高效得多。对于内置类型对象，初始化和赋值成本相同，但为了一致性最好也通过初始化列表来初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">A</span>(name):<span class="built_in">Name</span>(name),<span class="built_in">Addr</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//初始化列表：Name调用带参构造函数，Addr调用默认构造函数</span></span><br></pre></td></tr></table></figure>

<p>规定总是在初始化列表中列出所有成员变量。那些无需初值的变量使用一个()即可，以免还得记住哪些成员变量不需要初值。</p>
<p>另外，如果成员变量是const或reference的，它们就必须使用初始化列表。因而很多时候最简单的做法就是总使用初始化列表。</p>
<p>在初始化列表中，成员的初始化次序与初始化列表中的次序无关，真的的次序是成员变量在类中被声明的次序。这导致后声明的变量可以使用先声明的变量来初始化，反之不行。因此，也最好按声明的次序在初始化列表里初始化。</p>
<p>初始化列表除了初始化成员变量，还初始化继承的基类，一般基类总是在最前面。现在，还剩下non-local static对象需要讨论。</p>
<hr>
<p>所谓static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-base对象都被排除。这种对象包括global对象、定义于namespace作用域内的对象、在class内、在函数内、以及在file作用域内被声明为static的对象。函数内的static对象称为local static对象（因为它们对函数而言是local的），其他对象称为non-local static对象。程序结束时static对象自动销毁，也即它们的析构函数会在main()结束时被自动调用。</p>
<p>所谓编译单元，是指产出单一目标文件的那些源码，基本上它是单一源码文件加上其所含入的头文件。</p>
<p>我们关心的问题涉及至少两个源码文件。如果某编译单元内的某个non-local static对象的初始化动作使用了另一个编译单元内的某个non-local static对象，它所用到的这个对象可能尚未被初始化。</p>
<p>下面是一个实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件系统，应是全局的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span><span class="comment">//来自你的程序库</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">numDisks</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;<span class="comment">//预备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户的处理class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span><span class="comment">//来自程序库客户建立</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Directory</span>(params);</span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disk = tfs.<span class="built_in">numDisks</span>();<span class="comment">//使用tfs对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Directory <span class="title">tempDir</span><span class="params">(params)</span></span>;<span class="comment">//创建一个对象</span></span><br></pre></td></tr></table></figure>

<p>现在，除非tfs在tempDir之前被初始化，否则tempDir的构造函数会用到尚未初始化的tfs。但tfs和tempDir是不同的人在不同的时间于不同的源码文件建立起来的，它们是定义于不同编译单元内的non-local static对象，如何能确定tfs先初始化呢？</p>
<p>c++对此是非常困难，根本无解的。</p>
<p>一个小小的设计便可以完全消除这个问题，唯一需要做的是将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所包含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static对象被local static对象替换了。这便是Singleton模式的一个常见实现手法（《Design Patterns》）</p>
<p>这个手法的基础在于：c++保证函数内的local static会在“该函数被调用期间”以及“首次遇上该对象定义式”时被初始化。所以如果你以“函数调用”（返回reference指向local static对象）替换“直接访问non-local static对象”，就获得了保证：保证你所获得的哪个reference将指向一个历经初始化的对象。更棒的是，如果你从未调用non-local static对象的仿真函数，就不会引发构造和析构成本（直接访问需要先创建对象而不管之后会不会用到，这是有成本的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystem</span>&#123;&#125;;<span class="comment">//同前</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FileSystem fs;<span class="comment">//定义并初始化一个local static对象，并返回引用</span></span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span>&#123;&#125;;<span class="comment">//同前</span></span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="type">size_t</span> disk = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();<span class="comment">//改为tfs()</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Directory tempD;</span><br><span class="line">    <span class="keyword">return</span> tempD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们使用函数返回的“指向static对象”的引用，而不再使用static对象自身。</p>
<p>这种结构下的reference-returning函数往往十分单纯：第一行定义并初始化一个local static对象，第二行返回它。</p>
<p>在多线程系统中仍带有不确定性（不论是local或者non-local）。处理的做法是：在程序的单线程启动阶段手工调用所有reference-returning函数，这可消除与初始化有关的race conditions。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>为内置型对象进行手工初始化，因为c++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列（初始化列表），而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</li>
<li>为免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</li>
</ul>
</blockquote>
<h1 id="条款05"><a href="#条款05" class="headerlink" title="条款05"></a>条款05</h1><blockquote>
<p>了解c++默默编写并调用哪些函数</p>
</blockquote>
<p>如果没有声明拷贝构造、赋值构造、析构函数，编译器就会为它自动声明编译器版本的函数。此外如果没有声明任何构造函数，编译器也会自动声明一个默认构造函数。这些函数都是public且inline的。唯有当这些函数被需要（调用），它们才会被编译器创建出来。</p>
<p>「具体参考语法记录博客」</p>
<p>记住：</p>
<blockquote>
<p>编译器可以暗自为class创建默认构造函数、拷贝构造函数、赋值操作符以及析构函数。</p>
</blockquote>
<h1 id="条款06"><a href="#条款06" class="headerlink" title="条款06"></a>条款06</h1><blockquote>
<p>若不想使用编译器自动生成的函数，就该明确拒绝</p>
</blockquote>
<p>所有编译器产出的函数都是public。为阻止这些函数被创建出来，你得自行声明它们，但这里并没有什么需求使你必须将它们声明为public。因此你可以将构造函数、析构函数声明为private。藉由明确声明一个成员函数，你阻止了编译器暗自创建其专属版本；而令这些函数为private，使得你成功阻止人们调用它。</p>
<p>而成员函数和friend函数还是可以调用private函数，因此更进一步的做法是，在private声明而不去定义，这样即使调用，也会得到错误。</p>
<p>一般的做法是，将阻止构造的动作设计在基类，然后继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Uncopyable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="type">const</span> Uncopyable&amp;);<span class="comment">//声明，没有函数体，且无参数名称（无意义）</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">anyclass</span>:<span class="keyword">private</span> Uncopyable<span class="comment">//不一定要public继承，个人理解为都可以，因为没有其他数据</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，anyclass的拷贝构造和赋值构造都不会自动生成，因为基类已经声明了。</p>
<p>记住：</p>
<blockquote>
<p>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</p>
<p>附：在c++11以后，可以用delete修饰函数，这是一种更好的方法。</p>
</blockquote>
<h1 id="条款07"><a href="#条款07" class="headerlink" title="条款07"></a>条款07</h1><blockquote>
<p>为多态基类声明virtual析构函数。</p>
</blockquote>
<p>当一个基类指针指向一个派生类对象，而基类实现中析构函数是non-virtual的，则此时若进行销毁（delete），实际上只会调用基类的析构函数而不会调用派生类的析构函数（因为编译器发现这是基类指针），导致内存释放不完全，因为派生类对象的成员仍然存活，只有基类成员被消除。</p>
<p>消除这个问题的做法是：给基类一个virtual析构函数。这明确告诉编译器这个类是多态的，要销毁对象时要在运行期根据所指对象来调用析构函数（通过虚表）。</p>
<ul>
<li>任何class只要带有virtual函数，都几乎确定应该也有一个virtual析构函数；</li>
<li>如果class不含virtual函数，通常表明它并不意图被用作一个基类。</li>
<li>当class不企图被当作基类时，往往没有virtual函数，因为一旦有virtual函数，就需要一个虚函数指针指向虚表，这是额外的开销。</li>
<li>抽象类总是希望当作基类，因此往往析构函数写为（纯虚函数）：<code>virtual ~A() = 0;</code>除此之外，必须为纯虚的析构函数提供一份定义：<code>A::A()&#123;&#125;</code>。因为在析构时，编译器往往从最深层的析构函数开始调用，逐步调用每一个基类的析构函数，如果该析构函数没有定义，就会出错。</li>
</ul>
<p>不是所有的基类都是为了多态用途。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li>classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不应该声明virtual析构函数。</li>
<li>纯虚的析构函数必须给出定义。</li>
</ul>
</blockquote>
<h1 id="条款08"><a href="#条款08" class="headerlink" title="条款08"></a>条款08</h1><blockquote>
<p>别让异常逃离析构函数。</p>
</blockquote>
<p>不要在析构函数中抛出异常，原因是C++异常机制不能同时处理两个或两个以上的异常。多个异常同时存在的情况下，程序若不结束，会导致不明确行为。如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Widget</span>()&#123;...&#125;    <span class="comment">//假设这个可能吐出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Widget&gt; v;</span><br><span class="line">&#125;                    <span class="comment">//v在这里被自动销毁</span></span><br></pre></td></tr></table></figure>

<p>函数dosomething运行结束后，最为栈对象的vector v将被销毁，它同时也有责任销毁其内含的所有Widgets。假设v内含十个Widgets，而在析构第一个元素期间，有个异常被抛出。其他九个widgets还是应该被销毁（否则他们保存的任何资源都会发生泄漏），因此v应该调用它们各个析构函数。但假设在那些调用期间，第二个widget析构函数又抛出异常，C++无法同时处理两个或多个异常，多个异常同时存在的情况下，程序若不结束，会导致不明确行为。</p>
<p>如果析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？举个例子，假设你使用一个class负责数据库连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConnection</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　 ...</span><br><span class="line">　　 <span class="function"><span class="type">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>; <span class="comment">//返回DBConnection对象；为求简化暂略参数</span></span><br><span class="line">　　 <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">//关闭联机；失败则抛出异常。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为确保客户不忘记在DBConnection对象身上调用close()，一个合理的想法是创建一个用来管理DBConection资源的class，并在其析构函数中调用close。这就是著名的以对象管理资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123; <span class="comment">//这个class用来管理DBConnection对象 </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">　　 ...</span><br><span class="line">　　<span class="built_in">DBConn</span>(<span class="type">const</span> DBConnection&amp; db)&#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;db=db;</span><br><span class="line">   &#125;</span><br><span class="line">　 ~<span class="built_in">DBConn</span>() <span class="comment">//确保数据库连接总是会被关闭</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　    db.<span class="built_in">close</span>();</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">　　 DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用close成功，一切都美好。但如果该调用导致异常，DBConn析构函数会传播该异常，也就是允许它离开这个析构函数。那会造成问题，解决办法如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：结束程序</span></span><br><span class="line">DBConn::~<span class="built_in">DBconn</span>()&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...)&#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败</span></span><br><span class="line">        std::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强制结束程序”是个合理选项，毕竟它可以阻止异常从析构函数传播出去（那会导致不明确的行为）。也就是说调用abort可以抢先制“不明确行为”于死地。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二：吞下异常</span></span><br><span class="line">DBConn::~DBConn&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息。然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。为了让这成为一个可行方案，程序必须能够继续可靠的执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三：重新设计DBConn接口，使其客户有机会对可能出现的异常作出反应 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DBConn</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">//供客户使用的新函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        db.<span class="built_in">close</span>();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">DBConn</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;       <span class="comment">//关闭连接(如果客户不调用DBConn::close)</span></span><br><span class="line">                  db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span>(...) &#123; <span class="comment">//如果关闭动作失败，记录下来并结束程序或吞下异常。</span></span><br><span class="line">                制作运转记录，记下对close的调用失败；<span class="comment">//然后吞下异常或结束程序</span></span><br><span class="line">                ...</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="type">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 我们可以给DBConn添加一个close函数，赋予客户一个机会可以处理“因该操作而发生的异常”。把调用close的责任从DBConn析构函数手上移到DBConn客户手中，你也许会认为它违反了“让接口容易被正确使用”的忠告。</p>
<p>实际上这污名并不成立。如果某个操作可能在失败的时候抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。</p>
<p>由客户自己调用close并不会对他们带来负担，而是给他们一个处理错误的机会。如果他们不认为这个机会有用（或许他们坚信不会有错误发生），可能忽略它，依赖DBConn析构函数去调用close。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li>
</ul>
</blockquote>
<h1 id="条款09"><a href="#条款09" class="headerlink" title="条款09"></a>条款09</h1><blockquote>
<p>绝不在构造和析构过程中调用virtual函数</p>
</blockquote>
<p>之所以不要在构造函数和析构函数起点调用virtual函数，是因为这种调用并不会带来预期的结果。</p>
<p>举个例子，假设有这样一个class继承体系，用来模拟股市的买进、卖出的订单等。在这样的过程中，一定要经过审计，因此每当创建一个交易对象时，在审计日志（audit log）中也需要创建一笔适当的记录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;         <span class="comment">//所有交易的base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">//做出一份因为类型不同而不同的日志记录，目前是一个纯虚函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>()  <span class="comment">//base class的构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>();    <span class="comment">//最后的动作是对这笔交易进行记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;    <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//对这种类型的交易进行记录（log）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTransaction</span>: <span class="keyword">public</span> Transaction &#123;   <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//对这种类型的交易进行记录（log）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们执行如下语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p>无疑会有一个BuyTransaction构造函数被调用，但是，首先Transaction构造函数一定会更早的被调用。因为derived class对象内的base class成分会在derived class自身成分被构造之前先完成构造。</p>
<p>然而，Transaction构造函数中的virtual函数logTransaction却会引发问题。因为此时所调用的logTransaction是Transaction内的版本，而不是BuyTransaction内的版本——即使目前即将创建的对象是BuyTransaction。也就是说：base class构造期间，virtual函数绝不会下降到derived classes阶层。换种非正式的说法：在base class构造期间，virtual函数不是virtual函数。</p>
<ul>
<li>这是因为在base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived class阶层，要知道derived class的函数几乎必然取用local成员变量，而那些成员变量尚未初始化</li>
<li>更根本的原因在于：在derived class对象的base class构造期间，对象的类型是base class而不是derived class。不止virtual函数会被编译器解析至（resolve to）base class，若使用运行期间类型信息，也会把对象视为base class。</li>
</ul>
<p>在上面的例子中，当Transaction构造函数正在执行起来，打算初始化“BuyTransaction对象内的base class成分”时，该对象的类型是Transaction。而这个对象内的“BuyTransaction专属成分”尚未被初始化。因此在面对它们时，最安全的做法就是视它们不存在。对象在derived class构造函数开始执行之前不会成为一个derived class对象。</p>
<p>相同的道理同样适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现出未定义值。因此，C++将其视为仿佛不存在。进入base class析构函数后对象就变成了一个base class对象。</p>
<hr>
<p>因此，在上面的例子中，Transaction构造函数直接调用一个virtual函数，这很明显就违反了该条款的内容。这就导致了一个问题：因为logTransaction函数在Transaction内是一个pure virtual（纯虚函数）。除非它被定义了，否则程序无法连接，因为连接器找不到必要的Transaction::logTransaction实现代码。</p>
<p>但是，侦测“构造函数或析构函数运行期间是否调用virtual函数”并不简单。一般来说，如果Transaction有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复的一个优秀做法就是将共同的初始化代码（包括对logTransaction的调用）都放到一个初始化函数如init内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Transaction</span>()    <span class="comment">//调用non-virtual（init()是non-virtual）</span></span><br><span class="line">    &#123;  <span class="built_in">init</span>();  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">logTransaction</span>();    <span class="comment">//调用了virtual！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码，和早期的版本是一样的，但是却有更深层次的危害，因为这样并不会引起编译器和连接器的报错。此时，由于logTransaction是Transaction的一个pure virtual函数，当pure virtual函数被调用是，大多执行系统会终止程序。然而，如果logTransaction是个正常的virtual（即impure）函数，并在Transaction内带有一份代码，该版本就会被调用，程序也会继续往下进行，只会造成创建一个derived class对象时会调用错误版本的logTransaction（而不报任何信息）。</p>
<p>唯一能避免这一问题的解决办法为：保证构造函数和析构函数都没有（在对象被创建和销毁期间）调用virtual函数，而他们调用的所有函数也都服从同一约束。</p>
<p>但是，又如何确保每一次都有Transaction继承体系上的对象被创建，就会有适当版本的logTransaction被调用？一种办法是在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要的信息给Transaction构造函数，而后那个构造函数边可以安全的调用non-virtual logTransaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transaction</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="type">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">logTransaction</span><span class="params">(<span class="type">const</span> std:;string&amp; logInfo)</span> <span class="type">const</span></span>;<span class="comment">//此时，是一个non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="type">const</span> std::string&amp; logInfo)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">logTransaction</span>(logInfo);    <span class="comment">//此时，是一个non-virtual调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTransaction</span>: <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">BuyTransaction</span>( parameters )</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">createLogString</span>( parameters )) <span class="comment">//将log信息传递给base class构造函数</span></span><br><span class="line">        &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> std::string <span class="title">createLogString</span><span class="params">( parameters )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>换句话说，由于无法使用virtual函数从base class向下调用，在构造期间，可以由“令derived classes将必要的构造信息向上传递至base class构造函数”替换并加以弥补。</p>
<p>记住：</p>
<blockquote>
<p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。</p>
</blockquote>
<h1 id="条款10"><a href="#条款10" class="headerlink" title="条款10"></a>条款10</h1><blockquote>
<p>令 operator&#x3D; 返回一个reference to *this。</p>
</blockquote>
<ul>
<li>赋值采用<code>右结合律</code>。</li>
<li>趣的一点，是你可以把它写出<code>连锁赋值</code>的形式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br><span class="line"><span class="comment">//它相当于x=（y=（z=15））；</span></span><br></pre></td></tr></table></figure>

<p>为了实现这种连锁赋值，赋值操作符<code>必须返回一个reference指向操作符的左侧实参</code>。这也是实现class重载赋值操作符应该遵循的协议。这种协议不仅适用于标准赋值，也<code>适用于所有赋值相关的运算</code>（+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，&lt;&lt;&#x3D;,…）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Widget&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然这只是协议，并无强制性，不遵循，代码一样可以通过编译。然而这份协议被所有内置类型和标准库提供的类型，如string，vector，complex，trl1::shared_ptr或即将提供的类型<code>共同遵守</code>，除非你有一个标新立异的好理由，不然还是遵守吧。</p>
<p>记住：</p>
<blockquote>
<p>令赋值操作符返回一个reference to *this。</p>
</blockquote>
<h1 id="条款11"><a href="#条款11" class="headerlink" title="条款11"></a>条款11</h1><blockquote>
<p>在 operator&#x3D; 中处理“自我赋值”。</p>
</blockquote>
<p>“自我赋值”发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;          <span class="comment">//赋值给自己</span></span><br></pre></td></tr></table></figure>

<p>虽然这种做法看起来比较傻，但是这种操作却是合法的，所以绝不要认定客户不会这么做。</p>
<p>此外，自我赋值并不是总是可以一眼分辨出来，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];        <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>如果i和j具有相同的值时，这就是一个自我赋值。再比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*px = *py;          <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>如果指针px和py恰巧指向同一个东西，这也是一个自我赋值。</p>
<p>这些并不明显的复制行为，是“别名（aliasing）”所带来的结果。所谓“别名”：就是有一个以上的方法指称（指涉）某对象。</p>
<p>一般而言，如果某段代码操作pointers或references，而它们被从来“指向多个相同类型的对象”，就需要去考虑这些对象是否为同一个对象。实际上，两个对象只要来自同一个继承体系，它们甚至不需要声明为相同类型就可能会造成“别名”，因为一个base class的reference或者pointer可以指向一个derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomethings</span><span class="params">(<span class="type">const</span> Base&amp; rb, Derived* pd)</span></span>;   <span class="comment">//rd和*pd有可能其实是同一个对象</span></span><br></pre></td></tr></table></figure>

<p>在这里，假如说我们尝试自行管理资源（即打算写一个用于资源管理的class，就需要这样做），就可能会掉进“在停止使用资源之前意外释放了它”的陷阱。举个例子，假如建立一个class用来保存一个指针指向一块动态分配的位图（bitmap）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bitmap</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;     <span class="comment">//指针，指向一个从heap分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是operator&#x3D; 的实现代码，看起来虽然合理，但是在进行自我赋值时并不安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)    <span class="comment">//不安全的operator= 的实现版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;     <span class="comment">//停止使用当前的bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);       <span class="comment">//使用rhs&#x27;s bitmap的副本（复件）</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以会出现自我赋值的问题，是因为operator&#x3D; 函数内的*this（赋值的目的端）和rhs有可能是同一个对象。如果它们是同一个对象，那么delete对象就不只是销毁当前对象的bitmap，它也同时销毁了rhs的bitmap。在函数末尾，Widget发现自己持有一个指针指向一个已被删除的对象。</p>
<p>想要阻止这样的错误，传统的做法是在operator&#x3D; 最前面进行一个“证同测试（identity test）”，以此达到自我赋值的检验目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)        <span class="comment">//证同测试（identity test）</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">//如果是自我赋值，就不做任何事情</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解决办法是行得通的。在第一个版本的operator&#x3D; 中，不仅不具备“自我赋值安全性”，也不具备“异常安全性”，然而，这个新版本的operator&#x3D;，仍然存在异常方面的问题：如果“new BItmap”导致了异常（比如因为分配时内存不足或者因为Bitmap的copy构造函数抛出异常），Widget最终会持有一个指针指向一个被删除的Bitmap。(如果具备异常安全，在new发生之前不delete原来的对象，以防new异常后不能恢复。)</p>
<p>这样的指针是有害的：既不能安全的删除它，也不能安全的读取它。唯一能对它们做的安全的事情就是付出很多调试的功夫，去找到错误的起源。</p>
<hr>
<p>当我们让operator&#x3D; 具备“异常安全性”时，往往会自动获得“自我赋值安全性”的特性。因此，很多时候，并不专门去解决“自我赋值”的问题，而是将注意力放在“异常安全性（exception safety）”之上。例如对于下面，只需要注意在赋值pb所指的东西之前不要删除pb即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap* pOrig = pb;     <span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> <span class="built_in">Bitmap</span>(*rhs.pb);    <span class="comment">//令pb指向*pb的一个副本（复件）</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;     <span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，如果“new Bitmap”抛出异常，pb（及其栖身的那个Widget）也会保持原状。即使没有证同测试，这段代码也是能够处理自我赋值问题，因为我们对原bitmap做了一份复件、删除原bitmap、然后指向新制造的那个复件。</p>
<p>当然，如果我们想要提高效率，也可以将证同测试重新放到函数的起始处。然而这样做之前先问问自己，你估计“自我赋值”的发生频率有多高？因为这项测试也需要成本。它会使代码变大一些（包括原始码和目标码）并导入一个新的控制流分支，而两者都会降低执行速度。</p>
<hr>
<p>一个替代方案是，使用copy and swap技术。我在惯用法中更详细地说明了这项技术，事实上，内容基本包含了这一章节的内容。下面是简单的介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swqp</span><span class="params">(Widget&amp; rhs)</span></span>;   <span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);      <span class="comment">//为rhs数据制作一份复件</span></span><br><span class="line">    <span class="built_in">swap</span>(temp);            <span class="comment">//将*this数据和上述的复件进行数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更为高效简洁的写法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个写法更快的原因是参数通过值传递，抵消了创建temp的过程。</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)   <span class="comment">//rhs直接就是被传对象的一份复件，此时是pass by value</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);           <span class="comment">//将*this数据和上述的复件进行数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法之所以可以，是因为：</p>
<ul>
<li>某class的copy assignment操作符可能被声明为“以by value方法接受实参”</li>
<li>以by value方法传递东西会形成一份复件。</li>
</ul>
<p>这种方法牺牲了代码的清晰性，但是却将“copy动作”从函数本体内移至“函数参数构造阶段”，使得编译器生成了更有效的代码。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>确保当对象自我赋值时 operator&#x3D; 有良好行为。其中技术包括比较“来源对象”和“”目标对象“的地址、精心周到的语句顺序、以及copy-and-swap。</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li>
</ul>
</blockquote>
<h1 id="条款12"><a href="#条款12" class="headerlink" title="条款12"></a>条款12</h1><blockquote>
<p>复制对象时勿忘其每一个部分。</p>
</blockquote>
<p>设计良好的面向对象的系统，会将对象的内部封装起来，只留下两个函数来负责对象的拷贝（复制）：</p>
<ul>
<li>copy构造函数</li>
<li>copy assignment操作符</li>
</ul>
<p>我们将它们一起成为copying函数。</p>
<p>假如我们要声明自己的copying函数，即告诉编译器自己不会去使用缺省实现的某些行为，那么此时编译器会在代码几乎必然出错的情况下，却不去告诉你。</p>
<p>举个例子，考虑一个class，用来表示顾客，其中人为地书写copying函数（而非由编译器去创建），使得外界对它们的调用都会记录下来（logged）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logCall</span><span class="params">(<span class="type">const</span> std::string&amp; funcName)</span></span>;  <span class="comment">//制作一个log entry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs);     <span class="comment">//copy构造函数</span></span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs);    <span class="comment">//copy assignment操作符</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Customer::<span class="built_in">Customer</span>(<span class="type">const</span> Customer&amp; rhs) : <span class="built_in">name</span>(rhs.name)  <span class="comment">//复制rhs的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="type">const</span> Customer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;Customer copy assignment operator);</span></span><br><span class="line"><span class="string">    name = rhs.name;     //复制rhs的数据</span></span><br><span class="line"><span class="string">    return *this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然上面的代码看起来并没有什么问题，但是当另一个变量加入到其中时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123; ... &#125;;     <span class="comment">//日期</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:         <span class="comment">//定义与前面相同</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    Date lastTransaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，既有的copying函数执行的是局部拷贝（partial copy）：它们只复制了顾客的name，而没有复制新添加的lastTransaction。</p>
<p>这明显是个错误，但是编译器却并不会报错（即使在最高级别的警告中）。因此，如果我们为class添加一个新的成员变量时，就必须同时修改copying函数。（同时也需要修改class的所有构造函数以及任何非标准形式的operator&#x3D;）。</p>
<hr>
<p>另外，一旦发生继承，则会造成一个更严重的危机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityCustomer</span>: <span class="keyword">public</span> Customer &#123;   <span class="comment">//定义Derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs);    <span class="comment">//</span></span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">priority</span>(rhs.priority)     <span class="comment">//复制rhs的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy constructor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，PriorityCustomer的copying函数看起来好像是复制了PriorityCustomer内的每一样东西，但是实际上，它们只是复制了PriorityCustomer声明的成员变量，但是每个PriorityCustomer还内含了它所继承的Customer成员变量复件，而那些成员变量并没有被复制。即：Derived class没有连同base class中的字段一起复制。</p>
<p>PriorityCustomer的copy构造函数并没有指定实参传给其base class构造函数。（也即说它在它的成员初值列（member initialization list）中没有提到Customer）。</p>
<p>因此，PriorityCustomer对象的Customer成分会被不带有Customer构造函数（即default构造函数）初始化。default构造函数将会针对name和lastTransaction执行缺省的初始化动作。对于PriorityCustomer，它不曾企图修改其base class的成员变量，因此那些成员变量保持不变。</p>
<hr>
<p>任何时候只要你为派生类实现copying函数，必须很小心地也复制基类成分，那些成分往往是private，所以无法直接访问，应该让派生类的copying函数调用相应的基类函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityCustomer&amp; PriorityCustomer::<span class="keyword">operator</span>=(<span class="type">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">logCall</span>(<span class="string">&quot;PriorityCustomer copy assignment operator&quot;</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);<span class="comment">//对base class成分进行赋值动作</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你编写一个copying函数时，请确保：</p>
<ul>
<li>复制所有local成员变量；</li>
<li>调用所有基类内的适当的copying函数。</li>
</ul>
<hr>
<p>copying函数往往有近似相同的实现，但需要记住的是：令某个copying函数调用另一个copying函数无法达到目标，应把相同的实现放入第三个函数中由两个copying函数调用（通常命名为init，且为private）。</p>
<p>原因是，拷贝构造函数是针对未初始化的对象的操作，而赋值操作符只能施行于已初始化对象身上。当对象已初始化时，使用赋值操作符调用”只能作用于未初始化对象“的拷贝构造函数是没有意义的；同样，对象未初始化时，使用拷贝构造函数调用”只能施行于已初始化对象“的赋值操作符也是没有意义的；乃至于根本没有相关语法。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>copying函数应确保复制”对象内的所有成员变量“及”所有base class 成分“；</li>
<li>不要尝试以某个copying函数实现另一个copying函数。应将共同技能放进第三个函数中，并由两个copying函数共同调用。</li>
</ul>
</blockquote>
<h1 id="条款13"><a href="#条款13" class="headerlink" title="条款13"></a>条款13</h1><blockquote>
<p>以对象管理资源</p>
</blockquote>
<p>假设我们使用一个用来塑模投资行为（例如股票、债券等）的程序库，各种各样的投资类型继承自root class Investment。进一步假设这个库使用了通过一个 factory 函数为我们提供特定 Investment 对象的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123; ... &#125;; <span class="comment">// “投资类型”继承体系中的root class</span></span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">/*返回指向Investment继承体系内的动态分配对象的指针。调用者有责任删除它。这里为了简化，刻意不写参数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当 createInvestment 函数返回的对象不再使用时，由调用者负责删除它。下面的函数 f 来履行以下职责：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Investment *pInv = <span class="built_in">createInvestment</span>(); <span class="comment">// 调用factory对象</span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">delete</span> pInv; <span class="comment">// 释放pInv所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下几种情形会造成 f 可能无法删除它得自 createInvestment 的投资对象：</p>
<ul>
<li>“…” 部分的某处有一个提前出现的 return 语句，控制流就无法到达 delete 语句；</li>
<li>对 createInvestment 的使用和删除在一个循环里，而这个循环以一个 continue 或 goto 语句提前退出；</li>
<li>“…” 中的一些语句可能抛出一个异常，控制流不会再到达那个 delete。</li>
</ul>
<p>单纯依赖“f总是会执行其delete语句”是行不通的，因为代码可能会在时间渐渐过去后被其他人修改、维护。</p>
<p>为了确保 createInvestment 返回的资源总能被释放，我们需要将资源放入对象中，当控制流离开f，这个对象的析构函数会自动释放那些资源。将资源放到对象内部，我们可以依赖 C++ 的“析构函数自动调用机制”确保资源被释放。</p>
<p>许多资源都是动态分配到堆上的，并在单一区块或函数内使用，且应该在控制流离开那个块或函数的时候释放。标准库的 auto_ptr 正是为这种情形而设计的。auto_ptr 是一个类似指针的对象（智能指针），它的析构函数自动对其所指对象调用 delete。下面就是如何使用 auto_ptr 来预防 f 的潜在的资源泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// 调用工厂函数</span></span><br><span class="line">... <span class="comment">// 一如以往地使用pInv</span></span><br><span class="line">&#125; <span class="comment">// 经由auto_ptr的析构函数自动删除pInv</span></span><br></pre></td></tr></table></figure>

<p>这个简单的例子示范了“以对象管理资源”的两个关键想法：</p>
<ul>
<li>获得资源后应该立即放进管理对象内。</li>
<li>管理对象使用它们的析构函数确保资源被释放。</li>
</ul>
<p>auto_ptr 和 tr1::shared_ptr 都在它们的析构函数中使用 delete，而不是 delete []。这就意味着将 auto_ptr 或 tr1::shared_ptr 用于动态分配的数组是个馊主意。C++ 中没有可用于动态分配数组的类似 auto_ptr 或 tr1::shared_ptr 这样的东西，甚至在 TR1 中也没有。那是因为 vector 和 string 几乎总是能代替动态分配数组。</p>
<p>如果你手动释放资源（例如，使用 delete，而不使用资源管理类），你就是在自找麻烦。像 auto_ptr 和 tr1::shared_ptr 这样的预制的资源管理类通常会使本条款的建议变得容易，但有时你所使用的资源是目前这些预制的类无法妥善管理的，你就需要精心打造自己的资源管理类。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li>
<li>两个常被使用的RAII classes 分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择 ，因为其copy行为比较直观。若选择auto_ptr，复制动作会使被复制物指向null。</li>
</ul>
</blockquote>
<h1 id="条款14"><a href="#条款14" class="headerlink" title="条款14"></a>条款14</h1><blockquote>
<p>在资源管理类中小心copying行为。</p>
</blockquote>
<p>如果一个RAII对象被复制，会发生什么？</p>
<p>在上一个条款之中，提到了“资源获得的时机就是初始化时机”（Resource Acquisition Is Initialization（RAII）），并且说明了auto_ptr和tr1::shared_ptr如何在heap-based的资源上作用的。但是，并不是所有的资源都是“heap-based”的，对于这种资源，上述的这两种指类指针对象就不再适合作为资源管理者了。于是，我们需要建立自己的资源管理类，</p>
<p>举个例子，加入使用C API函数处理类型为Mutex的互斥器对象（mutex objects），共有lock和unlock两个函数可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm)</span></span><br><span class="line"><span class="function">    &#123;</span> <span class="built_in">lock</span>(mutexPtr); &#125;   <span class="comment">//获得资源</span></span><br><span class="line">    ~<span class="built_in">Lock</span>() ( <span class="built_in">unlock</span>(mutexPtr); )   <span class="comment">//释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用Lock时，符合RAII的标准：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;        <span class="comment">//定义所需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;               <span class="comment">//建立一个区块用来定义critical section</span></span><br><span class="line"><span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>;    <span class="comment">//锁定互斥器</span></span><br><span class="line">    ...         <span class="comment">//执行critical section内的操作</span></span><br><span class="line">&#125;               <span class="comment">//在区块结尾处，会自动解除互斥器的锁定</span></span><br></pre></td></tr></table></figure>

<p>这样的操作的是没有问题，但是如果此时Lock对象被复制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;       <span class="comment">//锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(m1l)</span></span>;      <span class="comment">//将ml1复制到ml2之上</span></span><br></pre></td></tr></table></figure>

<p>这个时候，对于这种情况，一般有两种选择：</p>
<ul>
<li>禁止复制。因为许多时候，允许RAII被复制并不合理。如果复制动作对于RAII对象不够合理，就应该禁止。实现这种禁止，即用到了条款6中所说的办法：将copying操作声明为private。</li>
<li>对底层资源使用“引用计数法”。有的时候，我们希望保持着资源，直到它的最后一个使用者（某个对象）被销毁。在这种情况下，复制RAII对象时，应该将资源的“被引用数”进行递增。tr1::shared_ptr就是如此。</li>
</ul>
<hr>
<p>通常只要内含一个tr1::shared_ptr成员变量，RAII classes就可以实现reference-counting copying行为（使用默认的拷贝构造函数即可，因为这时会对成员变量调用其拷贝构造）。假如前面的Lock想要使用reference counting，它可以直接去改变mutexPtr的类型即可：将其从Mutex*改为tr1::shared_ptr&lt; Mutex &gt;。</p>
<p>但是，需要注意的是，tr1::shared_ptr的默认行为为：当引用次数为0时，删除其所指物。删除操作并不是我们想要的，当我们使用一个Mutex，我们要做的释放动作是解除锁定而并非删除。</p>
<p>因此，tr1::shared_ptr是允许定义所谓的“删除器（deleter）”的，这是一个函数或者函数对象（function object），当引用的次数为0时被调用（这个功能并不存在与auto_ptr中，它总是将其指针删除）。这个删除器对于tr1::shared_ptr是第二个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">explict <span class="title">Lock</span><span class="params">(Mutex* pm)</span>   <span class="comment">//以某个Mutex初始化shared_ptr</span></span></span><br><span class="line"><span class="function">      : mutexPtr(pm, unlock)  //并且unlock函数作为删除器</span></span><br><span class="line"><span class="function">      &#123;</span></span><br><span class="line">          <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());   </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//注意！没有析构函数！</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;   <span class="comment">//使用shared_ptr代替raw pointer   </span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>在条款5中说过，无论是编译器自动生成的、还是用户自定义的，class 析构函数都会自动调用其non-static成员变量（在这里是mutexPtr）的析构函数，使计数器减1。而mutexPtr的析构函数会在互斥器的引用计数为0时自动调用tr1::shared_ptr的删除器（在这里是unlock）。也就是说，之所以没有声明析构函数，完全只是依赖了编译器生成的缺省行为。</p>
<p>总之，对RAII对象的复制基本就两种情况：</p>
<ul>
<li>复制底部资源。可以是多个对象指向一份资源（引用计数）；也可以深度拷贝，对这个资源多生成一份副本（从内存来看是不同的）。</li>
<li>转移底部资源的拥有权。确保永远只有一个RAII对象指向一个原始资源。</li>
</ul>
<p>记住：</p>
<blockquote>
<ul>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying 行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。</li>
</ul>
</blockquote>
<h1 id="条款15"><a href="#条款15" class="headerlink" title="条款15"></a>条款15</h1><blockquote>
<p>在资源管理类中提供对原始资源的访问。</p>
</blockquote>
<p>所谓资源管理类（resource-managing classes），可以有效的帮助我们去预防资源泄漏。但是，虽然在理想的情况下，我们希望所有的资源与对象之间的互动都依赖于这样的资源管理类，仍有许多的API会直接去涉及原始资源（raw resource）。</p>
<p>举个例子，在前面的条款13中，我们可以得知：使用智能指针auto_ptr或者tr1::shared_ptr来保存factory函数例如createInvestment的调用结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;<span class="comment">//pInv本身是shared_ptr，内部的成员指针才是Investment的</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望用某个函数来处理Investment对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dayHeld</span><span class="params">(<span class="type">const</span> Investment* pi)</span></span>;      <span class="comment">//返回投资的天数</span></span><br></pre></td></tr></table></figure>

<p>此时，如果我们想要这样去调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv);      <span class="comment">//错误！！</span></span><br></pre></td></tr></table></figure>

<p>这样做是错误的，因为daysHeld需要的是Investment的指针，而并非此时传递给它的类型为tr1::shared_ptr的对象。</p>
<p>因此，此时需要一个函数，可以将RAII class对象转换为其所内含的原始资源（即tr1::shared_ptr -&gt; Investment*）<br>有两种方法可以实现这样的功能：</p>
<ul>
<li><p>显式转换：tr1::shared_ptr和auto_ptr都提供了一个get成员函数，用来执行显式转换。也就是说，可以返回智能指针内部的原始资源（的复件）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days = <span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>());    <span class="comment">//成功的将pInv内的原始指针传给了daysHeld</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式转换：就像几乎所有的智能指针一样，这些对类指针对象都重载了指针取值（pointer dereferencing）操作符（operator -&gt;和operator *），它们允许隐式转换至底部的原始指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Investment</span> &#123;    <span class="comment">//investment继承体系的根类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isTaxFree</span> <span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;     <span class="comment">//factory函数</span></span><br><span class="line"></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pi1</span><span class="params">(createInvestment())</span></span>; <span class="comment">//令tr1::shared_ptr管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable1 = !(pi1-&gt;<span class="built_in">isTaxFree</span>());  <span class="comment">//经由operator-&gt;访问资源</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">std::auto_ptr&lt;Investment&gt; <span class="title">pi2</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//令auto_ptr管理一笔资源</span></span><br><span class="line"><span class="type">bool</span> taxable2 = !((*pi2).<span class="built_in">isTaxFree</span>());   <span class="comment">//经由operator*访问资源</span></span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<p>因为有时需要必须取得RAII内部的原始资源，一般的做法是提供一个隐式转换函数（operator A()，A的目标类型）。举个例子，对于用于字体的RAII class（对于C API而言，字体是一种原始数据结构、即原始资源）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;       <span class="comment">//这是一个C API</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;    <span class="comment">//来自同一组的C API</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;    <span class="comment">//RAII class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span> : f(fh)   //获得资源，采用pass-by-value的方法</span></span><br><span class="line"><span class="function">    &#123;</span> &#125;</span><br><span class="line">    ~<span class="built_in">Font</span>() &#123; <span class="built_in">releaseFont</span>(f); &#125;    <span class="comment">//释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;     <span class="comment">//原始（raw）字体资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有大量与字体相关的C API，它们处理的都是FontHandle，那么“将Font对象转换为FontHandle”将会是一件非常繁琐的事情。因此，Font class可以提供一个显式的转换函数，就像上面的get一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;    <span class="comment">//显式转换函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//然而，每次用户想要使用API时，都必须要调用get：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="type">int</span> newFontSize)</span></span>; <span class="comment">//C API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f.<span class="built_in">get</span>(), newFontSize);   <span class="comment">//明确地将Font转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>另外一种办法则是令Font提供隐式转换函数，转换的类型FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Font</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="type">const</span>   <span class="comment">//隐式转换函数</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样，在调用C API时，就非常的方便了：</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="type">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">changeFontSize</span>(f, newFontSize);   <span class="comment">//将Font隐式地转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>但是，这种隐式转换却会增加错误的发生机会。例如，当我们需要使用Font时，却会意外的创建一个FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1; <span class="comment">//注意！这里的本意是拷贝一个Font对象，但是因为隐式转换的原因（f2前面的FontHandle），将f1给隐式转换为了FontHandle，然后才执行了复制操作</span></span><br></pre></td></tr></table></figure>

<p>在上面的程序中，FontHandle由Font对象f1进行管理，但是这个FontHandle也可以直接通过f2进行取得。这样就会引发问题，例如当f1被销毁时，字体会被释放，而f2因此会成为“虚吊的”（dangle）。</p>
</li>
</ul>
<hr>
<p>综上所说，是否应该提供一个显式转换函数（例如get成员函数）将RAII class转换为其底部资源，还是提供隐式转换，取决于其执行的具体功能，具体说来：</p>
<ul>
<li>让接口容易被正确使用，不易被误用。因此，通常显式转换函数如get就是比较好的方法，因为显式转换将非故意的类型转换的发生的可能性最小化了。</li>
<li>然而有时候隐式类型转换所带来的自然用法也能取得方便。</li>
</ul>
<p>最后，值得说明的是，从RAII class 获取原始资源并没有什么矛盾（你可能认为这样的类封装是失败的）。关于RAII class，它们并不是为了封装，而是为了确保：资源释放，这一行为，一定会发生。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>APIs往往要求访问原始资源，所以每一个RAII class 应该提供一个“取得其所管理之资源”的办法。</li>
<li>对原始资源的访问可能经由显式转换（比如一个get成员函数）或隐式转换（重载operator A()）。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li>
</ul>
</blockquote>
<h1 id="条款16"><a href="#条款16" class="headerlink" title="条款16"></a>条款16</h1><blockquote>
<p>成对使用new和delete时要采取相同形式。</p>
</blockquote>
<p>这章内容比较简单，就是“单一对象”和“对象数组”的问题。</p>
<ul>
<li>当你使用delete[]时，实际上是告诉编译器我要delete的对象是一个数组，让它得知内存中存在一个“数组大小记录”，这样才能释放完全空间。</li>
<li>如果对象不是数组但依然用了delete[]，就会导致编译器在解释内存空间时误认为某一项是“数组大小”，然后错误地释放空间。</li>
<li>最后，不要对数组形式做typedef动作，因为这会导致你new时不容易发现到底有没有[]，从而导致delete出错。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p>
</blockquote>
<h1 id="条款17"><a href="#条款17" class="headerlink" title="条款17"></a>条款17</h1><blockquote>
<p>以独立语句将newed对象置入智能指针。</p>
</blockquote>
<p>首先，假设我们有个函数用来显示处理函数的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processWidget</span><span class="params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据“以对象管理资源”的条款，processWidget使用智能指针来对动态分配得到的Widget进行管理（即tr1::shared_ptr）</p>
<p>当我们试图调用processWidget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(<span class="keyword">new</span> Widget, <span class="built_in">priority</span>());<span class="comment">//这种情况会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，此时是不能通过编译的。tr1::shared_ptr构造函数需要一个原始指针（raw pointer），但是这个构造函数是一个explicit构造函数，无法进行隐式转换。因此，需要将“newWidget”的原始指针转换为processWidget所需要的tr1::shared_ptr，因此需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; (<span class="keyword">new</span> Widget), <span class="built_in">priority</span> ());<span class="comment">//先使用构造函数，再拷贝构造</span></span><br></pre></td></tr></table></figure>

<p>但是，虽然此时我们使用了“对象管理式资源”，仍然会产生资源的泄漏！</p>
<p>在编译器产生一个processWidget调用代码之前，首先需要确定把即将被传递的各个实参是什么。在上面的代码中，第二个实参较为简单，只是一个对priority函数的调用；而第一个实参则较为复杂，对于这个实参std::tr1::shared_ptr&lt; Widget &gt; (new Widget)，它有两部分组成：</p>
<ul>
<li>执行“new Widget”表达式</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>因此，在调用processWidget之前，编译器需要创建代码，做以下三件事情：</p>
<ul>
<li>调用priority</li>
<li>执行“new Widget”</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>对于这三件事情，对于C++而言，“new Widget”的执行次序一定是在“tr1::shared_ptr构造函数被调用”之前，因为这个表达式的结果还需要被传递作为tr1::shared_ptr构造函数的一个实参。但是对于priority的调用而言，则是可以在第一、第二或者第三执行。假如选择在第二位执行，可以得到这样的执行序列：</p>
<ul>
<li>1.执行“new Widget”</li>
<li>2.调用priority</li>
<li>3.调用tr1::shared_ptr构造函数</li>
</ul>
<p>因此，对于上面这个执行次序，如果priority的调用产生异常，此时“new Widget”返回的指针将会遗失，因为它尚未被置入tr1::shared_ptr内，而这个智能指针的存在就是为了防止资源泄漏的。因此，在对processWidget的调用过程中是会引发资源泄漏，因为在“资源被创建（经由“new Widget”）”和“资源被替换为资源管理对象”这两个时间点之间可能会被发生干扰。</p>
<p>为了避免这样的问题，解决办法为分离语句。即分别写出：</p>
<ul>
<li><p>1.创建WIdget</p>
</li>
<li><p>2.将它置入一个智能指针之中，然后再将这个智能指针传给processWidget：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;    <span class="comment">//在单独的语句内以智能指针存储newed所得对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">process</span>(pw <span class="built_in">priority</span>());     <span class="comment">//这个调用动作就不会造成泄漏</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>之所以可以解决这个问题，是因为编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有这个自由）。在上述修改后的代码中，“new Widget”表达式以及“对tr1::shared_ptr构造函数的调用”这两个动作，与“对priority的调用”是分隔开的，在不同的语句之中，因此编译器就不能再它们之间任意选择执行次序。</p>
<p>记住：</p>
<blockquote>
<p>以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出（在资源对象产生到置入资源管理对象之间，产生异常的话），有可能导致难以察觉的资源泄漏。</p>
</blockquote>
<h1 id="条款18"><a href="#条款18" class="headerlink" title="条款18"></a>条款18</h1><blockquote>
<p>让接口容易被正确使用，不易被误用。</p>
</blockquote>
<p>想要开发出一个“容易被正确使用，不易被误用”的接口，首先就需要明白使用这样的接口可能会产生怎样的错误？举个例子，假设我们为一个用来表示日期的class设计构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> month, <span class="type">int</span> day, <span class="type">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然这样定义的构造函数乍一看没什么问题，但其实在调用时，却可能会产生以下两个错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的传递参数次序：</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;    <span class="comment">//把月和日传递反了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递一个无效的月份或天数：</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">30</span>, <span class="number">1995</span>)</span></span>;    <span class="comment">//二月有30号？？</span></span><br></pre></td></tr></table></figure>

<p>想要解决这样的问题，类型系统（type system）是一个关键办法。我们使用外覆类型（wrapper type）来区别这样的天数、月份和年份，然后在Date构造函数中使用这些类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="type">int</span> d)</span> : val(d) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Month</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span> : val(m) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Year</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="type">int</span> y)</span> : val(y) &#123;</span> &#125;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">const</span> Month&amp; m, <span class="type">const</span> Day&amp; d, <span class="type">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">30</span>, <span class="number">3</span>, <span class="number">1995</span>)</span></span>;        <span class="comment">//错误的类型！</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">30</span>), Month(<span class="number">3</span>), Year(<span class="number">1995</span>))</span></span>;  <span class="comment">//错误的类型！</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;  <span class="comment">//正确了！</span></span><br></pre></td></tr></table></figure>

<p>当我们确定好类型的定义，限制它们的取值也是非常重要。比如，月份的取值只能是1-12。方法之一，就是利用enum表现月份。不过enum并不具备类型安全性。因此，比较安全的解法是预先定义所有有效的Months：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Month</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">1</span>): &#125;  <span class="comment">//函数，返回有效的月份（本质是构造函数）</span></span><br><span class="line">    <span class="type">static</span> Month <span class="built_in">Feb</span>() &#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">2</span>); &#125; <span class="comment">//“以函数替换对象”，请回忆条款4中non-local static对象问题</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Month</span>(<span class="number">12</span>);&#125;</span><br><span class="line">    ...    <span class="comment">//其他的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="type">int</span> m)</span>   <span class="comment">//阻止生成新的月份</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Mar(), Day(<span class="number">30</span>), Year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>预防错误的另一种方法，限制类型内什么事情可以做，什么不可以做。常见的限制是加上const。在前面的条款3中，就对const的作用进行了说明。</li>
<li>“让types容易被正确使用，不容易被误用”，进一步表现为：除非有更好的理由，否则应该尽量让我们定义的types的行为与内置的types一致。一旦有怀疑，就拿int类型当范本。比如a*b这个表达式不允许赋值。</li>
<li>避免无端的与内置类型不兼容，真正的理由是为了提供行为一致的接口。STL容器的接口就比较一致，这就使得它们非常容易被使用。例如，每个STL容器都有size函的成员函数，它会告诉调用者目前容器内的对象的个数。</li>
</ul>
<hr>
<p>如果一个接口要求使用者必须记住某些事情，就会有着“不正确使用”的倾向，因为使用者很有可能忘记做这件事。举个例子，在条款13中所说的factory函数，它会返回一个指针指向Investment继承体系内的一个动态分配的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了避免资源的泄漏，createInvestment返回的指针最终必须被删除，但是在这个过程中，至少可能会出现两个错误机会：（1）没有删除指针。（2）删除同一个指针超过一次。</p>
<p>在条款13中提供的解决办法是将createInvestment的返回值存储在一个智能指针内，于是delete的责任就赋予了智能指针。不过，使用者如果忘记使用智能指针，则会出现问题。因此，较为理想的接口就是令factory函数返回一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这实际上就是强迫使用者将返回值存储在一个tr1::shared_ptr内，</span></span><br><span class="line"><span class="comment">//因此几乎就消除了忘记删除底部Investment对象的可能性。</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>假设class的设计，希望“从createInvestment取得Investment*指针”，将该指针传递给一个名为getRidOfInvestment的函数，而不是直接delete。那么这样设计的一个接口（上面那个）却会产生新的错误：企图使用错误的资源析构机制——即使用delete替换getRidOfInvestment。</p>
<p>对于这个问题，一个解决办法则是：返回一个“将getRidOfInvestment绑定为删除器（deleter）”的tr1::shared_ptr。</p>
<p>在前面的条款中有讲到过，tr1::shared_ptr提供的构造函数有两个实参：</p>
<ul>
<li>（1）被管理的指针</li>
<li>（2）引用次数变成0时被调用的“删除器”</li>
</ul>
<p>由此可得，我们可以创建一个null tr1::shared_ptr并以getRidOfInvestment作为其删除器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试图创建一个null shared_ptr并携带一个自定的编译器</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="number">0</span>, getRidOfInvestment)</span></span>;</span><br><span class="line"><span class="comment">//错误的形式！无法通过编译！！</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是不能通过编译的，因为tr1::shared_ptr构造函数的第一个参数必须是个指针，而0不是指针。因此，转型（cast）可以解决这样的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确地创建一个null shared_ptr并携带一个自定的编译器</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), getRidOfInvestment)</span></span>;</span><br></pre></td></tr></table></figure>

<p>因此，如果我们想要实现createInvestment使它返回一个tr1::shared_ptr并夹带getRidOfInvestment函数作为删除器，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), getRidOfInvestment)</span></span>;</span><br><span class="line">    retVal = ...;    <span class="comment">//令retVal指向正确的对象</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果被管理的原始指针可以在建立智能指针之前先确定下来，那么将原始指针传给构造函数会比先初始化为null再赋值更好。</p>
<hr>
<p>tr1::shared_ptr的一个优秀的性质是：它会自动的使用它的“每个指针专属的删除器”这样的性质消除了一个潜在的可能错误：“cross-DLL problem”。</p>
<p>这个问题发生于“对象在动态链接库（DLL）中被创建，但却在另一个DLL内被delete销毁”。在一些平台上，这一类“跨DLL的new&#x2F;delete成对运用”会导致运行期间错误。</p>
<p>然而tr1::shared_ptr就没有这个问题，因为它默认的删除器是来自“tr1::shared_ptr诞生所在的那个那个DLL”的delete。举个例子来说，如果Stock派生自Investment，而createInvestment的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tr1::<span class="built_in">shared_ptr</span>&lt;Investment&gt;(<span class="keyword">new</span> Stock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的那个tr1::shared_ptr可被传递给任何其他的DLLs，无需在意“cross-DLL problem”。这个指向Stock的tr1::shared_ptr会追踪记录“当Stock的引用次数变成0时该调用的那个DLL’s delete”。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li>
<li>“促使正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li>
<li>tr1::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁（见条款14）等等。</li>
</ul>
</blockquote>
<h1 id="条款19"><a href="#条款19" class="headerlink" title="条款19"></a>条款19</h1><blockquote>
<p>设计class犹如设计type。</p>
</blockquote>
<p>当我们定义一个新的class时，就相当于定义了一个新的type。</p>
<p>如何设计一个高效的classes？主要面对以下的问题：</p>
<ul>
<li><strong>新type的对象应该如何被创建和销毁？</strong>这会影响到class的构造函数和构造函数以及内存分配函数和释放函数（operator new, operator new[], operator deleter和operator deleter[]）。</li>
<li><strong>对象的初始化和对象的赋值应该有什么差别？</strong>这个问题的答案，决定了构造函数和赋值（assignment）操作符的行为，以及它们之间的差异。需要注意的是，“初始化”和“赋值”是不同的，因为他们应用于不同的函数调用。（详见条款4）</li>
<li><strong>新type的对象如果被passed by value（以值传递），会怎样？</strong>需要记住的是，copy构造函数用来定义一个type的pass-by-value应该如何去实现。</li>
<li><strong>什么是type的“合法值”？</strong>对class的成员变量来说，通常某些只有数值集是有效的。那些数值集决定了class需要维护的约束条件（invariants），因此，也就决定了成员函数（特别是构造函数、赋值操作符以及所谓的“setter”函数）必须要进行错误检查工作。</li>
<li><strong>创建的新type需要配合某一个继承图系（inheritance graph）么？</strong>如果继承来自某些既有的classes，那么设计的新classes就受到了束缚，特别是受到“它们的函数是virtual或者non-virtual”的影响。如果我们定义的class允许其他class去继承，这样会影响我们所声明的函数——尤其是析构函数——是否为virtual（详见条款7）。</li>
<li><strong>创建的新type需要怎样的转换？</strong>如果我们希望允许类型T1可以被隐式地转换为类型T2，就必须在class T1中写一个类型转换函数（operator T2）或者在class T2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数。如果我们只允许explicit构造函数存在，就必须写出专门负责执行转换操作的函数。</li>
<li><strong>什么样的操作符和函数对新创建的type而言是合理的？</strong>针对这个问题，需要决定class声明哪些函数，在这些函数中，哪些应该是member 函数，哪些则不是。</li>
<li><strong>什么样的标准函数应该被驳回？</strong>这些函数是必须声明为private的函数（详见条款7）。</li>
<li><strong>谁来取用新的type成员？</strong>这个问题可以帮助我们决定哪些成员应该是public、protected和private；同时也可以帮我们决定哪一个class&#x2F;function应该是friends，以及将它们嵌套到另一个之内是否合理。</li>
<li><strong>什么是新type的“未声明接口”（undeclared interface）？</strong>它会对效率、异常安全性以及资源运用（例如多任务锁定和动态内存）提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</li>
<li><strong>创建的新的type有多么一般化？</strong>如果说我们所需要的不是一个type，而是需要一整个types家族，那么我们就需要定义一个新的class template。</li>
<li><strong>真的需要定义一个新的type吗？</strong>如果只是定义新的derived class以便既有的class添加功能，那么单纯的定义一个或多个non-member函数或者template，或许更能达到目标。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。</p>
</blockquote>
<h1 id="条款20"><a href="#条款20" class="headerlink" title="条款20"></a>条款20</h1><blockquote>
<p>宁以pass-by-reference-to-const替换pass-by-value。</p>
</blockquote>
<p>在一般的情况下，默认情况中C++会以by value的方式传递对象自（或来自）函数。除非我们去特别指定，否则函数参数都是以实际实参的复件为初值，而调用端获得的也是函数返回值的一个复件。这些复件是由对象的copy构造函数生成的，这可能会造成pass-by-value称为较为费事儿的操作。</p>
<p>对于下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string address;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:<span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">    !<span class="built_in">Student</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string schoolName;</span><br><span class="line">    std::string schoolAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，我们调用函数validateStudent，该函数需要一个Student实参（by value）并返回它是否是有效的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;   <span class="comment">//函数以by value的形式接受学生</span></span><br><span class="line">Student white;    <span class="comment">//定义一个学生white</span></span><br><span class="line"><span class="type">bool</span> whiteIsOk = <span class="built_in">validateStudent</span>(white);   <span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p>当我们执行上面的代码时：首先，Student的copy构造函数会被调用，以white为蓝本将s进行初始化。同时，当validateStudent返回s时会被销毁。因此，对于此函数而言，参数的传递成本是：</p>
<ul>
<li>一次Student copy构造函数调用</li>
<li>一次Student析构函数调用</li>
</ul>
<p>但是！这还不算完！Student对象内有两个string对象，因此每次构造一个Student对象也就构造了两个string对象。此外，Student对象继承自Person对象，因此，每次每次构造Student对象是也必须构造一个Person对象。一个Person对象又有两个string对象，因此，每一次Person的构造动作也要承担两个string对构造动作。</p>
<p>于是，最终结果是：以by value的形式传递一个Student对象会调用一次Student对象会导致调用一次Student copy构造函数、一次Person copy构造函数、四次string copy构造函数。因此，当函数内的Student复件被销毁时，每一个构造函数调用动作都会对应一个析构函数调用动作。以by-value方式传递一个Student对象，</p>
<p>总体成本是：六次构造函数 和 六次析构函数。</p>
<hr>
<p>这是一个非常大的代价了。想要回避这样的大代价的一个办法就是pass by reference-to-const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="type">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这样的传递方法，效率要高的多：没有构造函数或者析构函数被调用，因为没有任何新对象被创建。</p>
<p>在上面修改后的代码，参数const是非常重要的。因为在原先的validateStudent中参数是以by-value的形式进行传递的，因此变相的就告诉我们这个传递的参数是收到保护的，函数内绝不会对传入的Student进行任何的更改，能更改也只是对Student的复件进行修改。</p>
<p>于是，Student以by reference方式的传递，将它声明为const是必要的，使得确保传递的Student不至于被修改。</p>
<hr>
<p>以by reference方式传递参数，也可以避免slicing（对象切割）问题。</p>
<p>当一个derived class对象以by value方式进行传递，并被视为一个base class对象，base class的copy构造函数会被调用，然而：“造成此对象的行为像一个derived class对象”的那些特质化的特征全部被切割掉了，仅仅留下了一个base class对象。造成这种情况的原因是，这个对象正是base class构造函数进行建立的，然而这种现象是我们一定不希望看到的。</p>
<p>举个例子，假设我们定义一组class，用来实现一个图形窗口系统：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">//返回窗口的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//显示窗口和其中的内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowWithScrollBars</span> : <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于所有的Window对象，都有一个名称，我们可以通过name函数获取。所有的窗口显示，我们也可以通过display函数来进行实现。<br>其中，display函数是一个virtual函数，这就意味着base class Window对象的显示方式和WindowWithScrollBars对象的显示方式是不同的。</p>
<p>而当我们希望写一个函数去打印窗口的名称，然后显示该窗口，下面的写法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNameAndDisply</span><span class="params">(Window w)</span>   <span class="comment">//不正确，参数可能会被切割</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用上述的参数并向其传递一个WindowWithScrollBars对象时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WindowWithScrollBars wwsb;</span><br><span class="line"><span class="built_in">printNameAndDisplay</span>(wwsb);</span><br></pre></td></tr></table></figure>

<p>此时，参数w会被构造称为一个Window对象，因为它是pass by value的。于是，使得wwsb“之所以是一个WindowWithScrollBars对象”的所有特征都会被切割掉，简而言之：在printNameAndDisplay函数内不管是传递过来的对象时什么类型，参数w就像是一个Window对象。<br>因此，在printNameAndDisplay函数内调用display调用的总是Window::display，而绝不会是WindowWithScrollBars::display。</p>
<p>解决切割（slicing）问题的办法，就是以by reference-to-const方式传递w：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> printNameAndDisplay（<span class="type">const</span> Window&amp; w）</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;w.<span class="built_in">name</span>();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，传进来的窗口的是什么类型，w就表现出那种类型。</p>
<hr>
<p>当我们观察C++编译器底层时，可以看到reference往往是以指针来实现的，因此：pass by reference通常意味传递的是指针。</p>
<ul>
<li>根据这点，如果我们需要传递的对象属于内置类型（例如int），pass by value往往比pass by reference的效率更高。对于这一点，也同样适用于STL的迭代器和函数对象，因为习惯上，它们都被设计为passed by value。</li>
<li>因为内置类型都相当的小，所以可能有人就会认为，所有小型types都可以使用pass-by-value，甚至当它们是用户自定义的class也一样，这个结论是错误的！因为对象小不代表copy构造函数的代价就不高。有许多对象——包括大多数STL容器——内含的东西只比一个指针多一些而已，但是复制这种对象却需要承担“赋值这些指针所指的每一样东西”。因此，代价也是非常昂贵的。</li>
<li>即使小型对象拥有并不昂贵的copy构造函数，在效率上也可能有差距。某些编译器在对待“内置类型”和“用户自定义类型”的态度上截然不同，即使两者拥有相同的底层表述（underlying representation）。</li>
<li>“小型的用户自定义类型不一定通过pass-by-value”的另一个理由是：作为一个用户自定义类型，其大小容易变化。一个type目前虽然比较小，将来却可能会变得比较大，因为其内部实现可能会变化。</li>
</ul>
<p>总而言之，其他小型的type包括自定义的class，对象本身小不代表copy代价不高；就算代价不高，编译器的不同对待也会导致效率也比较低；并且这些自定义类型大小是容易变化的。</p>
<p>一般而言，我们可以认为：</p>
<ul>
<li>pass-by-value代价不高的唯一对象就是内置类型和STL的迭代器和函数对象。</li>
</ul>
<p>以至于所其他其他的任何东西，都应当尽量以pass-by-reference-to-const替换pass-by-value。</p>
<p>记住：</p>
<blockquote>
<ul>
<li>尽量以 pass-by-reference-to-const 替换pass-by-value。前者通常比较高效，并可避免切割问题。</li>
<li>以上规则并不适用于内置类型、STL的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。</li>
</ul>
</blockquote>
<h1 id="条款21"><a href="#条款21" class="headerlink" title="条款21"></a>条款21</h1><blockquote>
<p>必须返回对象时，别妄想返回其reference。</p>
</blockquote>
<p>在上一章中我们了解到，pass-by-value有很多效率方面的问题，因此pass-by-reference可能是一种比较好的方法。<br>但是！盲目的用reference可能会造成这样的错误：开始传递一些references指向其实并不存在的对象！</p>
<p>举个例子，对于一个用以表现有理数（rational number）的class，内含一个函数用来计算一个有理数的乘积：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//分子numerator和分母denominator</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">      <span class="type">const</span> Rational</span><br><span class="line">        <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line">                   <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，这个版本的operator 是以by value的方法返回其计算结果——一个rational对象。对于这样的返回方法，代价如何？<br>假如说我们进行修改，使用reference进行传递，就不需要付出代价了。</p>
<p>但是：所谓的reference，只是一个名称，代表着某个既有对象。即，它一定是某物的另一个名称。</p>
<p>就像上面的operator* ，如果他返回一个reference，那么后者一定指向某个既有的Rational对象，内含两个Rational对象的乘积。因此，我们不能期望这样一个内含乘积的Rational对象在调用operator* 之前就存在。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;       <span class="comment">//a = 1/2</span></span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;       <span class="comment">//b = 3/5</span></span><br><span class="line">Rational c = a * b;     <span class="comment">//c应该是3/10</span></span><br></pre></td></tr></table></figure>

<p>期望“原本就存在一个值为3&#x2F;10的Rational对象”并不合理。如果operator* 要返回一个reference指向这个数值，它就必须自己创建这个Rational对象！</p>
<hr>
<p>一般来说，函数创建新对象有两种方法：</p>
<ul>
<li>在stack空间创建</li>
<li>在heap空间创建</li>
</ul>
<p>如果我们定义一个local变量，就是在stack空间创建对象。根据这个策略，尝试写一下operator*：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;  <span class="comment">//使用了构造函数实现，但是非常糟糕！</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure>

<p>对于上面这个方法，是一个比较糟糕的办法！因为我们的目标是避免使用构造函数，而result却必须用构造函数的方法来进行构造。更严重的是，这个函数返回一个reference指向result，但是result是一个local对象，而local对象在函数退出之前就被销毁了。因此，此时operator* 所指向的Rational，是一个已经被销毁的Rational！于是，此时将会陷入“无定义行为”的困境。</p>
<p>简单总结一句话：任何函数如果返回一个reference指向某个local对象，都会产生必然的错误！</p>
<hr>
<p>因此，我们考虑在heap内构造一个对象，并返回reference指向它。<br>Heap-based对象是由new创建的，因此我们需要写一个heap-based operator*，形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.n * rhs.d);    <span class="comment">//更为！糟糕的写法！</span></span><br><span class="line">    <span class="keyword">return</span> *result;</span><br><span class="line">&#125;                       </span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们依然需要付出一个“构造函数调用”的代价，因为分配获得的内存将以一个适当的构造函数完成初始化动作。<br>然而，此时还有一个更为严重问题：谁应该为被new出来的对象实施delete？</p>
<p>即使我们十分谨慎，还是会在合情合理的使用下，造成内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rational w, x,y,z;</span><br><span class="line">w = x * y * z;          <span class="comment">//与operator*(operator*(x, y), z)相同</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，同一个语句调用了两次operator*，因此使用了两次new，因此也就需要两次delete。但是，并没有合理的办法让operator*的使用者进行哪些delete调用，因为没有合理的办法让他们取得operator* 返回的references背后隐藏的那个指针。</p>
<p>这势必会造成内存泄漏！</p>
<hr>
<p>无论是on-the-stack，还是on-the-heap的做法，都因为对operator* 返回的结果调用构造函数而产生了问题，而最开始的目标就是避免如此的构造函调用动作！于是，另一个想法则是基于：</p>
<ul>
<li>让operator* 返回的reference指向一个被定义于函数内部的static Rational对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                            <span class="type">const</span> Rational&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Rational result;    <span class="comment">//还是很糟糕！定义static对象，该函数将返回它的reference</span></span><br><span class="line">    result = ... ;             <span class="comment">//将lhs乘以rhs，并将结果置于result之内</span></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>上面的代码之所以糟糕，是因为如果对于以下的使用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Rational&amp; lhs,</span><br><span class="line">                <span class="type">const</span> Rational&amp; rhs);   <span class="comment">//一个针对Rational而写的operator==</span></span><br><span class="line">Rational a, b, c, d;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">if</span> ((a * b) == (c * d))</span><br><span class="line">&#123;</span><br><span class="line">    乘积相等所执行的动作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    乘积不等所执行的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现的问题是：无论a, b, c, d的值是多少，表达式((a * b) &#x3D;&#x3D; (c * d))总是被判定为True！</p>
<p>让我们将上述的if判断语句写成等价的函数形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d))</span><br></pre></td></tr></table></figure>

<p>上面这句代码，可以看到在operator==被调用之前，已经有两个operator* 被调用了，并且每一个都返回reference指向operator* 内部定义的static Rational对象。因此，operator==被要求将“operator* 内的static Rational对象值” 拿来和“operator* 内的static Rational对象值” 进行比较，这自然就是相等了。</p>
<p>值得注意的是，两次的operator*的调用确实是改变了static Rational对象值，但是由于他们都是返回reference，因此调用段看到的永远是static Rational对象的“现值”。</p>
<p>另外，如果创建一个static array保存这些static对象呢？一方面这个数组的大小很难选择（太小不够用，太大降低效率），一方面每个对象都会在函数第一次调用时构造完成，调用n个构造函数和最后有n个析构函数。接着，为了把结果值写入array，又要调用赋值操作，很多时候赋值操作相当于一个拷贝构造和一个析构函数，情况就更恶劣了。</p>
<hr>
<p>于是，一个“必须返回新对象”的函数的正确写法是：直接让这个函数返回一个新对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incline <span class="type">const</span> Rational <span class="keyword">operator</span>* ( <span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Raitonal&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然了，operator*返回值的构造成本和析构成本是必须支出的，但是这只是获得正确行为的小小代价。</p>
<p>总之：</p>
<ul>
<li>当我们必须在“返回一个reference和返回一个object”之间进行选择时，选择行为正确的那一个。</li>
</ul>
<p>记住：</p>
<blockquote>
<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象。或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference 指向一个local static对象”提供了一份设计实例。</p>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jysama.cn/2022/08/10/effectiveC++/" title="effective c++ 记录">https://jysama.cn/2022/08/10/effectiveC++/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/08/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="prev" title="lambda表达式">
      <i class="fa fa-chevron-left"></i> lambda表达式
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjM2Ny8zMjgzMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE01"><span class="nav-number">2.</span> <span class="nav-text">条款01</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE02"><span class="nav-number">3.</span> <span class="nav-text">条款02</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE03"><span class="nav-number">4.</span> <span class="nav-text">条款03</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE04"><span class="nav-number">5.</span> <span class="nav-text">条款04</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE05"><span class="nav-number">6.</span> <span class="nav-text">条款05</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE06"><span class="nav-number">7.</span> <span class="nav-text">条款06</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE07"><span class="nav-number">8.</span> <span class="nav-text">条款07</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE08"><span class="nav-number">9.</span> <span class="nav-text">条款08</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE09"><span class="nav-number">10.</span> <span class="nav-text">条款09</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE10"><span class="nav-number">11.</span> <span class="nav-text">条款10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE11"><span class="nav-number">12.</span> <span class="nav-text">条款11</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE12"><span class="nav-number">13.</span> <span class="nav-text">条款12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE13"><span class="nav-number">14.</span> <span class="nav-text">条款13</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE14"><span class="nav-number">15.</span> <span class="nav-text">条款14</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE15"><span class="nav-number">16.</span> <span class="nav-text">条款15</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE16"><span class="nav-number">17.</span> <span class="nav-text">条款16</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE17"><span class="nav-number">18.</span> <span class="nav-text">条款17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE18"><span class="nav-number">19.</span> <span class="nav-text">条款18</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE19"><span class="nav-number">20.</span> <span class="nav-text">条款19</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE20"><span class="nav-number">21.</span> <span class="nav-text">条款20</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE21"><span class="nav-number">22.</span> <span class="nav-text">条款21</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">160k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
