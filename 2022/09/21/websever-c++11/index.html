<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言前几天follow完了tinywebsever的项目，分析了很多代码，最后也能跑起来。不过感觉整体的代码框架有些杂乱，代码也有冗余、不清晰的地方，比如互斥锁在c++11已经有专门的实现，不需要自己实现了。 作者也推荐了另一个c++11写的更简洁更优雅的项目实现：https:&#x2F;&#x2F;github.com&#x2F;qinguoyi&#x2F;TinyWebServer，上一个项目最大的好处是作者专门写了一系列分析的文章">
<meta property="og:type" content="article">
<meta property="og:title" content="TinyWebServer-C++11">
<meta property="og:url" content="https://jysama.cn/2022/09/21/websever-c++11/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="前言前几天follow完了tinywebsever的项目，分析了很多代码，最后也能跑起来。不过感觉整体的代码框架有些杂乱，代码也有冗余、不清晰的地方，比如互斥锁在c++11已经有专门的实现，不需要自己实现了。 作者也推荐了另一个c++11写的更简洁更优雅的项目实现：https:&#x2F;&#x2F;github.com&#x2F;qinguoyi&#x2F;TinyWebServer，上一个项目最大的好处是作者专门写了一系列分析的文章">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-21T01:56:36.922Z">
<meta property="article:modified_time" content="2022-09-22T15:45:51.121Z">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jysama.cn/2022/09/21/websever-c++11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TinyWebServer-C++11 | JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/21/websever-c++11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TinyWebServer-C++11
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-21 09:56:36" itemprop="dateCreated datePublished" datetime="2022-09-21T09:56:36+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-22 23:45:51" itemprop="dateModified" datetime="2022-09-22T23:45:51+08:00">2022-09-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天follow完了tinywebsever的项目，分析了很多代码，最后也能跑起来。不过感觉整体的代码框架有些杂乱，代码也有冗余、不清晰的地方，比如互斥锁在c++11已经有专门的实现，不需要自己实现了。</p>
<p>作者也推荐了另一个c++11写的更简洁更优雅的项目实现：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer%EF%BC%8C%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%9C%80%E5%A4%A7%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BD%9C%E8%80%85%E4%B8%93%E9%97%A8%E5%86%99%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E5%88%86%E6%9E%90%E7%9A%84%E6%96%87%E7%AB%A0%EF%BC%8C%E8%80%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%B2%A1%E6%9C%89%E6%95%99%E7%A8%8B%E4%B9%9F%E6%B2%A1%E4%BB%80%E4%B9%88%E6%B3%A8%E9%87%8A%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%89%93%E7%AE%97%E5%86%8D%E5%86%99%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%86%99%E4%B8%8B%E6%B3%A8%E9%87%8A%EF%BC%8C%E6%9B%B4%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E6%8A%8A%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%E3%80%81%E9%80%BB%E8%BE%91%E7%90%86%E6%B8%85%E6%A5%9A%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%9C%8B%E7%9C%8Bc++11%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E4%BE%BF%E4%B9%8B%E5%A4%84%E3%80%82">https://github.com/qinguoyi/TinyWebServer，上一个项目最大的好处是作者专门写了一系列分析的文章，而这个项目没有教程也没什么注释，因此打算再写篇博客分析一下代码，写下注释，更重要的是把代码框架、逻辑理清楚，以及看看c++11实现的方便之处。</a></p>
<hr>
<p>另外，在这里说一下size_t，很多c系的程序员对这个类型用的比较少，但这个项目里经常出现。</p>
<p>可以参考下：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24773728">(24 封私信 &#x2F; 80 条消息) size_t 这个类型的意义是什么？ - 知乎 (zhihu.com)</a>。</p>
<p>主要还是为了可移植性，不同平台对于size_t的大小不同，64位系统是8字节，32位系统是4字节。为了方便移植，许多库函数的参数、返回值都是size_t。当换了个平台时，可以不改动代码而传入、接收更大或更小的值；并且系统不会使用更大的类型，从而加快速度。注意这些都是相对只用int、unsigned int、unsigned long作为类型对比的结果，用size_t有弹性。</p>
<p>但是，一个size_t类型的参数的用途却是用户定义的，比如可以把size_t就当int用，用来数组寻址等等，也可以用它来接收函数返回的参数然后作为一些长度，这些长度表示字节、还是两个字节都是用户决定的，它本身的值是多少就是多少。</p>
<p>一般用于作索引和表示单字节长度：</p>
<ul>
<li>size_t传达了语义：您立即知道它表示一个以字节为单位的大小或一个索引，而不仅仅是另一个整数。</li>
<li>std::size_t是任何sizeof表达式的类型，并且保证能够表达C ++中任何对象(包括任何数组)的最大大小。通过扩展，它也保证对任何数组索引都足够大，因此它是数组上逐个索引循环的自然类型。</li>
</ul>
<hr>
<p>C++11可以将{}初始化器用于任何类型（可以使用等号，也可以不适用），这是一种通用的初始化语法。</p>
<p>在C++11中，集合（列表）的初始化已经成为C++的一个基本功能，被称为“初始化列表（initializer list）”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;            <span class="comment">//C++98支持，C++11支持</span></span><br><span class="line"><span class="type">int</span> b[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;        <span class="comment">//C++98不支持，C++11支持</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">float</span>&gt; d = &#123;&#123; <span class="number">1</span>, <span class="number">1.0f</span> &#125;, &#123; <span class="number">2</span>, <span class="number">2.0f</span> &#125;, &#123; <span class="number">3</span>, <span class="number">3.0f</span> &#125; &#125;;<span class="comment">//C++98不支持，C++11支持</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>应用了很多新特性，比较难理解，要耐心一点。</p>
<p>右值引用可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">C++11右值引用（一看即懂） (biancheng.net)</a></p>
<p>std::move()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7863.html">C++11 move()函数：将左值强制转换为右值 (biancheng.net)</a></p>
<p>std::forward()可参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7868.html">C++11完美转发及实现方法详解 (biancheng.net)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-15</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> threadCount = <span class="number">8</span>)</span>: pool_(std::make_shared&lt;Pool&gt;()) &#123;</span><span class="comment">//传入一个pool指针</span></span><br><span class="line">            <span class="built_in">assert</span>(threadCount &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;<span class="comment">//创建count个线程，每个线程绑定工作函数并detach分离</span></span><br><span class="line">                <span class="comment">//lambda匿名函数，按值捕获pool_，本身是个指针，指向同一个实例。没有参数，省略“（）”</span></span><br><span class="line">                std::<span class="built_in">thread</span>([pool = pool_] &#123;<span class="comment">//接下来是函数体</span></span><br><span class="line">                    std::unique_lock&lt;std::mutex&gt; <span class="built_in">locker</span>(pool-&gt;mtx);<span class="comment">//灵活锁，因为要取一个元素。不放while可以避免重复定义</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!pool-&gt;tasks.<span class="built_in">empty</span>()) &#123;<span class="comment">//有元素就取</span></span><br><span class="line">                            <span class="keyword">auto</span> task = std::<span class="built_in">move</span>(pool-&gt;tasks.<span class="built_in">front</span>());<span class="comment">//左值转右值，转移task内存的所有权，把function取出来，调用移动构造函数</span></span><br><span class="line">                            pool-&gt;tasks.<span class="built_in">pop</span>();</span><br><span class="line">                            locker.<span class="built_in">unlock</span>();<span class="comment">//取完可以解锁了</span></span><br><span class="line">                            <span class="built_in">task</span>();<span class="comment">//工作</span></span><br><span class="line">                            locker.<span class="built_in">lock</span>();<span class="comment">//工作完因为是while，再锁，接下来再取元素。</span></span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(pool-&gt;isClosed) <span class="keyword">break</span>;<span class="comment">//结束线程</span></span><br><span class="line">                        <span class="keyword">else</span> pool-&gt;cond.<span class="built_in">wait</span>(locker);<span class="comment">//没有元素，解锁并等待唤醒</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).<span class="built_in">detach</span>();<span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">bool</span>&gt;(pool_)) &#123;<span class="comment">//强制转型，pool_有指向的话就是true，那么就准备让线程退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">                pool_-&gt;isClosed = <span class="literal">true</span>;<span class="comment">//退出标识</span></span><br><span class="line">            &#125;</span><br><span class="line">            pool_-&gt;cond.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有线程，要把工作都做完才退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;<span class="comment">//以模板定义的&amp;&amp;既能接受左值也能接受右值，但注意，task作为参数，有名且能寻址，成为了左值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddTask</span><span class="params">(F&amp;&amp; task)</span> </span>&#123;<span class="comment">//添加一个task，右值传入，使得传入的对象的所有权被task获取，</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(pool_-&gt;mtx)</span></span>;</span><br><span class="line">            <span class="comment">//c++11新特性，emplace使对象在内存中调用构造函数，push会先构造再拷贝构造</span></span><br><span class="line">            pool_-&gt;tasks.<span class="built_in">emplace</span>(std::forward&lt;F&gt;(task));<span class="comment">//完美转发，保留传入的左右值属性，</span></span><br><span class="line">            	<span class="comment">//直接传task是个左值，如果F是一个function&lt;&gt;类型，这会导致移动构造和拷贝构造的区别。如果F是一个普通函数或指针等，一律调用普通构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        pool_-&gt;cond.<span class="built_in">notify_one</span>();<span class="comment">//唤醒等待队列中的第一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pool</span> &#123;<span class="comment">//线程池结构体，相当于在类里再封装一层</span></span><br><span class="line">        std::mutex mtx;</span><br><span class="line">        std::condition_variable cond;</span><br><span class="line">        <span class="type">bool</span> isClosed;</span><br><span class="line">        std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;<span class="comment">//任务队列，元素是一个函数，执行任务，没有返回值和参数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;Pool&gt; pool_;<span class="comment">//使用共享指针，能自动销毁pool实例</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THREADPOOL_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>先介绍下std::mutex：头文件<code>&lt;mutex&gt; </code>，实际上跟linux中pthread的互斥锁差不多，手动上锁和解锁。</p>
<ul>
<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
<li>unlock()， 解锁，释放对互斥量的所有权。</li>
<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
<p>真正好用的是std::lock_guard：头文件<code>&lt;mutex&gt; </code>，使用RAII机制，退出作用域就解锁。</p>
<ul>
<li>&#96;&#96;&#96;c++<br>template <class _Mutex><br>class lock_guard { &#x2F;&#x2F; class with destructor that unlocks a mutex<br>public:<br>using mutex_type &#x3D; _Mutex;<br>&#x2F;&#x2F;无adopt_lock参数，构造时加锁<br>explicit lock_guard(_Mutex&amp; _Mtx) : _MyMutex(_Mtx) { &#x2F;&#x2F; construct and lock<br>    _MyMutex.lock();<br>}<br>&#x2F;&#x2F;有adopt_lock参数，构造时不加锁<br>lock_guard(_Mutex&amp; _Mtx, adopt_lock_t) : _MyMutex(_Mtx) {} &#x2F;&#x2F; construct but don’t lock<br>&#x2F;&#x2F;析构解锁<br>~lock_guard() noexcept {<br>    _MyMutex.unlock();<br>}<br>&#x2F;&#x2F;屏蔽拷贝构造<br>lock_guard(const lock_guard&amp;) &#x3D; delete;<br>lock_guard&amp; operator&#x3D;(const lock_guard&amp;) &#x3D; delete;<br>private:<br>_Mutex&amp; _MyMutex;<br>};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* lock_guard具有两种构造方法：</span><br><span class="line"></span><br><span class="line">  1. `lock_guard(mutex&amp; m)`</span><br><span class="line">  2. `lock_guard(mutex&amp; m, adopt_lock)`其中`mutex&amp; m`是互斥量，参数`adopt_lock`表示假定调用线程已经获得互斥体所有权并对其进行管理了。</span><br><span class="line"></span><br><span class="line">再说下std::unique_lock：头文件`&lt;mutex&gt;`，也是使用RAII机制，定义和lock_guard相同。</span><br><span class="line"></span><br><span class="line">主要还是说下二者的对比：</span><br><span class="line"></span><br><span class="line">* std::unique_lock 与std::lock_guard都能实现自动加锁与解锁功能，但是std::unique_lock要比std::lock_guard更灵活，但是更灵活的代价是占用空间相对更大一点且相对更慢一点。</span><br><span class="line">* 它提供了`lock()`和`unlock()`接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁。而lock_guard一锁就锁住一个作用域，直到退出才解锁，没有lock和unlock接口，有时只想锁住一段代码，用unique_lock就更灵活。</span><br><span class="line">* `unique_lock`和`lock_guard`都不能复制，`lock_guard`不能移动，但是`unique_lock`可以</span><br><span class="line">* 可以参考[[c++11\]多线程编程(五)——unique_lock - 简书 (jianshu.com)](https://www.jianshu.com/p/34d219380d90)</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">条件变量std::condition_variable：头文件` &lt;condition_variable&gt;`，和linux的差不多了，可以看下[(29条消息) C++11多线程条件变量std::condition_variable详解（转 ）_山城盛夏的博客-CSDN博客_std::condition_variable 详解](https://blog.csdn.net/qq_38210354/article/details/107168532)，当然不看也可以，无非是等待和唤醒。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">关于std::function，主要是用来包装函数的，像函数一样调用，具体可以参考之前的博客：[lambda表达式 | JySama](https://jysama.cn/2022/08/08/c++lambda表达式/)</span><br><span class="line"></span><br><span class="line">std::function是一个函数包装器，该函数包装器模板能包装任何类型的可调用实体，如普通函数，函数对象，lamda表达式等。包装器可拷贝，移动等，并且包装器类型仅仅依赖于调用特征，而不依赖于可调用元素自身的类型。std::function是C++11的新特性，包含在头文件`&lt;functional&gt;`中。</span><br><span class="line"></span><br><span class="line">一个std::function类型对象实例可以包装下列这几种可调用实体：函数、函数指针、成员函数、静态函数、lamda表达式和函数对象。std::function对象实例可被拷贝和移动，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象实例未包含任何实际可调用实体时，调用该std::function对象实例将抛出std::bad_function_call异常。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">std::forward()：完美转发 </span><br><span class="line"></span><br><span class="line">当我们将一个右值引用传入函数时，他在实参中有了命名，所以继续往下传或者调用其他函数时，根据C++ 标准的定义，这个参数变成了一个**左值**。那么他永远不会调用接下来函数的右值版本，这可能在一些情况下造成拷贝。为了解决这个问题 C++ 11引入了完美转发，根据右值判断的推倒，调用forward 传出的值，若原来是一个右值，那么他转出来就是一个右值，否则为一个左值。这样的处理就完美的转发了原有参数的左右值属性，不会造成一些不必要的拷贝。</span><br><span class="line"></span><br><span class="line">std::forward必须配合T&amp;&amp;来使用。例如T&amp;&amp;接受左值int&amp;时，T会被推断为int&amp;，而T&amp;&amp;接受右值int&amp;&amp;时，T被推断为int。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">std::thread：头文件`&lt;thread&gt;`，可移动不可复制</span><br><span class="line"></span><br><span class="line">* 默认构造函数，创建一个空的 `std::thread` 执行对象： thread() noexcept;</span><br><span class="line">* 初始化构造函数，创建一个 `std::thread` 对象，该 `std::thread` 对象可被 `joinable`，新产生的线程会调用 `fn` 函数，该函数的参数由 `args` 给出。</span><br><span class="line">  * template &lt;class Fn, class... Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br><span class="line"></span><br><span class="line"># 数据库</span><br><span class="line"></span><br><span class="line">数据库如出一辙，很好理解</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/*</span><br><span class="line"> * @Author       : mark</span><br><span class="line"> * @Date         : 2020-06-16</span><br><span class="line"> * @copyleft Apache 2.0</span><br><span class="line"> */ </span><br><span class="line">#ifndef SQLCONNPOOL_H</span><br><span class="line">#define SQLCONNPOOL_H</span><br><span class="line"></span><br><span class="line">#include &lt;mysql/mysql.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">class SqlConnPool &#123;</span><br><span class="line">public:</span><br><span class="line">    static SqlConnPool *Instance();//单例，静态成员函数</span><br><span class="line"></span><br><span class="line">    MYSQL *GetConn();</span><br><span class="line">    void FreeConn(MYSQL * conn);</span><br><span class="line">    int GetFreeConnCount();</span><br><span class="line"></span><br><span class="line">    void Init(const char* host, int port,</span><br><span class="line">              const char* user,const char* pwd, </span><br><span class="line">              const char* dbName, int connSize);</span><br><span class="line">    void ClosePool();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    SqlConnPool();</span><br><span class="line">    ~SqlConnPool();</span><br><span class="line"></span><br><span class="line">    int MAX_CONN_;</span><br><span class="line">    int useCount_;</span><br><span class="line">    int freeCount_;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;MYSQL *&gt; connQue_;</span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">    sem_t semId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif // SQLCONNPOOL_H</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">SqlConnPool::<span class="built_in">SqlConnPool</span>() &#123;<span class="comment">//放init也行，或者init放这</span></span><br><span class="line">    useCount_ = <span class="number">0</span>;</span><br><span class="line">    freeCount_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SqlConnPool* <span class="title">SqlConnPool::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例模式</span></span><br><span class="line">    <span class="type">static</span> SqlConnPool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::Init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">int</span> port,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">char</span>* user,<span class="type">const</span> <span class="type">char</span>* pwd, <span class="type">const</span> <span class="type">char</span>* dbName,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span> connSize = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(connSize &gt; <span class="number">0</span>);<span class="comment">//条件判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connSize; i++) &#123;</span><br><span class="line">        MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//定义一个sql指针</span></span><br><span class="line">        sql = <span class="built_in">mysql_init</span>(sql);<span class="comment">//用这个指针初始化一个sql结构体，返回一个指向这个结构体的指针</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;<span class="comment">//错误判断，写日志</span></span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql init error!&quot;</span>);</span><br><span class="line">            <span class="built_in">assert</span>(sql);<span class="comment">//报错</span></span><br><span class="line">        &#125;</span><br><span class="line">        sql = <span class="built_in">mysql_real_connect</span>(sql, host,</span><br><span class="line">                                 user, pwd,</span><br><span class="line">                                 dbName, port, <span class="literal">nullptr</span>, <span class="number">0</span>);<span class="comment">//init后就connect，连接数据库，返回一个可用连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sql) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySql Connect error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connQue_.<span class="built_in">push</span>(sql);<span class="comment">//放入队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    MAX_CONN_ = connSize;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semId_, <span class="number">0</span>, MAX_CONN_);<span class="comment">//初始化信号量的值，这个0表示只能在当前进程的所有线程之间共享</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取一个可用连接</span></span><br><span class="line"><span class="function">MYSQL* <span class="title">SqlConnPool::GetConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *sql = <span class="literal">nullptr</span>;<span class="comment">//句柄</span></span><br><span class="line">    <span class="keyword">if</span>(connQue_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;SqlConnPool busy!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为什么前面判断了空这里还要用信号量呢？原因是线程可能在队列非空时纷涌而至，但实际上没有那么多连接可用，因此还是要信号量阻塞buffer</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semId_);</span><br><span class="line">    &#123;<span class="comment">//lock的作用域</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//如果能取，要互斥</span></span><br><span class="line">        sql = connQue_.<span class="built_in">front</span>();</span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sql;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放一个连接，放回队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::FreeConn</span><span class="params">(MYSQL* sql)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sql);<span class="comment">//判空，不能放回虚假的连接</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//互斥放回</span></span><br><span class="line">    connQue_.<span class="built_in">push</span>(sql);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semId_);<span class="comment">//post</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SqlConnPool::ClosePool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//锁住先，避免在close时被使用</span></span><br><span class="line">    <span class="keyword">while</span>(!connQue_.<span class="built_in">empty</span>()) &#123;<span class="comment">//循环取</span></span><br><span class="line">        <span class="keyword">auto</span> item = connQue_.<span class="built_in">front</span>();<span class="comment">//auto真给力...</span></span><br><span class="line">        connQue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">mysql_close</span>(item);<span class="comment">//关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//避免在使用库完成应用程序后发生内存泄漏(例如，在关闭与服务器的连接之后)，</span></span><br><span class="line">    <span class="comment">//可以显式调用mysql_library_end()。这样可以执行内存 Management 以清理和释放库使用的资源。</span></span><br><span class="line">    <span class="built_in">mysql_library_end</span>();        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前可用连接大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SqlConnPool::GetFreeConnCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> connQue_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">SqlConnPool::~<span class="built_in">SqlConnPool</span>() &#123;</span><br><span class="line">    <span class="built_in">ClosePool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-19</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQLCONNRAII_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sqlconnpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 资源在对象构造初始化 资源在对象析构时释放*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlConnRAII</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqlConnRAII</span>(MYSQL** sql, SqlConnPool *connpool) &#123;<span class="comment">//双指针修改sql，为了获取连接，传入connpool</span></span><br><span class="line">        <span class="built_in">assert</span>(connpool);</span><br><span class="line">        *sql = connpool-&gt;<span class="built_in">GetConn</span>();<span class="comment">//获取连接</span></span><br><span class="line">        sql_ = *sql;<span class="comment">//记录</span></span><br><span class="line">        connpool_ = connpool;<span class="comment">//为了释放，需要记录sql和connpool</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">SqlConnRAII</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(sql_) &#123; connpool_-&gt;<span class="built_in">FreeConn</span>(sql_); &#125;<span class="comment">//析构释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MYSQL *sql_;</span><br><span class="line">    SqlConnPool* connpool_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SQLCONNRAII_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>阻塞队列，用互斥锁再封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCKQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCKQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockDeque</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BlockDeque</span><span class="params">(<span class="type">size_t</span> MaxCapacity = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BlockDeque</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::deque&lt;T&gt; deq_;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> capacity_;     </span><br><span class="line"></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isClose_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condConsumer_;</span><br><span class="line"></span><br><span class="line">    std::condition_variable condProducer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::<span class="built_in">BlockDeque</span>(<span class="type">size_t</span> MaxCapacity) :<span class="built_in">capacity_</span>(MaxCapacity) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(MaxCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    isClose_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BlockDeque&lt;T&gt;::~<span class="built_in">BlockDeque</span>() &#123;</span><br><span class="line">    <span class="built_in">Close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">Close</span>() &#123;</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        deq_.<span class="built_in">clear</span>();<span class="comment">//清除所有元素</span></span><br><span class="line">        isClose_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    condProducer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有生产者，准备退出</span></span><br><span class="line">    condConsumer_.<span class="built_in">notify_all</span>();<span class="comment">//唤醒所有消费者，准备退出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">flush</span>() &#123;</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//刷新，唤醒一个线程，准备工作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    deq_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">front</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BlockDeque&lt;T&gt;::<span class="built_in">back</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">size_t</span> BlockDeque&lt;T&gt;::<span class="built_in">capacity</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> capacity_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有问题，前面close唤醒了线程，这里没有根据isclose变量直接退出，在pop那是退出了的，这里可能会卡住，一旦wait的太多，就可能一直写然后一直while。</span></span><br><span class="line"><span class="comment">//除非线程数严格小于容量</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;<span class="comment">//条件变量的等待方式</span></span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);<span class="comment">//阻塞，等待唤醒，但唤醒后还是需要while看条件，因为有多个生产者在竞争</span></span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_back</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BlockDeque&lt;T&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">        condProducer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">    &#125;</span><br><span class="line">    deq_.<span class="built_in">push_front</span>(item);</span><br><span class="line">    condConsumer_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">full</span>()&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> deq_.<span class="built_in">size</span>() &gt;= capacity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        condConsumer_.<span class="built_in">wait</span>(locker);</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//如果close了就return了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();<span class="comment">//唤醒一个消费者线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> BlockDeque&lt;T&gt;::<span class="built_in">pop</span>(T &amp;item, <span class="type">int</span> timeout) &#123;<span class="comment">//增加了超时处理，push没有超时处理</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(deq_.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(condConsumer_.<span class="built_in">wait_for</span>(locker, std::chrono::<span class="built_in">seconds</span>(timeout)) </span><br><span class="line">                == std::cv_status::timeout)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻塞超时就结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isClose_)&#123;<span class="comment">//关了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    item = deq_.<span class="built_in">front</span>();</span><br><span class="line">    deq_.<span class="built_in">pop_front</span>();</span><br><span class="line">    condProducer_.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BLOCKQUEUE_H</span></span></span><br></pre></td></tr></table></figure>

<p>std::chrono::seconds：一个类，获取多少时间，这里以临时变量的形式传给wait_for，持续…seconds，超时结果就是timeout，和cv_status的timeout相等，借此判断是否超时。</p>
<p>std::cv_status：定义于头文件 <code>&lt;condition_variable&gt;</code>，带作用域枚举 <code>std::cv_status</code> 描述定时等待是否因时限返回。成员：</p>
<ul>
<li><code>no_timeout</code>：条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒</li>
<li><code>timeout</code>：条件变量因时限耗尽被唤醒</li>
</ul>
<p>wait_for：</p>
<p>返回值：若经过 <code>rel_time</code> 所指定的关联时限则为 std::cv_status::timeout，否则为 std::cv_status::no_timeout 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span>           <span class="comment">// vastart va_end</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>         <span class="comment">//mkdir</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blockqueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;./log&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">char</span>* suffix =<span class="string">&quot;.log&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> maxQueueCapacity = <span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Log* <span class="title">Instance</span><span class="params">()</span></span>;<span class="comment">//单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FlushLogThread</span><span class="params">()</span></span>;<span class="comment">//异步线程的回调函数，需要是staic，没有this隐藏参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format,...)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetLevel</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsOpen</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isOpen_; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AsyncWrite_</span><span class="params">()</span></span>;<span class="comment">//互斥写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_PATH_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LOG_NAME_LEN = <span class="number">256</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LINES = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path_;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* suffix_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX_LINES_;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lineCount_;</span><br><span class="line">    <span class="type">int</span> toDay_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isOpen_;</span><br><span class="line"> </span><br><span class="line">    Buffer buff_;<span class="comment">//一个日志仅有一个buffer，因为write被互斥锁锁住了</span></span><br><span class="line">    <span class="type">int</span> level_;</span><br><span class="line">    <span class="type">bool</span> isAsync_;</span><br><span class="line"></span><br><span class="line">    FILE* fp_;</span><br><span class="line">    std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_; <span class="comment">//智能指针，还没有实例</span></span><br><span class="line">    std::unique_ptr&lt;std::thread&gt; writeThread_;<span class="comment">//指向一个thread，还没有实例</span></span><br><span class="line">    std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//以宏的形式，感觉写个string形式也行</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_BASE(level, format, ...) \</span></span><br><span class="line"><span class="meta">    do &#123;\</span></span><br><span class="line"><span class="meta">        Log* log = Log::Instance();\</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (log-&gt;IsOpen() &amp;&amp; log-&gt;GetLevel() &lt;= level) &#123;\</span></span><br><span class="line"><span class="meta">            log-&gt;write(level, format, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            log-&gt;flush();\</span></span><br><span class="line"><span class="meta">        &#125;\</span></span><br><span class="line"><span class="meta">    &#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) do &#123;LOG_BASE(0, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) do &#123;LOG_BASE(1, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) do &#123;LOG_BASE(2, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) do &#123;LOG_BASE(3, format, ##__VA_ARGS__)&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//LOG_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-16</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>() &#123;</span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line">    isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    writeThread_ = <span class="literal">nullptr</span>;</span><br><span class="line">    deque_ = <span class="literal">nullptr</span>;</span><br><span class="line">    toDay_ = <span class="number">0</span>;</span><br><span class="line">    fp_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(writeThread_ &amp;&amp; writeThread_-&gt;<span class="built_in">joinable</span>()) &#123;<span class="comment">//如果写线程存在且需要join，就需要join</span></span><br><span class="line">        <span class="keyword">while</span>(!deque_-&gt;<span class="built_in">empty</span>()) &#123;<span class="comment">//不断唤醒消费者线程，把日志写完</span></span><br><span class="line">            deque_-&gt;<span class="built_in">flush</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        deque_-&gt;<span class="built_in">Close</span>();<span class="comment">//关掉</span></span><br><span class="line">        writeThread_-&gt;<span class="built_in">join</span>();<span class="comment">//join</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fp_) &#123;<span class="comment">//如果文件打开了</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">flush</span>();<span class="comment">//刷新fp的缓冲区，还有唤醒线程的功能，这里没用</span></span><br><span class="line">        <span class="built_in">fclose</span>(fp_);<span class="comment">//关掉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Log::GetLevel</span><span class="params">()</span> </span>&#123;<span class="comment">//日志系统级别，越高级能写的类型越多，日志系统没到对应级别不能写</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> level_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::SetLevel</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::init</span><span class="params">(<span class="type">int</span> level = <span class="number">1</span>, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> maxQueueSize)</span> </span>&#123;</span><br><span class="line">    isOpen_ = <span class="literal">true</span>;</span><br><span class="line">    level_ = level;</span><br><span class="line">    <span class="keyword">if</span>(maxQueueSize &gt; <span class="number">0</span>) &#123;<span class="comment">//如果设置了阻塞队列大小，就是异步</span></span><br><span class="line">        isAsync_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!deque_) &#123;</span><br><span class="line">            unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; <span class="built_in">newDeque</span>(<span class="keyword">new</span> BlockDeque&lt;std::string&gt;);<span class="comment">//创建一个实例</span></span><br><span class="line">            deque_ = <span class="built_in">move</span>(newDeque);<span class="comment">//unique指针只能移动构造</span></span><br><span class="line">            </span><br><span class="line">            <span class="function">std::unique_ptr&lt;std::thread&gt; <span class="title">NewThread</span><span class="params">(<span class="keyword">new</span> thread(FlushLogThread))</span></span>;<span class="comment">//异步同时要实例化一个写线程</span></span><br><span class="line">            writeThread_ = <span class="built_in">move</span>(NewThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isAsync_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lineCount_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> timer = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;timer);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    path_ = path;</span><br><span class="line">    suffix_ = suffix;</span><br><span class="line">    <span class="type">char</span> fileName[LOG_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">snprintf</span>(fileName, LOG_NAME_LEN - <span class="number">1</span>, <span class="string">&quot;%s/%04d_%02d_%02d%s&quot;</span>, </span><br><span class="line">            path_, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday, suffix_);<span class="comment">//日志文件名写到名称缓冲区</span></span><br><span class="line">    toDay_ = t.tm_mday;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">//互斥锁作用域，感觉没必要，init就主线程调用</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();</span><br><span class="line">        <span class="keyword">if</span>(fp_) &#123; <span class="comment">//如果文本打开了，就关了重新开</span></span><br><span class="line">            <span class="built_in">flush</span>();</span><br><span class="line">            <span class="built_in">fclose</span>(fp_); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据名称创建or打开</span></span><br><span class="line">        <span class="keyword">if</span>(fp_ == <span class="literal">nullptr</span>) &#123;<span class="comment">//打开失败，没有目标文件夹，要先创建</span></span><br><span class="line">            <span class="built_in">mkdir</span>(path_, <span class="number">0777</span>);<span class="comment">//0777是最大的访问权</span></span><br><span class="line">            fp_ = <span class="built_in">fopen</span>(fileName, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">time_t</span> tSec = now.tv_sec;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sysTime = <span class="built_in">localtime</span>(&amp;tSec);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> t = *sysTime;</span><br><span class="line">    <span class="comment">//宏参数初始化</span></span><br><span class="line">    va_list vaList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志日期 日志行数 */</span></span><br><span class="line">    <span class="keyword">if</span> (toDay_ != t.tm_mday || (lineCount_ &amp;&amp; (lineCount_  %  MAX_LINES == <span class="number">0</span>)))<span class="comment">//如果日志行数太多写满了，或着换了一天，要重新创建一个文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;<span class="comment">//这个锁感觉放if外好一点，因为让一个线程进来创建好新文件更新day喝line就可以了，这样就会很多线程一起进这个if</span></span><br><span class="line">        locker.<span class="built_in">unlock</span>();<span class="comment">//等下要用一个锁，先创建好，解锁。这对于同步写有用，因为同步的话有很多线程会调用</span></span><br><span class="line">        <span class="comment">//把lock锁if外，然后处理完，更新day和line，打开新文件，再解锁，其他线程就不会进if了</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> newFile[LOG_NAME_LEN];</span><br><span class="line">        <span class="type">char</span> tail[<span class="number">36</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">36</span>, <span class="string">&quot;%04d_%02d_%02d&quot;</span>, t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (toDay_ != t.tm_mday)<span class="comment">//如果是换了一天</span></span><br><span class="line">        &#123;<span class="comment">//-72是什么鬼，不需要那么长吗？</span></span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s%s&quot;</span>, path_, tail, suffix_);</span><br><span class="line">            toDay_ = t.tm_mday;<span class="comment">//给天赋值</span></span><br><span class="line">            lineCount_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(newFile, LOG_NAME_LEN - <span class="number">72</span>, <span class="string">&quot;%s/%s-%d%s&quot;</span>, path_, tail, (lineCount_  / MAX_LINES), suffix_);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        locker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">flush</span>();</span><br><span class="line">        <span class="built_in">fclose</span>(fp_);</span><br><span class="line">        fp_ = <span class="built_in">fopen</span>(newFile, <span class="string">&quot;a&quot;</span>);<span class="comment">//重新打开</span></span><br><span class="line">        <span class="built_in">assert</span>(fp_ != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后正常写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        lineCount_++;<span class="comment">//写一行</span></span><br><span class="line">        <span class="comment">//buffer不只是为日志系统写的，而且感觉这里不用buffer更好</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">snprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), <span class="number">128</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld &quot;</span>,</span><br><span class="line">                    t.tm_year + <span class="number">1900</span>, t.tm_mon + <span class="number">1</span>, t.tm_mday,</span><br><span class="line">                    t.tm_hour, t.tm_min, t.tm_sec, now.tv_usec);<span class="comment">//向buffer写时间信息，n是写入的长度</span></span><br><span class="line">                    </span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(n);<span class="comment">//移动指针，前n个写时间信息</span></span><br><span class="line">        <span class="built_in">AppendLogLevelTitle_</span>(level);<span class="comment">//然后添加等级</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">va_start</span>(vaList, format);<span class="comment">//遍历参数</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(buff_.<span class="built_in">BeginWrite</span>(), buff_.<span class="built_in">WritableBytes</span>(), format, vaList);<span class="comment">//不断向buffer写，返回写入长度</span></span><br><span class="line">        <span class="built_in">va_end</span>(vaList);<span class="comment">//关闭</span></span><br><span class="line"></span><br><span class="line">        buff_.<span class="built_in">HasWritten</span>(m);<span class="comment">//移动指针</span></span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;\n\0&quot;</span>, <span class="number">2</span>);<span class="comment">//加换行和终止</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isAsync_ &amp;&amp; deque_ &amp;&amp; !deque_-&gt;<span class="built_in">full</span>()) &#123;<span class="comment">//如果是异步的，放阻塞队列</span></span><br><span class="line">            deque_-&gt;<span class="built_in">push_back</span>(buff_.<span class="built_in">RetrieveAllToStr</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//如果是同步的，开写</span></span><br><span class="line">            <span class="built_in">fputs</span>(buff_.<span class="built_in">Peek</span>(), fp_);</span><br><span class="line">        &#125;</span><br><span class="line">        buff_.<span class="built_in">RetrieveAll</span>();<span class="comment">//清空缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AppendLogLevelTitle_</span><span class="params">(<span class="type">int</span> level)</span> </span>&#123;<span class="comment">//添加信息头</span></span><br><span class="line">    <span class="keyword">switch</span>(level) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[debug]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[warn] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[error]: &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        buff_.<span class="built_in">Append</span>(<span class="string">&quot;[info] : &quot;</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">()</span> </span>&#123;<span class="comment">//刷新缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(isAsync_) &#123; </span><br><span class="line">        deque_-&gt;<span class="built_in">flush</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fflush</span>(fp_);<span class="comment">//刷新文本的缓冲区，强制写完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::AsyncWrite_</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数的运行函数</span></span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(deque_-&gt;<span class="built_in">pop</span>(str)) &#123;<span class="comment">//不断取str，写进文本</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="built_in">fputs</span>(str.<span class="built_in">c_str</span>(), fp_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Log* <span class="title">Log::Instance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例函数</span></span><br><span class="line">    <span class="type">static</span> Log inst;</span><br><span class="line">    <span class="keyword">return</span> &amp;inst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::FlushLogThread</span><span class="params">()</span> </span>&#123;<span class="comment">//回调函数，调用运行函数</span></span><br><span class="line">    Log::<span class="built_in">Instance</span>()-&gt;<span class="built_in">AsyncWrite_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">//perror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  <span class="comment">// write</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">//readv</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize = <span class="number">1024</span>);</span><br><span class="line">    ~<span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">WritableBytes</span><span class="params">()</span> <span class="type">const</span></span>;       </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">PrependableBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RetrieveAll</span><span class="params">()</span> </span>;</span><br><span class="line">    <span class="function">std::string <span class="title">RetrieveAllToStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginWriteConst</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginWrite</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* Errno)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">BeginPtr_</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer_;<span class="comment">//buffer是一个vector...new一个得了，取地址比较简明</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; readPos_;<span class="comment">//原子类型，感觉还是用个互斥锁吧...资料太少了，查不到。不过操作buffer在顶层是被互斥锁锁住的，也许不用互斥</span></span><br><span class="line">    std::atomic&lt;std::<span class="type">size_t</span>&gt; writePos_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BUFFER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-26</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buffer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">int</span> initBuffSize) : <span class="built_in">buffer_</span>(initBuffSize), <span class="built_in">readPos_</span>(<span class="number">0</span>), <span class="built_in">writePos_</span>(<span class="number">0</span>) &#123;&#125;<span class="comment">//初始化列表，使用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::ReadableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//准备好的字节数</span></span><br><span class="line">    <span class="keyword">return</span> writePos_ - readPos_;<span class="comment">//原子地相减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::WritableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//可写入的字节数</span></span><br><span class="line">    <span class="keyword">return</span> buffer_.<span class="built_in">size</span>() - writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Buffer::PrependableBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//已读字节数</span></span><br><span class="line">    <span class="keyword">return</span> readPos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::Peek</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回readpos之后的字符串/位置，即准备好但没有取出的数据的起始地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + readPos_;<span class="comment">//定位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Retrieve</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//buffer被取出了多少字节</span></span><br><span class="line">    <span class="built_in">assert</span>(len &lt;= <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    readPos_ += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveUntil</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* end)</span> </span>&#123;<span class="comment">//取到了end这个字符？说明有一段已经读了但没记录</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Peek</span>() &lt;= end );<span class="comment">//已读的记录比已取出的小，地址的比较</span></span><br><span class="line">    <span class="built_in">Retrieve</span>(end - <span class="built_in">Peek</span>());<span class="comment">//被出去了这么多字节（地址）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::RetrieveAll</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出，清空</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;buffer_[<span class="number">0</span>], buffer_.<span class="built_in">size</span>());</span><br><span class="line">    readPos_ = <span class="number">0</span>;</span><br><span class="line">    writePos_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Buffer::RetrieveAllToStr</span><span class="params">()</span> </span>&#123;<span class="comment">//全部取出并转字string</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(Peek(), ReadableBytes())</span></span>;</span><br><span class="line">    <span class="built_in">RetrieveAll</span>();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginWriteConst</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回写到的位置之后的字符串，有何意义？后面不是没写到吗</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginWrite</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个能写的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">BeginPtr_</span>() + writePos_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::HasWritten</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//已写入多少个字节</span></span><br><span class="line">    writePos_ += len;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;<span class="comment">//重载函数</span></span><br><span class="line">    <span class="built_in">Append</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//任何指针类型data</span></span><br><span class="line">    <span class="built_in">assert</span>(data);</span><br><span class="line">    <span class="built_in">Append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data), len);<span class="comment">//其他类型，就强制转型为char*</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终调用这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//char*优先匹配</span></span><br><span class="line">    <span class="built_in">assert</span>(str);</span><br><span class="line">    <span class="built_in">EnsureWriteable</span>(len);<span class="comment">//确保空间足够</span></span><br><span class="line">    std::<span class="built_in">copy</span>(str, str + len, <span class="built_in">BeginWrite</span>());</span><br><span class="line">    <span class="built_in">HasWritten</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::Append</span><span class="params">(<span class="type">const</span> Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加另一个buff的数据</span></span><br><span class="line">    <span class="built_in">Append</span>(buff.<span class="built_in">Peek</span>(), buff.<span class="built_in">ReadableBytes</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::EnsureWriteable</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//确保这么大的长度能写</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() &lt; len) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="built_in">MakeSpace_</span>(len);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">WritableBytes</span>() &gt;= len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::ReadFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//接收</span></span><br><span class="line">    <span class="type">char</span> buff[<span class="number">65535</span>];<span class="comment">//如果第一个缓冲区填不满，就用到这个缓冲区</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov[<span class="number">2</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> writable = <span class="built_in">WritableBytes</span>();</span><br><span class="line">    <span class="comment">/* 分散读， 保证数据全部读完 */</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = <span class="built_in">BeginPtr_</span>() + writePos_;<span class="comment">//定位可写的地方，不就是beginwrite()吗</span></span><br><span class="line">    iov[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    iov[<span class="number">1</span>].iov_base = buff;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> len = <span class="built_in">readv</span>(fd, iov, <span class="number">2</span>);<span class="comment">//2是指iovec结构的个数，返回值是有符号整型</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(len) &lt;= writable) &#123;<span class="comment">//转为无符号整型，长度是一样的</span></span><br><span class="line">        writePos_ += len;<span class="comment">//小于可写的地方就更新当前的buffer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//写的超出了buffer可写的空间</span></span><br><span class="line">        writePos_ = buffer_.<span class="built_in">size</span>();<span class="comment">//更新</span></span><br><span class="line">        <span class="built_in">Append</span>(buff, len - writable);<span class="comment">//添加buff的数据，会扩大buffer的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">Buffer::WriteFd</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span>* saveErrno)</span> </span>&#123;<span class="comment">//写出</span></span><br><span class="line">    <span class="type">size_t</span> readSize = <span class="built_in">ReadableBytes</span>();</span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">write</span>(fd, <span class="built_in">Peek</span>(), readSize);<span class="comment">//从当前开始（peek），写入准备好的数据</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *saveErrno = errno;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125; </span><br><span class="line">    readPos_ += len;<span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//char* 返回指向的字符串的首地址、也可以返回第一个字符、也可以返回整个字符串</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> </span>&#123;<span class="comment">//指向第一个char的地址</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();<span class="comment">//*begin()取第一个字符，&amp;取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">Buffer::BeginPtr_</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//区别是返回值要不要当常量处理</span></span><br><span class="line">    <span class="keyword">return</span> &amp;*buffer_.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::MakeSpace_</span><span class="params">(<span class="type">size_t</span> len)</span> </span>&#123;<span class="comment">//扩容函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">WritableBytes</span>() + <span class="built_in">PrependableBytes</span>() &lt; len) &#123;<span class="comment">//如果可写和已读都小于len，就必须重新开辟空间</span></span><br><span class="line">        buffer_.<span class="built_in">resize</span>(writePos_ + len + <span class="number">1</span>);<span class="comment">//resize</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//否则，可以把已读的覆盖</span></span><br><span class="line">        <span class="type">size_t</span> readable = <span class="built_in">ReadableBytes</span>();<span class="comment">//准备好的数据大小</span></span><br><span class="line">        std::<span class="built_in">copy</span>(<span class="built_in">BeginPtr_</span>() + readPos_, <span class="built_in">BeginPtr_</span>() + writePos_, <span class="built_in">BeginPtr_</span>());<span class="comment">//把中间未读的，从头开始覆盖</span></span><br><span class="line">        readPos_ = <span class="number">0</span>;<span class="comment">//已读为0</span></span><br><span class="line">        writePos_ = readPos_ + readable;<span class="comment">//写的位置是准备好的数据的位置</span></span><br><span class="line">        <span class="built_in">assert</span>(readable == <span class="built_in">ReadableBytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>注意：这里没有加锁，上层的调用要加锁</p>
<p>chrono可以稍微参考下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oncealong/article/details/28599655">(29条消息) C++11的chrono库，可实现毫秒微秒级定时_oncealong的博客-CSDN博客_chrono sleep</a>。里面提了三种类型，虽然不详细。</p>
<ul>
<li>std::chrono::high_resolution_clock：high_resolution_clock只不过是system_clock或者steady_clock的typedef。用于获取时间点。<ul>
<li>std::chrono::system_clock 它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</li>
<li>std::chrono::steady_clock 为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大。用在需要得到时间间隔，并且这个时间间隔不会因为修改系统时间而受影响的场景；它是单调的时钟，相当于教练手中的秒表；只会增长，适合用于记录程序耗时，他表示的时钟是不能设置的。</li>
<li>可以使用now()方法取得时间，是一个纳秒，相对系统启动的时间多少。一般用time_point：<code>std::chrono::high_resolution_clock::time_point t1=std::chrono::high_resolution_clock::now()</code>;或者<code>auto t1=std::chrono::high_resolution_clock::now();</code></li>
</ul>
</li>
<li>std::chrono::milliseconds：表示毫秒，是一个时间间隔。</li>
<li>在代码里面，now()+MS(timeout)被赋值到high_resolution_clock的time_point上，毫秒会转换为纳秒加上去。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; TimeoutCallBack;</span><br><span class="line"><span class="keyword">typedef</span> std::chrono::high_resolution_clock Clock;<span class="comment">//时钟</span></span><br><span class="line"><span class="keyword">typedef</span> std::chrono::milliseconds MS;<span class="comment">//时间间隔</span></span><br><span class="line"><span class="keyword">typedef</span> Clock::time_point TimeStamp;<span class="comment">//时钟内的时间点，获取now()方法结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TimerNode</span> &#123;<span class="comment">//时间结构</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//这个id用来给哈希表映射，这样查找时间是O(1)，通过id映射到位置。</span></span><br><span class="line">    TimeStamp expires;<span class="comment">//时间点</span></span><br><span class="line">    TimeoutCallBack cb;<span class="comment">//回调函数</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> TimerNode&amp; t) &#123;</span><br><span class="line">        <span class="keyword">return</span> expires &lt; t.expires;<span class="comment">//比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeapTimer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HeapTimer</span>() &#123; heap_.<span class="built_in">reserve</span>(<span class="number">64</span>); &#125;<span class="comment">//先指定vector有64个空间，其他情况下会两倍两倍的扩容</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">HeapTimer</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> newExpires)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeOut, <span class="type">const</span> TimeoutCallBack&amp; cb)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(<span class="type">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNextTick</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//用size_t作为索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">siftup_</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;TimerNode&gt; heap_;<span class="comment">//用vector实现堆，是一个小顶堆</span></span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">size_t</span>&gt; ref_;<span class="comment">//哈希表，i-&gt;size_t</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAP_TIMER_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-17</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heaptimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::siftup_</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123;<span class="comment">//向上过滤，用于插入节点</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap_[j] &lt; heap_[i]) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::SwapNode_</span><span class="params">(<span class="type">size_t</span> i, <span class="type">size_t</span> j)</span> </span>&#123;<span class="comment">//交换节点的辅助函数</span></span><br><span class="line">    <span class="built_in">assert</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(j &gt;= <span class="number">0</span> &amp;&amp; j &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">swap</span>(heap_[i], heap_[j]);<span class="comment">//交换vector元素</span></span><br><span class="line">    ref_[heap_[i].id] = i;<span class="comment">//更改哈希表的映射</span></span><br><span class="line">    ref_[heap_[j].id] = j;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapTimer::siftdown_</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> n)</span> </span>&#123;<span class="comment">//向下过滤，用于建堆和删除顶点。这里是左闭右开的，n是取不到的右边界</span></span><br><span class="line">    <span class="built_in">assert</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; heap_[j + <span class="number">1</span>] &lt; heap_[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(heap_[i] &lt; heap_[j]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, j);</span><br><span class="line">        i = j;</span><br><span class="line">        j = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i &gt; index;<span class="comment">//如果向下过滤了就返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::add</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout, <span class="type">const</span> TimeoutCallBack&amp; cb)</span> </span>&#123;<span class="comment">//插入节点，关联回调函数</span></span><br><span class="line">    <span class="built_in">assert</span>(id &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">if</span>(ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 新节点：堆尾插入，调整堆 */</span></span><br><span class="line">        i = heap_.<span class="built_in">size</span>();</span><br><span class="line">        ref_[id] = i;<span class="comment">//先放i处</span></span><br><span class="line">        <span class="comment">//结构体可以struct A = &#123;...&#125;，调用默认构造函数，但必须把所有成员都赋值。常见的是struct A; A.x = ...逐个赋值</span></span><br><span class="line">        heap_.<span class="built_in">push_back</span>(&#123;id, Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout), cb&#125;);<span class="comment">//放i处，调用默认构造函数</span></span><br><span class="line">        <span class="built_in">siftup_</span>(i);<span class="comment">//向上过滤</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果原来就有这个节点，说明没到时，重设时间，调整一下即可</span></span><br><span class="line">        <span class="comment">/* 已有结点：调整堆 */</span></span><br><span class="line">        i = ref_[id];<span class="comment">//获得位置</span></span><br><span class="line">        heap_[i].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);<span class="comment">//调整</span></span><br><span class="line">        heap_[i].cb = cb;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, heap_.<span class="built_in">size</span>())) &#123;<span class="comment">//调整之后看看向上还是向下，如果不用向下过滤，那就向上过滤；如果向下过滤了，就不用向上了</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::doWork</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定id结点，并触发回调函数 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>() || ref_.<span class="built_in">count</span>(id) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> i = ref_[id];</span><br><span class="line">    TimerNode node = heap_[i];<span class="comment">//拷贝节点，如果是串行的话，是不是不需要拷贝，反正是调用完再删除</span></span><br><span class="line">    node.<span class="built_in">cb</span>();<span class="comment">//调用回调函数</span></span><br><span class="line">    <span class="built_in">del_</span>(i);<span class="comment">//删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::del_</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 删除指定位置的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; heap_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">/* 将要删除的结点换到队尾，然后调整堆 */</span></span><br><span class="line">    <span class="type">size_t</span> i = index;</span><br><span class="line">    <span class="type">size_t</span> n = heap_.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//下标=大小-1</span></span><br><span class="line">    <span class="built_in">assert</span>(i &lt;= n);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n) &#123;<span class="comment">//删的不是最后一个元素就交换</span></span><br><span class="line">        <span class="built_in">SwapNode_</span>(i, n);<span class="comment">//把目前最后的元素换到前面去，此时要删的元素放到了最后</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">siftdown_</span>(i, n)) &#123;<span class="comment">//然后要调整这个元素的位置，先试一下向下过滤</span></span><br><span class="line">            <span class="built_in">siftup_</span>(i);<span class="comment">//不向下过滤的话就向上过滤。这里为什么要向上过滤呢？因为堆的兄弟之间没有关系，大堆有两个子堆，如果交换到另一个子堆就可能要向上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 队尾元素删除 */</span></span><br><span class="line">    ref_.<span class="built_in">erase</span>(heap_.<span class="built_in">back</span>().id);</span><br><span class="line">    heap_.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::adjust</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 调整指定id的结点 */</span></span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>() &amp;&amp; ref_.<span class="built_in">count</span>(id) &gt; <span class="number">0</span>);</span><br><span class="line">    heap_[ref_[id]].expires = Clock::<span class="built_in">now</span>() + <span class="built_in">MS</span>(timeout);</span><br><span class="line">    <span class="built_in">siftdown_</span>(ref_[id], heap_.<span class="built_in">size</span>());<span class="comment">//调整只可能更大，向下过滤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::tick</span><span class="params">()</span> </span>&#123;<span class="comment">//这里的tick()时间复杂度要比链表形式的高</span></span><br><span class="line">    <span class="comment">/* 清除超时结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TimerNode node = heap_.<span class="built_in">front</span>();<span class="comment">//取顶</span></span><br><span class="line">        <span class="comment">//这里先用预设时间-当前时间，结果是一个纳秒级的时间间隔，用间隔转换转到毫秒级，调用count()，它的作用是返回当前级别还有多少ticks（单位时间）</span></span><br><span class="line">        <span class="comment">//比如3ms就有3ticks（在毫秒级下），因此这里是忽略毫秒级以下的数，只有剩余1毫秒及以上才不算超时。这是因为设定的超时时间是毫秒的，当然只看毫秒</span></span><br><span class="line">        <span class="keyword">if</span>(std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(node.expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>() &gt; <span class="number">0</span>) &#123; <span class="comment">//等于0或小于0都超时</span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="built_in">cb</span>();<span class="comment">//超时，调用回调函数</span></span><br><span class="line">        <span class="built_in">pop</span>();<span class="comment">//删除顶部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!heap_.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="built_in">del_</span>(<span class="number">0</span>);<span class="comment">//删除0号位置的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapTimer::clear</span><span class="params">()</span> </span>&#123;<span class="comment">//清除</span></span><br><span class="line">    ref_.<span class="built_in">clear</span>();</span><br><span class="line">    heap_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapTimer::GetNextTick</span><span class="params">()</span> </span>&#123;<span class="comment">//看未超时的顶点剩下多少ticks</span></span><br><span class="line">    <span class="built_in">tick</span>();<span class="comment">//处理完超时的节点</span></span><br><span class="line">    <span class="type">size_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!heap_.<span class="built_in">empty</span>()) &#123;<span class="comment">//如果非空</span></span><br><span class="line">        res = std::chrono::<span class="built_in">duration_cast</span>&lt;MS&gt;(heap_.<span class="built_in">front</span>().expires - Clock::<span class="built_in">now</span>()).<span class="built_in">count</span>();<span class="comment">//看顶点还剩多少ticks（毫秒级别下）</span></span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; res = <span class="number">0</span>; &#125;<span class="comment">//负数说明预设时间小于当前时间，也就是时间间隔是负的，说明超时了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//-1说明空了，0说明超时了，大于0说明剩下的ticks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h2><p>涉及到一个string.data()，看到比较好的文章里面提到了一点：</p>
<p>为什么C语言风格的字符串要以’\0’结尾，C++（string）可以不要？</p>
<p>c语言用char*指针作为字符串时，在读取字符串时需要一个特殊字符0来标记指针的结束位置，也就是通常认为的字符串结束标记。而c++语言则是面向对象的（string），长度信息直接被存储在了对象的成员中，读取字符串可以直接根据这个长度来读取，所以就没必要需要结束标记了。而且结束标记也不利于读取字符串中夹杂0字符的字符串。</p>
<hr>
<ul>
<li>首先会尝试把文件信息写入stat结构体，根据文件找不找得到、文件权限，得到对应的状态码。stat结构体主要是获得文件size</li>
<li>如果状态码是404那些，就把路径和stat结构体修改为404那些html文件的路径，如果是200OK，就再不修改。</li>
<li>然后添加状态行、头部信息</li>
<li>最后添加文件内容信息：<ul>
<li>先根据文件路径打开文件，可能是404那些html，也可能是真的文件。如果打开失败，会返回一个file not found的html</li>
<li>打开成功的话会尝试去内存映射，stat结构体的size在这有用。如果映射失败，也会返回一个file not found的html</li>
<li>如果打开成功，会添加文件的长度信息，把内存地址指针保存，可通过接口调用。因为不会真正写入文件内容</li>
<li>在添加文件长度信息后，顺便添加一个空行。</li>
</ul>
</li>
<li>没有写入内容，等待外部写入。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-25</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HTTP_RESPONSE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HTTP_RESPONSE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>       <span class="comment">// open</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>      <span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>    <span class="comment">// stat</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>    <span class="comment">// mmap, munmap</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../buffer/buffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HttpResponse</span>();</span><br><span class="line">    ~<span class="built_in">HttpResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> std::string&amp; srcDir, std::string&amp; path, <span class="type">bool</span> isKeepAlive = <span class="literal">false</span>, <span class="type">int</span> code = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MakeResponse</span><span class="params">(Buffer&amp; buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">UnmapFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">File</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">FileLen</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorContent</span><span class="params">(Buffer&amp; buff, std::string message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Code</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> code_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddStateLine_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHeader_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddContent_</span><span class="params">(Buffer &amp;buff)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ErrorHtml_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetFileType_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code_;<span class="comment">//响应状态码</span></span><br><span class="line">    <span class="type">bool</span> isKeepAlive_;</span><br><span class="line"></span><br><span class="line">    std::string path_;<span class="comment">//资源路径</span></span><br><span class="line">    std::string srcDir_;<span class="comment">//资源文件夹路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>* mmFile_; <span class="comment">//指向内存映射后的文件的内存空间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> mmFileStat_;<span class="comment">//存储文件信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态的且不允许修改</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;std::string, std::string&gt; SUFFIX_TYPE;<span class="comment">//把后缀类型映射到http的文件类型</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_STATUS;<span class="comment">//把响应码映射到响应字符串</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; CODE_PATH;<span class="comment">//把响应码映射到响应需要发送的html文件的路径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HTTP_RESPONSE_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author       : mark</span></span><br><span class="line"><span class="comment"> * @Date         : 2020-06-27</span></span><br><span class="line"><span class="comment"> * @copyleft Apache 2.0</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;httpresponse.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员定义，用&#123;&#125;构造整体，用&#123;key,value&#125;构造元素</span></span><br><span class="line"><span class="type">const</span> unordered_map&lt;string, string&gt; HttpResponse::SUFFIX_TYPE = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;.html&quot;</span>,  <span class="string">&quot;text/html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xml&quot;</span>,   <span class="string">&quot;text/xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.xhtml&quot;</span>, <span class="string">&quot;application/xhtml+xml&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.txt&quot;</span>,   <span class="string">&quot;text/plain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.rtf&quot;</span>,   <span class="string">&quot;application/rtf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.pdf&quot;</span>,   <span class="string">&quot;application/pdf&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.word&quot;</span>,  <span class="string">&quot;application/nsword&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.png&quot;</span>,   <span class="string">&quot;image/png&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gif&quot;</span>,   <span class="string">&quot;image/gif&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpg&quot;</span>,   <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.jpeg&quot;</span>,  <span class="string">&quot;image/jpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.au&quot;</span>,    <span class="string">&quot;audio/basic&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpeg&quot;</span>,  <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.mpg&quot;</span>,   <span class="string">&quot;video/mpeg&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.avi&quot;</span>,   <span class="string">&quot;video/x-msvideo&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.gz&quot;</span>,    <span class="string">&quot;application/x-gzip&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.tar&quot;</span>,   <span class="string">&quot;application/x-tar&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.css&quot;</span>,   <span class="string">&quot;text/css &quot;</span>&#125;,</span><br><span class="line">    &#123; <span class="string">&quot;.js&quot;</span>,    <span class="string">&quot;text/javascript &quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_STATUS = &#123;</span><br><span class="line">    &#123; <span class="number">200</span>, <span class="string">&quot;OK&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;Bad Request&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> unordered_map&lt;<span class="type">int</span>, string&gt; HttpResponse::CODE_PATH = &#123;</span><br><span class="line">    &#123; <span class="number">400</span>, <span class="string">&quot;/400.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">403</span>, <span class="string">&quot;/403.html&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">404</span>, <span class="string">&quot;/404.html&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    code_ = <span class="number">-1</span>;</span><br><span class="line">    path_ = srcDir_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HttpResponse::~<span class="built_in">HttpResponse</span>() &#123;</span><br><span class="line">    <span class="built_in">UnmapFile</span>();<span class="comment">//解除内存映射，不用参数，用mmFile_指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::Init</span><span class="params">(<span class="type">const</span> string&amp; srcDir, string&amp; path, <span class="type">bool</span> isKeepAlive, <span class="type">int</span> code)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(srcDir != <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123; <span class="built_in">UnmapFile</span>(); &#125;<span class="comment">//一个类实例可以多次init？多次的话就要把原来的映射解除</span></span><br><span class="line">    code_ = code;<span class="comment">//传入的状态，会根据之后的文件打开/访问成功与否改变</span></span><br><span class="line">    isKeepAlive_ = isKeepAlive;</span><br><span class="line">    <span class="comment">//访问的文件路径</span></span><br><span class="line">    path_ = path;</span><br><span class="line">    srcDir_ = srcDir;</span><br><span class="line">    mmFile_ = <span class="literal">nullptr</span>; </span><br><span class="line">    mmFileStat_ = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向buff写入响应信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::MakeResponse</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//传入一个buff，没有真正写入文件内容（file not found除外，自定义返回了一个html）</span></span><br><span class="line">    <span class="comment">/* 判断请求的资源文件 */</span></span><br><span class="line">    <span class="comment">//stat函数，向stat结构体中写入path指定的文件信息，成功返回0，失败返回-1</span></span><br><span class="line">    <span class="comment">//S_ISDIR()函数的作用是判断一个路径是不是目录，st_mode表示了文件对应的模式：文件，目录等。函数返回0表示是文件，返回1是文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_) &lt; <span class="number">0</span> || <span class="built_in">S_ISDIR</span>(mmFileStat_.st_mode)) &#123;<span class="comment">//如果请求的文件不存在或者是文件夹，就404not found</span></span><br><span class="line">        code_ = <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//st_mode是个32位的整型变量，不过现在的linux操作系统只用了低16位（估计是鉴于以后拓展的考虑）</span></span><br><span class="line">    <span class="comment">//最低9位代表了文件的许可权限，它标识了文件所有者（owner）、组用户（group）、其他用户（other）的读（r）、写（w）、执行（x）权限。</span></span><br><span class="line">    <span class="comment">//S_IROTH：00004（无符号八进制数）：others have read permission</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(mmFileStat_.st_mode &amp; S_IROTH)) &#123;<span class="comment">//也即，如果其他用户没有读权限的话就返回403forbidden</span></span><br><span class="line">        code_ = <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code_ == <span class="number">-1</span>) &#123; <span class="comment">//如果上面都没有，且没有被init为400，那就是初始值-1，表示ok</span></span><br><span class="line">        code_ = <span class="number">200</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ErrorHtml_</span>();<span class="comment">//如果是error状态，会把对应的html页面文件信息添加到stat结构体中，把路径改了，成功就不做任何事情</span></span><br><span class="line">    <span class="built_in">AddStateLine_</span>(buff);<span class="comment">//添加状态行</span></span><br><span class="line">    <span class="built_in">AddHeader_</span>(buff);<span class="comment">//添加头部信息</span></span><br><span class="line">    <span class="built_in">AddContent_</span>(buff);<span class="comment">//返回文件内容，会尝试真正地打开文件，映射到内存，但是没有写入buff，会把内存指针放到mmFile_，File()接口调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">HttpResponse::File</span><span class="params">()</span> </span>&#123;<span class="comment">//返回文件映射到内存的位置</span></span><br><span class="line">    <span class="keyword">return</span> mmFile_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">HttpResponse::FileLen</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="comment">//返回文件的大小</span></span><br><span class="line">    <span class="keyword">return</span> mmFileStat_.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorHtml_</span><span class="params">()</span> </span>&#123;<span class="comment">//如果是200OK，就不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span>(CODE_PATH.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有响应码对应的html文件，count找到返回1，否则0</span></span><br><span class="line">        path_ = CODE_PATH.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//find返回一个迭代器，first是key，second是value。</span></span><br><span class="line">        <span class="comment">//感觉可以用CODE_PATH[code_]，因为前面已经找到了才执行，虽说内部也会遍历去find。另外，如果直接用[]，没有这个元素会插入</span></span><br><span class="line">        <span class="built_in">stat</span>((srcDir_ + path_).<span class="built_in">data</span>(), &amp;mmFileStat_);<span class="comment">//把这个错误页面文件信息保存到stat中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddStateLine_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//向buff添加状态头部</span></span><br><span class="line">    string status;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;<span class="comment">//如果有code_对应的状态</span></span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;<span class="comment">//获取状态字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//上面处理了200，404，403，如果code_不知道被赋值成什么了，就400</span></span><br><span class="line">        code_ = <span class="number">400</span>;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(<span class="number">400</span>)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;HTTP/1.1 &quot;</span> + <span class="built_in">to_string</span>(code_) + <span class="string">&quot; &quot;</span> + status + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddHeader_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加头部信息</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Connection: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(isKeepAlive_) &#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive\r\n&quot;</span>);</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;keep-alive: max=6, timeout=120\r\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        buff.<span class="built_in">Append</span>(<span class="string">&quot;close\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-type: &quot;</span> + <span class="built_in">GetFileType_</span>() + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::AddContent_</span><span class="params">(Buffer&amp; buff)</span> </span>&#123;<span class="comment">//添加返回内容</span></span><br><span class="line">    <span class="comment">//打开文件，string.data()返回c式字符串指针，c++11后与c_str()等价，结尾加&#x27;\0&#x27;。</span></span><br><span class="line">    <span class="type">int</span> srcFd = <span class="built_in">open</span>((srcDir_ + path_).<span class="built_in">data</span>(), O_RDONLY);<span class="comment">//O_RDONLY表示只读</span></span><br><span class="line">    <span class="keyword">if</span>(srcFd &lt; <span class="number">0</span>) &#123; <span class="comment">//打开失败</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射到内存提高文件的访问速度 </span></span><br><span class="line"><span class="comment">        MAP_PRIVATE 建立一个写入时拷贝的私有映射*/</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;file path %s&quot;</span>, (srcDir_ + path_).<span class="built_in">data</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成功返回创建的映射区的首地址；失败返回宏MAP_FAILED，这个宏就是-1。mmap返回一个void*</span></span><br><span class="line">    <span class="comment">//返回值用mmret指向，表示指向一个int类型，解指针时以int类型解析，找4个字节</span></span><br><span class="line">    <span class="type">int</span>* mmRet = (<span class="type">int</span>*)<span class="built_in">mmap</span>(<span class="number">0</span>, mmFileStat_.st_size, PROT_READ, MAP_PRIVATE, srcFd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(*mmRet == <span class="number">-1</span>) &#123;<span class="comment">//取int，如果是-1表示失败了</span></span><br><span class="line">        <span class="built_in">ErrorContent</span>(buff, <span class="string">&quot;File NotFound!&quot;</span>);<span class="comment">//这里的notfound，实际上打开了文件了，但是写进内存出错了</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取地址，修改指向的类型，两个指针指向的地址起始相同，但现在解指针按照char的解析类型解析，找一个字节。</span></span><br><span class="line">    <span class="comment">//多少个字节都无妨，因为munmap传入的地址参数类型是void*指针，只要首地址正确就好</span></span><br><span class="line">    mmFile_ = (<span class="type">char</span>*)mmRet;</span><br><span class="line">    <span class="built_in">close</span>(srcFd);<span class="comment">//关闭文件</span></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(mmFileStat_.st_size) + <span class="string">&quot;\r\n\r\n&quot;</span>);<span class="comment">//只添加内容长度，两个\r\n，后面那个表示空行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::UnmapFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mmFile_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(mmFile_, mmFileStat_.st_size);<span class="comment">//解除映射</span></span><br><span class="line">        mmFile_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">HttpResponse::GetFileType_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 判断文件类型 */</span></span><br><span class="line">    <span class="comment">//find_last_of返回最后一个.的位置，就是后缀类型前面那个.。逆向查找，返回的是下标</span></span><br><span class="line">    <span class="comment">//size_type是string的长度表示方式，不同的机器大小不同，为了匹配机器上string的最大长度。因此找位置、长度这些要用size_type</span></span><br><span class="line">    string::size_type idx = path_.<span class="built_in">find_last_of</span>(<span class="string">&#x27;.&#x27;</span>);<span class="comment">//找不到返回string::npos，表示不存在位置，值是-1</span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string suffix = path_.<span class="built_in">substr</span>(idx);<span class="comment">//从.开始返回后缀</span></span><br><span class="line">    <span class="keyword">if</span>(SUFFIX_TYPE.<span class="built_in">count</span>(suffix) == <span class="number">1</span>) &#123;<span class="comment">//有相应的类型就返回</span></span><br><span class="line">        <span class="keyword">return</span> SUFFIX_TYPE.<span class="built_in">find</span>(suffix)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain&quot;</span>;<span class="comment">//没有相应类型就返回这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpResponse::ErrorContent</span><span class="params">(Buffer&amp; buff, string message)</span> <span class="comment">//自定义错误信息，在添加内容时遇到错误就返回这个html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string body;</span><br><span class="line">    string status;</span><br><span class="line">    body += <span class="string">&quot;&lt;html&gt;&lt;title&gt;Error&lt;/title&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;body bgcolor=\&quot;ffffff\&quot;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(CODE_STATUS.<span class="built_in">count</span>(code_) == <span class="number">1</span>) &#123;</span><br><span class="line">        status = CODE_STATUS.<span class="built_in">find</span>(code_)-&gt;second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    body += <span class="built_in">to_string</span>(code_) + <span class="string">&quot; : &quot;</span> + status  + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;p&gt;&quot;</span> + message + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">    body += <span class="string">&quot;&lt;hr&gt;&lt;em&gt;TinyWebServer&lt;/em&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    buff.<span class="built_in">Append</span>(<span class="string">&quot;Content-length: &quot;</span> + <span class="built_in">to_string</span>(body.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    buff.<span class="built_in">Append</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jysama.cn/2022/09/21/websever-c++11/" title="TinyWebServer-C++11">https://jysama.cn/2022/09/21/websever-c++11/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/09/TinyWebServer/" rel="prev" title="Follow-TinyWebServer">
      <i class="fa fa-chevron-left"></i> Follow-TinyWebServer
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjM2Ny8zMjgzMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">日志系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">4.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP"><span class="nav-number">6.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="nav-number">6.1.</span> <span class="nav-text">处理响应</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">281k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
