<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jysama.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="GitHub上的项目：qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)，这篇博客记录一下follow的日程和更详细的注解和逻辑思考。整个工程作者没有透露完成顺序，我就根据自己的理解从一个部分开始逐步往下。 第一站lock服务器需要一些互斥操作，因为一些共享资源（如数据库连接池、线程池）被同时访问时会出现错误，需要互斥访问。">
<meta property="og:type" content="article">
<meta property="og:title" content="Follow-TinyWebServer">
<meta property="og:url" content="https://jysama.cn/2022/09/09/TinyWebServer/index.html">
<meta property="og:site_name" content="JySama">
<meta property="og:description" content="GitHub上的项目：qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)，这篇博客记录一下follow的日程和更详细的注解和逻辑思考。整个工程作者没有透露完成顺序，我就根据自己的理解从一个部分开始逐步往下。 第一站lock服务器需要一些互斥操作，因为一些共享资源（如数据库连接池、线程池）被同时访问时会出现错误，需要互斥访问。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%951.png">
<meta property="og:image" content="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%952.png">
<meta property="article:published_time" content="2022-09-09T02:00:04.208Z">
<meta property="article:modified_time" content="2022-09-23T08:18:49.313Z">
<meta property="article:author" content="Jy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%951.png">

<link rel="canonical" href="https://jysama.cn/2022/09/09/TinyWebServer/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Follow-TinyWebServer | JySama</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JySama</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jysama.cn/2022/09/09/TinyWebServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jy">
      <meta itemprop="description" content="Re：从零开始的写博客生活">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JySama">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Follow-TinyWebServer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-09 10:00:04" itemprop="dateCreated datePublished" datetime="2022-09-09T10:00:04+08:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-23 16:18:49" itemprop="dateModified" datetime="2022-09-23T16:18:49+08:00">2022-09-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>GitHub上的项目：<a target="_blank" rel="noopener" href="https://github.com/qinguoyi/TinyWebServer">qinguoyi&#x2F;TinyWebServer: Linux下C++轻量级Web服务器学习 (github.com)</a>，这篇博客记录一下follow的日程和更详细的注解和逻辑思考。整个工程作者没有透露完成顺序，我就根据自己的理解从一个部分开始逐步往下。</p>
<h1 id="第一站"><a href="#第一站" class="headerlink" title="第一站"></a>第一站</h1><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>服务器需要一些互斥操作，因为一些共享资源（如数据库连接池、线程池）被同时访问时会出现错误，需要互斥访问。因此互斥作为一个小的辅助功能，在前面这里先进行分析。</p>
<p>locker.h代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span><span class="comment">//for mutex</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span><span class="comment">//for sem</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem</span>(<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//阻塞等待资源，资源获取后往下执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//执行完毕，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;<span class="comment">//信号量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span><span class="comment">//取类私有成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁对象，注意它本身不是指针，当参数时要用引用传入地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>)<span class="comment">//初始化不成功都返回异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pthread_mutex_destroy(&amp;m_mutex);</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">timewait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex, <span class="keyword">struct</span> timespec t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//static pthread_mutex_t m_mutex;</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;<span class="comment">//条件变量对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁mutex"><a href="#互斥锁mutex" class="headerlink" title="互斥锁mutex"></a>互斥锁mutex</h3><p>互斥锁主要是让一个资源锁起来，同一时间只能有一个活动在使用这个资源，其他的请求全部被卡住。项目中具体的实现不是用零散的mutex类的函数操作，而是用一个locker类封装好，构造和析构函数分别执行初始化和注销，这使得用户不需要手动去做（RAII思想，同时可以简化API较长的函数名，其他两个类也是这样的思想）。</p>
<ul>
<li>int pthread_mutex_init(<strong>pthread_mutex_t</strong> *restrict mutex,const <strong>pthread_mutexattr_t</strong> *restrict attr);<ul>
<li><strong>pthread_mutex_init</strong>() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空(<strong>NULL</strong>)，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。</li>
<li><strong>pthread_mutexattr_init</strong>() 函数成功完成之后会返回零，其他任何返回值都表示出现了错误。函数成功执行后，互斥锁被初始化为未锁住态。</li>
</ul>
</li>
<li>*<em>pthread_mutex_destroy()*<em>用于注销一个互斥锁，API定义如下：int <strong>pthread_mutex_destroy(pthread_mutex_t</strong> *<em>mute</em>x*</em>)*</em><ul>
<li>销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。由于在Linux中，互斥锁并不占用任何资源，因此LinuxThreads中的 pthread_mutex_destroy()除了检查锁状态以外（锁定状态则返回EBUSY）没有其他动作。</li>
</ul>
</li>
<li>int pthread_mutex_lock(pthread_mutex_t *mutex)：锁住，返回值为0成功；</li>
<li>int pthread_mutex_unlock(pthread_mutex_t *mutex)：解锁，返回值为0成功；</li>
</ul>
<p>简单来说：</p>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
<h3 id="信号量sem"><a href="#信号量sem" class="headerlink" title="信号量sem"></a>信号量sem</h3><p>信号量有数值大小，主要用来管理一个buffer，写入和读出都要满足buffer的边界，同样的取用资源也要在资源池满足的情况下进行。</p>
<ul>
<li>int sem_init(sem_t *sem, int pshared, unsigned int value);<ul>
<li>该函数初始化由 sem 指向的信号对象，并给它一个初始的整数值 value。pshared 控制信号量的类型，值为 0 代表该信号量用于多线程间的同步，值如果大于 0 表示可以共享，用于多个相关进程间的同步：参数 pshared &gt; 0 时指定了 sem 处于共享内存区域，所以可以在进程间共享该变量</li>
</ul>
</li>
<li>int sem_destroy(sem_t *sem);<ul>
<li>该函数用于对用完的信号量的清理。</li>
</ul>
</li>
<li>int sem_wait(sem_t *sem); <ul>
<li>sem_wait 是一个阻塞的函数，测试所指定信号量的值，它的操作是原子的。若 sem value &gt; 0，则该信号量值减去 1 并立即返回。若sem value &#x3D; 0，则阻塞直到 sem value &gt; 0，此时立即减去 1，然后返回。函数成功返回0，错误的话信号量的值不改动，返回-1。</li>
<li>还有另一个函数：sem_trywait 函数是非阻塞的函数，它会尝试获取获取 sem value 值，如果 sem value &#x3D; 0，不是阻塞住，而是直接返回一个错误 EAGAIN。</li>
</ul>
</li>
<li>int sem_post(sem_t *sem);<ul>
<li>把指定的信号量 sem 的值加 1，唤醒正在等待该信号量的任意线程。成功时返回 0；错误时，信号量的值没有更改，-1 被返回。</li>
</ul>
</li>
</ul>
<p>简单来说:</p>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
<h3 id="条件变量cond"><a href="#条件变量cond" class="headerlink" title="条件变量cond"></a>条件变量cond</h3><ul>
<li><p>int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *cattr);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。初始化一个条件变量。当参数cattr为空指针时，函数创建的是一个缺省的条件变量。否则条件变量的属性将由cattr中的属性值来决定。调用 pthread_cond_init函数时，参数cattr为空指针等价于cattr中的属性为缺省属性，只是前者不需要cattr所占用的内存开销。这个函数返回时，条件变量被存放在参数cv指向的内存中。</li>
</ul>
</li>
<li><p>int pthread_cond_destroy(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误。释放条件变量。需要注意的是只有在没有线程在该条件变量上等待时，才可以注销条件变量，否则会返回EBUSY。同时Linux在实现条件变量时，并没有为条件变量分配资源，所以在销毁一个条件变量时，只要注意该变量是否仍有等待线程即可。</li>
</ul>
</li>
<li><p>int pthread_cond_wait(pthread_cond_t *cv, pthread_mutex_t *mutex);</p>
<ul>
<li><p>返回值：函数成功返回0；任何其他返回值都表示错误。</p>
</li>
<li><p>为什么要关联一个mutex呢？无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求pthread_cond_wait()（或pthread_cond_timedwait()，下同）的竞争条件（Race Condition）。</p>
<ul>
<li>pthread_cond_wait(cond, mutex)的功能有3个：<ul>
<li>调用者线程首先释放mutex</li>
<li>然后阻塞，等待被别的线程唤醒</li>
<li>当调用者线程被唤醒后，调用者线程会再次获取mutex</li>
</ul>
</li>
<li>pthread_cond_wait(cond)的功能只有1个：<ul>
<li>调用者线程阻塞，等待被别的线程唤醒。</li>
</ul>
</li>
</ul>
<p>这里首先给一个简洁的回答：</p>
<ul>
<li><strong>通常的应用场景下，当前线程执行pthread_cond_wait时，处于临界区访问共享资源，存在一个mutex与该临界区相关联，这是理解pthread_cond_wait带有mutex参数的关键</strong></li>
<li>当前线程执行pthread_cond_wait前，已经获得了和临界区相关联的mutex；<strong>因为缺少其他条件</strong>，执行pthread_cond_wait会阻塞，但是在进入阻塞状态前，必须释放已经获得的mutex，让其它线程能够进入临界区</li>
<li>当前线程执行pthread_cond_wait后，阻塞等待的条件满足，条件满足时会被唤醒；被唤醒后，仍然处于临界区，因此被唤醒后必须再次获得和临界区相关联的mutex</li>
</ul>
<p>综上，调用pthread_cond_wait时，线程总是位于某个临界区，该临界区与mutex相关，pthread_cond_wait需要带有一个参数mutex，用于释放和再次获取mutex。</p>
</li>
</ul>
</li>
<li><p>int pthread_cond_timedwait(pthread_cond_t *cv,pthread_mutex_t *mp, const struct timespec * abstime);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>pthread_cond_timedwait()用于等待一个条件变量，等待条件变量的同时可以设置等待超时。这是一个非常有用的功能，如果不想一直等待某一条件变量，就可以使用这个函数。函数到了一定的时间，即使条件未发生也会解除阻塞。</li>
<li>条件变量默认使用的时间是CLOCK_REALTIME。通过clock_gettime()接口获取时间。</li>
</ul>
</li>
<li><p>int pthread_cond_signal(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数发送一个信号给另外一个正在处于阻塞等待状态的线程，使其脱离阻塞状态，继续执行。如果没有线程处在阻塞等待状态，pthread_cond_signal也会成功返回。</li>
</ul>
</li>
<li><p>int pthread_cond_broadcast(pthread_cond_t *cv);</p>
<ul>
<li>返回值：函数成功返回0；任何其他返回值都表示错误</li>
<li>函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cv被用来指定这个条件变量。当没有线程阻塞在这个条件变量上时，pthread_cond_broadcast函数无效。</li>
</ul>
</li>
</ul>
<h2 id="线程池threadpool"><a href="#线程池threadpool" class="headerlink" title="线程池threadpool"></a>线程池threadpool</h2><p>使用线程有动态方法和静态方法，动态方法是当一个工作需要完成时创建一个线程，当工作做完后释放线程。这种方式对资源的利用率高一些，但是耗费时间，因为要新创建、销毁线程。静态方法是使用线程池先创建好一系列等待请求的线程，当一个工作到来时直接分配空闲线程，工作完成后放回线程池。</p>
<p>线程池的代码放在threadpool.h中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../CGImysql/sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadpool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    <span class="built_in">threadpool</span>(<span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number = <span class="number">8</span>, <span class="type">int</span> max_request = <span class="number">10000</span>);</span><br><span class="line">    ~<span class="built_in">threadpool</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T *request, <span class="type">int</span> state)</span></span>;<span class="comment">//两种append，应该对应了不同的T的操作，实际上感觉重载就可以了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append_p</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;<span class="comment">//静态成员函数，是一个回调函数，后面会说明为什么要设置成静态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_thread_number;        <span class="comment">//线程池中的线程数，即可同时工作的数量</span></span><br><span class="line">    <span class="type">int</span> m_max_requests;         <span class="comment">//请求队列中允许的最大请求数，即最多同时等待的数量</span></span><br><span class="line">    <span class="type">pthread_t</span> *m_threads;       <span class="comment">//描述线程池的数组，其大小为m_thread_number</span></span><br><span class="line">    std::list&lt;T *&gt; m_workqueue; <span class="comment">//请求队列</span></span><br><span class="line">    locker m_queuelocker;       <span class="comment">//保护请求队列的互斥锁</span></span><br><span class="line">    sem m_queuestat;            <span class="comment">//是否有任务需要处理</span></span><br><span class="line">    connection_pool *m_connPool;  <span class="comment">//数据库</span></span><br><span class="line">    <span class="type">int</span> m_actor_model;          <span class="comment">//模型切换</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::<span class="built_in">threadpool</span>( <span class="type">int</span> actor_model, connection_pool *connPool, <span class="type">int</span> thread_number, <span class="type">int</span> max_requests) : <span class="built_in">m_actor_model</span>(actor_model),<span class="built_in">m_thread_number</span>(thread_number), <span class="built_in">m_max_requests</span>(max_requests), <span class="built_in">m_threads</span>(<span class="literal">NULL</span>),<span class="built_in">m_connPool</span>(connPool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_number &lt;= <span class="number">0</span> || max_requests &lt;= <span class="number">0</span>)    <span class="comment">//一些不合理请求的判断</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="type">pthread_t</span>[m_thread_number];	<span class="comment">//线程池的实作是一个线程数组</span></span><br><span class="line">    <span class="keyword">if</span> (!m_threads)	<span class="comment">//请求失败则m_threads是一个nullptr</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i)</span><br><span class="line">    &#123;	<span class="comment">//初始化线程池里的线程，返回值不为0说明失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_create</span>(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>)<span class="comment">//m_threads+i与m_threads[i]没区别</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在创建线程后，实现线程从主线程（进程）分离，这使得线程能在工作完后自动回收资源，具体在后面有写</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_detach</span>(m_threads[i]))<span class="comment">//感觉这个if和上面那个if的风格好不一样...</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~<span class="built_in">threadpool</span>()<span class="comment">//析构，new出来的delete掉</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_threads;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向请求队列添加请求</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T *request, <span class="type">int</span> state)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//多线程状态下工作，要互斥，否则request和list的修改会出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)<span class="comment">//超出最大请求，非阻塞返回。如果要阻塞的话，可以用一个full信号量控制</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    request-&gt;m_state = state;<span class="comment">//赋予状态，指读还是写</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);<span class="comment">//添加队列</span></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();<span class="comment">//信号量加一，告知线程池有任务在等待处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和上面一样</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadpool&lt;T&gt;::<span class="built_in">append_p</span>(T *request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//worker函数，传递参数给线程，然后调用真正的run函数工作。静态成员类外定义不用static</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> *threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span> *arg)<span class="comment">//void 指针可以指向任意类型的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    threadpool *pool = (threadpool *)arg;<span class="comment">//arg = this，将参数强转为线程池类，调用成员方法</span></span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();<span class="comment">//调用实例的run函数</span></span><br><span class="line">    <span class="keyword">return</span> pool;<span class="comment">//实际上run一直运行，估计不会return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//为什么是while呢？因为每个线程其实在不断的运行，如果有任务就取出来做，没有就wait阻塞</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();<span class="comment">//阻塞，要等有任务即前面post信号量了，才往下做</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();<span class="comment">//取出任务，要对list操作，那么要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_workqueue.<span class="built_in">empty</span>())<span class="comment">//感觉没必要，前面用wait其实已经判断了工作池buffer了，有任务才会往下</span></span><br><span class="line">        &#123;<span class="comment">//m_workqueue的大小应该和m_queuestat信号量的大小绑定了（根据append函数来看）</span></span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T *request = m_workqueue.<span class="built_in">front</span>();<span class="comment">//取第一个请求</span></span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();<span class="comment">//pop</span></span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();<span class="comment">//解锁，让下一个线程可以操作list</span></span><br><span class="line">        <span class="keyword">if</span> (!request)<span class="comment">//如果请求实际上是null</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//切换模式，reactor==1，proactor==0</span></span><br><span class="line">        <span class="comment">//非阻塞同步工作模式，读写均需要在线程里工作，调用read和write，并且进行最后的process业务逻辑处理。</span></span><br><span class="line">        <span class="comment">//非阻塞是指有数据才进行，但数据处理过程仍在线程里执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_actor_model)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == request-&gt;m_state)<span class="comment">//读</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">read_once</span>())<span class="comment">//如果成功则不关闭定时器，不用关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;request-&gt;mysql, m_connPool)</span></span>;</span><br><span class="line">                    request-&gt;<span class="built_in">process</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//不成功要关闭连接和定时器</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//写</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">write</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//模拟proactor模式的IO在主循环处理（是同步的），线程只需要处理业务逻辑即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            connectionRAII <span class="built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);</span><br><span class="line">            request-&gt;<span class="built_in">process</span>();<span class="comment">//处理业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>线程池类使用模板，目前还没看出作用，猜测是后面会用于多种不同资源的分配使用，如处理http连接、处理数据库请求等等。</li>
<li>int<code> </code>pthread_create(pthread_t *tidp,<code> </code>const<code> </code>pthread_attr_t *attr,(<code> </code>void<code> </code>*)(*start_rtn)(<code> </code>void<code> </code>*),<code> </code>void<code> </code>*arg);<ul>
<li>第一个参数为指向线程 标识符的指针。</li>
<li>第二个参数用来设置线程属性。</li>
<li>第三个参数是线程运行函数的起始地址（函数指针）。</li>
<li>最后一个参数是运行函数的参数。</li>
<li>若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。</li>
</ul>
</li>
<li>int pthread_detach(pthread_t thread);  成功：0；失败：错误号<ul>
<li>使用pthread_create创建的线程有两种状态：joinable和unjoinable。默认是joinable 状态。</li>
<li>线程创建后在线程中调用 pthread_detach, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。</li>
<li>pthread_detach()和pthread_join()就是控制子线程回收资源的两种不同的方式。同一进程间的线程具有共享和独立的资源，其中共享的资源有堆、全局变量、静态变量、文件等公用资源。而独享的资源有栈和寄存器，这两种方式就是决定子线程结束时如何回收独享的资源。<ul>
<li>如果是joinable状态，则该线程结束后（通过pthread_exit结束或者线程执行体任务执行完毕）不会释放线程所占用堆栈和线程描述符（总计8K多）等资源，除非在主线程调用了pthread_join函数之后才会释放。pthread_join函数一般应用在主线程需要等待子线程结束后才继续执行的场景。(pthread_join是一个阻塞函数，调用方会阻塞到pthread_join所指定的tid的线程结束后才被回收，但是在此之前，调用方是霸占系统资源的。 )</li>
<li>如果是unjoinable状态，则该线程结束后会自动释放占用资源。实现方式是在创建时指定属性，或者在线程执行体的最开始处添加一行：pthread_detach(pthread_self())；不会阻塞，调用它后，线程运行结束后会自动释放资源,后者非常方便。</li>
</ul>
</li>
<li>总结<ul>
<li>pthread_detach()即主线程与子线程分离，两者相互不干涉，子线程结束同时子线程的资源自动回收。</li>
<li>pthread_join()即是子线程合入主线程，主线程会一直阻塞，直到子线程执行结束，然后回收子线程资源，并继续执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作流程</strong>：<ul>
<li>构造函数初始化线程池：创建线程和分离线程状态</li>
<li>析构函数销毁线程池</li>
<li>append函数互斥地向list添加请求，并post信号量</li>
<li>一个线程对应一个worker，worker函数调用run。</li>
<li>run函数从list互斥地获得请求并工作，不断循环</li>
</ul>
</li>
<li>worker函数是一个成员函数，那么必须是一个静态的。它是一个回调函数，回调函数是通过指针调用的函数，最常使用的回调函数就是在创建线程时（pthread_create），以一个函数指针以及传递给这个函数多个参数来调用线程函数来创建线程。那么一般的类成员函数是不能用作回调函数的，因为在使用回调函数时，会传递指定的符合回调函数声明的的参数给回调函数，而类成员函数隐式包含一个this指针参数，所以把类成员函数当作回调函数编译时会因为参数不匹配会出错（回调后多了个this，与声明不一致）。<ul>
<li>静态成员函数就没有这个问题，里面没有this指针。</li>
</ul>
</li>
<li>那么为什么要用worker间接调用run函数呢？run设计成静态的直接调用不行吗？<ul>
<li>答案是不太方便，因为静态成员函数只能访问静态成员数据、其他静态成员和类外部的函数，因为没有this指针。不过我们这里手动传入了this指针使得它可以调用run成员函数。</li>
<li>this指针只能在类内部使用而不能在外部使用。可以访问类中所有public、private、protect的成员函数和变量。this指针是指向对象的实例，所以只有当对象被创建时this指针才有效。</li>
<li>同一个模板类的不同实例共享静态成员函数，不同实例有不同的资源，这导致静态成员函数不能访问那些实例各有的资源，因为不知道要访问哪个。而run要操作不同实例的list等等资源，通过共享的worker使用从线程传入的this指针操作各个实例的run函数，run就能操作自己这个实例的资源了。但如果run是静态的，即使通过手动传入this参数，run里面所有的资源都要this-&gt;一下，太不方便了。</li>
<li>因此，最好的方式就是静态成员函数通过this指针调用成员函数，这个成员函数就可以很方便地访问类实例的资源了（说白了就是使用资源不用this-&gt;了）。</li>
</ul>
</li>
</ul>
<h1 id="第二站"><a href="#第二站" class="headerlink" title="第二站"></a>第二站</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>后面会用到单例模式，这里先详解一下，参考了许多文章。</p>
<h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>保证整个系统中一个类只有一个对象的实例，实现这种功能的方式就叫单例模式。</p>
<h3 id="为什么要用单例模式"><a href="#为什么要用单例模式" class="headerlink" title="为什么要用单例模式?"></a>为什么要用单例模式?</h3><p><strong>1、单例模式节省公共资源</strong></p>
<p>比如：大家都要喝水，但是没必要每人家里都打一口井是吧，通常的做法是整个村里打一个井就够了，大家都从这个井里面打水喝。</p>
<p>对应到我们计算机里面，像日志管理、打印机、<strong>数据库连接池</strong>、应用配置。</p>
<p><strong>2、单例模式方便控制</strong></p>
<p>就像日志管理，如果多个人同时来写日志，你一笔我一笔那整个日志文件都乱七八糟，如果想要控制日志的正确性，那么必须要对关键的代码进行上锁，只能一个一个按照顺序来写，而单例模式只有一个人来向日志里写入信息方便控制，避免了这种多人干扰的问题出现。</p>
<h3 id="实现单例模式的思路"><a href="#实现单例模式的思路" class="headerlink" title="实现单例模式的思路"></a>实现单例模式的思路</h3><p><strong>1.</strong> <strong>构造私有:</strong></p>
<p>如果要保证一个类不能多次被实例化，那么我肯定要<strong>阻止对象被new</strong> 出来，所以需要把<strong>类的所有构造方法私有化</strong>。</p>
<p><strong>2.以静态方法返回实例</strong>。</p>
<p>因为外界就不能通过new来获得对象，所以我们要通过提供类的方法来让外界获取对象实例。</p>
<p><strong>3.确保对象实例只有一个</strong>。</p>
<p>只对类进行一次实例化，以后都直接获取第一次实例化的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">	<span class="comment">//确保对象实例只有一个。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">	<span class="comment">//构造方法私有</span></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//以静态方法返回实例</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里类的实例在类初始化的时候已经生成，不再进行第二次实例化了，而外界只能通过SingleCase.getInstance()方法来获取SingleCase对象， 所以这样就保证整个系统只能获取一个类的对象实例。</p>
<h3 id="单例模式的两种实现模式"><a href="#单例模式的两种实现模式" class="headerlink" title="单例模式的两种实现模式"></a>单例模式的两种实现模式</h3><p>饿汉模式：就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：简单</span><br><span class="line">缺点：可能会导致进程启动慢，且如果有多个单例类对象实例启动顺序不确定。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// C++98 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="comment">// or</span></span><br><span class="line">	<span class="comment">// C++11</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton::m_instance; <span class="comment">// 在程序入口之前就完成单例对象的初始化</span></span><br></pre></td></tr></table></figure>

<p>如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化，就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。</p>
<hr>
<p>懒汉模式：等到用的的时候程序再创建实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。</span><br><span class="line">缺点：复杂 </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 注意多线程环境下一定要使用Double-Check的方式加锁，才能保证效率和线程安全</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">			m_mtx.<span class="built_in">lock</span>();</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">nullptr</span> == m_pInstance) &#123;</span><br><span class="line">				m_pInstance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			m_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 实现一个内嵌垃圾回收类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CGarbo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		~<span class="built_in">CGarbo</span>()&#123;</span><br><span class="line">			<span class="keyword">if</span> (Singleton::m_pInstance)</span><br><span class="line">				<span class="keyword">delete</span> Singleton::m_pInstance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 定义一个静态成员变量，程序结束时，系统会自动调用它的析构函数从而释放单例对象</span></span><br><span class="line">	<span class="type">static</span> CGarbo Garbo;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 构造函数私有</span></span><br><span class="line">	<span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line">	<span class="comment">// 防拷贝</span></span><br><span class="line">	<span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">	<span class="type">static</span> Singleton* m_pInstance; <span class="comment">// 单例对象指针</span></span><br><span class="line">	<span class="type">static</span> mutex m_mtx; <span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_pInstance = <span class="literal">nullptr</span>;</span><br><span class="line">Singleton::CGarbo Garbo;</span><br><span class="line">mutex Singleton::m_mtx;</span><br></pre></td></tr></table></figure>

<p>添加一个类的静态对象，总是让人不太满意，所以有人用如下方法来重新实现单例和解决它相应的问题，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">CSingleton</span>()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">CSingleton</span>(<span class="type">const</span> CSingleton &amp;);</span><br><span class="line">    CSingleton &amp; <span class="keyword">operator</span> = (<span class="type">const</span> CSingleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> CSingleton * <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">static</span> CSingleton instance;   <span class="comment">//局部静态变量，在这个局部静态函数销毁才销毁，也就是当程序结束才销毁</span></span><br><span class="line">		<span class="keyword">return</span> &amp;instance;<span class="comment">//不管怎么getinstance，都只定义一次instance，返回的都是同一个实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用局部静态变量是非常强大的方法，完全实现了单例的特性，而且代码量更少，也不用担心单例销毁的问题。</p>
<h2 id="sql数据库连接"><a href="#sql数据库连接" class="headerlink" title="sql数据库连接"></a>sql数据库连接</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>数据库连接的头文件声明了很多信息，我们先分析头文件的逻辑，再去看定义的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CONNECTION_POOL_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONNECTION_POOL_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../log/log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connection_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">MYSQL *<span class="title">GetConnection</span><span class="params">()</span></span>;				 <span class="comment">//获取数据库连接</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ReleaseConnection</span><span class="params">(MYSQL *conn)</span></span>; <span class="comment">//释放连接</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetFreeConn</span><span class="params">()</span></span>;					 <span class="comment">//获取空闲连接数目</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DestroyPool</span><span class="params">()</span></span>;					 <span class="comment">//销毁所有连接</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//单例模式</span></span><br><span class="line">	<span class="function"><span class="type">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string url, string User, string PassWord, string DataBaseName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">connection_pool</span>();</span><br><span class="line">	~<span class="built_in">connection_pool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_MaxConn;  <span class="comment">//最大连接数</span></span><br><span class="line">	<span class="type">int</span> m_CurConn;  <span class="comment">//当前已使用的连接数</span></span><br><span class="line">	<span class="type">int</span> m_FreeConn; <span class="comment">//当前空闲的连接数</span></span><br><span class="line">	locker lock;<span class="comment">//互斥锁</span></span><br><span class="line">	list&lt;MYSQL *&gt; connList; <span class="comment">//连接池</span></span><br><span class="line">	sem reserve;<span class="comment">//信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_url;			 <span class="comment">//主机地址</span></span><br><span class="line">	string m_Port;		 <span class="comment">//数据库端口号</span></span><br><span class="line">	string m_User;		 <span class="comment">//登陆数据库用户名</span></span><br><span class="line">	string m_PassWord;	 <span class="comment">//登陆数据库密码</span></span><br><span class="line">	string m_DatabaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">	<span class="type">int</span> m_close_log;	<span class="comment">//日志开关</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">connectionRAII</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双指针对MYSQL *con修改。数据库连接本身是指针类型，所以参数需要通过双指针才能对其进行修改。</span></span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;<span class="comment">//这个RAII类拥有一个MYSQL连接</span></span><br><span class="line">	connection_pool *poolRAII;<span class="comment">//且要有一个连接池指针指向那个单例对象，调用释放函数把MYSQL连接释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件里主要是对connection_pool这个类的功能进行了声明：</p>
<ul>
<li>四种主要功能：获取数据库连接、获取空闲连接数目、释放连接、销毁所有连接。四个功能函数实际上从返回值就可以看出区别和要做什么事。</li>
<li>数据库初始化init函数，它通过地址、端口、用户名密码、使用的数据库名称来进行数据库的连接。</li>
<li>单例模式，把构造函数放private，使得只能用静态成员函数在类中创建类对象；把析构函数放private，使得无法在外部delete类对象，只能用内部的成员函数delete this，因为内部成员函数才能访问私有的析构函数。不过这里的单例模式不用new，因此也就没有对应的delete函数。</li>
</ul>
<p>还有一个connectionRAII类，这个类对连接池对象进行RAII式的管理，前面可以看到有个释放连接的功能，我们不想手动释放，就可以在这个类的析构函数里释放，具体看实现就好了。</p>
<ul>
<li>为什么con是双指针，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/bin510729392/article/details/51476327">c&#x2F;c++向函数传递指针并修改其指向的问题_AlanChaw292的博客-CSDN博客_c++改变指针指向</a>。大概的意思就是，如果是单指针传进来，编译器也会为形参做一个备份，如传入一个p，会备份一个p1（我们实际上使用的是p1，跟值传递是一个意思），p和p1的值相同，都指向对象的地址。我们当然可以使用p1来修改指向的值，但无法通过修改p1修改p（就像形参无法影响实参），也就是说传入的指针不能修改指针本身的地址（不能修改指针的指向，不是不允许，而是没意义）。这种时候，就需要用双指针，指向我们想修改的指针的地址，这样就行了，那篇博客讲的很清楚。</li>
</ul>
<h3 id="cpp实现"><a href="#cpp实现" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>话不多说，先上源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sql_connection_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">connection_pool::<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;	<span class="comment">//类内成员初始化</span></span><br><span class="line">	m_CurConn = <span class="number">0</span>;<span class="comment">//已使用的是0</span></span><br><span class="line">	m_FreeConn = <span class="number">0</span>;<span class="comment">//空闲的还不知道，但是没有init时就是0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span><span class="comment">//静态成员函数，单例模式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> connection_pool connPool;<span class="comment">//创建静态的连接池对象，只定义一次，每次调用都返回它</span></span><br><span class="line">	<span class="keyword">return</span> &amp;connPool;<span class="comment">//且是通过指针（地址）返回，不会导致拷贝构造</span></span><br><span class="line">    <span class="comment">//这个静态对象销毁是在静态成员函数销毁时销毁，而这个函数在程序结束才销毁...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::init</span><span class="params">(string url, string User, string PassWord, string DBName, <span class="type">int</span> Port, <span class="type">int</span> MaxConn, <span class="type">int</span> close_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">//给类成员赋值，这些类成员是为了以后访问连接池对象可以获取信息</span></span><br><span class="line"></span><br><span class="line">	m_url = url;</span><br><span class="line">	m_Port = Port;</span><br><span class="line">	m_User = User;</span><br><span class="line">	m_PassWord = PassWord;</span><br><span class="line">	m_DatabaseName = DBName;</span><br><span class="line">	m_close_log = close_log;</span><br><span class="line">    m_MaxConn = m_FreeConn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MaxConn; i++)<span class="comment">//一共（最多）可以有maxconn个连接</span></span><br><span class="line">	&#123;</span><br><span class="line">		MYSQL *con = <span class="literal">NULL</span>;</span><br><span class="line">		con = <span class="built_in">mysql_init</span>(con);<span class="comment">//分配并初始化一个新对象</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//NULL说明没有足够的内存分配</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//前面的init初始化了一个mysql的数据结构，现在real connect进行真正的连接</span></span><br><span class="line">		con = <span class="built_in">mysql_real_connect</span>(con, url.<span class="built_in">c_str</span>(), User.<span class="built_in">c_str</span>(), PassWord.<span class="built_in">c_str</span>(), DBName.<span class="built_in">c_str</span>(), Port, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (con == <span class="literal">NULL</span>)<span class="comment">//连接失败返回NULL</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">LOG_ERROR</span>(<span class="string">&quot;MySQL Error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		connList.<span class="built_in">push_back</span>(con);<span class="comment">//成功则在连接池(list)里添加</span></span><br><span class="line">		++m_FreeConn;<span class="comment">//空闲连接+1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reserve = <span class="built_in">sem</span>(m_FreeConn);<span class="comment">//给这个信号量赋值，实际上可以在for循环里post，不过逻辑有点怪就是了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当有请求时，从数据库连接池中返回一个可用连接，更新使用和空闲连接数</span></span><br><span class="line"><span class="function">MYSQL *<span class="title">connection_pool::GetConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL *con = <span class="literal">NULL</span>;<span class="comment">//创建一个指针，将要指向连接池已经创建的连接</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == connList.<span class="built_in">size</span>())<span class="comment">//没有就没有了，不阻塞</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">wait</span>();<span class="comment">//有的话就让信号量减一，不过既然前面return了，不阻塞了还有信号量干啥嘞</span></span><br><span class="line">	</span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//互斥访问这个连接，修改连接池（连接池是共享的），以及互斥修改一些表示buffer大小数据</span></span><br><span class="line"></span><br><span class="line">	con = connList.<span class="built_in">front</span>();</span><br><span class="line">	connList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">	--m_FreeConn;<span class="comment">//连接池容量buffer-1</span></span><br><span class="line">	++m_CurConn;<span class="comment">//连接池buffer使用+1</span></span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放当前使用的连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">connection_pool::ReleaseConnection</span><span class="params">(MYSQL *con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == con)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//回收连接，放回连接池，既然访问连接池这个公共资源，要互斥锁住</span></span><br><span class="line"></span><br><span class="line">	connList.<span class="built_in">push_back</span>(con);<span class="comment">//放回</span></span><br><span class="line">	++m_FreeConn;</span><br><span class="line">	--m_CurConn;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">	reserve.<span class="built_in">post</span>();<span class="comment">//信号量+1，越发感觉信号量和freeconn是一个东西？以及connlist.size()...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁数据库连接池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connection_pool::DestroyPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">lock</span>();<span class="comment">//主线程要关闭连接池，要等连接池操作完再说，不然在销毁过程中可能又同时放回，会混乱</span></span><br><span class="line">    			<span class="comment">//且其他线程在获取连接时，也要等连接池销毁的操作，不然连接池都销毁了还拿到了一个连接</span></span><br><span class="line">	<span class="keyword">if</span> (connList.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		list&lt;MYSQL *&gt;::iterator it;</span><br><span class="line">		<span class="keyword">for</span> (it = connList.<span class="built_in">begin</span>(); it != connList.<span class="built_in">end</span>(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			MYSQL *con = *it;</span><br><span class="line">			<span class="built_in">mysql_close</span>(con);<span class="comment">//一个一个关闭掉，但mysql对象、结构还在list里</span></span><br><span class="line">		&#125;</span><br><span class="line">		m_CurConn = <span class="number">0</span>;<span class="comment">//这些遍历的修改也要在临界区嘛</span></span><br><span class="line">		m_FreeConn = <span class="number">0</span>;</span><br><span class="line">		connList.<span class="built_in">clear</span>();<span class="comment">//移除所有元素，把那些关闭了的连接都删掉</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前空闲的连接数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connection_pool::GetFreeConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_FreeConn;<span class="comment">//这个就不锁了，没什么意义，就放回“当下”的值就好了。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection_pool::~<span class="built_in">connection_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DestroyPool</span>();<span class="comment">//析构连接池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个RAII类是针对单个sql连接的，具体怎么使用还要看实际代码，</span></span><br><span class="line"><span class="comment">//注意这个双指针修改sql连接本身的值（指向连接的地址），使这个连接可以更改指向，（可能从null）指向连接池的可用的连接。</span></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">	*SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">	</span><br><span class="line">	conRAII = *SQL;<span class="comment">//这个RAII类本身也要存一个备份，使得调用析构函数释放连接时知道要释放的连接的地址</span></span><br><span class="line">	poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">	poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);<span class="comment">//析构函数：释放连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL *mysql_init(MYSQL *mysql)<ul>
<li>分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。</li>
<li>返回值：初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。</li>
</ul>
</li>
<li>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)<ul>
<li>mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。</li>
<li>参数：<ul>
<li>第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。</li>
<li>“host”的值必须是主机名或IP地址。如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP&#x2F;IP连接到服务器。</li>
<li>“user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串””，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名。</li>
<li>“passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。</li>
<li>“db”是数据库名称。如果db为NULL，连接会将默认的数据库设为该值。</li>
<li>如果“port”不是0，其值将用作TCP&#x2F;IP连接的端口号。注意，“host”参数决定了连接的类型。</li>
<li>如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。</li>
<li>client_flag的值通常为0，其他标志可以实现特定的功能</li>
</ul>
</li>
<li>返回值：如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。</li>
</ul>
</li>
<li>void mysql_close(MYSQL *mysql)<ul>
<li>关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。</li>
</ul>
</li>
<li>string.c_str()：<ul>
<li>const char *c_str();</li>
<li>c_str()函数返回一个指向正规C字符串的指针常量, 内容与本string串相同。</li>
<li>这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。</li>
</ul>
</li>
</ul>
<h1 id="第三站"><a href="#第三站" class="headerlink" title="第三站"></a>第三站</h1><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>这里可以看看作者的讲解先理解一下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg">最新版Web服务器项目详解 - 09 日志系统（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/f-ujwFyCe1LZa3EB561ehA">最新版Web服务器项目详解 - 10 日志系统（下） (qq.com)</a></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>写入日志有同步的写入和异步的写入方式，同步的方式是当产生日志时就写入，主线程工作推迟；异步的写入方式是使用一个日志线程来管理，“写入日志”这个任务就需要有地方放，因此就要用一个阻塞队列来存放任务。为什么是阻塞的呢，日志线程有多个吗？实际上日志线程只有一个，但其他线程可以有多个，这就是一个多生产者–单消费者的模型。因此常规的解法就是用互斥锁+buffer信号量的组合。但这个阻塞队列还添加了超时处理的功能，信号量就需要改成条件变量，条件变量我没怎么使用过，之后回过头再整理一下，不过具体的功能在lock那章中写了。</p>
<p>下面是阻塞队列的代码，在头文件block_queue.h中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">*循环数组实现的阻塞队列，m_back = (m_back + 1) % m_max_size;  </span></span><br><span class="line"><span class="comment">*线程安全，每个操作前都要先加互斥锁，操作完后，再解锁</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCK_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">block_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="type">int</span> max_size = <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[max_size];</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//剩下的操作，涉及对队列内部元素的操作（插入删除）、对队列变量的访问（size，头尾指针等），都需要互斥访问</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">block_queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_array != <span class="literal">NULL</span>)<span class="comment">//少见...不过健壮（也许多余？）</span></span><br><span class="line">            <span class="keyword">delete</span> [] m_array;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否满了</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//访问msize，要锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">front</span><span class="params">(T &amp;value)</span><span class="comment">//以参数形式返回 </span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_front];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">back</span><span class="params">(T &amp;value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == m_size)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_back];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;<span class="comment">//不直接return，因为要加锁，return不能放锁里</span></span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmp = m_max_size;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//往队列添加元素，需要将所有使用队列的线程先唤醒，这些线程除了等待锁，还要等待任务出现以pop，因此push要唤醒它们</span></span><br><span class="line">    <span class="comment">//在应用上，调用pop的就一个日志线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当有元素push进队列,相当于生产者生产了一个元素</span></span><br><span class="line">    <span class="comment">//若当前没有线程等待条件变量,则唤醒无意义</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_size &gt;= m_max_size)<span class="comment">//队列满了，赶紧让pop线程做事</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒所有在wait的线程</span></span><br><span class="line">            <span class="comment">//在wait说明之前队列空了，但怎么会从空-&gt;满呢？可能是一直被push抢了互斥锁</span></span><br><span class="line">            <span class="comment">//因此这个唤醒让那些卡在while的pop从wait解放，然后一个一个等待抢占互斥锁做事（和pop抢也和push抢）</span></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line"></span><br><span class="line">        m_size++;</span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pop时,如果当前队列没有元素,将会等待条件变量</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//条件变量在临界区用，wait自身会解锁-等待唤醒-抢占锁</span></span><br><span class="line">        <span class="comment">//pop被多个线程调用，前面push都唤醒了那么这里会竞争任务，可能只有一部分线程执行了这个m_size就=0了</span></span><br><span class="line">        <span class="comment">//那么此时就要继续等待，因此用while而不是用if，if只能wait一次（这种情况是虚假唤醒）</span></span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))<span class="comment">//等待唤醒</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//wait出错就return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//条件变量被唤醒，抢到了互斥锁，且whlie正常退出，开始做事</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加了超时处理</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="type">int</span> ms_timeout)</span><span class="comment">//可以超时多少毫秒</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//时间类下面介绍</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timespec</span> t = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个纳秒</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//一个秒，一个微秒</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//获取系统当前时间</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//如果要等待的话，就进去wait，注意这里不是一直等到可以调用，所以不用while</span></span><br><span class="line">        <span class="comment">//如果超时就到下面的if返回，如果没超时就被唤醒，那么会有虚假唤醒的情况，</span></span><br><span class="line">        <span class="comment">//因此下面还要if判断一下，虚假唤醒就直接返回，所以这里超时就不做、虚假唤醒也不做</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//t是前面获取的时间加上超时的时间</span></span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;<span class="comment">//取秒位</span></span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;<span class="comment">//剩下没取到的毫秒（余数）弄成纳秒（为什么是*1000）</span></span><br><span class="line">            <span class="comment">//整体时间计算是秒+纳秒</span></span><br><span class="line">            <span class="keyword">if</span> (!m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t))<span class="comment">//时间到了就不等待唤醒了，直接润</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上面润完就到这里，注意因为抢了锁，所以不可能有push，这里一定是返回的</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	   <span class="comment">//正常干活</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;</span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    cond m_cond;<span class="comment">//条件变量</span></span><br><span class="line"></span><br><span class="line">    T *m_array;<span class="comment">//队列空间</span></span><br><span class="line">    <span class="type">int</span> m_size;<span class="comment">//队列目前大小</span></span><br><span class="line">    <span class="type">int</span> m_max_size;<span class="comment">//队列大小，使用这个变量就无需额外留一个空间</span></span><br><span class="line">    <span class="type">int</span> m_front;<span class="comment">//队列头部</span></span><br><span class="line">    <span class="type">int</span> m_back;<span class="comment">//队列尾部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在C语言中可以使用函数gettimeofday()函数来得到精确时间。它的精度可以达到微妙，是C标准库的函数。</p>
<p>在gettimeofday()函数中tv或者tz都可以为空。如果为空则就不返回其对应的结构体。</p>
<p>函数执行成功后返回0，失败后返回-1，错误代码存于errno中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettimeofday</span><span class="params">(<span class="keyword">struct</span>  timeval*tv,<span class="keyword">struct</span>  timezone *tz )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span>  timeval</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_sec;  <span class="comment">/*秒*/</span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span>  tv_usec; <span class="comment">/*微妙*/</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">timezone</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_minuteswest;<span class="comment">/*和greenwich 时间差了多少分钟*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tz_dsttime;    <span class="comment">/*type of DST correction*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：在使用gettimeofday()函数时，第二个参数一般都为空，因为我们一般都只是为了获得当前时间，而不用获得timezone的数值。</p>
<h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>定义了Log类，其中使用宏来为其他程序提供接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span><span class="comment">//与宏有关</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;block_queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//C++11以后,使用局部变量懒汉不用加锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Log instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="type">void</span> *args)</span><span class="comment">//是一个worker函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();<span class="comment">//静态成员函数的调用：A::func()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可选择的参数有日志文件、日志缓冲区大小、最大行数以及最长日志条队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size = <span class="number">8192</span>, <span class="type">int</span> split_lines = <span class="number">5000000</span>, <span class="type">int</span> max_queue_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flush</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">async_write_log</span><span class="params">()</span><span class="comment">//write_log执行push任务的功能，这个函数只取任务写到文件</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string single_log;</span><br><span class="line">        <span class="comment">//从阻塞队列中取出一个日志string，写入文件</span></span><br><span class="line">        <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))<span class="comment">//取是互斥的，写也是互斥的，但是两个锁并不相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();<span class="comment">//写入m_fp中，共享的文件空间的要锁一下</span></span><br><span class="line">            <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> dir_name[<span class="number">128</span>]; <span class="comment">//路径名</span></span><br><span class="line">    <span class="type">char</span> log_name[<span class="number">128</span>]; <span class="comment">//log文件名</span></span><br><span class="line">    <span class="type">int</span> m_split_lines;  <span class="comment">//日志最大行数</span></span><br><span class="line">    <span class="type">int</span> m_log_buf_size; <span class="comment">//日志缓冲区大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_count;  <span class="comment">//日志行数记录</span></span><br><span class="line">    <span class="type">int</span> m_today;        <span class="comment">//因为按天分类,记录当前时间是那一天</span></span><br><span class="line">    FILE *m_fp;         <span class="comment">//打开log的文件指针</span></span><br><span class="line">    <span class="type">char</span> *m_buf;</span><br><span class="line">    block_queue&lt;string&gt; *m_log_queue; <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="type">bool</span> m_is_async;                  <span class="comment">//是否同步标志位</span></span><br><span class="line">    locker m_mutex;</span><br><span class="line">    <span class="type">int</span> m_close_log; <span class="comment">//关闭日志</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏接口，调用write_log和flush</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR(format, ...) <span class="keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="cpp实现-1"><a href="#cpp实现-1" class="headerlink" title=".cpp实现"></a>.cpp实现</h3><p>主要是一些string的操作，因为写日志就是把字符写入文件嘛</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Log::<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_count = <span class="number">0</span>;<span class="comment">//每次行数重置为0，包括天数的记录也会重置，所以如果关闭了的话前面的记录就不存在，重复写一个日志文件就可能出错，因此如果关掉程序再打开的话，最好换一个文件重新开始写</span></span><br><span class="line">    m_is_async = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log::~<span class="built_in">Log</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步需要设置阻塞队列的长度，同步不需要设置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Log::init</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">int</span> close_log, <span class="type">int</span> log_buf_size, <span class="type">int</span> split_lines, <span class="type">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果设置了max_queue_size,则设置为异步，只有一个线程在取任务处理</span></span><br><span class="line">    <span class="keyword">if</span> (max_queue_size &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;<span class="comment">//设置写入方式flag</span></span><br><span class="line">        m_log_queue = <span class="keyword">new</span> <span class="built_in">block_queue</span>&lt;string&gt;(max_queue_size);<span class="comment">//创建并设置阻塞队列长度</span></span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">//flush_log_thread为回调函数,这里表示创建线程异步写日志</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员初始化</span></span><br><span class="line">    m_close_log = close_log;<span class="comment">//1的话关闭日志功能</span></span><br><span class="line">    m_log_buf_size = log_buf_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="type">char</span>[m_log_buf_size];<span class="comment">//缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);<span class="comment">//缓冲区数值初始化</span></span><br><span class="line">    m_split_lines = split_lines;<span class="comment">//最大行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//见后面，实际上就是得到具体的本地的时间，年月日时分秒等等</span></span><br><span class="line">    <span class="type">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从后往前找到第一个/的位置</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//该函数见后面</span></span><br><span class="line">    <span class="type">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//接下来要生成一个具体的日志文件名</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接下来相当于自定义日志名</span></span><br><span class="line">    <span class="comment">//若输入的文件名没有/，则直接将时间+文件名作为日志名</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, file_name);<span class="comment">//该函数见后面</span></span><br><span class="line">        <span class="comment">//下面两行是我自己分析觉得要加上的地方，否则创建新日志的名字可能不协同</span></span><br><span class="line">        dir_name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        log_name = file_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有的话，就是一个路径了，就要从/后面开始添加时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将/的位置向后移动一个位置，然后复制到logname中</span></span><br><span class="line">   	    <span class="comment">//p - file_name + 1是文件所在路径文件夹的长度</span></span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);<span class="comment">//存一下log_name</span></span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);<span class="comment">//dirname相当于./，这里就比上面多一个路径名，不过把filename拆分为dirname和logname，补个时间</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    m_today = my_tm.tm_mday;<span class="comment">//更新日期</span></span><br><span class="line">    </span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);<span class="comment">//根据上面的一系列操作获得的名称打开文件或创建文件</span></span><br><span class="line">    <span class="comment">//a表示追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</span></span><br><span class="line">    <span class="keyword">if</span> (m_fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="type">int</span> level, <span class="type">const</span> <span class="type">char</span> *format, ...)</span><span class="comment">//可变参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取具体时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> now = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//返回当前距离1970年的秒数和微妙数</span></span><br><span class="line">    <span class="type">time_t</span> t = now.tv_sec;<span class="comment">//取得从1970年1月1日至今的秒数。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> *sys_tm = <span class="built_in">localtime</span>(&amp;t);<span class="comment">//将time_t表示的时间转换为经过时区转换的UTC时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> my_tm = *sys_tm;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志类型标头</span></span><br><span class="line">    <span class="keyword">switch</span> (level)<span class="comment">//日志分级</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入一个log，对m_count++</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//m_count和m_fp是共享的，要用锁修改，这就表明上面的时间是调用的时间而不是写的时间，因为锁要阻塞耗时</span></span><br><span class="line">    m_count++;<span class="comment">//先++，因为是从0开始的，++后判断是否到最大行数了</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//日志不是今天或写入的日志行数是最大行的倍数，这个时候要新换一个日志文件</span></span><br><span class="line">    <span class="comment">//m_split_lines为最大行数</span></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//日志内容</span></span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);<span class="comment">//把缓冲区的内容强制写入文件，准备换新文件了</span></span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);<span class="comment">//关闭</span></span><br><span class="line">        <span class="type">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//时间信息</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);<span class="comment">//02表示月份和日期以两位数的形式呈现</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)<span class="comment">//新的一天，换一个文件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);<span class="comment">//这里可能有点问题，因为dirname和logname不一定有，如果前面p是NULL的话，那么新的文件就只有日期了，前面最好更新一个logname</span></span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//这一天的日志行数太多了，要分文件，m_count / m_split_lines表示这是第几份</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);<span class="comment">//打开新文件，把日志系统当前写入的文件更换</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    va_list valst;<span class="comment">//解决变参问题的宏，下面介绍</span></span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);<span class="comment">//初始化，指向第一个参数地址</span></span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    <span class="comment">//接下来开始写内容</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();<span class="comment">//写缓冲区，要锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入的具体时间内容格式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);<span class="comment">//前面分级的s在这里出现，它是内容开头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时间、级别都写进缓冲区之后，把内容写入，内容就是可变参数，通过valst写入</span></span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - <span class="number">1</span>, format, valst);<span class="comment">//该函数后面介绍</span></span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//添加一个换行</span></span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//这一个缓冲区字符串结束</span></span><br><span class="line">    log_str = m_buf;<span class="comment">//变成string</span></span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())<span class="comment">//如果是异步的且阻塞队列有空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);<span class="comment">//把写的任务推入队列，参数就是要写的全部内容，不执行写的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//同步的话或者阻塞队列已经满了就直接写</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//互斥写入文件中</span></span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);<span class="comment">//清空参数列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::flush</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//强制刷新写入流缓冲区</span></span><br><span class="line">    <span class="built_in">fflush</span>(m_fp);</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的与时间类相关的知识：</p>
<ul>
<li><p>struct tm *localtime(const time_t *timer)</p>
</li>
<li><p>timer – 这是指向表示日历时间的 time_t 值的指针。</p>
</li>
<li><p>C 库函数 <strong>struct tm *localtime(const time_t *timer)</strong> 使用 timer 的值来填充 <strong>tm</strong> 结构。<strong>timer</strong> 的值被分解为 <strong>tm</strong> 结构，并用本地时区表示。</p>
</li>
<li><p>该函数返回指向 <strong>tm</strong> 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">   <span class="type">int</span> tm_sec;         <span class="comment">/* 秒，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_min;         <span class="comment">/* 分，范围从 0 到 59                */</span></span><br><span class="line">   <span class="type">int</span> tm_hour;        <span class="comment">/* 小时，范围从 0 到 23                */</span></span><br><span class="line">   <span class="type">int</span> tm_mday;        <span class="comment">/* 一月中的第几天，范围从 1 到 31                    */</span></span><br><span class="line">   <span class="type">int</span> tm_mon;         <span class="comment">/* 月份，范围从 0 到 11                */</span></span><br><span class="line">   <span class="type">int</span> tm_year;        <span class="comment">/* 自 1900 起的年数                */</span></span><br><span class="line">   <span class="type">int</span> tm_wday;        <span class="comment">/* 一周中的第几天，范围从 0 到 6                */</span></span><br><span class="line">   <span class="type">int</span> tm_yday;        <span class="comment">/* 一年中的第几天，范围从 0 到 365                    */</span></span><br><span class="line">   <span class="type">int</span> tm_isdst;       <span class="comment">/* 夏令时                        */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>char *strrchr(const char *str, int c)</p>
</li>
<li><p>C 库函数 <strong>char *strrchr(const char *str, int c)</strong> 在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</li>
<li><p>该函数返回 str 中最后一次出现字符 c 的位置。如果未找到该值，则函数返回一个空指针。</p>
</li>
<li><p>int snprintf ( char * str, size_t size, const char * format, … );</p>
</li>
<li><p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数**(…)<strong>按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，</strong>size** 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断。</p>
</li>
<li><p>返回值</p>
<ul>
<li>1、如果格式化后的字符串长度小于 <strong>size</strong>，则会把字符串全部复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>；</li>
<li>2、如果格式化后的字符串长度大于等于 <strong>size</strong>，超过 <strong>size</strong> 的部分会被截断，只将其中的 <strong>(size-1)</strong> 个字符复制到 <strong>str</strong> 中，并给其后添加一个字符串结束符 <strong>\0</strong>，返回值为欲写入的字符串长度。</li>
</ul>
</li>
<li><p>VA_LIST 解决变参问题的一组宏，所在头文件：<code>#include &lt;stdarg.h&gt;</code>，用于获取不确定个数的参数，这种获取是根据参数类型对应的大小，找到对应的内存地址，然后获取参数来实现的</p>
</li>
<li><pre><code>typedef char *va_list;

获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）
#define va_start(list,param1) 

获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）
#define va_arg(list,mode)

清空va_list可变参数列表
#define va_end(list)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  va_list的使用方法：</span><br><span class="line">  a)  首先在函数中定义一个具有va_list型的变量，这个变量是指向参数的指针。</span><br><span class="line">  b)  然后用va_start宏初始化变量刚定义的va_list变量，使其指向第一个可变参数的地址。</span><br><span class="line">  c)  然后va_arg返回可变参数，va_arg的第二个参数是你要返回的参数的类型（如果多个可变参数，依次调用va_arg获取各个参数）。</span><br><span class="line">  d)  最后使用va_end宏结束可变参数的获取。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>int vsnprintf (char * s, size_t n, const char * format, va_list arg );</p>
</li>
<li><p>将格式化的数据从变量参数列表写入大小已设置的缓冲区</p>
</li>
<li><p>参数</p>
<ul>
<li><p>s</p>
<p>指向存储结果C-string的缓冲区的指针。 缓冲区的大小至少应为<em>n</em>字符。</p>
</li>
<li><p>n</p>
<p>缓冲区中要使用的最大字节数。 生成的字符串的长度最大为<code>n-1</code>，为其他终止空字符留出空间。</p>
</li>
<li><p>format</p>
<p>包含格式字符串的C字符串，其格式与prinf相同。</p>
</li>
<li><p>arg</p>
<p>一个值，该值标识用初始化的变量参数列表。</p>
</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功打印到sbuf中的字符的个数，不包括末尾追加的\0。如果格式化解析失败，则返回负数。</li>
</ul>
</li>
</ul>
<h1 id="第四站"><a href="#第四站" class="headerlink" title="第四站"></a>第四站</h1><h2 id="http——前置知识"><a href="#http——前置知识" class="headerlink" title="http——前置知识"></a>http——前置知识</h2><p>这部分内容很多，耐心些，别急</p>
<p>作者写的三篇介绍：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BfnNl-3jc_x5WPrWEJGdzQ">最新版Web服务器项目详解 - 04 http连接处理（上） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wAQHU-QZiRt1VACMZZjNlw">最新版Web服务器项目详解 - 05 http连接处理（中） (qq.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/451xNaSFHxcxfKlPBV3OCg">最新版Web服务器项目详解 - 06 http连接处理（下） (qq.com)</a></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是linux新内核中替换select来做事件触发的机制，效率非常高，底层使用红黑树实现。这篇博客讲的非常清楚，强烈推荐：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljx0305/article/details/4065058">epoll使用详解（精髓）_ljx0305的博客-CSDN博客_epoll</a>。下面简单介绍下API，头文件<code>#include &lt;sys/epoll.h&gt;</code>。</p>
<ul>
<li><p>int epoll_create(int size)</p>
<ul>
<li>创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数，size不起作用。(从Linux 2.6.8开始，max_size参数将被忽略，但必须大于零。)</li>
</ul>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</p>
<ul>
<li><p>该函数用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
</li>
<li><p>epfd：为epoll_creat的句柄</p>
</li>
<li><p>op：表示动作，用3个宏来表示：</p>
</li>
<li><ul>
<li>EPOLL_CTL_ADD (注册新的fd到epfd)，相当于把fd加到epfd这棵红黑树上</li>
<li>EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</li>
<li>EPOLL_CTL_DEL (从epfd删除一个fd)；</li>
</ul>
</li>
<li><p>fd：文件描述符</p>
</li>
<li><p>event：告诉内核需要监听的事件，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events; <span class="comment">/* Epoll events，是一串比特，设置类型时把类型或起来 */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>events描述事件类型，其中epoll事件类型有以下几种</p>
</li>
<li><ul>
<li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</li>
</ul>
</li>
<li><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</p>
<ul>
<li><p>该函数用于等待所监控文件描述符上有事件的产生，返回就绪的文件描述符个数</p>
<ul>
<li><p>events：用来存内核得到事件的集合，</p>
</li>
<li><p>maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</p>
</li>
<li><p>timeout：是超时时间</p>
</li>
<li><ul>
<li>-1：阻塞</li>
<li>0：立即返回，非阻塞</li>
<li>&gt;0：指定毫秒</li>
</ul>
</li>
<li><p>返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>触发模式：</p>
<ul>
<li><p>LT水平触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll还会再次向应用程序通知此事件，直到该事件被处理完毕。</li>
</ul>
</li>
<li><p>ET边缘触发模式</p>
</li>
<li><ul>
<li>当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</li>
<li>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain</li>
</ul>
</li>
<li><p>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，故效率要比LT模式高。LT模式是epoll的默认工作模式</p>
</li>
<li><p>EPOLLONESHOT</p>
</li>
<li><ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<p>项目中epoll相关代码部分包括非阻塞模式、内核事件表注册事件、删除事件、重置EPOLLONESHOT事件四种。</p>
<ul>
<li><p>非阻塞模式</p>
</li>
<li><pre><code class="c++">//对文件描述符设置非阻塞
int setnonblocking(int fd)
&#123;
    int old_option = fcntl(fd, F_GETFL);//返回fd的状态标志，是一串比特位
    int new_option = old_option | O_NONBLOCK;//设置非阻塞的比特位，把前面获得的flag和它或起来就可以了
    fcntl(fd, F_SETFL, new_option);//重新设置
    return old_option;
&#125;
/*
阻塞方式是文件读写操作的默认方式，但是应用程序员可通过使用O_NONBLOCK 标志来人为
的设置读写操作为非阻塞方式 .( 该标志定义在 &lt; linux/fcntl.h &gt; 中，在打开文件时指定 ) .
 
如果设置了 O_NONBLOCK 标志，read 和 write 的行为是不同的 ，如果进程没有数据就绪时调用了 read ，
或者在缓冲区没有空间时调用了 write ，系统只是简单的返回 EAGAIN，而不会阻塞进程.
*/
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd);</span><br><span class="line">int fcntl(int fd, int cmd, long arg);</span><br><span class="line">int fcntl(int fd, int cmd ,struct flock* lock);</span><br></pre></td></tr></table></figure>

fcntl函数功能依据cmd的值的不同而不同。参数对应功能如下：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">（1）F_DUPFD</span><br><span class="line">与dup函数功能一样，复制由fd指向的文件描述符，调用成功后返回新的文件描述符，与旧的文件描述符共同指向同一个文件。</span><br><span class="line"></span><br><span class="line">（2）F_GETFD</span><br><span class="line">读取文件描述符close-on-exec标志。</span><br><span class="line">close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特位代表一个打开的文件描述符，用于确定在调用系统调用execve()时需要关闭的文件句柄（参见include/fcntl.h）。当一个程序使用fork()函数创建了一个子进程时，通常会在该子进程中调用execve()函数加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中开始执行新程序。若一个文件描述符在close_on_exec中的对应比特位被设置，那么在执行execve()时该描述符将被关闭，否则该描述符将始终处于打开状态。</span><br><span class="line">试想一下这样的场景：在Webserver中，首先会使用root权限启动，以此打开root权限才能打开的端口、日志等文件。然后降权到普通用户，fork出一些worker进程，这些进程中再进行解析脚本、写日志、输出结果等进一步操作。</span><br><span class="line">然而这里，就会发现隐含一个安全问题：子进程中既然继承了父进程的FD，那么子进程中运行的脚本只需要继续操作这些FD，就能够使用普通权限“越权”操作root用户才能操作的文件。</span><br><span class="line"></span><br><span class="line">（3）F_SETFD</span><br><span class="line">将文件描述符close-on-exec标志设置为第三个参数arg的最后一位</span><br><span class="line"></span><br><span class="line">（4）F_GETFL</span><br><span class="line">获取文件打开方式的标志，标志值含义与open调用一致</span><br><span class="line"></span><br><span class="line">（5）F_SETFL</span><br><span class="line">设置文件打开方式标志为arg指定方式</span><br><span class="line"></span><br><span class="line">(6)F_SETLK</span><br><span class="line">此时fcntl函数用来设置或释放锁。当short_l_type为F_RDLCK为读锁，F_WDLCK为写锁，F_UNLCK为解锁。</span><br><span class="line">如果锁被其他进程占用，则返回-1;</span><br><span class="line">这种情况设的锁遇到锁被其他进程占用时，会立刻停止进程。</span><br><span class="line"></span><br><span class="line">(7)F_SETLKW</span><br><span class="line">此时也是给文件上锁，不同于F_SETLK的是，该上锁是阻塞方式。当希望设置的锁因为其他锁而被阻止设置时，该命令会等待相冲突的锁被释放。</span><br><span class="line"></span><br><span class="line">(8)F_GETLK</span><br><span class="line">第3个参数lock指向一个希望设置的锁的属性结构，如果锁能被设置，该命令并不真的设置锁，而是只修改lock的l_type为F_UNLCK,然后返回该结构体。如果存在一个或多个锁与希望设置的锁相互冲突，则fcntl返回其中的一个锁的flock结构。</span><br></pre></td></tr></table></figure>

返回值：与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。下列三个命令有特定返回值：F_DUPFD,F_GETFD,F_GETFL以及F_GETOWN。第一个返回新的文件描述符，第二个返回相应标志，最后一个返回一个正的进程ID或负的进程组ID。

</code></pre>
</li>
<li><p>内核事件表注册新事件，开启EPOLLONESHOT，针对客户端连接的描述符，listenfd不用开启</p>
</li>
<li><pre><code class="c++"> void addfd(int epollfd, int fd, bool one_shot)
 &#123;
     epoll_event event;
     event.data.fd = fd;
 
 #ifdef ET
     event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;//告知要监听可读事件、文件描述符被挂断事件
 #endif
 
#ifdef LT
    event.events = EPOLLIN | EPOLLRDHUP;//可读、文件描述符被挂断
#endif

    if (one_shot)
        event.events |= EPOLLONESHOT;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);//处理好描述的事件类型后，添加进内核事件表的文件描述符epfd
    setnonblocking(fd);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 内核事件表删除事件</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  void removefd(int epollfd, int fd)</span><br><span class="line">  &#123;</span><br><span class="line">      epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0);//标志是delete，删除这个fd</span><br><span class="line">      close(fd);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>重置EPOLLONESHOT事件</p>
</li>
<li><p>&#96;&#96;&#96;c++<br> void modfd(int epollfd, int fd, int ev)<br> {<br> epoll_event event;<br> event.data.fd &#x3D; fd;<br> #ifdef ET<br> event.events &#x3D; ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<br> #endif</p>
<p>#ifdef LT<br>event.events &#x3D; ev | EPOLLONESHOT | EPOLLRDHUP;<br>#endif</p>
<pre><code>epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### http细节</span><br><span class="line"></span><br><span class="line">请求报文：get和post，报文的请求头部不一定全部都有，但可以有：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  GET &#x2F;562f25980001b1b106000338.jpg HTTP&#x2F;1.1<br>  Host:img.mukewang.com<br>  User-Agent:Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64)<br>  AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;51.0.2704.106 Safari&#x2F;537.36<br>  Accept:image&#x2F;webp,image&#x2F;<em>,</em>&#x2F;*;q&#x3D;0.8<br>  Referer:<a target="_blank" rel="noopener" href="http://www.imooc.com/">http://www.imooc.com/</a><br>  Accept-Encoding:gzip, deflate, sdch<br>  Accept-Language:zh-CN,zh;q&#x3D;0.8<br>  空行<br>  请求数据为空</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive
空行
name=Professional%20Ajax&amp;publisher=Wiley
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **请求行**，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</span><br><span class="line">  GET说明请求类型为GET，/562f25980001b1b106000338.jpg(URL)为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</span><br><span class="line"></span><br><span class="line">- **请求头部**，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</span><br><span class="line"></span><br><span class="line">- - HOST，给出请求资源所在服务器的域名。</span><br><span class="line">  - User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</span><br><span class="line">  - Accept，说明用户代理可处理的媒体类型。</span><br><span class="line">  - Accept-Encoding，说明用户代理支持的内容编码。</span><br><span class="line">  - Accept-Language，说明用户代理能够处理的自然语言集。</span><br><span class="line">  - Content-Type，说明实现主体的媒体类型。</span><br><span class="line">  - Content-Length，说明实现主体的大小。</span><br><span class="line">  - Connection，连接管理，可以是Keep-Alive或close。</span><br><span class="line"></span><br><span class="line">- **空行**，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。</span><br><span class="line"></span><br><span class="line">- **请求数据**也叫主体，可以添加任意的其他数据。</span><br><span class="line"></span><br><span class="line">响应报文：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HTTP&#x2F;1.1 200 OK<br>Date: Fri, 22 May 2009 06:07:21 GMT<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8<br> 空行</p>
<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</span><br><span class="line">  第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。</span><br><span class="line">- 消息报头，用来说明客户端要使用的一些附加信息。</span><br><span class="line">  第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。</span><br><span class="line">- 空行，消息报头后面的空行是必须的。</span><br><span class="line">- 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</span><br><span class="line"></span><br><span class="line">状态码：</span><br><span class="line"></span><br><span class="line">HTTP有5种类型的状态码，具体的：</span><br><span class="line"></span><br><span class="line">- 1xx：指示信息--表示请求已接收，继续处理。</span><br><span class="line"></span><br><span class="line">- 2xx：成功--表示请求正常处理完毕。</span><br><span class="line"></span><br><span class="line">- - 200 OK：客户端请求被正常处理。</span><br><span class="line">  - 206 Partial content：客户端进行了范围请求。</span><br><span class="line"></span><br><span class="line">- 3xx：重定向--要完成请求必须进行更进一步的操作。</span><br><span class="line"></span><br><span class="line">- - 301 Moved Permanently：永久重定向，该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。</span><br><span class="line">  - 302 Found：临时重定向，请求的资源现在临时从不同的URI中获得。</span><br><span class="line"></span><br><span class="line">- 4xx：客户端错误--请求有语法错误，服务器无法处理请求。</span><br><span class="line"></span><br><span class="line">- - 400 Bad Request：请求报文存在语法错误。</span><br><span class="line">  - 403 Forbidden：请求被服务器拒绝。</span><br><span class="line">  - 404 Not Found：请求不存在，服务器上找不到请求的资源。</span><br><span class="line"></span><br><span class="line">- 5xx：服务器端错误--服务器处理请求出错。</span><br><span class="line"></span><br><span class="line">- - 500 Internal Server Error：服务器在执行请求时出现错误。</span><br><span class="line"></span><br><span class="line">http报文处理流程：</span><br><span class="line"></span><br><span class="line">- 浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</span><br><span class="line">- 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</span><br><span class="line">- 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</span><br><span class="line"></span><br><span class="line">### http类</span><br><span class="line"></span><br><span class="line">这一部分代码在TinyWebServer/http/http_conn.h中，主要是http类的定义。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef HTTPCONNECTION_H</span><br><span class="line">#define HTTPCONNECTION_H</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;//存储错误</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;../lock/locker.h&quot;</span><br><span class="line">#include &quot;../CGImysql/sql_connection_pool.h&quot;</span><br><span class="line">#include &quot;../timer/lst_timer.h&quot;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">class http_conn</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //设置读取文件的名称m_real_file大小</span><br><span class="line">    static const int FILENAME_LEN = 200;</span><br><span class="line">    //设置读缓冲区m_read_buf大小</span><br><span class="line">    static const int READ_BUFFER_SIZE = 2048;</span><br><span class="line">    //设置写缓冲区m_write_buf大小</span><br><span class="line">    static const int WRITE_BUFFER_SIZE = 1024;</span><br><span class="line">    </span><br><span class="line">    //报文的请求方法，本项目只用到GET和POST</span><br><span class="line">    enum METHOD</span><br><span class="line">    &#123;</span><br><span class="line">        GET = 0,</span><br><span class="line">        POST,</span><br><span class="line">        HEAD,</span><br><span class="line">        PUT,</span><br><span class="line">        DELETE,</span><br><span class="line">        TRACE,</span><br><span class="line">        OPTIONS,</span><br><span class="line">        CONNECT,</span><br><span class="line">        PATH</span><br><span class="line">    &#125;;</span><br><span class="line">    //主状态机的状态</span><br><span class="line">    enum CHECK_STATE</span><br><span class="line">    &#123;</span><br><span class="line">        CHECK_STATE_REQUESTLINE = 0,</span><br><span class="line">        CHECK_STATE_HEADER,</span><br><span class="line">        CHECK_STATE_CONTENT</span><br><span class="line">    &#125;;</span><br><span class="line">    //报文解析的结果</span><br><span class="line">    enum HTTP_CODE</span><br><span class="line">    &#123;</span><br><span class="line">        NO_REQUEST,</span><br><span class="line">        GET_REQUEST,</span><br><span class="line">        BAD_REQUEST,</span><br><span class="line">        NO_RESOURCE,</span><br><span class="line">        FORBIDDEN_REQUEST,</span><br><span class="line">        FILE_REQUEST,</span><br><span class="line">        INTERNAL_ERROR,</span><br><span class="line">        CLOSED_CONNECTION</span><br><span class="line">    &#125;;</span><br><span class="line">    //从状态机的状态</span><br><span class="line">    enum LINE_STATUS</span><br><span class="line">    &#123;</span><br><span class="line">        LINE_OK = 0,</span><br><span class="line">        LINE_BAD,</span><br><span class="line">        LINE_OPEN</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    http_conn() &#123;&#125;</span><br><span class="line">    ~http_conn() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //初始化套接字地址，函数内部会调用私有方法init</span><br><span class="line">    void init(int sockfd, const sockaddr_in &amp;addr, char *, int, int, string user, string passwd, string sqlname);</span><br><span class="line">    //关闭http连接</span><br><span class="line">    void close_conn(bool real_close = true);</span><br><span class="line">    </span><br><span class="line">    void process();</span><br><span class="line">    </span><br><span class="line">    //读取浏览器端发来的全部数据</span><br><span class="line">    bool read_once();</span><br><span class="line">    //响应报文写入函数</span><br><span class="line">    bool write();</span><br><span class="line">    </span><br><span class="line">    sockaddr_in *get_address()</span><br><span class="line">    &#123;</span><br><span class="line">        return &amp;m_address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //同步线程初始化数据库读取表</span><br><span class="line">    void initmysql_result(connection_pool *connPool);</span><br><span class="line">    </span><br><span class="line">    int timer_flag;</span><br><span class="line">    int improv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void init();</span><br><span class="line">    //从m_read_buf读取，并处理请求报文</span><br><span class="line">    HTTP_CODE process_read();</span><br><span class="line">    //向m_write_buf写入响应报文数据</span><br><span class="line">    bool process_write(HTTP_CODE ret);</span><br><span class="line">    //主状态机解析报文中的请求行数据</span><br><span class="line">    HTTP_CODE parse_request_line(char *text);</span><br><span class="line">    //主状态机解析报文中的请求头数据</span><br><span class="line">    HTTP_CODE parse_headers(char *text);</span><br><span class="line">    //主状态机解析报文中的请求内容</span><br><span class="line">    HTTP_CODE parse_content(char *text);</span><br><span class="line">    //生成响应报文</span><br><span class="line">    HTTP_CODE do_request();</span><br><span class="line">    </span><br><span class="line">    //m_start_line是已经解析的字符</span><br><span class="line">    //get_line用于将指针向后偏移，指向未处理的字符</span><br><span class="line">    char *get_line() &#123; return m_read_buf + m_start_line; &#125;;</span><br><span class="line">    </span><br><span class="line">    //从状态机读取一行，分析是请求报文的哪一部分</span><br><span class="line">    LINE_STATUS parse_line();</span><br><span class="line">    void unmap();</span><br><span class="line">    </span><br><span class="line">    //根据响应报文格式，生成对应8个部分，以下函数均由do_request调用</span><br><span class="line">    bool add_response(const char *format, ...);</span><br><span class="line">    bool add_content(const char *content);</span><br><span class="line">    bool add_status_line(int status, const char *title);</span><br><span class="line">    bool add_headers(int content_length);</span><br><span class="line">    bool add_content_type();</span><br><span class="line">    bool add_content_length(int content_length);</span><br><span class="line">    bool add_linger();</span><br><span class="line">    bool add_blank_line();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int m_epollfd;//内核事件表，类共享的</span><br><span class="line">    static int m_user_count;//记录总数，静态变量的形式</span><br><span class="line">    MYSQL *mysql;</span><br><span class="line">    int m_state;  //读为0, 写为1</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_sockfd;</span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    </span><br><span class="line">    //存储读取的请求报文数据</span><br><span class="line">    char m_read_buf[READ_BUFFER_SIZE];</span><br><span class="line">    //缓冲区中m_read_buf中数据的最后一个字节的下一个位置</span><br><span class="line">    int m_read_idx;</span><br><span class="line">    //m_read_buf读取的位置m_checked_idx</span><br><span class="line">    int m_checked_idx;</span><br><span class="line">    //m_read_buf中已经解析的字符个数</span><br><span class="line">    int m_start_line;</span><br><span class="line">    </span><br><span class="line">    //存储发出的响应报文数据</span><br><span class="line">    char m_write_buf[WRITE_BUFFER_SIZE];</span><br><span class="line">    //指示buffer中的长度</span><br><span class="line">    int m_write_idx;</span><br><span class="line">    </span><br><span class="line">    //主状态机的状态</span><br><span class="line">    CHECK_STATE m_check_state;</span><br><span class="line">    //请求方法</span><br><span class="line">    METHOD m_method;</span><br><span class="line">    </span><br><span class="line">    //以下为解析请求报文中对应的6个变量</span><br><span class="line">    //存储读取文件的名称</span><br><span class="line">    char m_real_file[FILENAME_LEN];</span><br><span class="line">    char *m_url;</span><br><span class="line">    char *m_version;</span><br><span class="line">    char *m_host;</span><br><span class="line">    int m_content_length;</span><br><span class="line">    bool m_linger;</span><br><span class="line">    </span><br><span class="line">    //读取服务器上的文件地址</span><br><span class="line">    char *m_file_address;</span><br><span class="line">    </span><br><span class="line">    //stat iovec后面介绍</span><br><span class="line">    struct stat m_file_stat;//获取文件的信息</span><br><span class="line">    //io向量机制iovec</span><br><span class="line">    struct iovec m_iv[2];</span><br><span class="line">    int m_iv_count;</span><br><span class="line">    int cgi;        //是否启用的POST</span><br><span class="line">    char *m_string; //存储请求头数据</span><br><span class="line">    int bytes_to_send;//剩余发送字节数</span><br><span class="line">    int bytes_have_send;//已发送字节数</span><br><span class="line">    char *doc_root;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; m_users;</span><br><span class="line">    int m_TRIGMode;</span><br><span class="line">    int m_close_log;</span><br><span class="line"></span><br><span class="line">    char sql_user[100];</span><br><span class="line">    char sql_passwd[100];</span><br><span class="line">    char sql_name[100];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在http请求接收部分，会涉及到init和read_once函数，但init仅仅是对私有成员变量进行初始化，不用过多讲解。</p>
<p>这里，对read_once进行介绍。read_once读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_idx。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(m_read_idx&gt;=READ_BUFFER_SIZE)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> bytes_read=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从套接字接收数据，存储在m_read_buf缓冲区</span></span><br><span class="line">        bytes_read=<span class="built_in">recv</span>(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,<span class="number">0</span>);<span class="comment">//该函数后面介绍</span></span><br><span class="line">        <span class="keyword">if</span>(bytes_read==<span class="number">-1</span>)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//非阻塞ET模式下，需要一次性将数据读完</span></span><br><span class="line">            <span class="keyword">if</span>(errno==EAGAIN||errno==EWOULDBLOCK)<span class="comment">//这种错误是系统告知要再尝试一次，可能是因为没有数据了，break返回true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bytes_read==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改m_read_idx的读取字节数</span></span><br><span class="line">        m_read_idx+=bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int recv(int sockfd, char * buf, int len, int flags);</p>
<ul>
<li>sockfd：连接的fd</li>
<li>buf：用于接收数据的缓冲区</li>
<li>len：缓冲区长度，一般是参数2的字节数-1，把<code>\0</code>字符串结尾留出来</li>
<li>flags：指定调用方式，一般设置为0</li>
<li>返回值：成功返回实际读到的字节数。如果recv在copy时出错，那么它返回err，err小于0；如果recv函数在等待协议接收数据时网络中断了，那么它返回0 。</li>
</ul>
</li>
<li><p>在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。EAGAIN和 EWOULDBLOCK等效！</p>
<ul>
<li>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以O_NONBLOCK的标志打开文件&#x2F;socket&#x2F;FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</li>
<li>这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</li>
</ul>
</li>
<li><p>struct iovec 结构体定义了一个向量元素，通常这个 iovec 结构体用于一个多元素的数组，对于每一个元素，iovec 结构体的字段 iov_base 指向一个缓冲区，这个缓冲区存放的是网络接收的数据（read），或者网络将要发送的数据（write）。iovec 结构体的字段 iov_len 存放的是接收数据的最大长度（read），或者实际写入的数据长度（write）。</p>
<ul>
<li><pre><code class="c++">struct iovec &#123;
    /* Starting address (内存起始地址）*/
    void  *iov_base;   

    /* Number of bytes to transfer（这块内存长度） */
    size_t iov_len;  
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct stat  </span><br><span class="line">    &#123;   </span><br><span class="line">        dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/  </span><br><span class="line">        ino_t       st_ino;     /* inode number -inode节点号*/    </span><br><span class="line">        mode_t      st_mode;    /* protection -保护模式?*/    </span><br><span class="line">        nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    </span><br><span class="line">        uid_t       st_uid;     /* user ID of owner -user id*/    </span><br><span class="line">        gid_t       st_gid;     /* group ID of owner - group id*/    </span><br><span class="line">        dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    </span><br><span class="line">        off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    </span><br><span class="line">        blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    </span><br><span class="line">        blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    </span><br><span class="line">        time_t      st_atime;   /* time of last access -最近存取时间*/    </span><br><span class="line">        time_t      st_mtime;   /* time of last modification -最近修改时间*/    </span><br><span class="line">        time_t      st_ctime;   /* time of last status change - */    </span><br><span class="line">    &#125;;  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="c++">//_stat函数用来获取指定路径的文件或者文件夹的信息。


//! 需要包含de头文件  
#include &lt;sys/types.h&gt;    
#include &lt;sys/stat.h&gt;   
int stat(
　　const char *filename    //文件或者文件夹的路径
　　, struct stat *buf      //获取的信息保存在内存中
); //! prototype,原型     

//正确——返回0
//错误——返回-1，具体错误码保存在errno中
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。</span><br><span class="line">  </span><br><span class="line">* #### mmap</span><br><span class="line"></span><br><span class="line">  * 用于将一个文件或其他对象映射到内存，提高文件的访问速度。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);</span><br><span class="line">    int munmap(void* start,size_t length);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址</p>
</li>
<li><p>length：映射区的长度</p>
</li>
<li><p>prot：期望的内存保护标志，不能与文件的打开模式冲突</p>
</li>
<li><ul>
<li>PROT_READ 表示页内容可以被读取</li>
</ul>
</li>
<li><p>flags：指定映射对象的类型，映射选项和映射页是否可以共享</p>
</li>
<li><ul>
<li>MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件</li>
</ul>
</li>
<li><p>fd：有效的文件描述符，一般是由open()函数返回</p>
</li>
<li><p>off_toffset：被映射对象内容的起点</p>
</li>
<li><p>返回值：成功返回创建的映射区的首地址；失败返回<strong>宏MAP_FAILED。</strong></p>
</li>
</ul>
</li>
<li><h4 id="writev"><a href="#writev" class="headerlink" title="writev"></a>writev</h4><ul>
<li><p>writev函数用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;uio.h&gt;<br>ssize_t writev(int filedes, const struct iovec *iov, int iovcnt);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * filedes表示文件描述符</span><br><span class="line"></span><br><span class="line">  * iov为前述io向量机制结构体iovec</span><br><span class="line"></span><br><span class="line">  * iovcnt为结构体的个数</span><br><span class="line"></span><br><span class="line">  * 若成功则返回已写的字节数，若出错则返回-1。`writev`以顺序`iov[0]`，`iov[1]`至`iov[iovcnt-1]`从缓冲区中聚集输出数据。`writev`返回输出的字节总数，通常，它应等于所有缓冲区长度之和。</span><br><span class="line"></span><br><span class="line">  * **特别注意：** 循环调用writev时，需要重新处理iovec中的指针和长度，该函数不会对这两个成员做任何处理。writev的返回值为已写的字节数，但这个返回值“实用性”并不高，因为参数传入的是iovec数组，计量单位是iovcnt，而不是字节数，我们仍然需要通过遍历iovec来计算新的基址，另外写入数据的“结束点”可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line"></span><br><span class="line">Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。</span><br><span class="line"></span><br><span class="line">&gt; *PS: 只有当系统调用或者调用lib函数时出错，才会置位`errno`！*</span><br><span class="line"></span><br><span class="line">查看系统中所有的`errno`所代表的含义，可以采用如下的代码：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">/* Function: obtain the errno string</span><br><span class="line">*   char *strerror(int errno)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;     //for strerror()</span><br><span class="line">//#include &lt;errno.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = 0;</span><br><span class="line">    for(tmp = 0; tmp &lt;=256; tmp++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;errno: %2d\t%s\n&quot;,tmp,strerror(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//输出信息如下：</span><br><span class="line">errno:  0       Success</span><br><span class="line">errno:  1       Operation not permitted</span><br><span class="line">errno:  2       No such file or directory</span><br><span class="line">errno:  3       No such process</span><br><span class="line">errno:  4       Interrupted system call</span><br><span class="line">errno:  5       Input/output error</span><br><span class="line">errno:  6       No such device or address</span><br><span class="line">errno:  7       Argument list too long</span><br><span class="line">errno:  8       Exec format error</span><br><span class="line">errno:  9       Bad file descriptor</span><br><span class="line">errno: 10       No child processes</span><br><span class="line">errno: 11       Resource temporarily unavailable</span><br><span class="line">errno: 12       Cannot allocate memory</span><br><span class="line">errno: 13       Permission denied</span><br><span class="line">errno: 14       Bad address</span><br><span class="line">errno: 15       Block device required</span><br><span class="line">errno: 16       Device or resource busy</span><br><span class="line">errno: 17       File exists</span><br><span class="line">errno: 18       Invalid cross-device link</span><br><span class="line">errno: 19       No such device</span><br><span class="line">errno: 20       Not a directory</span><br><span class="line">errno: 21       Is a directory</span><br><span class="line">errno: 22       Invalid argument</span><br><span class="line">errno: 23       Too many open files in system</span><br><span class="line">errno: 24       Too many open files</span><br><span class="line">errno: 25       Inappropriate ioctl for device</span><br><span class="line">errno: 26       Text file busy</span><br><span class="line">errno: 27       File too large</span><br><span class="line">errno: 28       No space left on device</span><br><span class="line">errno: 29       Illegal seek</span><br><span class="line">errno: 30       Read-only file system</span><br><span class="line">errno: 31       Too many links</span><br><span class="line">errno: 32       Broken pipe</span><br><span class="line">errno: 33       Numerical argument out of domain</span><br><span class="line">errno: 34       Numerical result out of range</span><br><span class="line">errno: 35       Resource deadlock avoided</span><br><span class="line">errno: 36       File name too long</span><br><span class="line">errno: 37       No locks available</span><br><span class="line">errno: 38       Function not implemented</span><br><span class="line">errno: 39       Directory not empty</span><br><span class="line">errno: 40       Too many levels of symbolic links</span><br><span class="line">errno: 41       Unknown error 41</span><br><span class="line">errno: 42       No message of desired type</span><br><span class="line">errno: 43       Identifier removed</span><br><span class="line">errno: 44       Channel number out of range</span><br><span class="line">errno: 45       Level 2 not synchronized</span><br><span class="line">errno: 46       Level 3 halted</span><br><span class="line">errno: 47       Level 3 reset</span><br><span class="line">errno: 48       Link number out of range</span><br><span class="line">errno: 49       Protocol driver not attached</span><br><span class="line">errno: 50       No CSI structure available</span><br><span class="line">errno: 51       Level 2 halted</span><br><span class="line">errno: 52       Invalid exchange</span><br><span class="line">errno: 53       Invalid request descriptor</span><br><span class="line">errno: 54       Exchange full</span><br><span class="line">errno: 55       No anode</span><br><span class="line">errno: 56       Invalid request code</span><br><span class="line">errno: 57       Invalid slot</span><br><span class="line">errno: 58       Unknown error 58</span><br><span class="line">errno: 59       Bad font file format</span><br><span class="line">errno: 60       Device not a stream</span><br><span class="line">errno: 61       No data available</span><br><span class="line">errno: 62       Timer expired</span><br><span class="line">errno: 63       Out of streams resources</span><br><span class="line">errno: 64       Machine is not on the network</span><br><span class="line">errno: 65       Package not installed</span><br><span class="line">errno: 66       Object is remote</span><br><span class="line">errno: 67       Link has been severed</span><br><span class="line">errno: 68       Advertise error</span><br><span class="line">errno: 69       Srmount error</span><br><span class="line">errno: 70       Communication error on send</span><br><span class="line">errno: 71       Protocol error</span><br><span class="line">errno: 72       Multihop attempted</span><br><span class="line">errno: 73       RFS specific error</span><br><span class="line">errno: 74       Bad message</span><br><span class="line">errno: 75       Value too large for defined data type</span><br><span class="line">errno: 76       Name not unique on network</span><br><span class="line">errno: 77       File descriptor in bad state</span><br><span class="line">errno: 78       Remote address changed</span><br><span class="line">errno: 79       Can not access a needed shared library</span><br><span class="line">errno: 80       Accessing a corrupted shared library</span><br><span class="line">errno: 81       .lib section in a.out corrupted</span><br><span class="line">errno: 82       Attempting to link in too many shared libraries</span><br><span class="line">errno: 83       Cannot exec a shared library directly</span><br><span class="line">errno: 84       Invalid or incomplete multibyte or wide character</span><br><span class="line">errno: 85       Interrupted system call should be restarted</span><br><span class="line">errno: 86       Streams pipe error</span><br><span class="line">errno: 87       Too many users</span><br><span class="line">errno: 88       Socket operation on non-socket</span><br><span class="line">errno: 89       Destination address required</span><br><span class="line">errno: 90       Message too long</span><br><span class="line">errno: 91       Protocol wrong type for socket</span><br><span class="line">errno: 92       Protocol not available</span><br><span class="line">errno: 93       Protocol not supported</span><br><span class="line">errno: 94       Socket type not supported</span><br><span class="line">errno: 95       Operation not supported</span><br><span class="line">errno: 96       Protocol family not supported</span><br><span class="line">errno: 97       Address family not supported by protocol</span><br><span class="line">errno: 98       Address already in use</span><br><span class="line">errno: 99       Cannot assign requested address</span><br><span class="line">errno: 100      Network is down</span><br><span class="line">errno: 101      Network is unreachable</span><br><span class="line">errno: 102      Network dropped connection on reset</span><br><span class="line">errno: 103      Software caused connection abort</span><br><span class="line">errno: 104      Connection reset by peer</span><br><span class="line">errno: 105      No buffer space available</span><br><span class="line">errno: 106      Transport endpoint is already connected</span><br><span class="line">errno: 107      Transport endpoint is not connected</span><br><span class="line">errno: 108      Cannot send after transport endpoint shutdown</span><br><span class="line">errno: 109      Too many references: cannot splice</span><br><span class="line">errno: 110      Connection timed out</span><br><span class="line">errno: 111      Connection refused</span><br><span class="line">errno: 112      Host is down</span><br><span class="line">errno: 113      No route to host</span><br><span class="line">errno: 114      Operation already in progress</span><br><span class="line">errno: 115      Operation now in progress</span><br><span class="line">errno: 116      Stale file handle</span><br><span class="line">errno: 117      Structure needs cleaning</span><br><span class="line">errno: 118      Not a XENIX named type file</span><br><span class="line">errno: 119      No XENIX semaphores available</span><br><span class="line">errno: 120      Is a named type file</span><br><span class="line">errno: 121      Remote I/O error</span><br><span class="line">errno: 122      Disk quota exceeded</span><br><span class="line">errno: 123      No medium found</span><br><span class="line">errno: 124      Wrong medium type</span><br><span class="line">errno: 125      Operation canceled</span><br><span class="line">errno: 126      Required key not available</span><br><span class="line">errno: 127      Key has expired</span><br><span class="line">errno: 128      Key has been revoked</span><br><span class="line">errno: 129      Key was rejected by service</span><br><span class="line">errno: 130      Owner died</span><br><span class="line">errno: 131      State not recoverable</span><br><span class="line">errno: 132      Operation not possible due to RF-kill</span><br><span class="line">errno: 133      Memory page has hardware error</span><br><span class="line">errno: 134~255  unknown error!</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Linux中，在头文件 <code>/usr/include/asm-generic/errno-base.h</code> 对基础常用errno进行了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPERM        1  <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOENT       2  <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRCH        3  <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINTR        4  <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIO      5  <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENXIO        6  <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E2BIG        7  <span class="comment">/* Argument list too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOEXEC      8  <span class="comment">/* Exec format error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADF        9  <span class="comment">/* Bad file number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHILD      10  <span class="comment">/* No child processes */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAGAIN      11  <span class="comment">/* Try again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEM      12  <span class="comment">/* Out of memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EACCES      13  <span class="comment">/* Permission denied */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFAULT      14  <span class="comment">/* Bad address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTBLK     15  <span class="comment">/* Block device required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBUSY       16  <span class="comment">/* Device or resource busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEXIST      17  <span class="comment">/* File exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXDEV       18  <span class="comment">/* Cross-device link */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODEV      19  <span class="comment">/* No such device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTDIR     20  <span class="comment">/* Not a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISDIR      21  <span class="comment">/* Is a directory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINVAL      22  <span class="comment">/* Invalid argument */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENFILE      23  <span class="comment">/* File table overflow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMFILE      24  <span class="comment">/* Too many open files */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTTY      25  <span class="comment">/* Not a typewriter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETXTBSY     26  <span class="comment">/* Text file busy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFBIG       27  <span class="comment">/* File too large */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSPC      28  <span class="comment">/* No space left on device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESPIPE      29  <span class="comment">/* Illegal seek */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EROFS       30  <span class="comment">/* Read-only file system */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMLINK      31  <span class="comment">/* Too many links */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPIPE       32  <span class="comment">/* Broken pipe */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOM        33  <span class="comment">/* Math argument out of domain of func */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERANGE      34  <span class="comment">/* Math result not representable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在 <code>/usr/include/asm-asm-generic/errno.h</code> 中，对剩余的errno做了宏定义</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_GENERIC_ERRNO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm-generic/errno-base.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLK     35  <span class="comment">/* Resource deadlock would occur */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAMETOOLONG    36  <span class="comment">/* File name too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLCK      37  <span class="comment">/* No record locks available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSYS      38  <span class="comment">/* Function not implemented */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTEMPTY   39  <span class="comment">/* Directory not empty */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELOOP       40  <span class="comment">/* Too many symbolic links encountered */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EWOULDBLOCK EAGAIN  <span class="comment">/* Operation would block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMSG      42  <span class="comment">/* No message of desired type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EIDRM       43  <span class="comment">/* Identifier removed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHRNG      44  <span class="comment">/* Channel number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2NSYNC    45  <span class="comment">/* Level 2 not synchronized */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3HLT      46  <span class="comment">/* Level 3 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL3RST      47  <span class="comment">/* Level 3 reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELNRNG      48  <span class="comment">/* Link number out of range */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUNATCH     49  <span class="comment">/* Protocol driver not attached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOCSI      50  <span class="comment">/* No CSI structure available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EL2HLT      51  <span class="comment">/* Level 2 halted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADE       52  <span class="comment">/* Invalid exchange */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADR       53  <span class="comment">/* Invalid request descriptor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXFULL      54  <span class="comment">/* Exchange full */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOANO      55  <span class="comment">/* No anode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADRQC     56  <span class="comment">/* Invalid request code */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADSLT     57  <span class="comment">/* Invalid slot */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDEADLOCK   EDEADLK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBFONT      59  <span class="comment">/* Bad font file format */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSTR      60  <span class="comment">/* Device not a stream */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENODATA     61  <span class="comment">/* No data available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIME       62  <span class="comment">/* Timer expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOSR       63  <span class="comment">/* Out of streams resources */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENONET      64  <span class="comment">/* Machine is not on the network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPKG      65  <span class="comment">/* Package not installed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTE     66  <span class="comment">/* Object is remote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOLINK     67  <span class="comment">/* Link has been severed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADV        68  <span class="comment">/* Advertise error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESRMNT      69  <span class="comment">/* Srmount error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECOMM       70  <span class="comment">/* Communication error on send */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTO      71  <span class="comment">/* Protocol error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMULTIHOP   72  <span class="comment">/* Multihop attempted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDOTDOT     73  <span class="comment">/* RFS specific error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADMSG     74  <span class="comment">/* Not a data message */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOVERFLOW   75  <span class="comment">/* Value too large for defined data type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTUNIQ    76  <span class="comment">/* Name not unique on network */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EBADFD      77  <span class="comment">/* File descriptor in bad state */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMCHG     78  <span class="comment">/* Remote address changed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBACC     79  <span class="comment">/* Can not access a needed shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBBAD     80  <span class="comment">/* Accessing a corrupted shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBSCN     81  <span class="comment">/* .lib section in a.out corrupted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBMAX     82  <span class="comment">/* Attempting to link in too many shared libraries */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIBEXEC    83  <span class="comment">/* Cannot exec a shared library directly */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EILSEQ      84  <span class="comment">/* Illegal byte sequence */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERESTART    85  <span class="comment">/* Interrupted system call should be restarted */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTRPIPE    86  <span class="comment">/* Streams pipe error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUSERS      87  <span class="comment">/* Too many users */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTSOCK    88  <span class="comment">/* Socket operation on non-socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDESTADDRREQ    89  <span class="comment">/* Destination address required */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMSGSIZE    90  <span class="comment">/* Message too long */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTOTYPE  91  <span class="comment">/* Protocol wrong type for socket */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOPROTOOPT 92  <span class="comment">/* Protocol not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROTONOSUPPORT 93  <span class="comment">/* Protocol not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESOCKTNOSUPPORT 94  <span class="comment">/* Socket type not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOPNOTSUPP  95  <span class="comment">/* Operation not supported on transport endpoint */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPFNOSUPPORT    96  <span class="comment">/* Protocol family not supported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EAFNOSUPPORT    97  <span class="comment">/* Address family not supported by protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRINUSE  98  <span class="comment">/* Address already in use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EADDRNOTAVAIL   99  <span class="comment">/* Cannot assign requested address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETDOWN    100 <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETUNREACH 101 <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENETRESET   102 <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNABORTED    103 <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNRESET  104 <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOBUFS     105 <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISCONN     106 <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTCONN    107 <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESHUTDOWN   108 <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETOOMANYREFS    109 <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ETIMEDOUT   110 <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECONNREFUSED    111 <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTDOWN   112 <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHOSTUNREACH    113 <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EALREADY    114 <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EINPROGRESS 115 <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTALE      116 <span class="comment">/* Stale file handle */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EUCLEAN     117 <span class="comment">/* Structure needs cleaning */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTNAM     118 <span class="comment">/* Not a XENIX named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENAVAIL     119 <span class="comment">/* No XENIX semaphores available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EISNAM      120 <span class="comment">/* Is a named type file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EREMOTEIO   121 <span class="comment">/* Remote I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDQUOT      122 <span class="comment">/* Quota exceeded */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOMEDIUM   123 <span class="comment">/* No medium found */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMEDIUMTYPE 124 <span class="comment">/* Wrong medium type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECANCELED   125 <span class="comment">/* Operation Canceled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOKEY      126 <span class="comment">/* Required key not available */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYEXPIRED 127 <span class="comment">/* Key has expired */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREVOKED 128 <span class="comment">/* Key has been revoked */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EKEYREJECTED    129 <span class="comment">/* Key was rejected by service */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for robust mutexes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EOWNERDEAD  130 <span class="comment">/* Owner died */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENOTRECOVERABLE 131 <span class="comment">/* State not recoverable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERFKILL     132 <span class="comment">/* Operation not possible due to RF-kill */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EHWPOISON   133 <span class="comment">/* Memory page has hardware error */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="http的调用"><a href="#http的调用" class="headerlink" title="http的调用"></a>http的调用</h3><p>这不是http的实现，实现后面再说，这里是使用epoll调用的运行代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建MAX_FD个http类对象</span></span><br><span class="line"> http_conn* users=<span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建内核事件表</span></span><br><span class="line"> epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"> epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line"> <span class="built_in">assert</span>(epollfd != <span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//将listenfd放在epoll树上</span></span><br><span class="line"><span class="built_in">addfd</span>(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上述epollfd赋值给http类对象的m_epollfd属性</span></span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待所监控文件描述符上有事件的产生</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对所有就绪事件进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sockfd = events[i].data.fd;<span class="comment">//通过epollfd监听到的就绪事件会放在events数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">//LT水平触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LT</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ET非阻塞边缘触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ET</span></span><br><span class="line">            <span class="comment">//需要循环接收数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">                <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[connfd].<span class="built_in">init</span>(connfd, client_address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读入对应缓冲区</span></span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//服务器关闭连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="http实现"><a href="#http实现" class="headerlink" title="http实现"></a>http实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义http响应的一些状态信息</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to staisfy.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file form this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the request file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">locker m_lock;</span><br><span class="line">map&lt;string, string&gt; users;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::initmysql_result</span><span class="params">(connection_pool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先从连接池中取一个连接</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))<span class="comment">//从mysql这个接口输入查询语句</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;SELECT error:%s\n&quot;</span>, <span class="built_in">mysql_error</span>(mysql));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    <span class="type">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;</span><br><span class="line">        users[temp1] = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="comment">//这可以把一个fd绑定在epollfd上，接下来对内核事件的操作（唤醒什么的）都是针对fd文件描述符的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)<span class="comment">//边缘触发模式</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<span class="comment">//add一个</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从内核时间表删除描述符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//从epollfd中删掉fd，然后关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将事件重置为EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">int</span> ev, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<span class="comment">//修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态变量定义</span></span><br><span class="line"><span class="type">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接，关闭一个连接，客户总量减一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;close %d\n&quot;</span>, m_sockfd);</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化连接,外部调用初始化套接字地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr, <span class="type">char</span> *root, <span class="type">int</span> TRIGMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> close_log, string user, string passwd, string sqlname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>, m_TRIGMode);<span class="comment">//注册一个连接</span></span><br><span class="line">    m_user_count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当浏览器出现连接重置时，可能是网站根目录出错或http响应格式出错或者访问的文件中内容完全为空</span></span><br><span class="line">    doc_root = root;</span><br><span class="line">    m_TRIGMode = TRIGMode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(sql_user, user.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_passwd, passwd.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_name, sqlname.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化新接受的连接</span></span><br><span class="line"><span class="comment">//check_state默认为分析请求行状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mysql = <span class="literal">NULL</span>;</span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">    m_linger = <span class="literal">false</span>;</span><br><span class="line">    m_method = GET;</span><br><span class="line">    m_url = <span class="number">0</span>;</span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line">    cgi = <span class="number">0</span>;</span><br><span class="line">    m_state = <span class="number">0</span>;</span><br><span class="line">    timer_flag = <span class="number">0</span>;</span><br><span class="line">    improv = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从状态机，用于分析出一行内容，见作者的分析中篇</span></span><br><span class="line"><span class="comment">//返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_read_buf[m_checked_idx];<span class="comment">//temp为将要分析的字节</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//如果当前是\r字符，则有可能会读取到完整行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx)<span class="comment">//下一个字符达到了buffer结尾，则接收不完整，需要继续接收</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//下一个字符是\n，将\r\n改为\0\0</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;<span class="comment">//如果都不符合，则返回语法错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//如果当前字符是\n，也有可能读取到完整行</span></span><br><span class="line">        &#123;<span class="comment">//一般是上次读取到\r就到buffer末尾了，没有接收完整，再次接收时会出现这种情况</span></span><br><span class="line">            <span class="keyword">if</span> (m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)<span class="comment">//前一个字符是\r，则接收完整</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;<span class="comment">//并没有找到\r\n，需要继续接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环读取客户数据，直到无数据可读或对方关闭连接</span></span><br><span class="line"><span class="comment">//非阻塞ET工作模式下，需要一次性将数据读完</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LT读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET读数据</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//循环读取</span></span><br><span class="line">        &#123;</span><br><span class="line">            bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)<span class="comment">//这时说明读完了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_read_idx += bytes_read;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求行，获得请求方法，目标url及http版本号</span></span><br><span class="line"><span class="comment">//在HTTP报文中，请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本，其中各个部分之间通过\t或空格分隔。</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//请求行中最先含有空格和\t任一字符的位置并返回</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//检索字符串 str1 中第一个匹配字符串 str2 中字符的字符</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url)<span class="comment">//如果没有空格或\t，则报文格式有误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//将该位置改为\0，用于将前面数据取出</span></span><br><span class="line">    <span class="type">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)<span class="comment">//取出数据，并通过与GET和POST比较，以确定请求方式</span></span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标，该函数返回 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);<span class="comment">//因为报文后面可能还有空格，跳过这些空格</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用与判断请求方式的相同逻辑，判断HTTP版本号</span></span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)<span class="comment">//只支持1.1版本</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)<span class="comment">//对请求资源前7个字符进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//同样增加https情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)<span class="comment">//一般的不会带有上述两种符号，直接是单独的/或/后面带访问资源</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    <span class="comment">//当url为/时，显示判断界面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);</span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;<span class="comment">//请求行处理完毕，将主状态机转移处理请求头</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//判断是空行还是请求头</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_content_length != <span class="number">0</span>)<span class="comment">//判断是GET还是POST请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;<span class="comment">//POST需要跳转到消息体处理状态</span></span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部连接字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//跳过空格和\t字符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>)<span class="comment">//如果是长连接，则将linger标志设置为true</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部内容长度字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)<span class="comment">//解析请求头部HOST字段</span></span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;oop!unknow header: %s&quot;</span>, text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="type">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//判断http请求是否被完整读入</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主状态机</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;<span class="comment">//初始化从状态机状态、HTTP请求解析结果</span></span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="type">char</span> *text = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//在GET请求报文中，每一行都是\r\n作为结束，所以对报文进行拆解时，仅用从状态机的状态line_status=parse_line())==LINE_OK语句即可。</span></span><br><span class="line">    <span class="comment">//在POST请求报文中，消息体的末尾没有任何字符，所以不能使用从状态机的状态，这里转而使用主状态机的状态作为循环入口条件。</span></span><br><span class="line">    <span class="comment">//解析完消息体后，报文的完整解析就完成了，但此时主状态机的状态还是CHECK_STATE_CONTENT，符合循环入口条件，还会再次进入循环，这并不是我们所希望的</span></span><br><span class="line">    <span class="comment">//为此，增加了该语句，并在完成消息体解析后，将line_status变量更改为LINE_OPEN，此时可以跳出循环，完成报文解析任务。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只有当从状态机处理好了，主状态机才运行</span></span><br><span class="line">    <span class="keyword">while</span> ((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line">        <span class="comment">//m_start_line是每一个数据行在m_read_buf中的起始位置</span></span><br><span class="line">        <span class="comment">//m_checked_idx表示从状态机在m_read_buf中读取的位置</span></span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">        <span class="keyword">switch</span> (m_check_state)<span class="comment">//主状态机的三种状态转移逻辑</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">        &#123;	<span class="comment">//解析请求行</span></span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">        &#123;	<span class="comment">//解析请求头</span></span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span> (ret == BAD_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            <span class="comment">//完整解析GET请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">        &#123;	<span class="comment">//解析消息体</span></span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">            <span class="comment">//完整解析POST请求后，跳转到报文响应函数</span></span><br><span class="line">            <span class="keyword">if</span> (ret == GET_REQUEST)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();<span class="comment">//正确的请求就转调用</span></span><br><span class="line">            line_status = LINE_OPEN;<span class="comment">//从状态机没处理好，退出循环，openline</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里跟html有关系</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file, doc_root);<span class="comment">//将初始化的m_real_file赋值为网站根目录</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//找到m_url中/的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理cgi</span></span><br><span class="line">    <span class="keyword">if</span> (cgi == <span class="number">1</span> &amp;&amp; (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))<span class="comment">//实现登录和注册校验</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据标志判断是登录检测还是注册检测</span></span><br><span class="line">        <span class="type">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">//user=123&amp;passwd=123</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = m_string[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是注册，先检测数据库中是否有重名的</span></span><br><span class="line">            <span class="comment">//没有重名的，进行增加数据</span></span><br><span class="line">            <span class="type">char</span> *sql_insert = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())<span class="comment">//没有这个名字</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_lock.<span class="built_in">lock</span>();<span class="comment">//操作数据库，互斥</span></span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);<span class="comment">//数据库，没有给mysql变量赋一个连接啊？</span></span><br><span class="line">                users.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(name, password));<span class="comment">//map</span></span><br><span class="line">                m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是登录，直接判断</span></span><br><span class="line">        <span class="comment">//若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)<span class="comment">//如果请求资源为/0，表示跳转注册界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/register.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)<span class="comment">//如果请求资源为/1，表示跳转登录界面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">        <span class="comment">//将网站目录和/log.html进行拼接，更新到m_real_file中</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *m_url_real = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//如果以上均不符合，即不是登录和注册，直接将url与网站目录拼接，这里的情况是welcome界面，请求服务器上的一个图片</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//通过stat获取请求资源文件信息，成功则将信息更新到m_file_stat结构体</span></span><br><span class="line">    <span class="comment">//失败返回NO_RESOURCE状态，表示资源不存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件的权限，是否可读，不可读则返回FORBIDDEN_REQUEST状态</span></span><br><span class="line">    <span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件类型，如果是目录，则返回BAD_REQUEST，表示请求报文有误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以只读方式获取文件描述符，通过mmap将该文件映射到内存中</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(m_real_file, O_RDONLY);</span><br><span class="line">    m_file_address = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//避免文件描述符的浪费和占用</span></span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;<span class="comment">//表示请求文件存在，且可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span><span class="comment">//解除内存映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_file_address)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(m_file_address, m_file_stat.st_size);</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//若要发送的数据长度为0</span></span><br><span class="line">    <span class="comment">//表示响应报文为空，一般不会出现这种情况</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将响应报文的状态行、消息头、空行和响应正文发送给浏览器端</span></span><br><span class="line">        temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)<span class="comment">//发送失败</span></span><br><span class="line">        &#123;	<span class="comment">//判断缓冲区是否满了</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;	<span class="comment">//重新注册写事件</span></span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果发送失败，但不是缓冲区问题，取消映射</span></span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">	   <span class="comment">//正常发送，temp为发送的字节数</span></span><br><span class="line">        bytes_have_send += temp;<span class="comment">//更新已发送字节</span></span><br><span class="line">        bytes_to_send -= temp;<span class="comment">//偏移文件iovec的指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个iovec头部信息的数据已发送完，发送第二个iovec数据</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;<span class="comment">//不再继续发送头部信息</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//继续发送第一个iovec头部信息的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断条件，数据已全部发送完</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//在epoll树上重置EPOLLONESHOT事件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)<span class="comment">//浏览器的请求为长连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();<span class="comment">//重新初始化HTTP对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE)<span class="comment">//如果写入内容超出m_write_buf大小则报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    va_list arg_list;<span class="comment">//定义可变参数列表</span></span><br><span class="line">    <span class="built_in">va_start</span>(arg_list, format);<span class="comment">//将变量arg_list初始化为传入参数</span></span><br><span class="line">    <span class="comment">//将数据format从可变参数列表写入缓冲区，返回写入数据的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">vsnprintf</span>(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line">    <span class="comment">//如果写入的数据长度超过缓冲区剩余空间，则报错</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;<span class="comment">//更新m_write_idx位置</span></span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);<span class="comment">//清空可变参列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;request:%s&quot;</span>, m_write_buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="type">int</span> status, <span class="type">const</span> <span class="type">char</span> *title)</span><span class="comment">//添加状态行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加消息报头，具体的添加文本长度、连接状态和空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_content_length</span>(content_len) &amp;&amp; <span class="built_in">add_linger</span>() &amp;&amp;</span><br><span class="line">           <span class="built_in">add_blank_line</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="type">int</span> content_len)</span><span class="comment">//添加Content-Length，表示响应报文的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span><span class="comment">//添加文本类型，这里是html</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span><span class="comment">//添加连接状态，通知浏览器端是保持连接还是关闭</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span><span class="comment">//添加空行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *content)</span><span class="comment">//添加文本content</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span><span class="comment">//逻辑上处理要写什么</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:<span class="comment">//内部错误，500</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);<span class="comment">//状态行</span></span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));<span class="comment">//消息报头</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:<span class="comment">//报文语法有误，404</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:<span class="comment">//资源没有访问权限，403</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:<span class="comment">//文件存在，200</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">        <span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>)<span class="comment">//如果请求的资源存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_headers</span>(m_file_stat.st_size);</span><br><span class="line">            <span class="comment">//第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx</span></span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">            <span class="comment">//第二个iovec指针指向mmap返回的文件指针，长度指向文件大小</span></span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//发送的全部数据为响应报文头部信息和文件大小</span></span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;	<span class="comment">//如果请求的资源大小为0，则返回空白html文件</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除FILE_REQUEST状态外，其余状态只申请一个iovec，指向响应报文缓冲区</span></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span><span class="comment">//对读事件完成最终处理并发送响应报文</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)<span class="comment">//NO_REQUEST，表示请求不完整，需要继续接收请求数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//注册并监听读事件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);<span class="comment">//调用process_write完成报文响应</span></span><br><span class="line">    <span class="keyword">if</span> (!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close_conn</span>();<span class="comment">//如果写错误就关闭连接，会把fd删除且关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//？都关闭了且没有注册怎么修改</span></span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);<span class="comment">//注册并监听写事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MYSQL_RES *mysql_store_result(MYSQL *mysql)<ul>
<li>对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result() 。</li>
<li>对于其他查询，不需要调用mysql_store_result()或mysql_use_result()，但是如果在任何情况下均调用了mysql_store_result()，它也不会导致任何伤害或性能降低。通过检查mysql_store_result()是否返回0，可检测查询是否没有结果集（以后会更多）。</li>
<li>如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。</li>
</ul>
</li>
<li>unsigned int mysql_field_count(MYSQL *mysql)<ul>
<li>返回作用在连接上的最近查询的列数。</li>
</ul>
</li>
<li>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)<ul>
<li>返回采用MYSQL_FIELD结构的结果集的列。重复调用该函数，以检索关于结果集中所有列的信息。</li>
</ul>
</li>
<li>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)<ul>
<li>检索结果集的下一行。在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL。在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL。行内值的数目由mysql_num_fields(result)给出。</li>
</ul>
</li>
<li>int munmap(void *start,size_t length);<ul>
<li>函数说明 munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。</li>
<li>返回值 如果解除映射成功则返回0，否则返回－1，错误原因存于errno中错误代码EINVAL参数 start或length 不合法。</li>
</ul>
</li>
</ul>
<h1 id="第五站"><a href="#第五站" class="headerlink" title="第五站"></a>第五站</h1><p>项目中使用的是<code>SIGALRM</code>信号，具体的，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计与定时任务的处理。</p>
<h2 id="定时器与信号API"><a href="#定时器与信号API" class="headerlink" title="定时器与信号API"></a>定时器与信号API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Linux中的信号是一种消息处理机制，它本质上是一个整数，不同的信号对应不同的值，信号在系统中的优先级是非常高的。</span><br><span class="line">- 项目中使用的信号</span><br><span class="line"> 	1. SIGALRM：定时器超时信号，超时的时间由系统调用alarm设置，默认终止进程。</span><br><span class="line"> 	2. SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</span><br><span class="line">- 两个特殊信号</span><br><span class="line">	1. SIGKILL：9号信号，无条件终止进程，不能被捕捉、阻塞和忽略。</span><br><span class="line">	2. SIGSTOP：19号信号，无条件暂停进程，不能被捕捉、阻塞和忽略。</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一个信号：SIGPIPE：当服务器close一个连接时，若client端接着发数据。根据TCP 协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。 <ul>
<li>TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown.</li>
<li>对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.</li>
<li>为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它, 给它设置SIG_IGN信号处理函数:signal(SIGPIPE, SIG_IGN);SIG_IGN表示忽略信号</li>
</ul>
</li>
</ul>
<ul>
<li>Linux中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略某些信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。</li>
<li>程序中的信号捕捉是一个注册的动作，提前告诉应用程序信号产生之后的处理动作，当进程中对应的信号产生了，这个处理动作也就被调用了。</li>
</ul>
<ul>
<li><p>sigaction结构体：</p>
<ul>
<li><pre><code class="c++">struct sigaction
&#123;
    void (*sa_handler)(int);                        // 函数指针，指向信号处理函数。
    void (*sa_sigaction)(int, siginfo_t *, void *); // 函数指针，指向信号处理函数，有三个参数。
    sigset_t sa_mask;                               // 在信号处理函数执行期间，临时屏蔽的信号。
    int sa_flags;                                   // 用于指定信号处理的行为
    void (*sa_restorer)(void);                      // 被废弃的成员，一般不使用
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * flag有以下几个：</span><br><span class="line"></span><br><span class="line">    * SA_RESTART，使被信号打断的系统调用自动重新发起</span><br><span class="line">    * SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号</span><br><span class="line">    * SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程</span><br><span class="line">    * SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号</span><br><span class="line">    * SA_RESETHAND，信号处理之后重新设置为默认的处理方式</span><br><span class="line"></span><br><span class="line">* sigaction函数：</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    int sigaction(</span><br><span class="line">        int signum,                  // 要捕捉的信号。</span><br><span class="line">        const struct sigaction *act, // 对信号设置新的处理方式。</span><br><span class="line">        struct sigaction *oldact     // 上一次信号处理方式，一般指定为NULL。</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>返回值，0 表示成功，-1 表示有错误发生。</p>
</li>
</ul>
</li>
<li><p>sigfillset函数：</p>
<ul>
<li>&#96;&#96;&#96;c++<br>int sigfillset(sigset_t * set);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sigfillset()用来将参数set信号集初始化，然后把所有的信号加入到此信号集里，即将所有的信号标志位置为1，屏蔽所有的信号。信号集是在执行信号处理程序时被阻塞的信号集。因此，当执行信号处理程序时，所有信号都被阻塞，不必担心另一个信号会中断信号处理程序。</span><br><span class="line"></span><br><span class="line">* SIGALRM、SIGTERM信号，是整形数</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #define SIGALRM  14     //由alarm系统调用产生timer时钟信号</span><br><span class="line">    #define SIGTERM  15     //终端发送的终止信号</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>alarm函数</p>
<ul>
<li><pre><code class="c++">#include&lt;unistd.h&gt;
unsigned int alarm（unsigned int seconds);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * alarm也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间到时，它向进程发送SIGALRM信号。可以设置忽略或者不捕获此信号，如果采用默认方式其动作是终止调用该alarm函数的进程。</span><br><span class="line"></span><br><span class="line">  * 要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。需要注意的是，经过指定的秒数后，信号由内核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一些时间。</span><br><span class="line"></span><br><span class="line">  * 返回值：成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。</span><br><span class="line"></span><br><span class="line">* socketpair函数</span><br><span class="line"></span><br><span class="line">  * 在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。socketpair创建的描述符任意一端既可以读也可以写。</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/socket.h&gt;</span><br><span class="line">    </span><br><span class="line">    int socketpair(int domain, int type, int protocol, int sv[2]);</span><br></pre></td></tr></table></figure>

* domain表示协议族，PF_UNIX或者AF_UNIX，AF = Address Family、PF = Protocol Family。PF_UNIX (也称作 PF_LOCAL ) 套接字族用来在同一机器上的提供有效的进程间通讯。AF\_和PF\_的值直接可以替换，没有其它区别。
* type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP
* protocol表示类型，只能为0
* sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作
</code></pre>
</li>
<li><p>返回结果， 0为创建成功，-1为创建失败</p>
</li>
</ul>
</li>
<li><p>send函数，当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;sys&#x2F;types.h&gt;<br>#include &lt;sys&#x2F;socket.h&gt;</p>
<p>ssize_t send(int sockfd, const void *buff, size_t nbytes, int flags);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * sockfd：指定发送端套接字描述符。</span><br><span class="line">    * buff： 存放要发送数据的缓冲区</span><br><span class="line">    * nbytes: 实际要改善的数据的字节数</span><br><span class="line">    * flags： 一般设置为0</span><br><span class="line"></span><br><span class="line">  * 1) send先比较发送数据的长度nbytes和套接字sockfd的发送缓冲区的长度，如果nbytes &gt; 套接字sockfd的发送缓冲区的长度, 该函数返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    2) 如果nbtyes &lt;= 套接字sockfd的发送缓冲区的长度，那么send先检查协议是否正在发送sockfd的发送缓冲区中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送sockfd的发送缓冲区中的数据或者sockfd的发送缓冲区中没有数据，那么send就比较sockfd的发送缓冲区的剩余空间和nbytes。</span><br><span class="line"></span><br><span class="line">    3) 如果 nbytes &gt; 套接字sockfd的发送缓冲区剩余空间的长度，send就一起等待协议把套接字sockfd的发送缓冲区中的数据发送完。</span><br><span class="line"></span><br><span class="line">    4) 如果 nbytes &lt; 套接字sockfd的发送缓冲区剩余空间大小，send就仅仅把buf中的数据copy到剩余空间里(注意：并不是send把套接字sockfd的发送缓冲区中的数据传到连接的另一端的，而是协议传送的。send仅仅是把buf中的数据copy到套接字sockfd的发送缓冲区的剩余空间里)。</span><br><span class="line"></span><br><span class="line">    5) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    6) 如果send函数copy成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果在等待协议传送数据时网络断开，send函数也返回SOCKET_ERROR。</span><br><span class="line"></span><br><span class="line">    7) 在unix系统下，如果send在等待协议传送数据时网络断开，调用send的进程会接收到一个SIGPIPE信号，进程对该信号的处理是进程终止。</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">## 头文件</span><br><span class="line"></span><br><span class="line">lst_timer.h</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#ifndef LST_TIMER</span><br><span class="line">#define LST_TIMER</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &quot;../log/log.h&quot;</span><br><span class="line"></span><br><span class="line">//连接资源结构体成员需要用到定时器类</span><br><span class="line">//前向声明</span><br><span class="line">class util_timer;</span><br><span class="line"></span><br><span class="line">//连接资源</span><br><span class="line">struct client_data</span><br><span class="line">&#123;</span><br><span class="line">    //客户端socket地址，项目中未使用</span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    int sockfd;//socket文件描述符</span><br><span class="line">    util_timer *timer;//定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器类</span><br><span class="line">class util_timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    util_timer() : prev(NULL), next(NULL) &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    time_t expire;//超时时间</span><br><span class="line">    </span><br><span class="line">    void (* cb_func)(client_data *);//回调函数指针，这个回调函数会删除client_data的资源连接</span><br><span class="line">    client_data *user_data;//连接资源，嵌套类使用指针，相当于内部成员指针互相指向对方实例</span><br><span class="line">    util_timer *prev;//前向定时器</span><br><span class="line">    util_timer *next;//后继定时器</span><br><span class="line">&#125;;</span><br><span class="line">//定时器容器类，双向链表</span><br><span class="line">class sort_timer_lst</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    sort_timer_lst();</span><br><span class="line">    ~sort_timer_lst();//常规销毁链表</span><br><span class="line"></span><br><span class="line">    void add_timer(util_timer *timer);//添加定时器，内部调用私有成员add_timer</span><br><span class="line">    void adjust_timer(util_timer *timer);//调整定时器，任务发生变化时，调整定时器在链表中的位置</span><br><span class="line">    void del_timer(util_timer *timer);//删除定时器</span><br><span class="line">    void tick();//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void add_timer(util_timer *timer, util_timer *lst_head);</span><br><span class="line"></span><br><span class="line">    //创建头尾指针，方便管理</span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Utils//资源管理类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Utils() &#123;&#125;</span><br><span class="line">    ~Utils() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void init(int timeslot);</span><br><span class="line"></span><br><span class="line">    //对文件描述符设置非阻塞</span><br><span class="line">    int setnonblocking(int fd);</span><br><span class="line"></span><br><span class="line">    //将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span><br><span class="line">    void addfd(int epollfd, int fd, bool one_shot, int TRIGMode);</span><br><span class="line"></span><br><span class="line">    //信号处理函数</span><br><span class="line">    static void sig_handler(int sig);</span><br><span class="line"></span><br><span class="line">    //设置信号函数</span><br><span class="line">    void addsig(int sig, void(handler)(int), bool restart = true);</span><br><span class="line"></span><br><span class="line">    //定时处理任务，重新定时以不断触发SIGALRM信号</span><br><span class="line">    void timer_handler();</span><br><span class="line"></span><br><span class="line">    void show_error(int connfd, const char *info);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    static int *u_pipefd;//管道描述符</span><br><span class="line">    sort_timer_lst m_timer_lst;//定时器容器</span><br><span class="line">    static int u_epollfd;//事务描述符</span><br><span class="line">    int m_TIMESLOT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void cb_func(client_data *user_data);//回调函数</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="cpp实现-2"><a href="#cpp实现-2" class="headerlink" title=".cpp实现"></a>.cpp实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lst_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sort_timer_lst::<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort_timer_lst::~<span class="built_in">sort_timer_lst</span>()<span class="comment">//常规销毁链表</span></span><br><span class="line">&#123;</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)<span class="comment">//没有timer要加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!head)<span class="comment">//链表中一个节点都没有</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = tail = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果新的定时器超时时间小于当前头部结点</span></span><br><span class="line">    <span class="comment">//直接将当前定时器结点作为头部结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire)</span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;next = head;</span><br><span class="line">        head-&gt;prev = timer;</span><br><span class="line">        head = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则要插入链表中间或结尾，调用私有方法</span></span><br><span class="line">    <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    util_timer *tmp = timer-&gt;next;</span><br><span class="line">    <span class="comment">//被调整的定时器在链表尾部，不调整</span></span><br><span class="line">    <span class="comment">//定时器超时值仍然小于下一个定时器超时值，不调整（定时器刷新时间只可能更大，不用和前面的节点比较）</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">        <span class="built_in">add_timer</span>(timer, timer-&gt;next);<span class="comment">//因为timer要比next大，所以next当头节点往后add就可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//删除定时器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::del_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line">    <span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (timer == tail)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时任务处理函数，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前时间，定时器的超时时间是以前设置的时间+n个单位超时时间（成为未来时间），所以用当前时间来比较判断是否超时</span></span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="comment">//遍历定时器链表</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//链表容器为升序排列</span></span><br><span class="line">        <span class="comment">//当前时间小于定时器的超时时间，后面的定时器也没有到期</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line">        <span class="comment">//将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有成员，被公有成员add_timer和adjust_time调用</span></span><br><span class="line"><span class="comment">//主要用于调整链表内部结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *prev = lst_head;</span><br><span class="line">    util_timer *tmp = prev-&gt;next;<span class="comment">//不可能比头节点小，所以比较后面的一个节点</span></span><br><span class="line">    <span class="comment">//遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire)<span class="comment">//可以插到tmp前面</span></span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;prev = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line">    <span class="keyword">if</span> (!tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        prev-&gt;next = timer;</span><br><span class="line">        timer-&gt;prev = prev;</span><br><span class="line">        timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::init</span><span class="params">(<span class="type">int</span> timeslot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_TIMESLOT = timeslot;<span class="comment">//单位时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符设置非阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Utils::setnonblocking</span><span class="params">(<span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot, <span class="type">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为保证函数的可重入性，保留原来的errno</span></span><br><span class="line">    <span class="comment">//可重入性表示中断后再次进入该函数，环境变量与之前相同，不会丢失数据</span></span><br><span class="line">    <span class="type">int</span> save_errno = errno;</span><br><span class="line">    <span class="type">int</span> msg = sig;</span><br><span class="line">    <span class="comment">//将信号值从管道写端写入，传输字符类型，而非整型</span></span><br><span class="line">    <span class="built_in">send</span>(u_pipefd[<span class="number">1</span>], (<span class="type">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置信号函数，信号是指SIGALRM这些信号，本质是一个int</span></span><br><span class="line"><span class="comment">//当超时时（比如alarm）会产生这个信号，这里的设置（注册）就是让这个信号的处理按照这里设置的方式，比如flag和处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::addsig</span><span class="params">(<span class="type">int</span> sig, <span class="type">void</span>(*handler)(<span class="type">int</span>), <span class="type">bool</span> restart)</span><span class="comment">//handler是sig_handler</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建sigaction结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> sa;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(sa));</span><br><span class="line">    <span class="comment">//信号处理函数中仅仅发送信号值，不做对应逻辑处理</span></span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    <span class="keyword">if</span> (restart)</span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    <span class="comment">//将所有信号添加到信号集sa_mask中，屏蔽所有信号</span></span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">//执行sigaction函数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);<span class="comment">//这个sig信号会屏蔽其他的信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(m_TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Utils::show_error</span><span class="params">(<span class="type">int</span> connfd, <span class="type">const</span> <span class="type">char</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">send</span>(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *Utils::u_pipefd = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Utils::u_epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utils</span>;<span class="comment">//在这声明是什么意思？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器回调函数，tick函数调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除非活动连接在socket上的注册事件</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(Utils::u_epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line">    <span class="comment">//减少连接数</span></span><br><span class="line">    http_conn::m_user_count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用逻辑"><a href="#使用逻辑" class="headerlink" title="使用逻辑"></a>使用逻辑</h2><p>首先注册（设置）好信号，比如SIGALRM信号，这使得产生这个信号时，能有对应的方式和处理（默认是终止进程），这里的方式是restart、屏蔽其他信号，处理是通过管道向主循环发这个信号。产生的方式是alarm()，主循环中每次尝试从管道获取信号，如果有这个信号，则设置timeout为true说明有超时事件要处理，因为是非必须事件，在这轮循环读写完再进行处理。</p>
<p>处理会调用timer_handler()，首先调用tick()，把定时器超时的都关了（调用cb_func），然后重新alarm()。</p>
<p>关于SIGTERM：程序结束信号，kill或Ctrl+C触发，默认终止进程。</p>
<p>也就是：</p>
<ul>
<li><p>信号</p>
<ul>
<li><p>1.先知道有些动作会产生一些信号</p>
</li>
<li><p>2.设置（注册）这些信号产生后的动作——方式（flag）和处理函数（handler）</p>
</li>
<li><p>3.处理函数只是通知主循环有个信号产生，主循环要做对应的处理。</p>
</li>
</ul>
</li>
<li><p>主循环，我们看看会发生什么</p>
<ul>
<li>1.当一个连接到来时，要创建一个定时器给它，初始化时间和回调函数等变量；</li>
<li>2.如果连接有读写，更新时间；</li>
<li>3.无论有没有定时器超时，每隔timeslot（时隙）会alarm一次，触发信号后主循环得知信号产生，去查看有哪些连接的定时器超时了，超时就关闭连接，然后重新设置alarm，循环往复。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建定时器容器链表</span></span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建连接资源数组</span></span><br><span class="line">client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时默认为False</span></span><br><span class="line"><span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alarm定时触发SIGALRM信号</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理新到的客户连接</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化客户端连接地址</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//该连接分配的文件描述符</span></span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化该连接对应的连接资源</span></span><br><span class="line">            users_timer[connfd].address = client_address;</span><br><span class="line">            users_timer[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建定时器临时变量</span></span><br><span class="line">            util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">            <span class="comment">//设置定时器对应的连接资源</span></span><br><span class="line">            timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">            <span class="comment">//设置回调函数</span></span><br><span class="line">            timer-&gt;cb_func = cb_func;</span><br><span class="line"></span><br><span class="line">            <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//设置绝对超时时间</span></span><br><span class="line">            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">            <span class="comment">//创建该连接对应的定时器，初始化为前述临时变量</span></span><br><span class="line">            users_timer[connfd].timer = timer;</span><br><span class="line">            <span class="comment">//将该定时器添加到链表中</span></span><br><span class="line">            timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理异常事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">            <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理定时器信号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//接收到SIGALRM信号，timeout设置为True</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建定时器临时变量，将该连接对应的定时器取出来</span></span><br><span class="line">            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//对其在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">       &#123;</span><br><span class="line">           util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">           <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line">                <span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">                <span class="keyword">if</span> (timer)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理定时器为非必须事件，收到信号并不是立马处理</span></span><br><span class="line">    <span class="comment">//完成读写事件后，再进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">timer_handler</span>();</span><br><span class="line">        timeout = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六站"><a href="#第六站" class="headerlink" title="第六站"></a>第六站</h1><p>内容比较少</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>头文件config.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Config</span>();</span><br><span class="line">    ~<span class="built_in">Config</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">    <span class="type">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式</span></span><br><span class="line">    <span class="type">int</span> LOGWrite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式</span></span><br><span class="line">    <span class="type">int</span> TRIGMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式</span></span><br><span class="line">    <span class="type">int</span> LISTENTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式</span></span><br><span class="line">    <span class="type">int</span> CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接</span></span><br><span class="line">    <span class="type">int</span> OPT_LINGER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量</span></span><br><span class="line">    <span class="type">int</span> sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量</span></span><br><span class="line">    <span class="type">int</span> thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> close_log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型选择</span></span><br><span class="line">    <span class="type">int</span> actor_model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Config::<span class="built_in">Config</span>()&#123;</span><br><span class="line">    <span class="comment">//端口号,默认9006</span></span><br><span class="line">    PORT = <span class="number">9006</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式，默认同步</span></span><br><span class="line">    LOGWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式,默认listenfd LT + connfd LT</span></span><br><span class="line">    TRIGMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式，默认LT</span></span><br><span class="line">    LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式，默认LT</span></span><br><span class="line">    CONNTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭链接，默认不使用</span></span><br><span class="line">    OPT_LINGER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量,默认8</span></span><br><span class="line">    sql_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量,默认8</span></span><br><span class="line">    thread_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭日志,默认不关闭</span></span><br><span class="line">    close_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型,默认是proactor，这个后面介绍</span></span><br><span class="line">    actor_model = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Config::parse_arg</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span>&#123;<span class="comment">//命令行形式获取参数</span></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((opt = <span class="built_in">getopt</span>(argc, argv, str)) != <span class="number">-1</span>)<span class="comment">//这个函数下面介绍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt)<span class="comment">//会重新排列参数顺序，所以要switch</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            PORT = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            LOGWrite = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            TRIGMode = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            OPT_LINGER = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            sql_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            thread_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            close_log = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            actor_model = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>getopt() 方法是用来分析命令行参数的，该方法由 Unix 标准库提供，包含在 &lt;unistd.h&gt; 头文件中。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int getopt(int argc, char * const argv[], const char *optstring);<br>extern char *optarg;  &#x2F;&#x2F;选项的参数指针<br>extern int optind,   &#x2F;&#x2F;下一次调用getopt的时，从optind存储的位置处重新开始检查选项。<br>extern int opterr,  &#x2F;&#x2F;当opterr&#x3D;0时，getopt不向stderr输出错误信息。<br>extern int optopt;  &#x2F;&#x2F;当命令行选项字符不包括在optstring中或者选项缺少必要的参数时，该选项存储在optopt中，getopt返回’？’、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * argc：通常由函数直接传入，表示参数的数量</span><br><span class="line"></span><br><span class="line">  * argv：通常也由函数直接传入，表示参数的字符串变量数组</span><br><span class="line"></span><br><span class="line">  * optstring：一个包含正确的参数选项字符串，用于参数的解析。例如 “abc:”，其中 -a，-b 就表示两个普通选项，-c 表示一个必须有参数的选项，因为它后面有一个冒号</span><br><span class="line"></span><br><span class="line">    * 1.单个字符，表示选项，</span><br><span class="line">    * 2.单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</span><br><span class="line">    * 3 单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）。</span><br><span class="line"></span><br><span class="line">  * getopt处理以&#x27;-’开头的命令行参数，如optstring=&quot;ab:c::d::&quot;,命令行为getopt.exe -a -b host -ckeke -d haha</span><br><span class="line">    在这个命令行参数中，-a和-h就是选项元素，去掉&#x27;-&#x27;，a,b,c就是选项。host是b的参数，keke是c的参数。但haha并不是d的参数，因为它们中间有空格隔开。</span><br><span class="line"></span><br><span class="line">  * getopt()用来分析命令行参数。参数argc和argv是由main()传递的参数个数和内容。参数optstring 则代表欲处理的选项字符串。此函数会返回在argv 中下一个的选项字母（指针不断移动），此字母会对应参数optstring 中的字母。如果选项字符串里的字母后接着冒号“:”，则表示还有相关的参数，全域变量optarg 即会指向此额外参数。如果getopt()找不到符合的参数则会印出错信息，并将全域变量optopt设为“?”字符，如果不希望getopt()印出错信息，则只要将全域变量opterr设为0即可。</span><br><span class="line"></span><br><span class="line">  * 还要注意的是默认情况下getopt会重新排列命令行参数的顺序，所以到最后所有不包含选项的命令行参数都排到最后。</span><br><span class="line">    如getopt.exe -a ima -b host -ckeke -d haha, 都最后命令行参数的顺序是： -a -b host -ckeke -d ima haha</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">关于proactor模式，小林coding的这篇分析写得很好，推荐看一看：[如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26943938)</span><br><span class="line"></span><br><span class="line">项目中用的是假reactor和模拟proactor（同步的）：[(29条消息) 两种高效的事件处理模式：Reactor模式和Proactor模式_ZY-JIMMY的博客-CSDN博客_reactor模式和proactor](https://blog.csdn.net/ZYZMZM_/article/details/98049471)</span><br><span class="line"></span><br><span class="line">## main</span><br><span class="line"></span><br><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //需要修改的数据库信息,登录名,密码,库名</span><br><span class="line">    string user = &quot;root&quot;;</span><br><span class="line">    string passwd = &quot;root&quot;;</span><br><span class="line">    string databasename = &quot;qgydb&quot;;</span><br><span class="line"></span><br><span class="line">    //命令行解析</span><br><span class="line">    Config config;</span><br><span class="line">    config.parse_arg(argc, argv);</span><br><span class="line"></span><br><span class="line">    WebServer server;//websever在config.h中导入了websever.h</span><br><span class="line"></span><br><span class="line">    //初始化</span><br><span class="line">    server.init(config.PORT, user, passwd, databasename, config.LOGWrite, </span><br><span class="line">                config.OPT_LINGER, config.TRIGMode,  config.sql_num,  config.thread_num, </span><br><span class="line">                config.close_log, config.actor_model);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //日志</span><br><span class="line">    server.log_write();</span><br><span class="line"></span><br><span class="line">    //数据库</span><br><span class="line">    server.sql_pool();</span><br><span class="line"></span><br><span class="line">    //线程池</span><br><span class="line">    server.thread_pool();</span><br><span class="line"></span><br><span class="line">    //触发模式</span><br><span class="line">    server.trig_mode();</span><br><span class="line"></span><br><span class="line">    //监听</span><br><span class="line">    server.eventListen();</span><br><span class="line"></span><br><span class="line">    //运行</span><br><span class="line">    server.eventLoop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="makefile-amp-g"><a href="#makefile-amp-g" class="headerlink" title="makefile&amp;g++"></a>makefile&amp;g++</h2><p>先看这个入门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/82696682">(29条消息) Makefile 语法入门_阿飞__的博客-CSDN博客_makefile语法</a></p>
<p>再看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fangye945a/article/details/85039249">(29条消息) Makefile文件语法规则及用法总结_fangye945a的博客-CSDN博客_makefile语法规则</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhaixue.cc/makefile/makefile-ifeq.html">Makefile 条件判断 - ifeq、ifneq、ifdef、ifndef - Makefile 简明教程 | 宅学部落 (zhaixue.cc)</a></p>
<p>g++参数：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104197249">C&#x2F;C++专题—gcc g++ 参数详解 - 知乎 (zhihu.com)</a></p>
<p>rm命令：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/744.html">Linux rm命令：删除文件或目录 (biancheng.net)</a></p>
<p>项目中的makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX ?= g++</span><br><span class="line"></span><br><span class="line">DEBUG ?= 1</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>, 1)</span><br><span class="line">    CXXFLAGS += -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CXXFLAGS += -O2</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">server: main.cpp  ./timer/lst_timer.cpp ./http/http_conn.cpp ./log/log.cpp ./CGImysql/sql_connection_pool.cpp  webserver.cpp config.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o server  <span class="variable">$^</span> <span class="variable">$(CXXFLAGS)</span> -lpthread -lmysqlclient</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm  -r server</span><br></pre></td></tr></table></figure>

<h1 id="第七站"><a href="#第七站" class="headerlink" title="第七站"></a>第七站</h1><h2 id="顶层实现"><a href="#顶层实现" class="headerlink" title="顶层实现"></a>顶层实现</h2><p>头文件websever.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WEBSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WEBSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./threadpool/threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./http/http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FD = <span class="number">65536</span>;           <span class="comment">//最大文件描述符，即最大连接数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>; <span class="comment">//最大事件数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TIMESLOT = <span class="number">5</span>;             <span class="comment">//最小超时单位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WebServer</span>();</span><br><span class="line">    ~<span class="built_in">WebServer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> port , string user, string passWord, string databaseName,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> log_write , <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thread_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sql_pool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log_write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trig_mode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventListen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealclinetdata</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dealwithsignal</span><span class="params">(<span class="type">bool</span>&amp; timeout, <span class="type">bool</span>&amp; stop_server)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//基础</span></span><br><span class="line">    <span class="type">int</span> m_port;<span class="comment">//端口</span></span><br><span class="line">    <span class="type">char</span> *m_root;<span class="comment">//根目录地址</span></span><br><span class="line">    <span class="type">int</span> m_log_write;<span class="comment">//是否要异步写日志，异步写用一个阻塞队列</span></span><br><span class="line">    <span class="type">int</span> m_close_log;<span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="type">int</span> m_actormodel;<span class="comment">//模型切换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_pipefd[<span class="number">2</span>];<span class="comment">//管道通信</span></span><br><span class="line">    <span class="type">int</span> m_epollfd;<span class="comment">//内核描述符</span></span><br><span class="line">    http_conn *users;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库相关</span></span><br><span class="line">    connection_pool *m_connPool;</span><br><span class="line">    string m_user;         <span class="comment">//登陆数据库用户名</span></span><br><span class="line">    string m_passWord;     <span class="comment">//登陆数据库密码</span></span><br><span class="line">    string m_databaseName; <span class="comment">//使用数据库名</span></span><br><span class="line">    <span class="type">int</span> m_sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池相关</span></span><br><span class="line">    threadpool&lt;http_conn&gt; *m_pool;</span><br><span class="line">    <span class="type">int</span> m_thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll_event相关</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_listenfd;<span class="comment">//监听文件描述符</span></span><br><span class="line">    <span class="type">int</span> m_OPT_LINGER;</span><br><span class="line">    <span class="type">int</span> m_TRIGMode;<span class="comment">//控制连接和读写的触发模式</span></span><br><span class="line">    <span class="type">int</span> m_LISTENTrigmode;</span><br><span class="line">    <span class="type">int</span> m_CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器相关</span></span><br><span class="line">    client_data *users_timer;</span><br><span class="line">    Utils utils;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>.cpp实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;webserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WebServer::<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//http_conn类对象</span></span><br><span class="line">    users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//root文件夹路径</span></span><br><span class="line">    <span class="type">char</span> server_path[<span class="number">200</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(server_path, <span class="number">200</span>);</span><br><span class="line">    <span class="type">char</span> root[<span class="number">6</span>] = <span class="string">&quot;/root&quot;</span>;</span><br><span class="line">    m_root = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(server_path) + <span class="built_in">strlen</span>(root) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(m_root, server_path);</span><br><span class="line">    <span class="built_in">strcat</span>(m_root, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    users_timer = <span class="keyword">new</span> client_data[MAX_FD];<span class="comment">//每个连接都对应一个定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebServer::~<span class="built_in">WebServer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(m_epollfd);</span><br><span class="line">    <span class="built_in">close</span>(m_listenfd);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(m_pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">delete</span>[] users;</span><br><span class="line">    <span class="keyword">delete</span>[] users_timer;</span><br><span class="line">    <span class="keyword">delete</span> m_pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::init</span><span class="params">(<span class="type">int</span> port, string user, string passWord, string databaseName, <span class="type">int</span> log_write, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> opt_linger, <span class="type">int</span> trigmode, <span class="type">int</span> sql_num, <span class="type">int</span> thread_num, <span class="type">int</span> close_log, <span class="type">int</span> actor_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_port = port;</span><br><span class="line">    m_user = user;</span><br><span class="line">    m_passWord = passWord;</span><br><span class="line">    m_databaseName = databaseName;</span><br><span class="line">    m_sql_num = sql_num;</span><br><span class="line">    m_thread_num = thread_num;</span><br><span class="line">    m_log_write = log_write;</span><br><span class="line">    m_OPT_LINGER = opt_linger;</span><br><span class="line">    m_TRIGMode = trigmode;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_actormodel = actor_model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::trig_mode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//LT + LT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;<span class="comment">//读写的模式</span></span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;<span class="comment">//连接的模式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LT + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + LT</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET + ET</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">3</span> == m_TRIGMode)</span><br><span class="line">    &#123;</span><br><span class="line">        m_LISTENTrigmode = <span class="number">1</span>;</span><br><span class="line">        m_CONNTrigmode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::log_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_close_log)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == m_log_write)<span class="comment">//是否异步写日志</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">800</span>);<span class="comment">//800是阻塞队列长度</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">init</span>(<span class="string">&quot;./ServerLog&quot;</span>, m_close_log, <span class="number">2000</span>, <span class="number">800000</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::sql_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化数据库连接池</span></span><br><span class="line">    m_connPool = connection_pool::<span class="built_in">GetInstance</span>();</span><br><span class="line">    m_connPool-&gt;<span class="built_in">init</span>(<span class="string">&quot;localhost&quot;</span>, m_user, m_passWord, m_databaseName, <span class="number">3306</span>, m_sql_num, m_close_log);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据库读取表</span></span><br><span class="line">    users-&gt;<span class="built_in">initmysql_result</span>(m_connPool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::thread_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//线程池，前面创建了users一组http_conn对象，每个对象的工作处理由线程池调用</span></span><br><span class="line">    m_pool = <span class="keyword">new</span> <span class="built_in">threadpool</span>&lt;http_conn&gt;(m_actormodel, m_connPool, m_thread_num);<span class="comment">//只有这一个实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventListen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//网络编程基础步骤</span></span><br><span class="line">    m_listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//创建一个套接字，监听套接口，socket函数看后面</span></span><br><span class="line">    <span class="built_in">assert</span>(m_listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">linger</span> tmp = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == m_OPT_LINGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> linger tmp = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//地址配置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//本函数将一个32位数从主机字节顺序转换成网络字节顺序。INADDR_ANY见后面</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(m_port);<span class="comment">//将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，</span></span><br><span class="line"><span class="comment">	从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用big-endian排序方式。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//打开地址复用功能，允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    ret = <span class="built_in">bind</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address));<span class="comment">//见后面</span></span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line">    ret = <span class="built_in">listen</span>(m_listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">init</span>(TIMESLOT);<span class="comment">//初始化资源管理类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//epoll创建内核事件表</span></span><br><span class="line">    epoll_event events[MAX_EVENT_NUMBER];<span class="comment">//事件集合</span></span><br><span class="line">    m_epollfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);<span class="comment">//事件表描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_listenfd, <span class="literal">false</span>, m_LISTENTrigmode);<span class="comment">//内核事件表注册读事件，监听socket</span></span><br><span class="line">    http_conn::m_epollfd = m_epollfd;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_pipefd);<span class="comment">//创建管道套接字</span></span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    utils.<span class="built_in">setnonblocking</span>(m_pipefd[<span class="number">1</span>]);<span class="comment">//信号写端，设置非阻塞，当缓冲区满了时候不阻塞，减少send执行时间</span></span><br><span class="line">    utils.<span class="built_in">addfd</span>(m_epollfd, m_pipefd[<span class="number">0</span>], <span class="literal">false</span>, <span class="number">0</span>);<span class="comment">//设置管道读端为ET非阻塞</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//传递给主循环的信号值，这里为信号注册处理函数，restart是false，在程序中手动重新设置</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);<span class="comment">//忽略连接断开信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//超时信号</span></span><br><span class="line">    utils.<span class="built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="literal">false</span>);<span class="comment">//终止信号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alarm</span>(TIMESLOT);<span class="comment">//开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具类,信号和描述符基础操作</span></span><br><span class="line">    Utils::u_pipefd = m_pipefd;</span><br><span class="line">    Utils::u_epollfd = m_epollfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::timer</span><span class="params">(<span class="type">int</span> connfd, <span class="keyword">struct</span> sockaddr_in client_address)</span><span class="comment">//获取一个连接后，初始化计时器和用户数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    users[connfd].<span class="built_in">init</span>(connfd, client_address, m_root, m_CONNTrigmode, m_close_log, m_user, m_passWord, m_databaseName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化client_data数据</span></span><br><span class="line">    <span class="comment">//创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到链表中</span></span><br><span class="line">    users_timer[connfd].address = client_address;</span><br><span class="line">    users_timer[connfd].sockfd = connfd;</span><br><span class="line">    util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">    timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line">    timer-&gt;cb_func = cb_func;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    users_timer[connfd].timer = timer;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"><span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::adjust_timer</span><span class="params">(util_timer *timer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">    utils.m_timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;adjust timer once&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::deal_timer</span><span class="params">(util_timer *timer, <span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line">    <span class="keyword">if</span> (timer)</span><br><span class="line">    &#123;</span><br><span class="line">        utils.m_timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;close fd %d&quot;</span>, users_timer[sockfd].sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealclinetdata</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == m_LISTENTrigmode)<span class="comment">//LT模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<span class="comment">//返回值是连接描述符</span></span><br><span class="line">        <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">timer</span>(connfd, client_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//ET模式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//必须一次把监听到的连接读取完，因此循环读取、初始化，直至缓冲区为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> connfd = <span class="built_in">accept</span>(m_listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="keyword">if</span> (connfd &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s:errno is:%d&quot;</span>, <span class="string">&quot;accept error&quot;</span>, errno);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD)</span><br><span class="line">            &#123;</span><br><span class="line">                utils.<span class="built_in">show_error</span>(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">timer</span>(connfd, client_address);<span class="comment">//读取一个连接就初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WebServer::dealwithsignal</span><span class="params">(<span class="type">bool</span> &amp;timeout, <span class="type">bool</span> &amp;stop_server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    ret = <span class="built_in">recv</span>(m_pipefd[<span class="number">0</span>], signals, <span class="built_in">sizeof</span>(signals), <span class="number">0</span>);<span class="comment">//从读管道读取信号，放到signals缓冲区</span></span><br><span class="line">    <span class="comment">//recv的作用，就是通过fdt找到这个缓冲区，并把数据复制到咱们的参数2指向的地址，复制参数3个</span></span><br><span class="line">    <span class="comment">//返回：读出来的字节大小；客户端下线，返回0；执行失败，返回-1</span></span><br><span class="line">    <span class="comment">//正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (signals[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            &#123;</span><br><span class="line">                timeout = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            &#123;</span><br><span class="line">                stop_server = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithread</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reactor，非阻塞同步</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若监测到读事件，将该事件放入请求队列（线程池的请求队列中），同步模式让线程处理整个读过程和相响应报文生成过程</span></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">0</span>);<span class="comment">//users[sockfd]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//一直等待这个读事件完成，很多评论说是作者偷懒了，</span></span><br><span class="line">        <span class="comment">//这不是reactor模式，这相当于阻塞了，最多只有一个http请求。完全没有发挥线程池的作用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)<span class="comment">//完成标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)<span class="comment">//如果要关闭的话</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);<span class="comment">//关闭连接</span></span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//异步，主线程和内核执行IO，工作线程负责业务处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor，实际上这里是模拟proactor模式，是同步的模式，只有主线程串行IO</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())<span class="comment">//读数据成功的话（无论是LT还是ET），返回true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;deal with the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line">            m_pool-&gt;<span class="built_in">append_p</span>(users + sockfd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::dealwithwrite</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">    <span class="comment">//reactor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == m_actormodel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_pool-&gt;<span class="built_in">append</span>(users + sockfd, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].improv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == users[sockfd].timer_flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">                    users[sockfd].timer_flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                users[sockfd].improv = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//proactor</span></span><br><span class="line">        <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;send data to the client(%s)&quot;</span>, <span class="built_in">inet_ntoa</span>(users[sockfd].<span class="built_in">get_address</span>()-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">adjust_timer</span>(timer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebServer::eventLoop</span><span class="params">()</span><span class="comment">//主循环</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;epoll failure&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理新到的客户连接</span></span><br><span class="line">            <span class="keyword">if</span> (sockfd == m_listenfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealclinetdata</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line">                util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line">                <span class="built_in">deal_timer</span>(timer, sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理信号</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == m_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="built_in">dealwithsignal</span>(timeout, stop_server);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;dealclientdata failure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithread</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dealwithwrite</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">timer_handler</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;timer tick&quot;</span>);</span><br><span class="line"></span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><pre><code class="c++">int socket(int af, int type, int protocol);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。</span><br><span class="line">  * type 为数据传输方式/套接字类型，常用的有 SOCK_STREAM（流格式套接字/面向连接的套接字） 和 SOCK_DGRAM（数据报套接字/无连接的套接字）。</span><br><span class="line">  * protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</span><br><span class="line">  * 为什么还需要第三个参数呢？一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</span><br><span class="line"></span><br><span class="line">* 若无错误发生，socket()返回引用新套接口的描述字。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int listen(int sockfd, int backlog);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
</li>
<li><p>成功返回0</p>
</li>
<li><pre><code class="c++">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。</p>
</li>
<li><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为客户端协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
</li>
</ul>
<hr>
<ul>
<li><p>struct linger用法：</p>
</li>
<li><p>Linux下tcp连接断开的时候调用close()函数，有优雅断开和强制断开两种方式。那么如何设置断开连接的方式呢？是通过设置socket描述符一个linger结构体属性。</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>#include &lt;arpa&#x2F;inet.h&gt;</p>
<p>struct linger {<br>　　int l_onoff;<br>　　int l_linger;<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 三种断开方式：</span><br><span class="line"></span><br><span class="line">  * 1. l_onoff = 0; l_linger忽略：close()立刻返回，底层会将未发送完的数据发送完成后再释放资源，即优雅退出。</span><br><span class="line">    2. l_onoff != 0; l_linger = 0：close()立刻返回，但不会发送未发送完成的数据，而是通过一个REST包强制的关闭socket描述符，即强制退出。</span><br><span class="line">    3. l_onoff != 0; l_linger &gt; 0：close()不会立刻返回，内核会延迟一段时间，这个时间就由l_linger的值来决定。如果超时时间到达之前，发送完未发送的数据(包括FIN包)并得到另一端的确认，close()会返回正确，socket描述符优雅性退出。否则，close()会直接返回错误值，未发送数据丢失，socket描述符被强制性退出。需要注意的时，如果socket描述符被设置为非堵塞型，则close()会直接返回值。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">使用完linger之后，就用setsockopt()设置</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">int setsockopt( int socket, int level, int option_name,const void *option_value, size_t ，ption_len);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>第一个参数socket是套接字描述符。第二个参数level是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把level设置为 SOL_SOCKET。 option_name指定准备设置的选项，len是选项的长度。option_name可以有哪些取值，这取决于level，以linux 2.6内核为例（在不同的平台上，这种关系可能会有不同），在套接字级别上(SOL_SOCKET)，option_name可以有以下取值：</p>
<ul>
<li><p>SO_LINGER，如果选择此选项, close或 shutdown将等到所有套接字里排队的消息成功发送或到达延迟时间后&gt;才会返回. 否则, 调用将立即返回。该选项的参数（option_value)是一个linger结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linger</span> &#123;</span><br><span class="line">      <span class="type">int</span>  l_onoff;</span><br><span class="line">      <span class="type">int</span>  l_linger; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果linger.l_onoff值为0(关闭），则清 sock-&gt;sk-&gt;sk_flag中的SOCK_LINGER位；</span></span><br><span class="line"><span class="comment">否则，置该位，并赋sk-&gt;sk_lingertime值为 linger.l_linger。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SO_DEBUG，打开或关闭调试信息。当option_value不等于0时，打开调试信息，否则，关闭调试信息。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置 SOCK_DBG(第10)位，或清SOCK_DBG位。</p>
</li>
<li><p>SO_REUSEADDR，打开或关闭地址复用功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是置sock-&gt;sk-&gt;sk_reuse为1或0。</p>
<ul>
<li>SO_REUSEADDR是一个很有用的选项，一般服务器的监听socket都应该打开它。它的大意是允许服务器bind一个地址，即使这个地址当前已经存在已建立的连接，比如：<ul>
<li><p>服务器启动后，有客户端连接并已建立，如果服务器主动关闭，那么和客户端的连接会处于TIME_WAIT状态，此时再次启动服务器，就会bind不成功，报：Address already in use。</p>
</li>
<li><p>服务器父进程监听客户端，当和客户端建立链接后，fork一个子进程专门处理客户端的请求，如果父进程停止，因为子进程还和客户端有连接，所以再次启动父进程，也会报Address already in use。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SO_DONTROUTE，打开或关闭路由查找功能。当option_value不等于0时，打开，否则，关闭。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_LOCALROUTE位。</p>
</li>
<li><p>SO_BROADCAST，允许或禁止发送广播数据。当option_value不等于0时，允许，否则，禁止。它实际所做的工作是在sock-&gt;sk-&gt;sk_flag中置或清SOCK_BROADCAST位。</p>
</li>
<li><p>等等…太多了。</p>
</li>
</ul>
<hr>
<ul>
<li><p>sockaddr_in</p>
</li>
<li><pre><code class="c++">struct sockaddr_in &#123;
    __uint8_t sin_len;
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * sin_family指代协议族，在socket编程中只能是AF_INET</span><br><span class="line">  * sin_port存储端口号（使用网络字节顺序）</span><br><span class="line">  * sin_addr存储IP地址，使用in_addr这个数据结构</span><br><span class="line">  * sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</span><br><span class="line">  * addr.sin_len=sizeof(addr);//socket字节长度</span><br><span class="line"></span><br><span class="line">* sockaddr_in 结构体：struct sockaddr_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_INET地址族，非常地常用</span><br><span class="line"></span><br><span class="line">* sin_zero 初始值应该使用函数 bzero() 来全部置零。一般采用下面语句</span><br><span class="line"></span><br><span class="line">  * ```c++</span><br><span class="line">    struct sockaddr_in cliaddr; </span><br><span class="line">    bzero(&amp;cliaddr,sizeof(cliaddr)); </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>sockaddr_in结构体变量的基本配置</p>
<ul>
<li>&#96;&#96;&#96;c++<br>struct sockaddr_in ina;<br>bzero(&amp;ina,sizeof(ina));<br>ina.sin_family&#x3D;AF_INET;<br>ina.sin_port&#x3D;htons(23);<br>ina.sin_addr.s_addr &#x3D; inet_addr(“132.241.5.10”);  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* sockaddr</span><br><span class="line"></span><br><span class="line">* ```c++</span><br><span class="line">  struct sockaddr &#123;</span><br><span class="line">  unsigned short sa_family; /* address family, AF_xxx */</span><br><span class="line">  char sa_data[14]; /* 14字节，包含目标地址和端口信息 */</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sockaddr的缺陷是：sa_data把目标地址和端口信息混在一起了</p>
</li>
<li><p>sockaddr_in和sockaddr二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。二者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p>
</li>
<li><p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。</p>
</li>
<li><p>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>
</li>
</ul>
<hr>
<ul>
<li>INADDR_ANY</li>
<li>转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。<br>比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢?</li>
<li>如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？</li>
<li>所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。</li>
</ul>
<hr>
<ul>
<li><p>bind：服务端用于将把用于通信的地址和端口绑定到 socket上。</p>
</li>
<li><pre><code class="C++">int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
</code></pre>
<ul>
<li>参数 sockfd ，需要绑定的socket。</li>
<li>参数 addr ，存放了服务端用于通信的地址和端口。ip地址和端口号是放在 socketaddr_in 结构体里面的。</li>
<li>参数 addrlen ，表示 addr 结构体的大小。</li>
</ul>
</li>
<li><p>返回值：成功则返回0 ，失败返回-1，错误原因存于 errno 中。如果绑定的地址错误，或者端口已被占用，bind 函数一定会报错，否则一般不会返回错误</p>
</li>
</ul>
<h1 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h1><p>先安装依赖</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%951.png" alt="image-20220919164341581"></p>
<p>然后到webbench-1.5的目录下：make clean，再make。</p>
<p>测试：</p>
<p><img src="https://fastly.jsdelivr.net/gh/Chen-Jin-yuan/blogSources@master/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%952.png" alt="image-20220919164437394"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jy
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jysama.cn/2022/09/09/TinyWebServer/" title="Follow-TinyWebServer">https://jysama.cn/2022/09/09/TinyWebServer/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/23/%E5%8A%9B%E6%89%A3/" rel="prev" title="刷刷力扣">
      <i class="fa fa-chevron-left"></i> 刷刷力扣
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/21/websever-c++11/" rel="next" title="TinyWebServer-C++11">
      TinyWebServer-C++11 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NjM2Ny8zMjgzMA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%99"><span class="nav-number">1.</span> <span class="nav-text">第一站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lock"><span class="nav-number">1.1.</span> <span class="nav-text">lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81mutex"><span class="nav-number">1.1.1.</span> <span class="nav-text">互斥锁mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsem"><span class="nav-number">1.1.2.</span> <span class="nav-text">信号量sem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcond"><span class="nav-number">1.1.3.</span> <span class="nav-text">条件变量cond</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpool"><span class="nav-number">1.2.</span> <span class="nav-text">线程池threadpool</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%99"><span class="nav-number">2.</span> <span class="nav-text">第二站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是单例模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">为什么要用单例模式?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">实现单例模式的思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.4.</span> <span class="nav-text">单例模式的两种实现模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.2.</span> <span class="nav-text">sql数据库连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpp%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">.cpp实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%99"><span class="nav-number">3.</span> <span class="nav-text">第三站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.</span> <span class="nav-text">日志系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">3.1.1.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="nav-number">3.1.2.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpp%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.1.3.</span> <span class="nav-text">.cpp实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%99"><span class="nav-number">4.</span> <span class="nav-text">第四站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E2%80%94%E2%80%94%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">4.1.</span> <span class="nav-text">http——前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">4.1.1.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#writev"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">writev</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">4.1.2.</span> <span class="nav-text">http的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">http实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%99"><span class="nav-number">5.</span> <span class="nav-text">第五站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%BF%A1%E5%8F%B7API"><span class="nav-number">5.1.</span> <span class="nav-text">定时器与信号API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cpp%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">5.2.</span> <span class="nav-text">.cpp实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91"><span class="nav-number">5.3.</span> <span class="nav-text">使用逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%99"><span class="nav-number">6.</span> <span class="nav-text">第六站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#config"><span class="nav-number">6.1.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#makefile-amp-g"><span class="nav-number">6.2.</span> <span class="nav-text">makefile&amp;g++</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%99"><span class="nav-number">7.</span> <span class="nav-text">第七站</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.1.</span> <span class="nav-text">顶层实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="nav-number">8.</span> <span class="nav-text">压力测试</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jy</p>
  <div class="site-description" itemprop="description">Re：从零开始的写博客生活</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">462k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
